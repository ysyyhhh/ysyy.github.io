<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Home | Ysyy's</title><link>https://ysyyhhh.github.io/</link><atom:link href="https://ysyyhhh.github.io/index.xml" rel="self" type="application/rss+xml"/><description>Home</description><generator>Hugo Blox Builder (https://hugoblox.com)</generator><language>en-us</language><lastBuildDate>Tue, 24 Oct 2023 00:00:00 +0000</lastBuildDate><image><url>https://ysyyhhh.github.io/media/logo.svg</url><title>Home</title><link>https://ysyyhhh.github.io/</link></image><item><title>杂</title><link>https://ysyyhhh.github.io/blog/%E6%9D%82/</link><pubDate>Sat, 11 May 2024 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/blog/%E6%9D%82/</guid><description>&lt;p>session权限问题&lt;/p>
&lt;p>&lt;a href="https://blog.51cto.com/u_15162069/2778036" target="_blank" rel="noopener">https://blog.51cto.com/u_15162069/2778036&lt;/a>&lt;/p>
&lt;h5 id="rsa前后端解密出错">RSA前后端解密出错&lt;/h5>
&lt;p>14：07&lt;/p>
&lt;p>JSEncrypt支持的是&lt;a href="https://so.csdn.net/so/search?q=openssl&amp;amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener">openssl&lt;/a>生成的pkcs1格式私钥，java需要pkcs8格式私钥，公钥格式不变&lt;/p>
&lt;p>前端加入替换 encodeURI(encodeData).replace(/\+/g, &amp;lsquo;%2B&amp;rsquo;)&lt;/p>
&lt;p>后端接口加入 URLDecoder.decode(password,&amp;ldquo;UTF-8&amp;rdquo;);&lt;/p>
&lt;p>&lt;a href="https://blog.csdn.net/qq_42979402/article/details/109184787" target="_blank" rel="noopener">https://blog.csdn.net/qq_42979402/article/details/109184787&lt;/a>&lt;/p>
&lt;p>真正错误是密码加了hash函数后，返回值是数字而不是字符串！！！&lt;/p>
&lt;h4 id="数据库返回乱码">数据库返回乱码&lt;/h4>
&lt;p>&lt;a href="https://www.cnblogs.com/fanbi/p/13940432.html" target="_blank" rel="noopener">https://www.cnblogs.com/fanbi/p/13940432.html&lt;/a>&lt;/p>
&lt;h4 id="实际上是apigateway-放入-header-后再取出-乱码httpsblogcsdnnetqq_31277409articledetails118544597">&lt;a href="https://blog.csdn.net/qq_31277409/article/details/118544597" target="_blank" rel="noopener">实际上是apigateway 放入 header 后再取出 乱码&lt;/a>&lt;/h4>
&lt;h4 id="存储过程返回多结果集并接收">存储过程返回多结果集并接收&lt;/h4>
&lt;h4 id="test时报错-aop之类的">test时报错 AOP之类的&lt;/h4>
&lt;p>&lt;a href="https://blog.csdn.net/crxk_/article/details/103196146" target="_blank" rel="noopener">禁用字节码校验&lt;/a>&lt;/p></description></item><item><title>rpc框架</title><link>https://ysyyhhh.github.io/blog/rpc%E6%A1%86%E6%9E%B6/</link><pubDate>Wed, 06 Mar 2024 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/blog/rpc%E6%A1%86%E6%9E%B6/</guid><description/></item><item><title>大文件上传</title><link>https://ysyyhhh.github.io/blog/%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</link><pubDate>Wed, 06 Mar 2024 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/blog/%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</guid><description/></item><item><title>密码安全</title><link>https://ysyyhhh.github.io/blog/%E5%AF%86%E7%A0%81%E5%AE%89%E5%85%A8/</link><pubDate>Wed, 06 Mar 2024 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/blog/%E5%AF%86%E7%A0%81%E5%AE%89%E5%85%A8/</guid><description/></item><item><title>短链系统</title><link>https://ysyyhhh.github.io/blog/%E7%9F%AD%E9%93%BE%E7%B3%BB%E7%BB%9F/</link><pubDate>Wed, 06 Mar 2024 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/blog/%E7%9F%AD%E9%93%BE%E7%B3%BB%E7%BB%9F/</guid><description/></item><item><title>秒杀系统</title><link>https://ysyyhhh.github.io/blog/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/</link><pubDate>Wed, 06 Mar 2024 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/blog/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/</guid><description/></item><item><title>6.5840 Lab 1: MapReduce</title><link>https://ysyyhhh.github.io/blog/6.5840-lab-1-mapreduce/</link><pubDate>Tue, 05 Mar 2024 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/blog/6.5840-lab-1-mapreduce/</guid><description>&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;p>在这个实验中，你将构建一个 MapReduce 系统。你将实现一个工作节点进程，调用应用程序的 Map 和 Reduce 函数，处理文件的读写，以及一个协调器进程，向工作节点分发任务，并处理失败的工作节点。你将构建类似于 &lt;a href="https://pdos.csail.mit.edu/6.824/labs/lab-mr.html" target="_blank" rel="noopener">MapReduce 论文&lt;/a>中描述的系统。（注意：&lt;strong>这个实验使用“协调器”而不是论文中的“主节点”。&lt;/strong>）&lt;/p>
&lt;h2 id="getting-started">Getting started&lt;/h2>
&lt;p>准备工作:
&lt;a href="https://pdos.csail.mit.edu/6.824/labs/go.html" target="_blank" rel="noopener">安装Go&lt;/a>
&lt;a href="https://git-scm.com/" target="_blank" rel="noopener">安装Git&lt;/a>&lt;/p>
&lt;p>获取项目:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">git clone git://g.csail.mit.edu/6.5840-golabs-2024 6.5840
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">cd&lt;/span> 6.824
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ls
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 输出为 Makefile src&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们为你提供了一个简单的顺序 MapReduce 实现，位于 src/main/mrsequential.go 中。
它一次只在单个进程中运行一个 Map 和一个 Reduce。&lt;/p>
&lt;p>我们还为你提供了几个 MapReduce 应用程序：在 &lt;code>mrapps/wc.go&lt;/code> 中是单词计数，而在 &lt;code>mrapps/indexer.go&lt;/code> 中是文本索引器。你可以按顺序运行单词计数如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 生成 wc.so 文件&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">go build -buildmode&lt;span class="o">=&lt;/span>plugin ../mrapps/wc.go
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 删除 mr-out* 文件 这是输出文件&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">rm mr-out*
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 运行 mrsequential.go 使用 wc.so 插件处理 pg*.txt 文件, 这是提供的线性处理程序&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># pg*.txt 是输入文件, 包含了一些文本&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">go run mrsequential.go wc.so pg*.txt
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看输出文件 mr-out-0 的内容&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">more mr-out-0
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Go 将其输出保留在文件 mr- out-0中，输入来自名为 pg-xxx.txt 的文本文件。&lt;/p>
&lt;p>可以随意借用 mrSequential.go 的代码。您还应该查看 mrapps/wc.go，看看 MapReduce 应用程序代码是什么样的。&lt;/p>
&lt;h2 id="任务">任务&lt;/h2>
&lt;p>你的任务是实现一个分布式的 MapReduce，包括两个程序，协调器和工作节点。将只有一个协调器进程，以及一个或多个并行执行的工作节点进程。在一个真实的系统中，工作节点可能会在一堆不同的机器上运行，但是对于这个实验，你会将它们全部运行在单个机器上。工作节点将通过 RPC 与协调器通信。&lt;/p>
&lt;p>每个工作节点进程都会循环询问协调器要一个任务，从一个或多个文件中读取任务的输入，执行任务，将任务的输出写入一个或多个文件，然后再次向协调器请求一个新的任务。&lt;/p>
&lt;p>如果一个工作节点在合理的时间内（在这个实验中，使用十秒）没有完成它的任务，协调器应该注意到，并将相同的任务分配给另一个工作节点。&lt;/p>
&lt;p>协调器和 worker 的“ main”例程位于 main/mrCollaborator.go 和 main/mrworker.go 中; 不要更改这些文件。&lt;/p>
&lt;p>只修改mr/coordinator.go, mr/worker.go, and mr/rpc.go&lt;/p>
&lt;h3 id="示例">示例&lt;/h3>
&lt;p>下面是如何在单词计数 MapReduce 应用程序上运行代码的方法。首先，确保单词计数插件是新构建的:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">go build -buildmode&lt;span class="o">=&lt;/span>plugin ../mrapps/wc.go
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">rm mr-out*
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">go run mrcoordinator.go pg-*.txt
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中 pg-.txt 参数是输入文件；每个文件对应一个“分片”，是一个 Map 任务的输入。&lt;/p>
&lt;p>然后,在一个或多个其他窗口中，运行一些工作节点：
&lt;code>go run mrworker.go wc.so&lt;/code>&lt;/p>
&lt;p>在&lt;code>mr-out-*&lt;/code>文件中，可以单词计数的输出。&lt;/p>
&lt;p>当coordinator完成所有任务后, 会输出如下内容:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">cat mr-out-* &lt;span class="p">|&lt;/span> sort &lt;span class="p">|&lt;/span> more
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="测试">测试&lt;/h3>
&lt;p>我们在 main/test-mr.sh 中为你提供了一个测试脚本。
这些测试检查当给定 pg-xxx.txt 文件作为输入时，wc 和 indexer MapReduce 应用程序是否产生正确的输出。
测试还会检查你的实现是否并行运行 Map 和 Reduce 任务，并且你的实现是否能够从在运行任务时崩溃的工作节点中恢复。&lt;/p>
&lt;p>运行测试脚本的方法如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">bash test-mr.sh
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>tips:&lt;/p>
&lt;blockquote>
&lt;p>如果现在直接执行mrcoordinator会一直卡在那, 因为&lt;code>mr/coordinator.go&lt;/code>中的Done函数没有被实现.
一直返回false, 无法结束任务.
如果想先测试一下流程,直接把&lt;code>mr/coordinator.go&lt;/code>中的&lt;code>Done&lt;/code>函数改成&lt;code>return true&lt;/code>就可以了.&lt;/p>
&lt;/blockquote>
&lt;p>这个测试脚本会输出到 &lt;code>mr-out-X&lt;/code>中&lt;/p>
&lt;p>如果全部完成了,可以看到输出的内容:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">*** Starting wc test.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">--- wc test: PASS
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">*** Starting indexer test.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">--- indexer test: PASS
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">*** Starting map parallelism test.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">--- map parallelism test: PASS
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">*** Starting reduce parallelism test.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">--- reduce parallelism test: PASS
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">*** Starting job count test.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">--- job count test: PASS
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">*** Starting early &lt;span class="nb">exit&lt;/span> test.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">--- early &lt;span class="nb">exit&lt;/span> test: PASS
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">*** Starting crash test.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">--- crash test: PASS
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">*** PASSED ALL TESTS
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="一些可以忽略的问题">一些可以忽略的问题&lt;/h3>
&lt;p>&lt;code>rpc.Register: method &amp;quot;Done&amp;quot; has 1 input parameters; needs exactly three&lt;/code>
这个
将协调器注册为 RPC 服务器检查它的所有方法是否适合 RPC (有3个输入) ;
我们知道RPC并没有调用 Done。&lt;/p>
&lt;p>另外，根据你终止工作进程的策略，你可能会看到一些形式的错误。
&lt;code> dialing:dial unix /var/tmp/5840-mr-501: connect: connection refused&lt;/code>
每个测试可以看到一些这样的消息; 当协调器退出后，工作者无法与协调器 RPC 服务器联系时，就会出现这些消息。&lt;/p>
&lt;h2 id="a-few-rules">A few rules&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>Map 阶段应该将中间键分成 nReduce 个 reduce 任务的桶，其中 nReduce 是 reduce 任务的数量 &amp;ndash; 这是 main/mrcoordinator.go 传递给 MakeCoordinator() 的参数。每个 Mapper 应该为 Reduce 任务创建 nReduce 个中间文件以供使用。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Worker 的实现应该将第 X 个 reduce 任务的输出放入文件 mr-out-X 中。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>mr-out-X 文件应该包含一个 Reduce 函数输出的行。这一行应该用 Go 的 &amp;ldquo;%v %v&amp;rdquo; 格式生成，调用时传入键和值。在 main/mrsequential.go 中找到被注释为 &amp;ldquo;这是正确的格式&amp;rdquo; 的行。如果你的实现与这个格式相差太远，测试脚本会失败。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>你可以修改 mr/worker.go、mr/coordinator.go 和 mr/rpc.go。你可以临时修改其他文件进行测试，但确保你的代码与原始版本一起工作；我们将使用原始版本进行测试。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Worker 应该将中间 Map 输出放在当前目录中的文件中，以便稍后的 Reduce 任务读取它们作为输入。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>main/mrcoordinator.go 期望 mr/coordinator.go 实现一个 Done() 方法，在 MapReduce 作业完全完成时返回 true；此时，mrcoordinator.go 将退出。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当作业完全完成时，工作进程应该退出。实现这一点的一个简单方法是使用 call() 的返回值：如果工作节点无法联系到协调器，它可以假设协调器已经退出，因为作业已经完成，所以工作节点也可以终止。根据你的设计，你可能还会发现有一个“请退出”的伪任务对协调器给工作节点很有帮助。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="hints">Hints&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://pdos.csail.mit.edu/6.824/labs/guidance.html" target="_blank" rel="noopener">指南页面&lt;/a>上有一些关于开发和调试的提示。&lt;/li>
&lt;li>开始的一种方法是修改 mr/worker.go 中的 Worker()，向协调器发送一个 RPC 请求任务。然后修改协调器以响应一个尚未启动的 Map 任务的文件名。然后修改工作节点以读取该文件并调用应用程序的 Map 函数，就像在 mrsequential.go 中一样。&lt;/li>
&lt;li>应用程序的 Map 和 Reduce 函数是在运行时使用 Go 插件包加载的，文件的名称以 .so 结尾。&lt;/li>
&lt;li>如果你改变了 mr/ 目录中的任何内容，你可能需要重新构建你使用的任何 MapReduce 插件，例如使用 go build -buildmode=plugin ../mrapps/wc.go。&lt;/li>
&lt;li>这个实验依赖于&lt;strong>工作节点共享文件系统&lt;/strong>。当所有工作节点运行在同一台机器上时，这很简单，但如果工作节点在不同的机器上运行，则需要像 GFS 这样的全局文件系统。&lt;/li>
&lt;li>中间文件的一个合理命名约定是 mr-X-Y，其中 X 是 Map 任务编号，Y 是 reduce 任务编号。&lt;/li>
&lt;li>工作节点的 Map 任务代码将需要一种方法来将&lt;strong>中间键/值对存储在文件中&lt;/strong>，以便在 reduce 任务期间正确读取回来。一种可能性是使用 Go 的 encoding/json 包。要将键/值对以 JSON 格式写入到打开的文件中：
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">enc&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">json&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">NewEncoder&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">file&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="nx">_&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">kv&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="o">...&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">enc&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Encode&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">kv&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>并读取回来：
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">dec&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">json&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">NewDecoder&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">file&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">var&lt;/span> &lt;span class="nx">kv&lt;/span> &lt;span class="nx">KeyValue&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">dec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Decode&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">kv&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">break&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">kva&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nb">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">kva&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">kv&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>你的工作节点的 Map 部分可以使用 ihash(key) 函数（在 worker.go 中）来选择给定键的 reduce 任务。&lt;/li>
&lt;li>你可以从 mrsequential.go 中偷一些代码来读取 Map 输入文件，对 Map 和 Reduce 之间的中间键/值对进行排序，并将 Reduce 输出存储在文件中。&lt;/li>
&lt;li>作为一个 RPC 服务器的协调器将是并发的；不要忘记锁定共享数据。&lt;/li>
&lt;li>使用 Go 的竞争检测器，使用 go run -race。test-mr.sh 在开头有一条注释，告诉你如何用 -race 运行它。当我们评估你的实验时，我们不会使用竞争检测器。&lt;strong>尽管如此，如果你的代码有竞争条件，即使没有竞争检测器，也有很大可能会在我们测试时失败&lt;/strong>。&lt;/li>
&lt;li>工作节点有时需要等待，例如在最后一个 Map 完成之前不能开始 Reduce。一种可能性是让工作节点定期向协调器请求工作，在每个请求之间使用 time.Sleep() 进行睡眠。另一种可能性是让协调器中相应的 RPC 处理程序具有等待循环，可以使用 time.Sleep() 或 sync.Cond 进行等待。Go 在自己的线程中运行每个 RPC 的处理程序，因此一个处理程序在等待时不会阻止协调器处理其他 RPC。&lt;/li>
&lt;li>协调器不能可靠地区分崩溃的工作节点、仍然存活但由于某种原因停滞不前的工作节点以及执行但速度太慢以至于无用的工作节点。你能做的最好的事情是让协调器等待一段时间，然后放弃并将任务重新分配给另一个工作节点。对于这个实验，让协调器等待十秒；之后，&lt;strong>协调器应该假设工作节点已经死亡&lt;/strong>（当然，它可能没有）。&lt;/li>
&lt;li>如果选择实现备份任务（第 3.6 节），请注意我们测试你的代码在工作节点执行任务而不崩溃时不安排多余的任务。备份任务应该只在一段相对较长的时间（例如，10 秒）之后才被安排。&lt;/li>
&lt;li>为了测试崩溃恢复，你可以使用 mrapps/crash.go 应用程序插件。它会在 Map 和 Reduce 函数中随机退出。&lt;/li>
&lt;li>为了确保在崩溃的情况下没有人观察到部分写入的文件，MapReduce 论文提到了使用临时文件并在完全写入后以原子方式重命名它的技巧。你可以使用 ioutil.TempFile（或者如果你正在运行 Go 1.17 或更高版本，则可以使用 os.CreateTemp）来创建临时文件，并使用 os.Rename 来原子地重命名它。&lt;/li>
&lt;li>test-mr.sh 在子目录 mr-tmp 中运行所有进程，所以如果出了问题，你想查看中间文件或输出文件，请查看那里。可以随意暂时修改 test-mr.sh，在失败的测试后退出，这样脚本就不会继续测试（并覆盖输出文件）。&lt;/li>
&lt;li>test-mr-many.sh 连续多次运行 test-mr.sh，这样做可以帮助你发现低概率的错误。它接受一个参数，指定运行测试的次数。你不应该并行运行多个 test-mr.sh 实例，因为协调器会重用相同的套接字，导致冲突。&lt;/li>
&lt;li>Go RPC 只发送字段名称以大写字母开头的结构字段。子结构体也必须具有大写的字段名称。&lt;/li>
&lt;li>在调用 RPC 的 call() 函数时，应答结构体应包含所有默认值。RPC 调用应该像这样：
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">reply&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">SomeType&lt;/span>&lt;span class="p">{}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">call&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">...&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">reply&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>在调用之前不设置任何 reply 字段。如果传递具有非默认字段的 reply 结构体，则 RPC 系统可能会静默返回不正确的值。&lt;/li>
&lt;/ul>
&lt;h2 id="挑战">挑战&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>实现你自己的 MapReduce 应用程序（参见 mrapps/* 中的示例），例如，分布式 Grep（MapReduce 论文第 2.3 节）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>让你的 MapReduce 协调器和工作节点在不同的机器上运行，就像在实际中一样。你需要设置你的 RPC 以通过 TCP/IP 进行通信，而不是 Unix 套接字（参见 Coordinator.server() 中的注释行），并使用共享文件系统进行文件读写。例如，你可以 ssh 进入麻省理工学院的多个 Athena 集群机器，它们使用 AFS 共享文件；或者你可以租用几个 AWS 实例，并使用 S3 进行存储。&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>lab2 key value server</title><link>https://ysyyhhh.github.io/blog/lab2-key-value-server/</link><pubDate>Tue, 05 Mar 2024 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/blog/lab2-key-value-server/</guid><description/></item><item><title>MapReduce: Simplified Data Processing on Large Clusters</title><link>https://ysyyhhh.github.io/blog/mapreduce-simplified-data-processing-on-large-clusters/</link><pubDate>Tue, 05 Mar 2024 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/blog/mapreduce-simplified-data-processing-on-large-clusters/</guid><description>&lt;p>MapReduce: 一种用于大规模数据处理的简化并行计算模型&lt;/p>
&lt;p>引用: Jeffrey Dean and Sanjay Ghemawat. 2008. MapReduce: simplified data processing on large clusters. Commun. ACM 51, 1 (January 2008), 107–113. &lt;a href="https://doi.org/10.1145/1327452.1327492" target="_blank" rel="noopener">https://doi.org/10.1145/1327452.1327492&lt;/a>&lt;/p>
&lt;p>论文: [MapReduce: Simplified Data Processing on Large Clusters](&lt;a href="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/mapreduce-osdi04.pdf" target="_blank" rel="noopener">https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/mapreduce-osdi04.pdf&lt;/a>&lt;/p>
&lt;h2 id="摘要">摘要&lt;/h2>
&lt;p>MapReduce 是一个用于处理和生成大数据集的编程模型和相关实现。&lt;/p>
&lt;p>用户需要指定一个 map 函数来处理键/值对，生成一组中间键/值对，还有一个 reduce 函数来合并与同一个中间键相关联的所有中间值。&lt;/p>
&lt;p>许多现实世界的任务都可以用这个模型来表达，就像论文中所示的那样。以&lt;strong>这种函数式风格编写的程序会自动并行化&lt;/strong>，并在一大群廉价机器上执行。运行时系统负责处理输入数据的分区细节，调度程序在一组机器上的执行，处理机器故障，并管理所需的机器间通信。&lt;/p>
&lt;p>这使得没有任何并行和分布式系统经验的程序员可以轻松利用大型分布式系统的资源。&lt;/p>
&lt;p>我们的 MapReduce 实现运行在一大群廉价机器上，而且具有高度可扩展性：典型的 MapReduce 计算在成千上万台机器上处理着数百 TB 的数据。程序员发现这个系统易于使用：已经实现了数百个 MapReduce 程序，并且每天有上千个 MapReduce 作业在 Google 的集群上执行。&lt;/p>
&lt;h2 id="1-介绍">1. 介绍&lt;/h2>
&lt;p>在过去的五年里，作者和谷歌的许多其他人实现了数百种专用计算，处理大量原始数据，例如爬取的文档、网页请求日志等，以计算各种派生数据，例如倒排索引、网页文档的图结构的各种表示、每个主机爬取的页面数量摘要，给定日中最常见的查询集等等。大多数&lt;strong>这样的计算在概念上都很简单&lt;/strong>。但是，输入数据通常很大，计算必须分布在数百甚至数千台机器上才能在合理的时间内完成。&lt;strong>如何并行化计算、分布数据以及处理故障等问题，使原本简单的计算变得复杂&lt;/strong>，需要大量的复杂代码来解决这些问题。&lt;/p>
&lt;p>针对这种复杂性，我们设计了一个新的抽象，&lt;strong>允许我们表达我们试图执行的简单计算，但隐藏了并行化、容错、数据分布和负载平衡等混乱的细节在一个库&lt;/strong>中。我们的抽象受到Lisp和许多其他函数式语言中存在的map和reduce原语的启发。&lt;/p>
&lt;p>我们意识到，我们的大多数计算涉及将map操作应用于输入中的每个逻辑“记录”，以计算一组中间键/值对，然后将reduce操作应用于所有共享相同键的值，以适当地组合派生数据。我们使用具有&lt;strong>用户指定的map和reduce操作的函数模型，可以轻松地并行化大型计算，并使用重新执行作为容错的主要机制&lt;/strong>。&lt;/p>
&lt;p>这项工作的主要贡献是一个简单而强大的接口，可以实现大规模计算的自动并行化和分发，结合了该接口的一个实现，在大规模PC集群上实现了高性能。&lt;/p>
&lt;ul>
&lt;li>第2节描述了基本编程模型并给出了几个示例。&lt;/li>
&lt;li>第3节描述了针对我们基于集群的计算环境定制的MapReduce接口的实现。&lt;/li>
&lt;li>第4节描述了我们发现有用的编程模型的几个细化。&lt;/li>
&lt;li>第5节对我们的实现在各种任务中的性能进行了测量。&lt;/li>
&lt;li>第6节探讨了在谷歌内部使用MapReduce的情况，包括我们将其用作重写生产索引系统的基础的经验。&lt;/li>
&lt;li>第7节讨论了相关和未来的工作。&lt;/li>
&lt;/ul>
&lt;h2 id="2-编程模型">2. 编程模型&lt;/h2>
&lt;p>编程模型计算接受一组输入键/值对，并产生一组输出键/值对。MapReduce库的用户将计算表示为两个函数：Map和Reduce。&lt;/p>
&lt;p>用户编写的Map函数接受一个输入对，并生成一组中间键/值对。MapReduce库将所有与相同中间键I关联的中间值组合在一起，并将它们传递给Reduce函数。&lt;/p>
&lt;p>Reduce函数也由用户编写，接受一个中间键I和该键的一组值。它将这些值合并在一起，形成可能更小的一组值。通常，每次调用Reduce都只产生零个或一个输出值。中间值通过迭代器提供给用户的reduce函数。这使我们能够处理太大而无法放入内存的值列表。&lt;/p>
&lt;h3 id="21-示例">2.1 示例&lt;/h3>
&lt;p>下面考虑在大量文档集合中计算每个单词出现次数的问题。用户将编写类似以下伪代码的代码:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">map&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">String&lt;/span> &lt;span class="n">key&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">//&lt;/span> &lt;span class="n">key&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">文档名&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">//&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">文档内容&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">each&lt;/span> &lt;span class="n">word&lt;/span> &lt;span class="n">w&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">EmitIntermediate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">w&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;1&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">reduce&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">String&lt;/span> &lt;span class="n">key&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">Iterator&lt;/span> &lt;span class="n">values&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">//&lt;/span> &lt;span class="n">key&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">单词&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">//&lt;/span> &lt;span class="n">values&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">与key关联的值的迭代器&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">int&lt;/span> &lt;span class="n">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">each&lt;/span> &lt;span class="n">v&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">values&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">result&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">ParseInt&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">v&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Emit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">AsString&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">result&lt;/span>&lt;span class="p">));&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Map函数将文档名和内容作为输入，并为每个单词w生成一组中间键/值对。对于每个单词，我们发出一个中间键/值对，其中键是单词，值是字符串“1”。&lt;/p>
&lt;p>reduce函数将为特定单词发出的所有计数相加在一起。&lt;/p>
&lt;p>此外，用户编写代码来填写一个mapreduce规范对象，其中包含输入和输出文件的名称，以及可选的调优参数。&lt;/p>
&lt;p>然后，用户调用MapReduce函数，将规范对象传递给它。用户的代码与MapReduce库（用C++实现）链接在一起。&lt;/p>
&lt;p>此示例的完整程序文本:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 本节包含一个程序，用于统计命令行指定的一组输入文件中每个唯一单词的出现次数。
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;#34;mapreduce/mapreduce.h&amp;#34;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 用户的map函数
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">class&lt;/span> &lt;span class="nc">WordCounter&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="k">public&lt;/span> &lt;span class="n">Mapper&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">public&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">virtual&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="n">Map&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="n">MapInput&lt;/span>&lt;span class="o">&amp;amp;&lt;/span> &lt;span class="n">input&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">const&lt;/span> &lt;span class="n">string&lt;/span>&lt;span class="o">&amp;amp;&lt;/span> &lt;span class="n">text&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">input&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">const&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">n&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">text&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">size&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 跳过前导空白
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">isspace&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">text&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 寻找单词结尾
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">start&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="o">!&lt;/span>&lt;span class="n">isspace&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">text&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">start&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Emit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">text&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">substr&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">start&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">start&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="s">&amp;#34;1&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">REGISTER_MAPPER&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">WordCounter&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 用户的reduce函数
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">class&lt;/span> &lt;span class="nc">Adder&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="k">public&lt;/span> &lt;span class="n">Reducer&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">virtual&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">Reduce&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ReduceInput&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">input&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 遍历所有具有相同键的条目，并将值相加
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">int64&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">input&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">done&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">value&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">StringToInt&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">input&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="p">());&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">input&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">NextValue&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 发出输入键（input-&amp;gt;key()）的总和
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">Emit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">IntToString&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="p">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">REGISTER_REDUCER&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Adder&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">argc&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">char&lt;/span>&lt;span class="o">**&lt;/span> &lt;span class="n">argv&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ParseCommandLineFlags&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">argc&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">argv&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">MapReduceSpecification&lt;/span> &lt;span class="n">spec&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 将输入文件列表存储到 &amp;#34;spec&amp;#34; 中
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">argc&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">MapReduceInput&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">input&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">spec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">add_input&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">input&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">set_format&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;text&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">input&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">set_filepattern&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">argv&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">input&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">set_mapper_class&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;WordCounter&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 指定输出文件:
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// /gfs/test/freq-00000-of-00100
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// /gfs/test/freq-00001-of-00100
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">MapReduceOutput&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">out&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">spec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">output&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">out&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">set_filebase&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/gfs/test/freq&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">out&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">set_num_tasks&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">100&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">out&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">set_format&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;text&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">out&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">set_reducer_class&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Adder&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 可选: 在map任务中执行部分求和以节省网络带宽
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 组合器函数
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">out&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">set_combiner_class&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Adder&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 调优参数: 最多使用2000台机器和每个任务100 MB的内存
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">spec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">set_machines&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2000&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">spec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">set_map_megabytes&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">100&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">spec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">set_reduce_megabytes&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">100&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 现在运行它
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">MapReduceResult&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">MapReduce&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">spec&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">result&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">abort&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 完成: &amp;#39;result&amp;#39; 结构包含有关计数器、花费时间、使用的机器数量等的信息
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="22-类型">2.2 类型&lt;/h3>
&lt;p>即使先前的伪代码是以字符串输入和输出为基础编写的，从概念上讲，用户提供的Map和Reduce函数具有关联的类型：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">map&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">k1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">v1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="nb">list&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">k2&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">v2&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">reduce&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">k2&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nb">list&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">v2&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="nb">list&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">v2&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>也就是说，输入的键和值和输出的键和值来自不同的领域。此外，&lt;strong>中间键和值来自与输出键和值&lt;/strong>相同的领域。&lt;/p>
&lt;p>我们的 C++ 实现将字符串传递给用户定义的函数，并将其留给用户代码在字符串和适当类型之间进行转换。&lt;/p>
&lt;h3 id="23-更多示例">2.3 更多示例&lt;/h3>
&lt;p>以下是几个简单的有趣程序的示例，可以很容易地表达为 MapReduce 计算。&lt;/p>
&lt;p>分布式 Grep：如果匹配提供的模式，则Map函数发出一行。Reduce函数是一个恒等函数，只是将提供的中间数据复制到输出。&lt;/p>
&lt;p>URL 访问频率计数：Map函数处理 Web 页面请求的日志并输出 〈URL，1〉。Reduce函数将同一 URL 的所有值相加，并发出一个 〈URL，总计数〉 对。&lt;/p>
&lt;p>反向 Web-Link 图：Map函数为在名为源的页面中找到的指向目标 URL 的每个链接输出 〈目标，源〉 对。Reduce函数将与给定目标 URL 关联的所有源 URL 的列表串联在一起，并发出：〈目标，列表（源）〉&lt;/p>
&lt;p>每个主机的术语向量：术语向量汇总了出现在文档或一组文档中的最重要的单词，作为 〈word，frequency〉 对的列表。Map函数为每个输入文档（其中主机名从文档的 URL 中提取）发出一个 〈主机名，术语向量〉 对。Reduce函数为给定主机传递了所有每文档术语向量。它将这些术语向量相加，丢弃不经常出现的术语，然后发出一个最终的 〈主机名，术语向量〉 对。&lt;/p>
&lt;p>倒排索引：Map函数解析每个文档，并发出一系列 〈单词，文档 ID〉 对。Reduce函数接受给定单词的所有对，对相应的文档 ID 进行排序，并发出一个 〈单词，文档 ID 列表〉 对。所有输出对的集合形成一个简单的倒排索引。很容易扩展这个计算以跟踪单词位置。&lt;/p>
&lt;p>分布式排序：Map函数从每个记录中提取键，并发出一个 〈键，记录〉 对。Reduce函数保持所有对不变地发出。此计算依赖于第 4.1 节描述的分区设施和第 4.2 节描述的排序属性。&lt;/p>
&lt;h2 id="3-实施">3 实施&lt;/h2>
&lt;p>MapReduce 接口的许多不同实现是可能的。正确的选择取决于环境。例如，一个实现可能适用于小型共享内存机器，另一个适用于大型 NUMA 多处理器，还有一个适用于更大的网络机器集合。&lt;/p>
&lt;p>本节描述了一个针对谷歌广泛使用的计算环境的实现：大量使用廉价个人计算机连接在一起，采用交换式以太网 [4]。在我们的环境中：&lt;/p>
&lt;ol>
&lt;li>机器通常是运行 Linux 的双处理器 x86 处理器，每台机器配备 2-4GB 内存。&lt;/li>
&lt;li>采用廉价的网络硬件 - 通常是 100 兆位/秒或 1 千兆位/秒的机器级别，但总体双向分割带宽要低得多。&lt;/li>
&lt;li>一个集群由数百或数千台机器组成，因此机器故障很常见。&lt;/li>
&lt;li>存储由廉价的 IDE 硬盘直接连接到个别机器上提供。内部开发的分布式文件系统 [8] 用于管理存储在这些硬盘上的数据。文件系统使用复制在不可靠的硬件上提供可用性和可靠性。&lt;/li>
&lt;li>用户向调度系统提交作业。每个作业由一组任务组成，并由调度程序Map到集群中的一组可用机器。&lt;/li>
&lt;/ol>
&lt;h3 id="31-执行概述">3.1 执行概述&lt;/h3>
&lt;p>Map 调用通过自动分区输入数据到一组 M 个分片的方式分布在多台机器上。输入分片可以由不同的机器并行处理。Reduce 调用通过使用分区函数（例如，hash(key) mod R）将中间键空间分成 R 个部分进行分区。分区数量（R）和分区函数由用户指定。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/mapreduce-simplified-data-processing-on-large-clusters/img/2024-03-05-19-02-07_hu4614229610023055020.webp 400w,
/blog/mapreduce-simplified-data-processing-on-large-clusters/img/2024-03-05-19-02-07_hu12559675312700088908.webp 760w,
/blog/mapreduce-simplified-data-processing-on-large-clusters/img/2024-03-05-19-02-07_hu10732418564934562134.webp 1200w"
src="https://ysyyhhh.github.io/blog/mapreduce-simplified-data-processing-on-large-clusters/img/2024-03-05-19-02-07_hu4614229610023055020.webp"
width="760"
height="512"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
上图显示了我们实现的 MapReduce 操作的整体流程。当用户程序调用 MapReduce 函数时，将发生以下动作序列（图中的编号标签对应下面列表中的编号）：&lt;/p>
&lt;ol>
&lt;li>用户程序中的 MapReduce 库首先将输入文件分成 M 个片段，通常每个片段为 16 MB 到 64 MB（用户可以通过可选参数控制）。然后，在一组机器上启动许多程序副本。&lt;/li>
&lt;li>程序的其中一个副本是特殊的 - &lt;strong>主节点。其余的是工作节点，由主节点分配工作。有&lt;/strong> M 个Map任务和 R 个Reduce任务要分配。主节点选择空闲的工作节点，并为每个分配一个Map任务或Reduce任务。&lt;/li>
&lt;li>被分配Map任务的工作节点读取相应输入分片的内容。它&lt;strong>从输入数据中解析出键/值对，并将每对传递给用户定义的 Map 函数&lt;/strong>。由 Map 函数产生的中间键/值对在内存中进行缓冲。&lt;/li>
&lt;li>&lt;strong>定期&lt;/strong>，缓冲的对会被写入本地磁盘，并由分区函数分成 R 个区域。这些缓冲对的位置被传回给主节点，负责将这些位置转发给Reduce工作节点。&lt;/li>
&lt;li>当Reduce工作节点收到主节点关于这些位置的通知时，它&lt;strong>使用RPC从Map工作节点的本地磁盘读取缓冲数据&lt;/strong>。当Reduce工作节点读取了所有中间数据时，它会根据中间键对数据进行排序，以便将相同键的所有出现组合在一起。**排序是必要的，因为通常许多不同的键Map到同一个Reduce任务。**如果中间数据量太大无法放入内存，则使用外部排序。&lt;/li>
&lt;li>Reduce工作节点遍历排序后的中间数据，并对每个唯一的中间键进行处理，&lt;strong>将键和相应的中间值集合传递给用户的 Reduce 函数&lt;/strong>。Reduce函数的输出附加到此Reduce分区的最终输出文件中。&lt;/li>
&lt;li>当所有Map任务和Reduce任务完成时，主节点唤醒用户程序。此时，用户程序中的 MapReduce 调用返回给用户代码。&lt;/li>
&lt;/ol>
&lt;p>成功完成后，mapreduce 执行的输出可用于 R 个输出文件中（&lt;strong>每个Reduce任务一个文件&lt;/strong>，文件名由用户指定）。&lt;/p>
&lt;p>通常，&lt;strong>用户不需要将这些 R 个输出文件合并为一个文件&lt;/strong> - 他们通常将这些文件作为另一个 MapReduce 调用的输入，或者从另一个能够处理被分成多个文件的输入的分布式应用程序中使用它们。&lt;/p>
&lt;h3 id="32-主数据结构">3.2 主数据结构&lt;/h3>
&lt;p>主节点保持着几个数据结构。对于每个Map任务和Reduce任务，它存储状态（空闲、进行中或已完成），以及工作机器的标识（对于非空闲任务）。&lt;/p>
&lt;p>主节点是中间文件区域的位置从Map任务传播到Reduce任务的通道。&lt;/p>
&lt;p>因此，对于每个已完成的Map任务，主节点存储由该Map任务产生的 R 个中间文件区域的位置和大小。&lt;/p>
&lt;p>当Map任务完成时，会接收到此位置和大小信息的更新。这些信息被逐步推送给具有正在进行的Reduce任务的工作节点。&lt;/p>
&lt;h3 id="33-容错性">3.3 容错性&lt;/h3>
&lt;p>由于 MapReduce 库旨在使用数百或数千台机器处理大量数据，因此该库必须能够优雅地容忍机器故障。&lt;/p>
&lt;h4 id="工作节点故障">工作节点故障&lt;/h4>
&lt;p>主节点&lt;strong>定期对每个工作节点进行 ping&lt;/strong>。如果一段时间内没有从工作节点接收到响应，主节点将该工作节点标记为失败。&lt;/p>
&lt;blockquote>
&lt;p>任何状态的Map任务被重置
由该工作节点完成的&lt;strong>任何Map任务&lt;/strong>都将被重置回初始空闲状态，因此可以被重新调度到其他工作节点上。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>进行中的Reduce被重置
类似地，由失败的工作节点&lt;strong>进行中&lt;/strong>的任何Map任务或Reduce任务也将被重置为空闲状态，并且有资格重新调度。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>已完成的Reduce任务不需要被重置&lt;/p>
&lt;/blockquote>
&lt;p>由于其输出存储在失败机器的本地磁盘上，因此&lt;strong>已完成的Map任务在失败时会被重新执行&lt;/strong>，并且因此无法访问。
&lt;strong>已完成的Reduce任务无需重新执行&lt;/strong>，因为其输出存储在全局文件系统中。&lt;/p>
&lt;p>当工作节点 A 首先执行Map任务，然后稍后由工作节点 B（因为 A 失败）执行时，&lt;strong>执行Reduce任务的所有工作节点&lt;/strong>都会收到重新执行的通知。
尚未从工作节点 A 读取数据的任何Reduce任务将从工作节点 B 读取数据。&lt;/p>
&lt;p>MapReduce 对大规模工作节点故障具有弹性。
例如，在一个 MapReduce 操作期间，运行中的集群上进行网络维护导致每次有 80 台机器成为几分钟内无法访问。MapReduce &lt;strong>主节点简单地重新执行了不可访问的工作节点机器完成的工作&lt;/strong>，并继续向前推进，最终完成了 MapReduce 操作。&lt;/p>
&lt;h4 id="主节点故障">主节点故障&lt;/h4>
&lt;p>主节点定期写入上述主数据结构的周期性检查点是很简单的。如果主任务死亡，则可以从最后一个检查点状态启动新的副本。&lt;/p>
&lt;p>然而，考虑到只有一个主节点，它的故障是不太可能的；因此，我们当前的实现在主节点故障时会中止 MapReduce 计算。客户端可以检查此条件，并在需要时重试 MapReduce 操作。&lt;/p>
&lt;h4 id="故障存在时的语义">故障存在时的语义&lt;/h4>
&lt;p>当用户提供的Map和Reduce运算符是其输入值的确定性函数时，我们的分布式实现产生的输出与整个程序的非故障顺序执行所产生的输出相同。&lt;/p>
&lt;p>我们依赖于Map和Reduce任务输出的原子提交来实现此属性。每个进行中的任务&lt;strong>将其输出写入私有临时文件&lt;/strong>。&lt;/p>
&lt;p>一个Reduce任务产生一个这样的文件，而&lt;strong>一个Map任务产生 R 个这样的文件（每个Reduce任务一个）&lt;/strong>。&lt;/p>
&lt;p>当Map任务完成时，工作节点向主节点发送一条消息，并在消息中包含 R 个临时文件的名称。如果主节点收到已经完成的Map任务的完成消息，则会忽略该消息。否则，它会将 R 个文件的名称记录在主数据结构中。&lt;/p>
&lt;p>当Reduce任务完成时，Reduce工作节点&lt;strong>将其临时输出文件原子地重命名为最终输出文件&lt;/strong>。如果相同的Reduce任务在多个机器上执行，则&lt;strong>对同一最终输出文件将执行多个重命名调用&lt;/strong>。我们依赖底层文件系统提供的原子重命名操作来保证最终的文件系统状态仅包含由Reduce任务的一次执行产生的数据。&lt;/p>
&lt;p>我们的大多数Map和Reduce运算符是确定性的，而我们的语义在这种情况下等同于顺序执行，这使得程序员很容易理解其程序的行为。当Map或Reduce运算符是非确定性的时，我们提供了更弱但仍合理的语义。&lt;/p>
&lt;p>在非确定性运算符存在的情况下，特定Reduce任务 R1 的输出等同于顺序执行非确定性程序产生的 R1 的输出。然而，不同Reduce任务 R2 的输出可能对应于&lt;strong>由不同顺序执行非确定性程序产生的 R2 的输出&lt;/strong>。&lt;/p>
&lt;p>考虑Map任务 M 和Reduce任务 R1 和 R2。设 e(Ri) 是执行 Ri 的已提交的执行（正好有一个这样的执行）。较弱的语义出现是因为 e(R1) 可能已读取由 M 的一个执行产生的输出，而 e(R2) 可能已读取由 M 的不同执行产生的输出。&lt;/p>
&lt;h3 id="34-本地性">3.4 本地性&lt;/h3>
&lt;p>在我们的计算环境中，网络带宽是相对稀缺的资源。我们通过利用输入数据（由 GFS [8] 管理）存储在构成我们集群的机器的本地磁盘上的事实来节省网络带宽。&lt;/p>
&lt;p>GFS 将每个文件划分为 64 MB 的块，并在不同的机器上存储每个块的多个副本（通常为 3 个副本）。&lt;/p>
&lt;p>MapReduce 主节点考虑输入文件的位置信息，并尝试在包含相应输入数据副本的机器上安排Map任务。如果失败，它将尝试在靠近该任务输入数据副本的地方安排Map任务（例如，在与包含数据的机器相同网络交换机上的工作机器）。
当在集群中的大部分工作节点上运行大型 MapReduce 操作时，大多数输入数据都是本地读取的，不会消耗网络带宽。&lt;/p>
&lt;h3 id="35-任务粒度">3.5 任务粒度&lt;/h3>
&lt;p>我们将映射阶段细分为 M 个部分，将Reduce阶段细分为 R 个部分，如上所述。&lt;/p>
&lt;p>理想情况下，M 和 R 应远大于工作节点的数量。让每个工作节点执行许多不同的任务可以改善动态负载平衡，并且在工作节点失败时加快恢复速度：它已完成的许多Map任务可以分散到所有其他工作节点上。&lt;/p>
&lt;p>在我们的实现中，M 和 R 的大小存在实际的限制，因为主节点必须根据上述描述做出 O(M + R) 的调度决策，并在内存中保持 O(M * R) 的状态。（然而，内存使用的常数因子很小：状态的 O(M * R) 部分大约包含每个Map任务/Reduce任务对的一个字节的数据。）&lt;/p>
&lt;p>此外，R 通常受用户约束，因为每个Reduce任务的输出最终都会在单独的输出文件中结束。&lt;/p>
&lt;p>在实践中，我们倾向于选择 M，使每个单独的任务大约为 16 MB 到 64 MB 的输入数据（这样上面描述的本地性优化效果最佳），并且我们将 R 设为我们预期使用的工作节点数量的小倍数。&lt;/p>
&lt;p>我们经常使用 M = 200,000 和 R = 5,000 来执行 MapReduce 计算，使用 2,000 个工作节点。&lt;/p>
&lt;h3 id="36-备用任务">3.6 备用任务&lt;/h3>
&lt;p>延长 MapReduce 操作总时间的常见原因之一是“拖延者”：一个机器在计算中完成 &lt;strong>最后几个映射或Reduce任务中的一个&lt;/strong> 时花费异常长的时间。&lt;/p>
&lt;p>拖延者可能出现的原因很多。&lt;/p>
&lt;ul>
&lt;li>一个有坏硬盘的机器可能会经常发生可纠正错误，从而将其读取性能从 30 MB/s 减慢到 1 MB/s。&lt;/li>
&lt;li>集群调度系统可能已将其他任务调度到该机器上，导致由于竞争 CPU、内存、本地磁盘或网络带宽而更慢地执行 MapReduce 代码。&lt;/li>
&lt;li>我们最近遇到的一个问题是机器初始化代码中的一个错误导致处理器缓存被禁用：受影响的机器上的计算速度下降了一百多倍。&lt;/li>
&lt;/ul>
&lt;p>我们有一个通用机制来缓解拖延者的问题。&lt;/p>
&lt;ul>
&lt;li>当 MapReduce 操作&lt;strong>即将完成时&lt;/strong>，主节点会&lt;strong>安排剩余正在进行的任务的备用执行&lt;/strong>。&lt;/li>
&lt;li>只要&lt;strong>主要执行或备用执行完成&lt;/strong>，任务就被标记为已完成。&lt;/li>
&lt;li>我们已经调整了这个机制，使其通常将操作使用的&lt;strong>计算资源增加不超过几个百分点&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>我们发现这显著缩短了完成大型 MapReduce 操作所需的时间。例如，第 5.3 节中描述的排序程序在禁用备用任务机制时需要花费的时间要长 44%。&lt;/p>
&lt;h2 id="4优化">4.优化&lt;/h2>
&lt;p>虽然简单地编写映射和Reduce函数提供的基本功能对大多数需求已足够，但我们发现一些扩展很有用。这些在本节中描述。&lt;/p>
&lt;h3 id="41-分区函数">4.1 分区函数&lt;/h3>
&lt;p>MapReduce 的用户指定他们希望的Reduce任务/输出文件数量（R）。使用中间键上的分区函数将数据分区到这些任务中。&lt;/p>
&lt;p>提供了一个默认的分区函数，使用哈希（例如“hash(key) mod R”）。这往往会产生相当均衡的分区。&lt;/p>
&lt;p>但是，在某些情况下，通过键的某些其他函数对数据进行分区是有用的。例如，有时输出键是 URL，我们希望所有单个主机的条目都最终出现在同一个输出文件中。&lt;/p>
&lt;p>为了支持这种情况，MapReduce 库的用户可以提供一个特殊的分区函数。例如，使用“hash(Hostname(urlkey)) mod R”作为分区函数将导致同一主机的所有 URL 最终出现在同一个输出文件中。&lt;/p>
&lt;h3 id="42-排序保证">4.2 排序保证&lt;/h3>
&lt;p>我们保证在给定分区内，中间键/值对按照递增的键顺序处理。&lt;/p>
&lt;p>这个排序保证使得生成每个分区的排序输出文件变得容易，当输出文件格式需要支持通过键进行高效的随机访问查找，或者输出的用户发现按排序数据很方便时，这是很有用的。&lt;/p>
&lt;h3 id="43-组合器功能">4.3 组合器功能&lt;/h3>
&lt;p>在某些情况下，每个Map任务产生的&lt;strong>中间键中存在重复&lt;/strong>，并且用户指定的Reduce函数是&lt;strong>可交换和可结合&lt;/strong>的。&lt;/p>
&lt;p>这种情况的一个很好的例子是第 2.1 节中的单词计数示例。由于单词频率往往遵循 Zipf 分布，每个Map任务将产生数百或数千个形式为 &amp;lt;the, 1&amp;gt; 的记录。&lt;/p>
&lt;p>所有这些计数都将通过网络发送到单个Reduce任务，然后由Reduce函数相加以产生一个数字。我们&lt;strong>允许用户指定一个可选的组合器函数&lt;/strong>，在将数据发送到网络之前对其进行部分合并。&lt;/p>
&lt;p>组合器函数在执行Map任务的每台机器上执行。通常情况下，相同的代码用于实现组合器和Reduce函数。&lt;/p>
&lt;p>Reduce函数和组合器函数之间唯一的区别是 MapReduce 库如何处理函数的输出。Reduce函数的输出写入最终输出文件。组合器函数的输出写入一个&lt;strong>中间文件&lt;/strong>，该文件将被发送到Reduce任务。&lt;/p>
&lt;p>部分合并显着加速了某些类别的 MapReduce 操作。
2.1示例中使用了组合器函数&lt;/p>
&lt;h3 id="44-输入和输出类型">4.4 输入和输出类型&lt;/h3>
&lt;p>MapReduce 库提供了对几种不同格式的输入数据进行读取的支持。&lt;/p>
&lt;p>例如，“文本”模式输入将每一行视为一个键/值对：键是文件中的偏移量，值是行的内容。另一个常见的支持格式存储按键排序的键/值对序列。&lt;/p>
&lt;p>每种输入类型的实现都知道如何将自己分割成适当的范围以作为单独的Map任务进行处理（例如，文本模式的范围分割确保范围分割仅发生在行边界处）。&lt;/p>
&lt;p>用户可以通过&lt;strong>提供简单的读取器接口的实现来添加对新输入类型的支持&lt;/strong>，尽管大多数用户只使用少量预定义的输入类型之一。&lt;/p>
&lt;p>读取器不一定需要提供从文件读取的数据。例如，可以轻松定义一个从数据库或内存中映射的数据结构中读取记录的读取器。&lt;/p>
&lt;p>类似地，我们&lt;strong>支持一组输出类型&lt;/strong>，以产生不同格式的数据，用户代码可以轻松地添加对新输出类型的支持。&lt;/p>
&lt;h3 id="45-副作用">4.5 副作用&lt;/h3>
&lt;p>在某些情况下，MapReduce 的用户发现从他们的Map和/或Reduce操作中&lt;strong>产生辅助文件作为附加输出&lt;/strong>是很方便的。&lt;/p>
&lt;p>我们&lt;strong>依赖于应用程序编写者使这些副作用具有原子性和幂等性&lt;/strong>。通常，应用程序将写入临时文件，&lt;strong>并在完全生成后原子地&lt;/strong>将此文件重命名。&lt;/p>
&lt;p>我们&lt;strong>不支持由单个任务产生的多个输出文件的原子两阶段提交&lt;/strong>。因此，产生具有跨文件一致性要求的多个输出文件的任务应该是确定性的。在实践中，这种限制从未成为问题。&lt;/p>
&lt;h3 id="46-跳过错误记录">4.6 跳过错误记录&lt;/h3>
&lt;p>有时用户代码中存在错误，导致 Map 或 Reduce 函数在某些记录上出现确定性崩溃。这种错误会阻止 MapReduce 操作完成。&lt;/p>
&lt;p>通常的做法是修复错误，但有时这是不可行的；也许错误是由于不可用的第三方库中的 bug。&lt;/p>
&lt;p>此外，有时可以忽略一些记录，例如在大型数据集上进行统计分析时。我们提供了一种可选的执行模式，其中 MapReduce 库会&lt;strong>检测哪些记录导致确定性崩溃，并跳过这些记录以继续向前推进&lt;/strong>。&lt;/p>
&lt;p>每个工作进程都安装了一个信号处理程序，用于捕获段错误和总线错误。在调用用户的 Map 或 Reduce 操作之前，MapReduce 库会将参数的序列号存储在一个全局变量中。如果用户代码生成信号，信号处理程序会发送一个“最后一口气”的 UDP 数据包，其中包含序列号到 MapReduce 主节点。&lt;/p>
&lt;p>当主节点在特定记录上看到多次失败时，它表示应该在下一个重新执行相应的 Map 或 Reduce 任务时跳过该记录。&lt;/p>
&lt;h3 id="47-本地执行">4.7 本地执行&lt;/h3>
&lt;p>调试 Map 或 Reduce 函数中的问题可能会很棘手，因为实际的计算发生在一个分布式系统中，通常在数千台机器上进行，并由主节点动态地进行工作分配决策。&lt;/p>
&lt;p>为了帮助进行调试、分析和小规模测试，我们开发了 MapReduce 库的替代实现，它在本地机器上顺序执行 MapReduce 操作的所有工作。为用户提供了控制，以便计算可以限制在特定的Map任务上。&lt;/p>
&lt;p>用户使用特殊标志调用其程序，然后可以轻松地使用任何有用的调试或测试工具（例如 gdb）。&lt;/p>
&lt;h3 id="48-状态信息">4.8 状态信息&lt;/h3>
&lt;p>主节点运行一个内部 HTTP 服务器，并为人类消费者导出一组状态页面。&lt;/p>
&lt;p>状态页面显示计算的进度，例如已完成多少任务、正在进行多少任务、输入字节数、中间数据字节数、输出字节数、处理速率等。&lt;/p>
&lt;p>页面还包含每个任务生成的标准错误和标准输出文件的链接。用户可以使用这些数据来预测计算需要多长时间，以及是否应该向计算中添加更多资源。这些页面还可以用于确定计算是否比预期的慢得多。&lt;/p>
&lt;p>此外，顶级状态页面显示了哪些工作节点失败，以及它们在失败时正在处理哪些映射和缩减任务。在尝试诊断用户代码中的错误时，这些信息非常有用。&lt;/p>
&lt;h3 id="49-计数器">4.9 计数器&lt;/h3>
&lt;p>MapReduce 库提供了一个计数器功能，用于&lt;strong>计算各种事件的发生次数&lt;/strong>。&lt;/p>
&lt;p>例如，用户代码可能希望计算处理的总单词数或索引的德语文档数等。&lt;/p>
&lt;p>要使用此功能，用户代码创建一个命名计数器对象，然后在 Map 和/或 Reduce 函数中适当地递增计数器。例如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="n">Counter&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">uppercase&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">uppercase&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">GetCounter&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;uppercase&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">map&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">String&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="n">contents&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">each&lt;/span> &lt;span class="n">word&lt;/span> &lt;span class="n">w&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">contents&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">IsCapitalized&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">w&lt;/span>&lt;span class="p">)):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">uppercase&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">Increment&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">EmitIntermediate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">w&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;1&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>来自各个工作机器的计数器值会&lt;strong>定期传播到主节点（通过 ping 响应搭载）&lt;/strong>。&lt;/p>
&lt;p>主节点汇总成功的映射和缩减任务的计数器值，并在 MapReduce 操作完成时将它们返回给用户代码。
当前的计数器值也显示在主节点状态页面上，以便人类观察实时计算的进度。&lt;/p>
&lt;p>在聚合计数器值时，&lt;strong>主节点消除相同映射或缩减任务的重复执行的影响&lt;/strong>，以避免重复计数。（重复执行可能源自我们对备用任务的使用以及由于失败而重新执行任务。）&lt;/p>
&lt;p>MapReduce 库自动维护了一些计数器值，例如处理的输入键/值对数和生成的输出键/值对数。&lt;/p>
&lt;p>用户发现计数器功能对于检查 MapReduce 操作的行为非常有用。例如，在某些 MapReduce 操作中，用户代码可能希望确保生成的输出对数恰好等于处理的输入对数，或者处理的德语文档的比例在总处理的文档数中的可容忍比例内。&lt;/p>
&lt;h2 id="5-性能">5 性能&lt;/h2>
&lt;p>在这一部分，我们将衡量在一个大型机群上运行的两个计算的MapReduce性能。&lt;/p>
&lt;ul>
&lt;li>一个计算搜索大约1TB的数据，寻找特定的模式。&lt;/li>
&lt;li>另一个计算对大约1TB的数据进行排序。&lt;/li>
&lt;/ul>
&lt;p>这两个程序代表了MapReduce用户编写的真实程序的一个大的子集 - 一个类别的程序将数据从一种表示形式转换为另一种表示形式，另一个类别从大数据集中提取少量有趣的数据。&lt;/p>
&lt;h3 id="51-机群配置">5.1 机群配置&lt;/h3>
&lt;p>所有程序都在一个包含大约1800台机器的机群上执行。每台机器配备两个2GHz的Intel Xeon处理器，并启用超线程技术，4GB内存，两个160GB IDE硬盘，以及一个千兆以太网连接。这些机器排列成一个两级树形交换网络，根节点拥有约100-200 Gbps的聚合带宽。所有机器都位于同一个托管设施，因此任何一对机器之间的往返时间都不到一毫秒。&lt;/p>
&lt;p>在4GB内存中，大约有1-1.5GB被集群上运行的其他任务所占用。这些程序是在一个周末下午执行的，当时CPU、磁盘和网络大部分时间都是空闲的。&lt;/p>
&lt;h3 id="52-grep">5.2 Grep&lt;/h3>
&lt;p>grep程序扫描10^10个100字节的记录，搜索一个相对罕见的三字符模式（该模式在92337条记录中出现）。输入被分成大约64MB的片段（M = 15000），整个输出放在一个文件中（R = 1）。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/mapreduce-simplified-data-processing-on-large-clusters/img/2024-03-05-20-59-39_hu13327311053369897456.webp 400w,
/blog/mapreduce-simplified-data-processing-on-large-clusters/img/2024-03-05-20-59-39_hu8111238485008439292.webp 760w,
/blog/mapreduce-simplified-data-processing-on-large-clusters/img/2024-03-05-20-59-39_hu10990893313297337869.webp 1200w"
src="https://ysyyhhh.github.io/blog/mapreduce-simplified-data-processing-on-large-clusters/img/2024-03-05-20-59-39_hu13327311053369897456.webp"
width="760"
height="458"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
上图显示了随时间推移计算的进展情况。&lt;/p>
&lt;p>Y轴显示了扫描输入数据的速率。随着越来越多的机器被分配给这个MapReduce计算，速率逐渐提高，当分配了1764个工作节点时，达到了30GB/s以上的峰值。随着映射任务的完成，速率开始下降，并且在计算进行到大约80秒时降为零。整个计算大约需要150秒完成。这包括约一分钟的启动开销。这种开销是由于将程序传播到所有工作机器，以及与GFS交互以打开1000个输入文件集并获取所需信息以进行位置优化而造成的延迟。&lt;/p>
&lt;h3 id="53-排序">5.3 排序&lt;/h3>
&lt;p>sort程序对1010个100字节的记录进行排序（约1TB的数据）。该程序是模仿TeraSort基准测试[10]设计的。&lt;/p>
&lt;p>排序程序由不到50行的用户代码组成。三行Map函数从文本行中提取一个10字节的排序键并发出键和原始文本行作为中间键/值对。我们使用内置的Identity函数作为Reduce运算符。这个函数将中间键/值对不改变地作为输出键/值对。最终排序后的输出被写入一组2路复制的GFS文件（即，程序的输出为2TB）。与之前一样，输入数据被分割成64MB的片段（M = 15000）。我们将排序后的输出分成4000个文件（R = 4000）。分区函数使用键的初始字节将其分隔成R个片段之一。我们的分区函数对这个基准测试具有键的分布的内置知识。在一般的排序程序中，我们会添加一个预处理的MapReduce操作，该操作将收集键的样本并使用样本键的分布来计算最终排序传递的分割点。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/mapreduce-simplified-data-processing-on-large-clusters/img/2024-03-05-21-02-00_hu12583937083573790214.webp 400w,
/blog/mapreduce-simplified-data-processing-on-large-clusters/img/2024-03-05-21-02-00_hu9838881073722081948.webp 760w,
/blog/mapreduce-simplified-data-processing-on-large-clusters/img/2024-03-05-21-02-00_hu1144826555800371889.webp 1200w"
src="https://ysyyhhh.github.io/blog/mapreduce-simplified-data-processing-on-large-clusters/img/2024-03-05-21-02-00_hu12583937083573790214.webp"
width="760"
height="441"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
图显示了排序程序正常执行的进度。左上角的图表显示了读取输入的速率。速率峰值约为13 GB/s，并在大约200秒内迅速下降，因为所有的映射任务在200秒之前都已完成。请注意，输入速率小于grep。这是因为排序映射任务将大约一半的时间和I/O带宽用于将中间输出写入其本地磁盘。相应的grep的中间输出尺寸可以忽略不计。
左中的图表显示了数据从映射任务发送到减少任务的网络速率。这种洗牌在第一个映射任务完成后立即开始。图表中的第一个驼峰是约为1700个减少任务的第一批（整个MapReduce分配了约1700台机器，并且每台机器最多执行一个减少任务）。计算约300秒后，这些第一批减少任务中的一些完成，我们开始为剩余的减少任务洗牌数据。所有的洗牌在计算约600秒后完成。
左下的图表显示了排序数据由减少任务写入最终输出文件的速率。在第一个洗牌周期结束和写入周期开始之间有一个延迟，因为机器正在忙于排序中间数据。一段时间后，写入速率维持在约2-4 GB/s。所有写入在计算约850秒后完成。
包括启动开销，整个计算需要891秒。这与TeraSort基准测试[18]的当前最佳报告结果1057秒相似。
需要注意的几点：输入速率高于洗牌速率和输出速率，因为我们的局部性优化 - 大多数数据从本地磁盘读取，绕过了我们相对带宽受限的网络。洗牌速率高于输出速率，因为输出阶段写入了排序数据的两个副本（我们为了可靠性和可用性原因制作了输出的两个副本）。我们写入两个副本，因为这是我们底层文件系统提供的可靠性和可用性机制。如果底层文件系统使用纠删码[14]而不是复制，那么写入数据的网络带宽要求将会降低。&lt;/p>
&lt;h3 id="54-备份任务的影响">5.4 备份任务的影响&lt;/h3>
&lt;p>在图(b)中，我们展示了禁用备份任务的排序程序执行。执行流程与图3(a)中显示的类似，唯一不同的是存在一个非常长的尾部，在那里几乎没有任何写入活动发生。
在960秒后，除了5个减少任务外，所有任务都已完成。然而，这最后几个慢性病者直到300秒后才完成。整个计算需要1283秒，比经过的时间增加了44%。&lt;/p>
&lt;h3 id="55-机器故障">5.5 机器故障&lt;/h3>
&lt;p>在图(c)中，我们展示了排序程序的执行，我们在计算几分钟后故意杀死了1746个工作进程中的200个。底层集群调度程序立即在这些机器上重新启动了新的工作进程（因为只有进程被杀死，机器仍然正常运行）。&lt;/p>
&lt;p>工作进程的死亡表现为负的输入速率，因为一些之前完成的映射工作消失了（因为对应的映射工作者被杀死了），需要重新做。这个映射工作的重新执行发生得相对迅速。整个计算包括启动开销在内在933秒内完成（仅比正常执行时间增加了5%）。&lt;/p>
&lt;h2 id="6-经验">6 经验&lt;/h2>
&lt;p>我们在2003年2月编写了MapReduce库的第一个版本，并在2003年8月进行了重大改进，包括局部性优化、动态负载平衡跨工作机器的任务执行等。自那时起，我们惊讶地发现MapReduce库在我们处理的问题类型上具有广泛的适用性。&lt;/p>
&lt;p>它已经在Google内部的各个领域广泛应用，包括：&lt;/p>
&lt;ul>
&lt;li>大规模机器学习问题，&lt;/li>
&lt;li>Google新闻和Froogle产品的聚类问题，&lt;/li>
&lt;li>提取用于生成流行查询报告（例如Google Zeitgeist）的数据，&lt;/li>
&lt;li>为新实验和产品从网页中提取属性（例如从大量网页中提取地理位置以进行本地化搜索），&lt;/li>
&lt;li>大规模图计算。&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/mapreduce-simplified-data-processing-on-large-clusters/img/2024-03-05-21-04-13_hu11258222744468367439.webp 400w,
/blog/mapreduce-simplified-data-processing-on-large-clusters/img/2024-03-05-21-04-13_hu10010165053047341662.webp 760w,
/blog/mapreduce-simplified-data-processing-on-large-clusters/img/2024-03-05-21-04-13_hu14040378897671344556.webp 1200w"
src="https://ysyyhhh.github.io/blog/mapreduce-simplified-data-processing-on-large-clusters/img/2024-03-05-21-04-13_hu11258222744468367439.webp"
width="760"
height="757"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
图4显示了随着时间的推移，我们在主要源代码管理系统中检入的单独MapReduce程序数量的显著增长，从2003年初的0增加到截至2004年9月底近900个独立实例。MapReduce之所以如此成功，是因为它使得编写一个简单的程序，并在半个小时内在一千台机器上高效运行成为可能，极大地加快了开发和原型周期。此外，它允许没有分布式和/或并行系统经验的程序员轻松利用大量资源。在每个作业结束时，MapReduce库记录了作业使用的计算资源的统计信息。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/mapreduce-simplified-data-processing-on-large-clusters/img/2024-03-05-21-04-28_hu11061199633272111429.webp 400w,
/blog/mapreduce-simplified-data-processing-on-large-clusters/img/2024-03-05-21-04-28_hu2252395999914244064.webp 760w,
/blog/mapreduce-simplified-data-processing-on-large-clusters/img/2024-03-05-21-04-28_hu14387791825805509236.webp 1200w"
src="https://ysyyhhh.github.io/blog/mapreduce-simplified-data-processing-on-large-clusters/img/2024-03-05-21-04-28_hu11061199633272111429.webp"
width="760"
height="596"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
在表1中，我们展示了Google在2004年8月运行的一些MapReduce作业的统计信息子集。&lt;/p>
&lt;h3 id="61-大规模索引">6.1 大规模索引&lt;/h3>
&lt;p>迄今为止，我们对MapReduce的最重要的使用之一是完全重写了用于Google网页搜索服务的生产索引系统。索引系统将由我们的爬取系统检索到的大量文档作为输入，存储为一组GFS文件。这些文档的原始内容超过20TB的数据。索引过程作为五到十个MapReduce操作的序列运行。使用MapReduce（而不是之前版本索引系统中的特定分布式操作）带来了几个好处：&lt;/p>
&lt;ul>
&lt;li>索引代码更简单、更小、更容易理解，因为处理容错、分布和并行化的代码被隐藏在MapReduce库中。例如，计算的一个阶段的代码量从约3800行C++代码减少到使用MapReduce表达时约为700行。&lt;/li>
&lt;li>MapReduce库的性能足够好，我们可以将概念上无关的计算分开，而不是将它们混合在一起以避免对数据的额外传递。这使得改变索引过程变得容易。例如，在旧的索引系统中需要几个月的变更，在新系统中只需要几天就能实现。&lt;/li>
&lt;li>索引过程的操作变得更加容易，因为大部分由机器故障、慢机器和网络故障引起的问题都由MapReduce库自动处理，无需操作员干预。此外，通过向索引集群添加新机器来改进索引过程的性能也很容易。&lt;/li>
&lt;/ul>
&lt;h2 id="7-相关工作">7 相关工作&lt;/h2>
&lt;p>许多系统提供了受限制的编程模型，并利用这些限制自动并行化计算。例如，可以使用并行前缀计算在N个处理器上以log N时间计算N个元素数组的所有前缀[6, 9, 13]。根据我们在大型现实世界计算中的经验，MapReduce可以被视为对其中一些模型的简化和提炼。更重要的是，我们提供了一个可容忍故障的实现，可以扩展到数千个处理器。相比之下，大多数并行处理系统只在较小的规模上实现，并将处理机器故障的细节留给程序员。&lt;/p>
&lt;p>批量同步编程[17]和一些MPI原语[11]提供了更高级别的抽象，使程序员更容易编写并行程序。这些系统与MapReduce之间的一个关键区别在于，MapReduce利用受限编程模型来自动并行化用户程序，并提供透明的容错机制。&lt;/p>
&lt;p>我们的局部性优化受到了诸如主动磁盘[12, 15]等技术的启发，其中计算被推送到靠近本地磁盘的处理元素，以减少跨I/O子系统或网络发送的数据量。我们在普通处理器上运行，其中直接连接了少量磁盘，而不是直接在磁盘控制器处理器上运行，但总体方法是相似的。&lt;/p>
&lt;p>我们的备份任务机制类似于Charlotte系统[3]中采用的急切调度机制。简单的急切调度的一个缺点是，如果一个给定的任务导致重复的故障，整个计算将无法完成。我们通过跳过错误记录的机制来解决一些这样的问题。&lt;/p>
&lt;p>MapReduce实现依赖于一种内部集群管理系统，该系统负责在大量共享机器上分发和运行用户任务。尽管本文的重点不在此，但集群管理系统在精神上与其他系统如Condor [16]类似。&lt;/p>
&lt;p>MapReduce库中的排序设施与NOW-Sort [1]的操作类似。源机器（映射工作器）对要排序的数据进行分区，并将其发送到R个减少工作者之一。每个减少工作者在本地排序其数据（如果可能的话在内存中）。当然，NOW-Sort没有用户可定义的Map和Reduce函数，这使得我们的库具有广泛的适用性。&lt;/p>
&lt;p>River [2]提供了一个编程模型，其中进程通过在分布式队列上发送数据进行通信。与MapReduce类似，River系统试图在异构硬件或系统扰动引入的非均匀性的情况下提供良好的平均性能。River通过仔细调度磁盘和网络传输来实现平衡的完成时间。MapReduce采用了一种不同的方法。通过限制编程模型，MapReduce框架能够将问题划分为大量的细粒度任务。这些任务动态地调度在可用工作者上，以便更快的工作者处理更多的任务。受限编程模型还允许我们在作业结束时调度任务的冗余执行，这在存在非均匀性（例如慢速或卡住的工作者）时极大地减少了完成时间。&lt;/p>
&lt;p>BAD-FS [5]与MapReduce有着非常不同的编程模型，与MapReduce不同，它的目标是跨广域网络执行作业。然而，它们有两个基本的相似之处。一是这两个系统都使用冗余执行来从故障引起的数据丢失中恢复。二是它们都使用了局部感知调度来减少在拥塞的网络链路上传输的数据量。&lt;/p>
&lt;p>TACC [7]是一个旨在简化高可用网络服务构建的系统。与MapReduce类似，它依赖于重新执行作为实现容错的机制。&lt;/p>
&lt;h2 id="8-结论">8 结论&lt;/h2>
&lt;p>MapReduce编程模型在Google被成功地用于许多不同的目的。我们将这一成功归因于几个原因。&lt;/p>
&lt;ul>
&lt;li>首先，该模型易于使用，即使是对于没有并行和分布式系统经验的程序员，因为它隐藏了并行化、容错、局部优化和负载平衡的细节。&lt;/li>
&lt;li>其次，大量的问题都可以很容易地表达为MapReduce计算。例如，MapReduce用于生成Google生产的网络搜索服务的数据，用于排序，数据挖掘，机器学习以及许多其他系统。&lt;/li>
&lt;li>第三，我们开发了一个MapReduce的实现，可以扩展到包含数千台机器的大型集群。该实现有效地利用了这些机器资源，因此适用于Google遇到的许多大型计算问题。&lt;/li>
&lt;/ul>
&lt;p>我们从这项工作中学到了几件事情。&lt;/p>
&lt;ul>
&lt;li>首先，限制编程模型使得并行化和分布计算变得容易，并使得这样的计算具有容错性。&lt;/li>
&lt;li>其次，网络带宽是一种稀缺资源。因此，我们系统中的许多优化都旨在减少在网络上传输的数据量：局部优化允许我们从本地磁盘读取数据，将中间数据写入本地磁盘的单个副本可以节省网络带宽。&lt;/li>
&lt;li>第三，冗余执行可以减少慢速机器的影响，并处理机器故障和数据丢失。&lt;/li>
&lt;/ul></description></item><item><title>Abstraction vs implementation</title><link>https://ysyyhhh.github.io/blog/abstraction-vs-implementation/</link><pubDate>Fri, 01 Mar 2024 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/blog/abstraction-vs-implementation/</guid><description>&lt;h2 id="ispc-language">ISPC language&lt;/h2>
&lt;p>SPMD: Single Program Multiple Data
一种花哨的方式来说，就是一种并行编程的范式，它的特点是：在编程时，我们只需要写一个程序，然后在运行时，这个程序会被复制多份，每一份都会被分配到不同的处理器上去执行，这样就实现了并行。&lt;/p>
&lt;p>用ISPC实现sinx&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="n">export&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">sinx&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">uniform&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">uniform&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">terms&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">uniform&lt;/span> &lt;span class="kt">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">uniform&lt;/span> &lt;span class="kt">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//assume N % programCount == 0
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">uniform&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">programCount&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">idx&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">programIndex&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">float&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">idx&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">float&lt;/span> &lt;span class="n">number&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">uniform&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">denom&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">6&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">uniform&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">sign&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">uniform&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">terms&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">j&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">value&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">sign&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">number&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="n">denom&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">number&lt;/span> &lt;span class="o">*=&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">denom&lt;/span> &lt;span class="o">*=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">sign&lt;/span> &lt;span class="o">*=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">result&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">idx&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用C++来调用
调用ISPC的东西是个程序实例的集合, gang.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c++" data-lang="c++">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;#34;sinx.ispc.h&amp;#34;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="n">N&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1000000&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="n">terms&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="kt">float&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">N&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="kt">float&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">N&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//init x
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//execute
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">ispc&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">sinx&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">N&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">terms&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">result&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/abstraction-vs-implementation/img/2023-10-07-21-12-02_hu9282701625375597985.webp 400w,
/blog/abstraction-vs-implementation/img/2023-10-07-21-12-02_hu5657243070188642960.webp 760w,
/blog/abstraction-vs-implementation/img/2023-10-07-21-12-02_hu17478584031291858892.webp 1200w"
src="https://ysyyhhh.github.io/blog/abstraction-vs-implementation/img/2023-10-07-21-12-02_hu9282701625375597985.webp"
width="377"
height="390"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>ispc中不需要手动设置programCount,programIndex&lt;/p>
&lt;p>programCount: &lt;strong>number of simultaneous program&lt;/strong> instances in the gang (uniform value)&lt;/p>
&lt;p>programIndex: &lt;strong>id of the current program&lt;/strong> instance in the gang(a non-uniform value)&lt;/p>
&lt;p>uniform value: 一个值在gang中的所有实例中都是一样的&lt;/p>
&lt;p>如果在ispc中直接使用sinx 并不会更快.&lt;/p>
&lt;p>因为有一些相同的工作会被重复做很多次.
通过分离他们,可以减少重复计算的次数,从而提高效率.&lt;/p>
&lt;p>一个设想的实现方法如下:
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/abstraction-vs-implementation/img/2023-10-07-21-20-55_hu4285193158749084352.webp 400w,
/blog/abstraction-vs-implementation/img/2023-10-07-21-20-55_hu14737522556731425507.webp 760w,
/blog/abstraction-vs-implementation/img/2023-10-07-21-20-55_hu1903451696671621838.webp 1200w"
src="https://ysyyhhh.github.io/blog/abstraction-vs-implementation/img/2023-10-07-21-20-55_hu4285193158749084352.webp"
width="728"
height="526"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>ISPC是为了更容易编写SIMD代码而设计的, 只需要通过特殊的宏或编译指示就可以使用SIMD指令.&lt;/p>
&lt;p>programCount 就是 向量宽度&lt;/p>
&lt;p>SPMD programming &lt;strong>abstraction&lt;/strong>&lt;/p>
&lt;p>ISPC compiler generates SIMD &lt;strong>implementation&lt;/strong>&lt;/p>
&lt;p>version2版本的代码,这是分块进行而不是交错的.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="n">export&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">sinx&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">uniform&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">uniform&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">terms&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">uniform&lt;/span> &lt;span class="kt">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">uniform&lt;/span> &lt;span class="kt">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">uniform&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">count&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">N&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="n">programCount&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">start&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">programIndex&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">count&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//assume N % programCount == 0
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">uniform&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">count&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">idx&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">start&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">float&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">idx&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">float&lt;/span> &lt;span class="n">number&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">uniform&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">denom&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">6&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">uniform&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">sign&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">uniform&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">terms&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">j&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">value&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">sign&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">number&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="n">denom&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">number&lt;/span> &lt;span class="o">*=&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">denom&lt;/span> &lt;span class="o">*=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">sign&lt;/span> &lt;span class="o">*=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">result&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">idx&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/abstraction-vs-implementation/img/2023-10-07-21-26-19_hu48968933533596123.webp 400w,
/blog/abstraction-vs-implementation/img/2023-10-07-21-26-19_hu9706866500724855113.webp 760w,
/blog/abstraction-vs-implementation/img/2023-10-07-21-26-19_hu10557575453289442180.webp 1200w"
src="https://ysyyhhh.github.io/blog/abstraction-vs-implementation/img/2023-10-07-21-26-19_hu48968933533596123.webp"
width="723"
height="530"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>交错通常比分块更好,因为分块会导致数据的访问不连续. 当计算量不均匀时,分块会导致一些处理器的负载过重,而另一些处理器的负载过轻.&lt;/p>
&lt;p>并且因为是同时进行的, 交错可以访问邻近的数据,这样可以增加cache的命中率.&lt;/p>
&lt;p>根本原因:
矢量加载指令(寄存器)是一次加载多个数据,如果在很短的时间内,要加载的数据是连续的,那么就可以一次加载多个数据,如果数据是不连续的,那么就需要多次加载,这样就会降低效率.
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/abstraction-vs-implementation/img/2023-10-07-21-30-56_hu14819585606310540165.webp 400w,
/blog/abstraction-vs-implementation/img/2023-10-07-21-30-56_hu9520840019919960909.webp 760w,
/blog/abstraction-vs-implementation/img/2023-10-07-21-30-56_hu14020451338183904720.webp 1200w"
src="https://ysyyhhh.github.io/blog/abstraction-vs-implementation/img/2023-10-07-21-30-56_hu14819585606310540165.webp"
width="760"
height="562"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>如果有个聪明的编译器,它可以自动将分块的代码转换为交错的代码,这样就可以兼顾两者的优点.&lt;/p>
&lt;p>foreach就可以实现这个功能,让程序员不需要关心这些细节.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="n">export&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">sinx&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">uniform&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">uniform&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">terms&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">uniform&lt;/span> &lt;span class="kt">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">uniform&lt;/span> &lt;span class="kt">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">foreach&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="p">...&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">float&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">float&lt;/span> &lt;span class="n">number&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">uniform&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">denom&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">6&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">uniform&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">sign&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">uniform&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">terms&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">j&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">value&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">sign&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">number&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="n">denom&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">number&lt;/span> &lt;span class="o">*=&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">denom&lt;/span> &lt;span class="o">*=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">sign&lt;/span> &lt;span class="o">*=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">result&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ISPC的错误例子:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="n">export&lt;/span> &lt;span class="n">uniform&lt;/span> &lt;span class="kt">float&lt;/span> &lt;span class="nf">sumall&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">uniform&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">uniform&lt;/span> &lt;span class="kt">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">uniform&lt;/span> &lt;span class="kt">float&lt;/span> &lt;span class="n">sum&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">foreach&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="p">...&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">sum&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">sum&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>错误:编译器会报错,因为sum是一个uniform value,它在所有的实例中都是一样的,但是在foreach中,每个实例都会对sum进行修改,这样就会导致错误.&lt;/p>
&lt;p>修正这个错误:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="n">export&lt;/span> &lt;span class="n">uniform&lt;/span> &lt;span class="kt">float&lt;/span> &lt;span class="nf">sumall&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">uniform&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">uniform&lt;/span> &lt;span class="kt">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">uniform&lt;/span> &lt;span class="kt">float&lt;/span> &lt;span class="n">sum&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">float&lt;/span> &lt;span class="n">partial_sum&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">foreach&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="p">...&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">partial_sum&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">sum&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nf">reduce_add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">partial_sum&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">sum&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>reduce_add原语: 允许将一组不同的值合并为一个值,这个值在所有的实例中都是一样的.&lt;/p>
&lt;p>编译后的细节
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/abstraction-vs-implementation/img/2023-10-07-21-41-11_hu3050225511229111609.webp 400w,
/blog/abstraction-vs-implementation/img/2023-10-07-21-41-11_hu9574356879993187582.webp 760w,
/blog/abstraction-vs-implementation/img/2023-10-07-21-41-11_hu4819400568730628279.webp 1200w"
src="https://ysyyhhh.github.io/blog/abstraction-vs-implementation/img/2023-10-07-21-41-11_hu3050225511229111609.webp"
width="741"
height="536"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>ISPC tasks: 基本上就是一个线程,但是它可以被分配到不同的处理器上去执行.&lt;/p>
&lt;h2 id="三种并行编程范式-和-三种-machine-architecture">三种并行编程范式 和 三种 machine architecture&lt;/h2>
&lt;p>聚焦于 communication 和 cooperation&lt;/p>
&lt;p>使用pthread时要call operate system
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/abstraction-vs-implementation/img/2023-10-07-21-46-12_hu5352982571072477324.webp 400w,
/blog/abstraction-vs-implementation/img/2023-10-07-21-46-12_hu6026897659817638473.webp 760w,
/blog/abstraction-vs-implementation/img/2023-10-07-21-46-12_hu11828751277665544466.webp 1200w"
src="https://ysyyhhh.github.io/blog/abstraction-vs-implementation/img/2023-10-07-21-46-12_hu5352982571072477324.webp"
width="737"
height="539"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>而在ISPC中,只需要call compiler&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/abstraction-vs-implementation/img/2023-10-07-21-46-25_hu29904574745819789.webp 400w,
/blog/abstraction-vs-implementation/img/2023-10-07-21-46-25_hu366018418687561907.webp 760w,
/blog/abstraction-vs-implementation/img/2023-10-07-21-46-25_hu5509121158314551360.webp 1200w"
src="https://ysyyhhh.github.io/blog/abstraction-vs-implementation/img/2023-10-07-21-46-25_hu29904574745819789.webp"
width="727"
height="516"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="three-models-of-communicationabstraction">Three models of communication(abstraction)&lt;/h3>
&lt;h4 id="1shared-address-space">1.Shared address space&lt;/h4>
&lt;p>asst3中会用到&lt;/p>
&lt;p>多个线程之间通过互斥锁来进行通信&lt;/p>
&lt;p>在硬件中, Dance-hall model
所有处理器在同一侧.&lt;/p>
&lt;p>Symmetric Multiprocessor(SMP) system 就是如此&lt;/p>
&lt;p>最简单的方式是总线, 但这样无法扩展,因为总线的带宽是有限的.
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/abstraction-vs-implementation/img/2023-10-07-21-53-08_hu13520670111447733998.webp 400w,
/blog/abstraction-vs-implementation/img/2023-10-07-21-53-08_hu17084229708586410951.webp 760w,
/blog/abstraction-vs-implementation/img/2023-10-07-21-53-08_hu2213875292188230937.webp 1200w"
src="https://ysyyhhh.github.io/blog/abstraction-vs-implementation/img/2023-10-07-21-53-08_hu13520670111447733998.webp"
width="719"
height="515"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
但实际中:
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/abstraction-vs-implementation/img/2023-10-07-21-55-16_hu6769983445287323807.webp 400w,
/blog/abstraction-vs-implementation/img/2023-10-07-21-55-16_hu17809240237380959910.webp 760w,
/blog/abstraction-vs-implementation/img/2023-10-07-21-55-16_hu18165064752681911829.webp 1200w"
src="https://ysyyhhh.github.io/blog/abstraction-vs-implementation/img/2023-10-07-21-55-16_hu6769983445287323807.webp"
width="700"
height="525"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/abstraction-vs-implementation/img/2023-10-07-21-55-34_hu2070005192718626287.webp 400w,
/blog/abstraction-vs-implementation/img/2023-10-07-21-55-34_hu9616390532636536733.webp 760w,
/blog/abstraction-vs-implementation/img/2023-10-07-21-55-34_hu7454933321016008505.webp 1200w"
src="https://ysyyhhh.github.io/blog/abstraction-vs-implementation/img/2023-10-07-21-55-34_hu2070005192718626287.webp"
width="713"
height="527"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>还有一种访问本地内存的方式,就是通过cache,这样就可以减少对总线的访问,从而提高效率.
Non-Uniform Memory Access(NUMA) system
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/abstraction-vs-implementation/img/2023-10-14-14-14-34_hu5567853062031940854.webp 400w,
/blog/abstraction-vs-implementation/img/2023-10-14-14-14-34_hu13487847106337012368.webp 760w,
/blog/abstraction-vs-implementation/img/2023-10-14-14-14-34_hu3680532865459202053.webp 1200w"
src="https://ysyyhhh.github.io/blog/abstraction-vs-implementation/img/2023-10-14-14-14-34_hu5567853062031940854.webp"
width="760"
height="410"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>但它为程序员引入的复杂性是很大的,因为程序员需要手动的将数据放到本地内存中,这样才能提高效率.&lt;/p>
&lt;p>shared address space的优点:&lt;/p>
&lt;ol>
&lt;li>程序员不需要关心数据的传输&lt;/li>
&lt;li>程序员不需要关心数据的分布&lt;/li>
&lt;/ol>
&lt;h4 id="2message-passing">2.Message passing&lt;/h4>
&lt;p>aasst4中会用到&lt;/p>
&lt;p>由于实现缓存一致性需要额外的成本，因此在大型系统中，共享内存的实现是不可行的。在这种情况下，消息传递是一种更好的选择。&lt;/p>
&lt;p>在消息传递中，每个处理器都有自己的私有内存，而且没有共享内存。要在处理器之间传递数据，必须使用显式的消息传递原语。&lt;/p>
&lt;p>不需要任何硬件支持，因此可以在任何系统上实现。只需要网络。&lt;/p>
&lt;p>可以构建大型系统，因为没有共享内存的限制。&lt;/p>
&lt;p>这些原语允许程序员在处理器之间传递数据，但是程序员必须显式地指定数据的传输。这种方式的缺点是，程序员需要关心数据的传输，这样就会增加程序员的负担。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/abstraction-vs-implementation/img/2023-10-14-14-18-37_hu7621481027696933928.webp 400w,
/blog/abstraction-vs-implementation/img/2023-10-14-14-18-37_hu17833657425707473931.webp 760w,
/blog/abstraction-vs-implementation/img/2023-10-14-14-18-37_hu12451637276131113093.webp 1200w"
src="https://ysyyhhh.github.io/blog/abstraction-vs-implementation/img/2023-10-14-14-18-37_hu7621481027696933928.webp"
width="760"
height="513"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h4 id="3data-parallel">3.Data parallel&lt;/h4>
&lt;p>asst2中会用到&lt;/p>
&lt;p>上面两种方式可以在任何硬件上实现。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/abstraction-vs-implementation/img/2023-10-14-14-22-41_hu15714592328482043297.webp 400w,
/blog/abstraction-vs-implementation/img/2023-10-14-14-22-41_hu11542848716373312190.webp 760w,
/blog/abstraction-vs-implementation/img/2023-10-14-14-22-41_hu6585098874126988090.webp 1200w"
src="https://ysyyhhh.github.io/blog/abstraction-vs-implementation/img/2023-10-14-14-22-41_hu15714592328482043297.webp"
width="760"
height="440"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>Data parallel对程序员来说是最简单的，因为程序员不需要关心数据的传输，也不需要关心数据的分布。但是，它只能在特定的硬件上实现，因为它需要硬件支持。&lt;/p>
&lt;p>过去我们使用SIMD，现在使用SPMD。&lt;/p>
&lt;p>并行程序的问题&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/abstraction-vs-implementation/img/2023-10-14-14-28-16_hu185476308639165877.webp 400w,
/blog/abstraction-vs-implementation/img/2023-10-14-14-28-16_hu3329871272011984252.webp 760w,
/blog/abstraction-vs-implementation/img/2023-10-14-14-28-16_hu16023658006445354560.webp 1200w"
src="https://ysyyhhh.github.io/blog/abstraction-vs-implementation/img/2023-10-14-14-28-16_hu185476308639165877.webp"
width="760"
height="562"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>这样的并行会得到不确定的结果。&lt;/p>
&lt;p>那么如何有原则性地使用并行呢？&lt;/p>
&lt;p>有一个抽象概念是stream，可以避免并行竞争问题。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/abstraction-vs-implementation/img/2023-10-14-14-30-44_hu5083156463735481845.webp 400w,
/blog/abstraction-vs-implementation/img/2023-10-14-14-30-44_hu10339864883292218012.webp 760w,
/blog/abstraction-vs-implementation/img/2023-10-14-14-30-44_hu18252197702213786161.webp 1200w"
src="https://ysyyhhh.github.io/blog/abstraction-vs-implementation/img/2023-10-14-14-30-44_hu5083156463735481845.webp"
width="760"
height="519"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>两个函数间的用法：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/abstraction-vs-implementation/img/2023-10-14-14-31-24_hu15113251809133243437.webp 400w,
/blog/abstraction-vs-implementation/img/2023-10-14-14-31-24_hu16123933768306769971.webp 760w,
/blog/abstraction-vs-implementation/img/2023-10-14-14-31-24_hu13300369273000068306.webp 1200w"
src="https://ysyyhhh.github.io/blog/abstraction-vs-implementation/img/2023-10-14-14-31-24_hu15113251809133243437.webp"
width="760"
height="559"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>当如果使用stream，就必须创建tmp。不得不把临时数据写入浪费的带宽中。&lt;/p>
&lt;p>所以我们希望也许有一些新的运算符可以做更加高级的操作。&lt;/p>
&lt;p>gather: 将数据从不同的stream中收集到一个stream中。
scatter: 将数据从一个stream中分散到不同的stream中。&lt;/p>
&lt;p>intel包括了gather，但不包括scatter。
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/abstraction-vs-implementation/img/2023-10-14-14-39-33_hu18320445558944685366.webp 400w,
/blog/abstraction-vs-implementation/img/2023-10-14-14-39-33_hu6799013135932567298.webp 760w,
/blog/abstraction-vs-implementation/img/2023-10-14-14-39-33_hu7501076981725886325.webp 1200w"
src="https://ysyyhhh.github.io/blog/abstraction-vs-implementation/img/2023-10-14-14-39-33_hu18320445558944685366.webp"
width="760"
height="568"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/abstraction-vs-implementation/img/2023-10-14-14-42-00_hu15474912180832884224.webp 400w,
/blog/abstraction-vs-implementation/img/2023-10-14-14-42-00_hu10242706057101632700.webp 760w,
/blog/abstraction-vs-implementation/img/2023-10-14-14-42-00_hu4245931999208258144.webp 1200w"
src="https://ysyyhhh.github.io/blog/abstraction-vs-implementation/img/2023-10-14-14-42-00_hu15474912180832884224.webp"
width="760"
height="557"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h4 id="总结">总结&lt;/h4>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/abstraction-vs-implementation/img/2023-10-14-14-44-11_hu13040388546316006982.webp 400w,
/blog/abstraction-vs-implementation/img/2023-10-14-14-44-11_hu15444513962589127224.webp 760w,
/blog/abstraction-vs-implementation/img/2023-10-14-14-44-11_hu9367966423806365823.webp 1200w"
src="https://ysyyhhh.github.io/blog/abstraction-vs-implementation/img/2023-10-14-14-44-11_hu13040388546316006982.webp"
width="760"
height="512"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>这些并不是完全独立的，而是可以组合使用的。&lt;/p>
&lt;p>通常在实践中为了得到最好的性能，会使用以上所有的方式。&lt;/p>
&lt;p>多核芯片内部通常是shared address space，但小规模情况下使用message passing。&lt;/p></description></item><item><title>asst1</title><link>https://ysyyhhh.github.io/blog/asst1/</link><pubDate>Fri, 01 Mar 2024 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/blog/asst1/</guid><description>&lt;p>&lt;a href="https://www.cnblogs.com/kalicener/p/16824312.html" target="_blank" rel="noopener">参考&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://github.com/stanford-cs149/asst1" target="_blank" rel="noopener">任务&lt;/a>&lt;/p>
&lt;h2 id="program-1-parallel-fractal-generation-using-threads-20-pointshttpsgithubcomstanford-cs149asst1program-1-parallel-fractal-generation-using-threads-20-points">&lt;a href="https://github.com/stanford-cs149/asst1#program-1-parallel-fractal-generation-using-threads-20-points" target="_blank" rel="noopener">Program 1: Parallel Fractal Generation Using Threads (20 points)&lt;/a>&lt;/h2>
&lt;p>提示:
需要先看CMU15-418/CS149的L2再完成Pro1&lt;/p>
&lt;p>任务描述:
用多线程画mandelbrot fractal.&lt;/p>
&lt;p>代码中给出了串行的实现, 你需要实现多线程的版本.&lt;/p>
&lt;p>多线程版本中只需要修改 &lt;code>workerThreadStart&lt;/code>函数.
不需要手动创建线程, 也不需要手动join线程.
直接调用mandelbrotThread().&lt;/p>
&lt;h3 id="11--12-计算在23456781632个线程下的加速比">1.1 &amp;amp; 1.2, 计算在2,3,4,5,6,7,8,16,32个线程下的加速比&lt;/h3>
&lt;h4 id="编写并观察">编写并观察&lt;/h4>
&lt;p>workerThreadStart函数的实现:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="mi">345&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">workerThreadStart&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">WorkerArgs&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// TODO FOR CS149 STUDENTS: Implement the body of the worker
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// thread here. Each thread should make a call to mandelbrotSerial()
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// to compute a part of the output image. For example, in a
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// program that uses two threads, thread 0 could compute the top
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// half of the image and thread 1 could compute the bottom half.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// printf(&amp;#34;Hello world from thread %d\n&amp;#34;, args-&amp;gt;threadId);
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">double&lt;/span> &lt;span class="n">startTime&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">CycleTimer&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">currentSeconds&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 每个线程负责的行数(除不尽的部分由最后一个线程负责)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">height&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">height&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">numThreads&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">startRow&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">threadId&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">height&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">numRows&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">height&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">threadId&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">numThreads&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 如果是最后一个线程，那么就要把除不尽的部分也算上
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">numRows&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">height&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">height&lt;/span> &lt;span class="o">%&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">numThreads&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Thread %d startRow: %d, numRows: %d&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">threadId&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">startRow&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">numRows&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">mandelbrotSerial&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">x0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">y0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">x1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">y1&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">width&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">height&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">startRow&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">numRows&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">maxIterations&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">output&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">double&lt;/span> &lt;span class="n">endTime&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">CycleTimer&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">currentSeconds&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Thread %d time: %.3f ms&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">threadId&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">endTime&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">startTime&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="mi">1000&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>结果:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>线程数&lt;/th>
&lt;th>加速比&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>2&lt;/td>
&lt;td>1.97&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>3&lt;/td>
&lt;td>1.63&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>4&lt;/td>
&lt;td>2.31&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>5&lt;/td>
&lt;td>2.37&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>6&lt;/td>
&lt;td>3.08&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>7&lt;/td>
&lt;td>3.15&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>8&lt;/td>
&lt;td>3.74&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>16&lt;/td>
&lt;td>5.14&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>可以观察到，加速比和线程数并不是线性相关.&lt;/p>
&lt;h4 id="猜测原因">猜测原因&lt;/h4>
&lt;p>猜测可能的原因有:&lt;/p>
&lt;ul>
&lt;li>线程通信的开销&lt;/li>
&lt;li>每个线程分配的任务不均匀&lt;/li>
&lt;/ul>
&lt;h3 id="13-查看每个线程的执行时间验证猜想">1.3 查看每个线程的执行时间,验证猜想&lt;/h3>
&lt;p>当线程数为4时, 每个线程的执行时间如下:
Thread 0 time: 63.974 ms
Thread 3 time: 65.563 ms
Thread 2 time: 259.972 ms
Thread 1 time: 260.669 ms&lt;/p>
&lt;p>当线程数为8时, 每个线程的执行时间如下:
Thread 0 time: 13.702 ms
Thread 7 time: 16.831 ms
Thread 1 time: 57.324 ms
Thread 6 time: 61.069 ms
Thread 5 time: 113.431 ms
Thread 2 time: 115.753 ms
Thread 4 time: 164.736 ms
Thread 3 time: 166.306 ms&lt;/p>
&lt;p>可以看到,中间线程分配的任务更多,执行时间更长.
因此在增加线程数时,加速比并不是线性增加的.&lt;/p>
&lt;h3 id="14">1.4&lt;/h3>
&lt;p>任务描述:&lt;/p>
&lt;ul>
&lt;li>解决上面的问题,使得加速比更接近线性.
&lt;ul>
&lt;li>如: 8线程时的加速比需要在7~8之间.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>解决方法需要具有适用性, 适用所有的线程数.&lt;/li>
&lt;/ul>
&lt;p>tips:
有一个非常简单的静态赋值可以实现这个目标，并且线程之间不需要通信/同步.&lt;/p>
&lt;h4 id="解决方案">解决方案&lt;/h4>
&lt;p>思路:
根据代码可知, 每行的计算是独立的, 因此可以将每行分配给不同的线程.
但由上面的实验可知,中间行的计算量比较大.&lt;/p>
&lt;p>因此我们不应该直接平均切分行, 而是以线程数量为步长,线程交叉依次分配行.
即 第i个线程分配k*n+i行.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">workerThreadStart&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">WorkerArgs&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// TODO FOR CS149 STUDENTS: Implement the body of the worker
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// thread here. Each thread should make a call to mandelbrotSerial()
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// to compute a part of the output image. For example, in a
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// program that uses two threads, thread 0 could compute the top
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// half of the image and thread 1 could compute the bottom half.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// printf(&amp;#34;Hello world from thread %d\n&amp;#34;, args-&amp;gt;threadId);
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">double&lt;/span> &lt;span class="n">startTime&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">CycleTimer&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">currentSeconds&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cm">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> 方案1
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> // 每个线程负责的行数(除不尽的部分由最后一个线程负责)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> int baseHeight = args-&amp;gt;height / args-&amp;gt;numThreads;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> int startRow = args-&amp;gt;threadId * baseHeight;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> int numRows = baseHeight;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> int yu = args-&amp;gt;height % args-&amp;gt;numThreads;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> // 均匀分配剩余行
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> if (args-&amp;gt;threadId &amp;lt; yu)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> {
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> numRows++;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> }
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> startRow += std::min(args-&amp;gt;threadId, yu);
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> printf(&amp;#34;Thread %d startRow: %d, numRows: %d\n&amp;#34;, args-&amp;gt;threadId, startRow, numRows);
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> mandelbrotSerial(args-&amp;gt;x0, args-&amp;gt;y0, args-&amp;gt;x1, args-&amp;gt;y1,
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> args-&amp;gt;width, args-&amp;gt;height,
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> startRow, numRows,
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> args-&amp;gt;maxIterations, args-&amp;gt;output);
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 方案2, 依次分配行
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">height&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">height&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">threadId&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">height&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">numThreads&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">mandelbrotSerial&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">x0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">y0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">x1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">y1&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">width&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">height&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">maxIterations&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">output&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">double&lt;/span> &lt;span class="n">endTime&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">CycleTimer&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">currentSeconds&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Thread %d time: %.3f ms&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">threadId&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">endTime&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">startTime&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="mi">1000&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>输出结果:&lt;/p>
&lt;p>Thread 3 time: 88.842 ms
Thread 1 time: 89.680 ms
Thread 0 time: 89.717 ms
Thread 7 time: 90.280 ms
Thread 5 time: 90.715 ms
Thread 6 time: 90.743 ms
Thread 2 time: 91.049 ms
Thread 4 time: 92.982 ms
[mandelbrot thread]: [93.318] ms
Wrote image file mandelbrot-thread.ppm
(7.10x speedup from 8 threads)&lt;/p>
&lt;p>上面的解决方案使得每个线程的执行时间基本相同,因此加速比接近线性.
在8线程时,加速比为7.1.&lt;/p>
&lt;h3 id="15-16线程和8线程的加速比">1.5 16线程和8线程的加速比&lt;/h3>
&lt;p>现在16线程是否明显优于8线程? 给出是或否的原因.
(6.45x speedup from 16 threads)
16线程并没有明显由于8线程,反而还更慢.
原因:&lt;/p>
&lt;ul>
&lt;li>电脑本身是4核, 超线程后是8线程.&lt;/li>
&lt;li>16线程时线程切换反而导致开销增加.&lt;/li>
&lt;/ul>
&lt;h3 id="总结">总结&lt;/h3>
&lt;p>pro1的目的是为了认识到并行计算的overhead, 以及多线程在计算上也应该是依次交替分配的. 不能简单的平均分配.&lt;/p>
&lt;p>pro1是通过垂直分割来实现并行计算.
而向量化是通过水平分割来实现并行计算.&lt;/p>
&lt;h2 id="program-2-vectorizing-code-using-simd-intrinsics">program-2-vectorizing-code-using-simd-intrinsics&lt;/h2>
&lt;p>前提: L2
任务描述：
使用SIMD指令(CS149intrin.h提供的),来实现clampedExpVector函数.&lt;/p>
&lt;p>示例函数:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">absVector&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">values&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">output&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">__cs149_vec_float&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">__cs149_vec_float&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">__cs149_vec_float&lt;/span> &lt;span class="n">zero&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">_cs149_vset_float&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mf">0.f&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">__cs149_mask&lt;/span> &lt;span class="n">maskAll&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">maskIsNegative&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">maskIsNotNegative&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// Note: Take a careful look at this loop indexing. This example
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// code is not guaranteed to work when (N % VECTOR_WIDTH) != 0.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// Why is that the case?
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">N&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">+=&lt;/span>&lt;span class="n">VECTOR_WIDTH&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// All ones
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">maskAll&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">_cs149_init_ones&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// All zeros
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">maskIsNegative&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">_cs149_init_ones&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Load vector of values from contiguous memory addresses
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">_cs149_vload_float&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">values&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">maskAll&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// x = values[i];
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Set mask according to predicate
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">_cs149_vlt_float&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">maskIsNegative&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">zero&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">maskAll&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// if (x &amp;lt; 0) {
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Execute instruction using mask (&amp;#34;if&amp;#34; clause)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">_cs149_vsub_float&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">result&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">zero&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">maskIsNegative&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// output[i] = -x;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Inverse maskIsNegative to generate &amp;#34;else&amp;#34; mask
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">maskIsNotNegative&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">_cs149_mask_not&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">maskIsNegative&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// } else {
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Execute instruction (&amp;#34;else&amp;#34; clause)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">_cs149_vload_float&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">result&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">values&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">maskIsNotNegative&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// output[i] = x; }
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Write results back to memory
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">_cs149_vstore_float&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">output&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">maskAll&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>示例函数absVector并不能适用于所有情况,原因如下:
当n%VECTOR_WIDTH != 0时, 会越界.&lt;/p>
&lt;h3 id="12-实现clampedexpvector函数">1&amp;amp;2 实现clampedExpVector函数&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">clampedExpVector&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">float&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">values&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">exponents&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">float&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">output&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// CS149 STUDENTS TODO: Implement your vectorized version of
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// clampedExpSerial() here.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// Your solution should work for any value of
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// N and VECTOR_WIDTH, not just when VECTOR_WIDTH divides N
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">__cs149_vec_float&lt;/span> &lt;span class="n">one&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">nine&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">__cs149_vec_int&lt;/span> &lt;span class="n">zeroInt&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">oneInt&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">oneInt&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">_cs149_vset_int&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">zeroInt&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">_cs149_vset_int&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">one&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">_cs149_vset_float&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mf">1.f&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">nine&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">_cs149_vset_float&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mf">9.999999f&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">VECTOR_WIDTH&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">__cs149_mask&lt;/span> &lt;span class="n">maskAll&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">maskIsZero&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">maskIsNotZero&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">__cs149_vec_float&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">__cs149_vec_int&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// All ones
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">maskAll&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">_cs149_init_ones&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// All zeros
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">maskIsZero&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">_cs149_init_ones&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 防止在最后一次循环时，i+VECTOR_WIDTH超出N
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">VECTOR_WIDTH&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">maskAll&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">_cs149_init_ones&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">N&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// float x = values[i];
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">_cs149_vload_float&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">values&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">maskAll&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// int y = exponents[i];
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">_cs149_vload_int&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">exponents&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">maskAll&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// if (y == 0)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">_cs149_veq_int&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">maskIsZero&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">zeroInt&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">maskAll&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// {
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// output[i] = 1.f;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// }
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">_cs149_vstore_float&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">output&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">one&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">maskIsZero&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// else
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">maskIsNotZero&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">_cs149_mask_not&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">maskIsZero&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 消除最后一次循环时，i+VECTOR_WIDTH超出N的情况
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">maskIsNotZero&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">_cs149_mask_and&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">maskIsNotZero&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">maskAll&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// float result = x;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">__cs149_vec_float&lt;/span> &lt;span class="n">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// int count = y - 1;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">__cs149_vec_int&lt;/span> &lt;span class="n">count&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">_cs149_vsub_int&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">count&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">oneInt&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">maskIsNotZero&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 哪些count&amp;gt;0
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">__cs149_mask&lt;/span> &lt;span class="n">countMark&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">_cs149_vgt_int&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">countMark&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">count&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">zeroInt&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">maskIsNotZero&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// while (count &amp;gt; 0)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">_cs149_cntbits&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">countMark&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// result *= x;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">_cs149_vmult_float&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">result&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">countMark&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// count--;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">_cs149_vsub_int&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">count&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">count&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">oneInt&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">countMark&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 哪些count&amp;gt;0
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">_cs149_vgt_int&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">countMark&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">count&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">zeroInt&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">countMark&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// if (result &amp;gt; 9.999999f)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">__cs149_mask&lt;/span> &lt;span class="n">gtNineMask&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">_cs149_vgt_float&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">gtNineMask&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">nine&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">maskIsNotZero&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// { reult = 9.999999f;}
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">_cs149_vmove_float&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">result&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">nine&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">gtNineMask&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// output[i] = result;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">_cs149_vstore_float&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">output&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">maskIsNotZero&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>通过init_ones来防止在有n%vectorWith!=0时 越界.&lt;/p>
&lt;ul>
&lt;li>在最开始的maskAll时设置&lt;/li>
&lt;li>在取反码后也要设置一次&lt;/li>
&lt;/ul>
&lt;p>count循环:
通过设置一个mask来标记哪些count&amp;gt;0, 从而实现循环.&lt;/p>
&lt;p>修改vectorWidth为2, 4, 8, to 16来回答:
Does the vector utilization increase, decrease or stay the same as VECTOR_WIDTH changes? Why?&lt;/p>
&lt;p>vectorWidth为2时, 结果如下:
****************** Printing Vector Unit Statistics *******************
Vector Width: 2
Total Vector Instructions: 162728
Vector Utilization: 77.0%
Utilized Vector Lanes: 250653
Total Vector Lanes: 325456&lt;/p>
&lt;p>vectorWidth为4时, 结果如下:
****************** Printing Vector Unit Statistics *******************
Vector Width: 3
Total Vector Instructions: 119440
Vector Utilization: 72.2%
Utilized Vector Lanes: 258879
Total Vector Lanes: 358320&lt;/p>
&lt;p>vectorWidth为8时, 结果如下:
****************** Printing Vector Unit Statistics *******************
Vector Width: 8
Total Vector Instructions: 51628
Vector Utilization: 66.0%
Utilized Vector Lanes: 272539
Total Vector Lanes: 413024&lt;/p>
&lt;p>vectorWidth为16时, 结果如下:
****************** Printing Vector Unit Statistics *******************
Vector Width: 16
Total Vector Instructions: 26968
Vector Utilization: 64.2%
Utilized Vector Lanes: 277188
Total Vector Lanes: 431488&lt;/p>
&lt;p>可以发现, 随着vectorWidth的增加, vectorUtilization也在减少.&lt;/p>
&lt;p>原因:
有多个条件语句,当vectorWidth增加时, 每次在某个条件中不执行的指令也会增加.&lt;/p>
&lt;h3 id="3-实现arraysumvector">3 实现arraySumVector&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">float&lt;/span> &lt;span class="nf">arraySumVector&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">float&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">values&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// CS149 STUDENTS TODO: Implement your vectorized version of arraySumSerial here
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">__cs149_vec_float&lt;/span> &lt;span class="n">sum&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">_cs149_vset_float&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mf">0.f&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">VECTOR_WIDTH&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">__cs149_mask&lt;/span> &lt;span class="n">maskAll&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">__cs149_vec_float&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// All ones
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">maskAll&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">_cs149_init_ones&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 防止在最后一次循环时，i+VECTOR_WIDTH超出N
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">VECTOR_WIDTH&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">maskAll&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">_cs149_init_ones&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">N&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// float x = values[i];
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">_cs149_vload_float&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">values&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">maskAll&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// sum += x;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">_cs149_vadd_float&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">sum&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">sum&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">maskAll&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">float&lt;/span> &lt;span class="n">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mf">0.f&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// log2(VECTOR_WIDTH)内解决
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">log2&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">VECTOR_WIDTH&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 使用_cs149_hadd_float函数，将sum中的每两个元素相加
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 再使用_cs149_interleave_float函数，将sum中的每两个元素交叉放置
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 重复log2(VECTOR_WIDTH)次
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">_cs149_hadd_float&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">sum&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">sum&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">_cs149_interleave_float&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">sum&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">sum&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 将sum中的第一个元素赋值给result
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">sum&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>假设VECTOR_WIDTHs始终是N的因子.&lt;/p>
&lt;p>可以实现在O(N/VECTOR_WIDTH + log2(VECTOR_WIDTH))的时间内完成计算.&lt;/p>
&lt;p>最后的log2实现方式.
提示中给了两个函数
hadd: 将每两个元素相加
interleave: 将每两个元素交叉放置&lt;/p>
&lt;p>因此我们可以类似与归并排序的方式,将sum中的每两个元素相加,再将每两个元素交叉放置.
重复log2(VECTOR_WIDTH)次后,第一个元素就是结果.&lt;/p>
&lt;h2 id="program-3-ispc">program-3 ISPC&lt;/h2>
&lt;p>前提: L3&lt;/p>
&lt;h3 id="part1-ispc-basic">part1 ISPC basic&lt;/h3>
&lt;p>任务:学习ISPC基本概念和编写.&lt;/p>
&lt;p>ISPC是一种编译器,可以将C代码编译为SIMD指令.&lt;/p>
&lt;h3 id="part2-ispc-task">part2 ISPC task&lt;/h3>
&lt;p>任务描述:
观察ISPCtask执行的结果&lt;/p>
&lt;h4 id="1">1&lt;/h4>
&lt;p>启动mandelbrot_ispc &amp;ndash;tasks&lt;/p>
&lt;p>结果:
[mandelbrot serial]: [424.881] ms
Wrote image file mandelbrot-serial.ppm
[mandelbrot ispc]: [97.180] ms
Wrote image file mandelbrot-ispc.ppm
[mandelbrot multicore ispc]: [48.986] ms
Wrote image file mandelbrot-task-ispc.ppm
(4.37x speedup from ISPC)
(8.67x speedup from task ISPC)&lt;/p>
&lt;p>因为设置了两个task所以大约是两倍的加速比 对于 ISPC&lt;/p>
&lt;h4 id="2">2&lt;/h4>
&lt;p>修改mandelbrot_ispc_withtasks()中的task数量,
you should be able to achieve performance that exceeds the sequential version of the code by over 32 times!
How did you determine how many tasks to create?
Why does the number you chose work best?&lt;/p>
&lt;p>根据机器的最大超线程数量设置
我设置了16个task, 因为我的机器是4核8线程, 16个task可以使得每个线程都有两个task.&lt;/p>
&lt;h4 id="3">3&lt;/h4>
&lt;p>what happens when you launch 10,000 ISPC tasks? What happens when you launch 10,000 threads?&lt;/p>
&lt;p>向量加速&lt;/p>
&lt;p>思考题:
Q: Why are there two different mechanisms (foreach and launch) for expressing independent, parallelizable work to the ISPC system?
A:foreach是将一个任务分配给多个线程,而launch是将多个任务分配给多个线程.&lt;/p>
&lt;p>Q: Couldn&amp;rsquo;t the system just partition the many iterations of foreach across all cores and also emit the appropriate SIMD code for the cores?
A:&lt;/p>
&lt;h2 id="program-4-iterative-sqrt-15-points">program-4 Iterative sqrt (15 points)&lt;/h2>
&lt;p>用sqrt复习ISPC的基本概念&lt;/p>
&lt;h3 id="1-1">1&lt;/h3>
&lt;p>运行结果:
[sqrt serial]: [1316.793] ms
[sqrt ispc]: [301.134] ms
[sqrt task ispc]: [52.439] ms
(4.37x speedup from ISPC)
(25.11x speedup from task ISPC)
4.37x speedup due to SIMD
25.11 / 4.37 = 5.74x speedup due to multi-core&lt;/p>
&lt;h3 id="2-1">2&lt;/h3>
&lt;p>构造数组使得加速比最大.&lt;/p>
&lt;p>全部数为2.998.
思路:
因为每个元素相同可以让计算更均匀,2.998可以充分调动cpu
结构:
(5.60x speedup from ISPC)
(30.39x speedup from task ISPC)&lt;/p>
&lt;h3 id="3-1">3&lt;/h3>
&lt;p>构造数组使得加速比最小.&lt;/p>
&lt;p>全部数为1
思路:
1的sqrt计算迭代最少.&lt;/p>
&lt;p>结果:
(2.50x speedup from ISPC)
(3.08x speedup from task ISPC)&lt;/p>
&lt;h2 id="program-5-blas-saxpy-10-points">program-5 BLAS saxpy (10 points)&lt;/h2>
&lt;h3 id="1-2">1&lt;/h3>
&lt;p>运行观察加速比
[saxpy ispc]: [25.098] ms [11.874] GB/s [1.594] GFLOPS
[saxpy task ispc]: [18.438] ms [16.164] GB/s [2.169] GFLOPS
(1.36x speedup from use of tasks)&lt;/p>
&lt;p>因为需要访问内存所以加速比不高.&lt;/p>
&lt;h3 id="2-2">2&lt;/h3>
&lt;p>Even though saxpy loads one element from X, one element from Y, and writes one element to result the multiplier by 4 is correct. Why is this the case? (Hint, think about how CPU caches work.)&lt;/p>
&lt;p>当程序写入结果的一个元素时，它首先将包含这个元素的缓存行提取到缓存中。这需要一个内存操作。然后，当不需要这个缓存行时，它将从缓存中闪现出来，这需要另一个内存操作。&lt;/p></description></item><item><title>asst2</title><link>https://ysyyhhh.github.io/blog/asst2/</link><pubDate>Fri, 01 Mar 2024 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/blog/asst2/</guid><description>&lt;h2 id="c-sync">C++ Sync&lt;/h2>
&lt;h3 id="thread的使用">thread的使用&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;thread&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">my_func&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">thread_id&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">num_threads&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Hello from spawned thread %d of %d&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">thread_id&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">num_threads&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">argc&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">char&lt;/span>&lt;span class="o">**&lt;/span> &lt;span class="n">argv&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="kr">thread&lt;/span> &lt;span class="n">t0&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="kr">thread&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">my_func&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="kr">thread&lt;/span> &lt;span class="n">t1&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="kr">thread&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">my_func&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;The main thread is running concurrently with spawned threads.&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">t0&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">t1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Spawned threads have terminated at this point.&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="mutex">mutex&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;chrono&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;map&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;mutex&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;string&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;thread&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">map&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">string&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">g_pages&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">mutex&lt;/span> &lt;span class="n">g_pages_mutex&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">save_page&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">string&lt;/span>&lt;span class="o">&amp;amp;&lt;/span> &lt;span class="n">url&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// simulate a long page fetch
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">this_thread&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">sleep_for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">chrono&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">seconds&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">string&lt;/span> &lt;span class="n">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#34;fake content&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">lock_guard&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">mutex&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">guard&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">g_pages_mutex&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">g_pages&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">url&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="kr">thread&lt;/span> &lt;span class="n">t1&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">save_page&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;http://foo&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="kr">thread&lt;/span> &lt;span class="n">t2&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">save_page&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;http://bar&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">t1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">t2&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// safe to access g_pages without lock now, as the threads are joined
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="k">auto&lt;/span>&lt;span class="o">&amp;amp;&lt;/span> &lt;span class="nl">pair&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="n">g_pages&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">pair&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">first&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34; =&amp;gt; &amp;#34;&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">pair&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">second&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="sc">&amp;#39;\n&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Output&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">http://bar &lt;span class="o">=&lt;/span>&amp;gt; fake content
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">http://foo &lt;span class="o">=&lt;/span>&amp;gt; fake content
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="condition_variable">condition_variable&lt;/h3>
&lt;p>线程调用 wait (lock)来指示它希望等待来自另一个线程的通知。&lt;/p>
&lt;p>注意，互斥对象(包装在 std: : only _ lock 中)被传递给 wait ()调用。当通知线程时，条件变量将获得锁。&lt;/p>
&lt;p>这意味着当调用 wait ()返回时，调用线程是锁的当前持有者。锁通常用于保护线程现在需要检查的共享变量，以确保它正在等待的条件为真。&lt;/p>
&lt;p>创建 N 个线程。N-1个线程等待来自线程0的通知，然后在接到通知后，自动递增一个受共享互斥锁保护的计数器。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="cm">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * Wrapper class around a counter, a condition variable, and a mutex.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">ThreadState&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">public&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">condition_variable&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">condition_variable_&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">mutex&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">mutex_&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">counter_&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">num_waiting_threads_&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ThreadState&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">num_waiting_threads&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">condition_variable_&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">condition_variable&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">mutex_&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">mutex&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">counter_&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">num_waiting_threads_&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">num_waiting_threads&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">~&lt;/span>&lt;span class="n">ThreadState&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">delete&lt;/span> &lt;span class="n">condition_variable_&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">delete&lt;/span> &lt;span class="n">mutex_&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">signal_fn&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ThreadState&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">thread_state&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Acquire mutex to make sure the shared counter is read in a
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// consistent state.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">thread_state&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">mutex_&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">lock&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">thread_state&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">counter_&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">thread_state&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">num_waiting_threads_&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">thread_state&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">mutex_&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">unlock&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Release the mutex before calling `notify_all()` to make sure
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// waiting threads have a chance to make progress.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">thread_state&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">condition_variable_&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">notify_all&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Re-acquire the mutex to read the shared counter again.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">thread_state&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">mutex_&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">lock&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">thread_state&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">mutex_&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">unlock&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">wait_fn&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ThreadState&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">thread_state&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// A lock must be held in order to wait on a condition variable.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// This lock is atomically released before the thread goes to sleep
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// when `wait()` is called. The lock is atomically re-acquired when
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// the thread is woken up using `notify_all()`.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">unique_lock&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">mutex&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">lk&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">thread_state&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">mutex_&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">thread_state&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">condition_variable_&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">wait&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">lk&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Increment the shared counter with the lock re-acquired to inform the
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// signaling thread that this waiting thread has successfully been
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// woken up.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">thread_state&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">counter_&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Lock re-acquired after wait()...&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">lk&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">unlock&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * Signaling thread spins until each waiting thread increments a shared
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * counter after being woken up from the `wait()` method.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">condition_variable_example&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">num_threads&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;==============================================================&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Starting %d threads for signal-and-waiting...&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">num_threads&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="kr">thread&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">threads&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="kr">thread&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">num_threads&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ThreadState&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">thread_state&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">ThreadState&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">num_threads&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">threads&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="kr">thread&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">signal_fn&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">thread_state&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">num_threads&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">threads&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="kr">thread&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">wait_fn&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">thread_state&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">num_threads&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">threads&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;==============================================================&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">delete&lt;/span> &lt;span class="n">thread_state&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">delete&lt;/span>&lt;span class="p">[]&lt;/span> &lt;span class="n">threads&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="part_a">part_a&lt;/h2>
&lt;h3 id="step-1-实现tasksystemparallelspawn">step 1 实现TaskSystemParallelSpawn&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c++" data-lang="c++">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="n">TaskSystemParallelSpawn&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">run&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">IRunnable&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">runnable&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">num_total_tasks&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// TODO: CS149 students will modify the implementation of this
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// method in Part A. The implementation provided below runs all
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// tasks sequentially on the calling thread.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">atomic&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">taskId&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">num_threads&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">num_threads&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="kr">thread&lt;/span> &lt;span class="n">threads&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">num_threads&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 交叉分配任务
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">num_threads&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">threads&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="kr">thread&lt;/span>&lt;span class="p">([&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">]()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">task_id&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">taskId&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">fetch_add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">task_id&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">num_total_tasks&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">runnable&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">runTask&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">task_id&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">num_total_tasks&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">task_id&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">taskId&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">fetch_add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">num_threads&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">threads&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// printf(&amp;#34;done\n&amp;#34;);
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Q:How will you assign tasks to your worker threads? Should you consider static or dynamic assignment of tasks to threads?
A:交叉分配任务，动态分配任务&lt;/p>
&lt;p>Q:How will you ensure that all tasks are executed exactly once?
A:使用原子变量taskId&lt;/p>
&lt;h3 id="step-2-实现--tasksystemparallelthreadpoolspinning">step 2 实现 TaskSystemParallelThreadPoolSpinning&lt;/h3>
&lt;p>step1 的overhead主要是创建线程的开销(尤其是计算量低的任务上)，因此使用线程池可以减少开销&lt;/p>
&lt;p>要求: 在TestSystem 创建时,或者在run时创建线程池&lt;/p>
&lt;p>Q1: 作为一个开始的实现，我们建议您将worker threads设计为连续循环，始终检查它们是否有更多的工作要执行。(进入 while 循环直到条件为真的线程通常称为“spinning”)
那么worker thread 如何确定有work要执行呢？&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c++" data-lang="c++">&lt;span class="line">&lt;span class="cl">&lt;span class="n">TaskSystemParallelThreadPoolSpinning&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">TaskSystemParallelThreadPoolSpinning&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">num_threads&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">ITaskSystem&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">num_threads&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// TODO: CS149 student implementations may decide to perform setup
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// operations (such as thread pool construction) here.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// Implementations are free to add new class member variables
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// (requiring changes to tasksys.h).
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">exit_flag_&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">false&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">num_threads&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">threads&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">emplace_back&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">TaskSystemParallelThreadPoolSpinning&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">func&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">TaskSystemParallelThreadPoolSpinning&lt;/span>&lt;span class="o">::~&lt;/span>&lt;span class="n">TaskSystemParallelThreadPoolSpinning&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">exit_flag_&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">true&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">auto&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="kr">thread&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">threads&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">thread&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="n">TaskSystemParallelThreadPoolSpinning&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">run&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">IRunnable&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">runnable&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">num_total_tasks&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// TODO: CS149 students will modify the implementation of this
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// method in Part A. The implementation provided below runs all
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// tasks sequentially on the calling thread.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// printf(&amp;#34;run\n&amp;#34;);
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">runnable_&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">runnable&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">num_tasks_&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">num_total_tasks&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">num_tasks_done_&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">num_total_tasks&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">num_total_tasks&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">tasks_mutex_&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">lock&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">tasks_&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">push&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">tasks_mutex_&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">unlock&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">num_tasks_done_&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">num_total_tasks&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">this_thread&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">yield&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Q:为什么要使用yield
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// A:因为如果不使用yield，那么线程会一直占用CPU，导致其他线程无法运行
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// Q:那我直接死循环呢
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// A:死循环会导致CPU占用率100%，导致其他线程无法运行
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Q2:确保 run ()实现所需的同步行为是非常重要的。如何更改 run ()的实现以确定批量任务启动中的所有任务都已完成？
A:使用原子变量num_tasks_done_，每个任务完成时，num_tasks_done_加一，当num_tasks_done_等于num_total_tasks时，所有任务完成&lt;/p>
&lt;h3 id="step-3-实现-tasksystemparallelthreadpoolsleeping">step 3 实现 TaskSystemParallelThreadPoolSleeping&lt;/h3>
&lt;p>Step2的缺点：
当线程“spin”等待某些操作时，它们会利用 CPU 核心的执行资源。&lt;/p>
&lt;ul>
&lt;li>例如，工作线程可能会循环等待新任务到达。&lt;/li>
&lt;li>另一个例子是，主线程可能会循环等待辅助线程完成所有任务，这样它就可以从 run ()调用返回。&lt;/li>
&lt;/ul>
&lt;p>这可能会影响性能，因为即使这些线程没有做有用的工作，也会使用 CPU 资源来运行这些线程。&lt;/p>
&lt;p>在任务的这一部分中，我们希望您通过让线程处于休眠状态来提高任务系统的效率，直到它们所等待的条件得到满足。&lt;/p>
&lt;p>您的实现可以选择使用条件变量来实现此行为。条件变量是一个同步原语，它允许线程在等待条件存在时休眠(不占用 CPU 处理资源)。其他线程向等待唤醒的线程发出“信号”，以查看它们所等待的条件是否已经满足。例如，如果没有工作要做，您的工作线程可能会处于休眠状态(这样它们就不会从尝试执行有用工作的线程那里占用 CPU 资源)。另一个例子是，调用 run ()的主应用程序线程可能希望在等待批量任务启动中的所有任务由工作线程完成时休眠。(否则，一个旋转的主线程将从工作线程那里夺走 CPU 资源!)有关 C + + 中条件变量的更多信息，请参见我们的 C + + 同步教程。&lt;/p>
&lt;p>您在这部分作业中的实现可能需要考虑棘手的race conditions 。您需要考虑许多可能的线程行为交错&lt;/p>
&lt;p>您可能需要考虑编写额外的测试用例来测试您的系统。赋值入门代码包括评分脚本用于评分代码性能的工作负载，但是我们也将使用一组更广泛的工作负载来测试您的实现的正确性，而我们在入门代码中并没有提供这些工作负载！&lt;/p>
&lt;p>The assignment starter code includes the workloads that the grading script will use to grade the performance of your code, but we will also test the correctness of your implementation using a wider set of workloads that we are not providing in the starter code!&lt;/p>
&lt;p>tasksys.h&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="cm">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * TaskSystemParallelThreadPoolSleeping: This class is the student&amp;#39;s
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * optimized implementation of a parallel task execution engine that uses
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * a thread pool. See definition of ITaskSystem in
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * itasksys.h for documentation of the ITaskSystem interface.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">TaskSystemParallelThreadPoolSleeping&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="k">public&lt;/span> &lt;span class="n">ITaskSystem&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">public&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">TaskSystemParallelThreadPoolSleeping&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">num_threads&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">~&lt;/span>&lt;span class="n">TaskSystemParallelThreadPoolSleeping&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">const&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nf">name&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">void&lt;/span> &lt;span class="nf">run&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">IRunnable&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">runnable&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">num_total_tasks&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">TaskID&lt;/span> &lt;span class="nf">runAsyncWithDeps&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">IRunnable&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">runnable&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">num_total_tasks&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">const&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">vector&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">TaskID&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">deps&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">void&lt;/span> &lt;span class="nf">sync&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">private&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">vector&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="kr">thread&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">threads&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">num_tasks_&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">bool&lt;/span> &lt;span class="n">exit_flag_&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">atomic&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">num_tasks_done_&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">queue&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">tasks_&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">mutex&lt;/span> &lt;span class="n">tasks_mutex_&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">IRunnable&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">runnable_&lt;/span>&lt;span class="p">{};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">void&lt;/span> &lt;span class="nf">func&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">condition_variable&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">queue_condition_&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">condition_variable&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">condition_variable&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">all_done_condition_&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">condition_variable&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">num_waiting_threads_&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">atomic&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">num_tasks_remaining_&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">mutex&lt;/span> &lt;span class="n">all_done_mutex_&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>tasksys.cpp&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="cm">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * ================================================================
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * Parallel Thread Pool Sleeping Task System Implementation
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * ================================================================
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">const&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">TaskSystemParallelThreadPoolSleeping&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="s">&amp;#34;Parallel + Thread Pool + Sleep&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="n">TaskSystemParallelThreadPoolSleeping&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">func&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">task_id&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">exit_flag_&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">task_id&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">task_id&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">unique_lock&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">mutex&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">lk&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">tasks_mutex_&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 等待任务
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">queue_condition_&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">wait&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">lk&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">[]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">exit_flag_&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">tasks_&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">empty&lt;/span>&lt;span class="p">())&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">task_id&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">tasks_&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">front&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">tasks_&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">pop&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">runnable_&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">runTask&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">task_id&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">num_tasks_&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">num_tasks_remaining_&lt;/span>&lt;span class="o">--&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">num_tasks_remaining_&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 通知主线程
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// printf(&amp;#34;notify_all_done\n&amp;#34;);
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">all_done_condition_&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">notify_one&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 通知其他线程
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// printf(&amp;#34;notify_all\n&amp;#34;);
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">queue_condition_&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">notify_one&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">TaskSystemParallelThreadPoolSleeping&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">TaskSystemParallelThreadPoolSleeping&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">num_threads&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">ITaskSystem&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">num_threads&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// TODO: CS149 student implementations may decide to perform setup
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// operations (such as thread pool construction) here.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// Implementations are free to add new class member variables
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// (requiring changes to tasksys.h).
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">exit_flag_&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">false&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">num_threads&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">threads&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">emplace_back&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">TaskSystemParallelThreadPoolSleeping&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">func&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">TaskSystemParallelThreadPoolSleeping&lt;/span>&lt;span class="o">::~&lt;/span>&lt;span class="n">TaskSystemParallelThreadPoolSleeping&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// TODO: CS149 student implementations may decide to perform cleanup
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// operations (such as thread pool shutdown construction) here.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// Implementations are free to add new class member variables
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// (requiring changes to tasksys.h).
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">exit_flag_&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">true&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">queue_condition_&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">notify_all&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">auto&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="kr">thread&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">threads&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">thread&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="n">TaskSystemParallelThreadPoolSleeping&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">run&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">IRunnable&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">runnable&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">num_total_tasks&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// TODO: CS149 students will modify the implementation of this
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// method in Parts A and B. The implementation provided below runs all
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// tasks sequentially on the calling thread.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">runnable_&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">runnable&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">num_tasks_&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">num_total_tasks&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">num_tasks_remaining_&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">num_total_tasks&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">tasks_mutex_&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">lock&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">num_total_tasks&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">tasks_&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">push&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">tasks_mutex_&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">unlock&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 通知其他线程
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">queue_condition_&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">notify_all&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// printf(&amp;#34;run\n&amp;#34;);
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">num_tasks_remaining_&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">unique_lock&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">mutex&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">lk2&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">all_done_mutex_&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">all_done_condition_&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">wait&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">lk2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">[]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// printf(&amp;#34;all done\n&amp;#34;);
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// printf(&amp;#34;all done\n&amp;#34;);
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>结果分析:&lt;/p>
&lt;p>sleep对spin的提升效果不明显，可能是因为任务太少，线程切换的开销比较大.&lt;/p>
&lt;p>运行结果:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">&lt;span class="o">================================================================================&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Running task system grading harness... &lt;span class="o">(&lt;/span>&lt;span class="m">11&lt;/span> total tests&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> - Detected CPU with &lt;span class="m">16&lt;/span> execution contexts
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> - Task system configured to use at most &lt;span class="m">8&lt;/span> &lt;span class="nv">threads&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">================================================================================&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">================================================================================&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Executing test: super_super_light...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Reference binary: ./runtasks_ref_linux
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Results &lt;span class="k">for&lt;/span>: super_super_light
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> STUDENT REFERENCE PERF?
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Serial&lt;span class="o">]&lt;/span> 5.281 5.788 0.91 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Always Spawn&lt;span class="o">]&lt;/span> 95.221 92.995 1.02 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Spin&lt;span class="o">]&lt;/span> 10.877 10.446 1.04 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Sleep&lt;span class="o">]&lt;/span> 6.943 42.705 0.16 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">================================================================================&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Executing test: super_light...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Reference binary: ./runtasks_ref_linux
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Results &lt;span class="k">for&lt;/span>: super_light
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> STUDENT REFERENCE PERF?
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Serial&lt;span class="o">]&lt;/span> 37.497 37.844 0.99 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Always Spawn&lt;span class="o">]&lt;/span> 108.136 108.805 0.99 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Spin&lt;span class="o">]&lt;/span> 10.777 13.615 0.79 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Sleep&lt;span class="o">]&lt;/span> 10.274 44.686 0.23 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">================================================================================&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Executing test: ping_pong_equal...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Reference binary: ./runtasks_ref_linux
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Results &lt;span class="k">for&lt;/span>: ping_pong_equal
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> STUDENT REFERENCE PERF?
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Serial&lt;span class="o">]&lt;/span> 603.419 606.739 0.99 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Always Spawn&lt;span class="o">]&lt;/span> 167.412 178.638 0.94 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Spin&lt;span class="o">]&lt;/span> 105.983 123.525 0.86 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Sleep&lt;span class="o">]&lt;/span> 108.243 148.316 0.73 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">================================================================================&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Executing test: ping_pong_unequal...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Reference binary: ./runtasks_ref_linux
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Results &lt;span class="k">for&lt;/span>: ping_pong_unequal
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> STUDENT REFERENCE PERF?
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Serial&lt;span class="o">]&lt;/span> 1126.19 1109.329 1.02 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Always Spawn&lt;span class="o">]&lt;/span> 259.271 260.822 0.99 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Spin&lt;span class="o">]&lt;/span> 199.088 198.013 1.01 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Sleep&lt;span class="o">]&lt;/span> 198.777 214.293 0.93 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">================================================================================&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Executing test: recursive_fibonacci...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Reference binary: ./runtasks_ref_linux
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Results &lt;span class="k">for&lt;/span>: recursive_fibonacci
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> STUDENT REFERENCE PERF?
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Serial&lt;span class="o">]&lt;/span> 1052.273 1128.069 0.93 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Always Spawn&lt;span class="o">]&lt;/span> 156.014 172.113 0.91 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Spin&lt;span class="o">]&lt;/span> 156.31 171.337 0.91 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Sleep&lt;span class="o">]&lt;/span> 156.462 166.476 0.94 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">================================================================================&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Executing test: math_operations_in_tight_for_loop...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Reference binary: ./runtasks_ref_linux
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Results &lt;span class="k">for&lt;/span>: math_operations_in_tight_for_loop
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> STUDENT REFERENCE PERF?
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Serial&lt;span class="o">]&lt;/span> 411.426 423.96 0.97 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Always Spawn&lt;span class="o">]&lt;/span> 537.747 532.353 1.01 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Spin&lt;span class="o">]&lt;/span> 99.286 104.844 0.95 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Sleep&lt;span class="o">]&lt;/span> 95.817 239.76 0.40 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">================================================================================&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Executing test: math_operations_in_tight_for_loop_fewer_tasks...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Reference binary: ./runtasks_ref_linux
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Results &lt;span class="k">for&lt;/span>: math_operations_in_tight_for_loop_fewer_tasks
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> STUDENT REFERENCE PERF?
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Serial&lt;span class="o">]&lt;/span> 413.681 415.961 0.99 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Always Spawn&lt;span class="o">]&lt;/span> 514.021 505.234 1.02 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Spin&lt;span class="o">]&lt;/span> 108.644 117.702 0.92 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Sleep&lt;span class="o">]&lt;/span> 106.84 260.724 0.41 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">================================================================================&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Executing test: math_operations_in_tight_for_loop_fan_in...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Reference binary: ./runtasks_ref_linux
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Results &lt;span class="k">for&lt;/span>: math_operations_in_tight_for_loop_fan_in
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> STUDENT REFERENCE PERF?
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Serial&lt;span class="o">]&lt;/span> 212.534 211.52 1.00 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Always Spawn&lt;span class="o">]&lt;/span> 76.402 76.09 1.00 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Spin&lt;span class="o">]&lt;/span> 37.203 39.662 0.94 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Sleep&lt;span class="o">]&lt;/span> 36.523 57.039 0.64 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">================================================================================&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Executing test: math_operations_in_tight_for_loop_reduction_tree...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Reference binary: ./runtasks_ref_linux
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Results &lt;span class="k">for&lt;/span>: math_operations_in_tight_for_loop_reduction_tree
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> STUDENT REFERENCE PERF?
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Serial&lt;span class="o">]&lt;/span> 208.076 207.488 1.00 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Always Spawn&lt;span class="o">]&lt;/span> 45.054 45.227 1.00 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Spin&lt;span class="o">]&lt;/span> 33.079 33.9 0.98 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Sleep&lt;span class="o">]&lt;/span> 34.502 38.389 0.90 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">================================================================================&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Executing test: spin_between_run_calls...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Reference binary: ./runtasks_ref_linux
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Results &lt;span class="k">for&lt;/span>: spin_between_run_calls
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> STUDENT REFERENCE PERF?
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Serial&lt;span class="o">]&lt;/span> 353.553 382.373 0.92 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Always Spawn&lt;span class="o">]&lt;/span> 180.401 197.119 0.92 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Spin&lt;span class="o">]&lt;/span> 205.374 222.315 0.92 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Sleep&lt;span class="o">]&lt;/span> 214.819 197.579 1.09 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">================================================================================&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Executing test: mandelbrot_chunked...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Reference binary: ./runtasks_ref_linux
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Results &lt;span class="k">for&lt;/span>: mandelbrot_chunked
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> STUDENT REFERENCE PERF?
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Serial&lt;span class="o">]&lt;/span> 257.289 256.815 1.00 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Always Spawn&lt;span class="o">]&lt;/span> 34.395 34.058 1.01 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Spin&lt;span class="o">]&lt;/span> 34.241 34.922 0.98 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Sleep&lt;span class="o">]&lt;/span> 35.191 35.273 1.00 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">================================================================================&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Overall performance results
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Serial&lt;span class="o">]&lt;/span> : All passed Perf
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Always Spawn&lt;span class="o">]&lt;/span> : All passed Perf
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Spin&lt;span class="o">]&lt;/span> : All passed Perf
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Sleep&lt;span class="o">]&lt;/span> : All passed Perf
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="part_b">part_b&lt;/h2>
&lt;p>在任务的 B 部分中，您将扩展您的 A 部分任务系统实现，以支持可能依赖于以前任务的任务的异步启动。这些任务间依赖关系创建了任务执行库必须遵守的调度约束。&lt;/p>
&lt;p>ITaskSystem 接口还有一个方法:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="k">virtual&lt;/span> &lt;span class="n">TaskID&lt;/span> &lt;span class="nf">runAsyncWithDeps&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">IRunnable&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">runnable&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">num_total_tasks&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">const&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">vector&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">TaskID&lt;/span>&lt;span class="o">&amp;gt;&amp;amp;&lt;/span> &lt;span class="n">deps&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>RunAsyncWithDeps ()类似于 run () ，因为它也用于执行 num &lt;em>total&lt;/em> asks 任务的批量启动。但是，它与 run ()在许多方面有所不同&amp;hellip;&lt;/p>
&lt;h3 id="asynchronous-task-launch">Asynchronous Task Launch&lt;/h3>
&lt;p>首先，使用 runAsyncWithDeps ()创建的任务由任务系统与调用线程异步执行。&lt;/p>
&lt;p>这意味着 runAsyncWithDeps ()应该立即返回给调用方，即使任务尚未完成执行。&lt;/p>
&lt;p>该方法返回与此批量任务启动关联的唯一标识符。&lt;/p>
&lt;p>调用线程可以通过调用 sync ()来确定大容量任务启动的实际完成时间。&lt;/p>
&lt;p>&lt;code>virtual void sync() = 0;&lt;/code>&lt;/p>
&lt;p>只有当与之前所有批量任务启动关联的任务完成时，sync ()才返回给调用方。例如，考虑以下代码:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// assume taskA and taskB are valid instances of IRunnable...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">vector&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">TaskID&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">noDeps&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// empty vector
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">ITaskSystem&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">t&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">TaskSystem&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">num_threads&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// bulk launch of 4 tasks
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">TaskID&lt;/span> &lt;span class="n">launchA&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">t&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">runAsyncWithDeps&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">taskA&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">noDeps&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// bulk launch of 8 tasks
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">TaskID&lt;/span> &lt;span class="n">launchB&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">t&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">runAsyncWithDeps&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">taskB&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">8&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">noDeps&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// at this point tasks associated with launchA and launchB
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// may still be running
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">t&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">sync&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// at this point all 12 tasks associated with launchA and launchB
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// are guaranteed to have terminated
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如上面的注释中所述，在线程调用sync() runAsyncWithDeps() ) 的任务已完成。 准确地说， runAsyncWithDeps()告诉您的任务系统执行新的批量任务启动，但您的实现可以灵活地在下次调用sync()之前随时执行这些任务。 请注意，此规范意味着无法保证您的实现在从 launchB 启动任务之前先执行 launchA 中的任务！&lt;/p>
&lt;h3 id="support-for-explicit-dependencies">Support for Explicit Dependencies&lt;/h3>
&lt;p>runAsyncWithDeps()的第二个关键细节是它的第三个参数：TaskID 标识符向量，必须引用之前使用runAsyncWithDeps()启动的批量任务。 该向量指定当前批量任务启动中的任务所依赖的先前任务。 因此，在依赖向量中给出的启动中的所有任务完成之前，您的任务运行时无法开始执行当前批量任务启动中的任何任务！ 例如，考虑以下示例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">vector&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">TaskID&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">noDeps&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// empty vector
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">vector&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">TaskID&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">depOnA&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">vector&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">TaskID&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">depOnBC&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">ITaskSystem&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">t&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">TaskSystem&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">num_threads&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">TaskID&lt;/span> &lt;span class="n">launchA&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">t&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">runAsyncWithDeps&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">taskA&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">128&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">noDeps&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">depOnA&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">push_back&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">launchA&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">TaskID&lt;/span> &lt;span class="n">launchB&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">t&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">runAsyncWithDeps&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">taskB&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">depOnA&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">TaskID&lt;/span> &lt;span class="n">launchC&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">t&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">runAsyncWithDeps&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">taskC&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">6&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">depOnA&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">depOnBC&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">push_back&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">launchB&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">depOnBC&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">push_back&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">launchC&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">TaskID&lt;/span> &lt;span class="n">launchD&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">t&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">runAsyncWithDeps&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">taskD&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">32&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">depOnBC&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">t&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">sync&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面的代码有四个批量任务启动（taskA：128 个任务，taskB：2 个任务，taskC：6 个任务，taskD：32 个任务）。 请注意，任务 B 和任务 C 的启动取决于任务 A。 taskD 的批量启动 ( launchD ) 取决于launchB和launchC的结果。 因此，虽然您的任务运行时可以按任意顺序（包括并行）处理与launchB和launchC关联的任务，但这些启动中的所有任务必须在launchA的任务完成后开始执行，并且它们必须在运行时开始之前完成从launchD执行任何任务。&lt;/p>
&lt;p>我们可以通过任务图直观地说明这些依赖关系。 任务图是有向无环图 (DAG)，其中图中的节点对应于批量任务启动，从节点 X 到节点 Y 的边表示 Y 对 X 输出的依赖关系。上述代码的任务图是：
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="https://github.com/jeremyephron/asst2/raw/master/figs/task_graph.png" alt="Alt text" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>请注意，如果您在具有八个执行上下文的 Myth 计算机上运行上面的示例，则并行调度launchB和launchC中的任务的能力可能非常有用，因为单独的批量任务启动都不足以使用所有执行机器的资源。&lt;/p>
&lt;h3 id="task">Task&lt;/h3>
&lt;p>您必须从 A 部分扩展任务系统实现，才能正确实现TaskSystem::runAsyncWithDeps()和TaskSystem::sync() 。 与 A 部分一样，我们为您提供以下入门提示：&lt;/p>
&lt;ul>
&lt;li>It may be helpful to think about the behavior of runAsyncWithDeps() as pushing a record corresponding to the bulk task launch, or perhaps records corresponding to each of the tasks in the bulk task launch onto a &amp;ldquo;work queue&amp;rdquo;. Once the record to work to do is in the queue, runAsyncWithDeps() can return to the caller.&lt;/li>
&lt;li>The trick in this part of the assignment is performing the appropriate bookkeeping to track dependencies. What must be done when all the tasks in a bulk task launch complete? (This is the point when new tasks may become available to run.)&lt;/li>
&lt;li>It can be helpful to have two data structures in your implementation: (1) a structure representing tasks that have been added to the system via a call to runAsyncWithDeps(), but are not yet ready to execute because they depend on tasks that are still running (these tasks are &amp;ldquo;waiting&amp;rdquo; for others to finish) and (2) a &amp;ldquo;ready queue&amp;rdquo; of tasks that are not waiting on any prior tasks to finish and can safely be run as soon as a worker thread is available to process them.&lt;/li>
&lt;li>You need not worry about integer wrap around when generating unique task launch ids. We will not hit your task system with over 2^31 bulk task launches.&lt;/li>
&lt;li>You can assume all programs will either call only run() or only runAsyncWithDeps(); that is, you do not need to handle the case where a run() call needs to wait for all proceeding calls to runAsyncWithDeps() to finish.&lt;/li>
&lt;/ul>
&lt;p>在part_b/子目录中实现B部分实现，以与正确的参考实现（ part_b/runtasks_ref_* ）进行比较。&lt;/p></description></item><item><title>L2</title><link>https://ysyyhhh.github.io/blog/l2/</link><pubDate>Fri, 01 Mar 2024 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/blog/l2/</guid><description>&lt;h2 id="并行程序">并行程序&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c++" data-lang="c++">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">sinx&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">terms&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">float&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">float&lt;/span> &lt;span class="n">number&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">sign&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">denom&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">6&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">terms&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">j&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">value&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">sign&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">number&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="n">denom&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">sign&lt;/span> &lt;span class="o">*=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">denom&lt;/span> &lt;span class="o">*=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">number&lt;/span> &lt;span class="o">*=&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">result&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>转换成汇编后大致如下:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-asm" data-lang="asm">&lt;span class="line">&lt;span class="cl">&lt;span class="nf">ld&lt;/span> &lt;span class="no">r0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">addr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="no">r1&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">mul&lt;/span> &lt;span class="no">ri&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">r0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">r0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">mul&lt;/span> &lt;span class="no">r1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">r1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">r0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">可以看到每次循环都是独立的。&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">对于最简单的是顺序执行。&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">通过超线程(超标量处理器具有从单个指令流中提取多个指令的能力)可以提高性能。有时称指令级并行性。(&lt;/span>&lt;span class="nf">ILP&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">Instruction&lt;/span> &lt;span class="no">Level&lt;/span> &lt;span class="no">Parallelism&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">但在这些汇编指令中必须顺序执行。&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">因此实现指令级并行性是一个挑战。&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">但即使是纯顺序执行的代码,也有很多方式使其运行更快(基于写代码的方式和编译器的智能程度).&lt;/span> &lt;span class="nf">Pentium&lt;/span> &lt;span class="mi">4&lt;/span> &lt;span class="err">比如先取多条指令等&lt;/span>&lt;span class="p">.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">(有个黑匣子会预测分支,预测错误的话就会清空流水线,浪费时间)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">解决方法:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">1.&lt;/span> &lt;span class="err">通过&lt;/span>&lt;span class="nf">pthread编写并行性的程序&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">2.&lt;/span> &lt;span class="err">假设有一种语言可以表示并行性,编译器可以自动并行化程序&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">如:&lt;/span> &lt;span class="nf">forall&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">int&lt;/span> &lt;span class="no">i&lt;/span> &lt;span class="no">from&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="no">to&lt;/span> &lt;span class="no">n-1&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="err">{}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">自动并行化可能的解决方法:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">1.&lt;/span> &lt;span class="err">直接分为&lt;/span>&lt;span class="nf">k个线程&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="err">每个线程处理&lt;/span>&lt;span class="no">n&lt;/span>&lt;span class="err">/&lt;/span>&lt;span class="no">k个循环.&lt;/span> &lt;span class="err">然后将结果合并&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">2.&lt;/span> &lt;span class="err">在硬件上执行.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">有一堆性能较低但具有并行性的处理器时,&lt;/span> &lt;span class="err">也需要更多电力/时间来驱动很多信号从一端到另一端.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">## CPU &amp;amp;&amp;amp; GPU
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nf">GPU将核心的概念带到了极致&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="err">抛弃了所有的分支预测&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="err">只是控制逻辑而不完成计算&lt;/span>&lt;span class="p">.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">对于上面的程序有垂直和水平两种分割方式:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">-&lt;/span> &lt;span class="err">垂直:&lt;/span> &lt;span class="err">每个线程处理一个循环&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">-&lt;/span> &lt;span class="err">水平:&lt;/span> &lt;span class="err">同时处理多个循环,&lt;/span> &lt;span class="err">如先同时进行所有的第一个乘法&lt;/span>&lt;span class="na">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">## SIMD Single Instruction Multiple Data
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="err">假设我正在执行的多次操作之间没有依赖关系,都能够并行运行.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">a&lt;/span> &lt;span class="no">single&lt;/span> &lt;span class="no">instruction&lt;/span> &lt;span class="no">is&lt;/span> &lt;span class="no">applied&lt;/span> &lt;span class="no">to&lt;/span> &lt;span class="no">multiple&lt;/span> &lt;span class="no">data&lt;/span> &lt;span class="no">elements&lt;/span> &lt;span class="no">simultaneously.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">即:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">同时对8个数值和另一个地方的8个数值取出并进行加法.&lt;/span> &lt;span class="err">有时这些数值可以被称作向量.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">使用&lt;/span>&lt;span class="nf">AVX&lt;/span> &lt;span class="no">intrinsics的向量化程序&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">```&lt;/span>&lt;span class="nf">c&lt;/span>&lt;span class="err">++&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">void&lt;/span> &lt;span class="no">sinx&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">int&lt;/span> &lt;span class="no">N&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">int&lt;/span> &lt;span class="no">terms&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">float&lt;/span>&lt;span class="p">*&lt;/span> &lt;span class="no">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">float&lt;/span>&lt;span class="p">*&lt;/span> &lt;span class="no">result&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="err">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="no">int&lt;/span> &lt;span class="no">i&lt;/span> &lt;span class="err">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="c1">; i &amp;lt; N; i+=8) {
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">__m256&lt;/span> &lt;span class="no">origx&lt;/span> &lt;span class="err">=&lt;/span> &lt;span class="no">_mm256_load_ps&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="err">&amp;amp;&lt;/span>&lt;span class="no">x&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="no">i&lt;/span>&lt;span class="p">])&lt;/span>&lt;span class="c1">;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">__m256&lt;/span> &lt;span class="no">value&lt;/span> &lt;span class="err">=&lt;/span> &lt;span class="no">origx&lt;/span>&lt;span class="c1">;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">__m256&lt;/span> &lt;span class="no">number&lt;/span> &lt;span class="err">=&lt;/span> &lt;span class="no">_mm256_mul_ps&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">origx&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">_mm256_mul_ps&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">origx&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">origx&lt;/span>&lt;span class="p">))&lt;/span>&lt;span class="c1">;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">float&lt;/span> &lt;span class="no">sign&lt;/span> &lt;span class="err">=&lt;/span> &lt;span class="p">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="c1">;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">__m256&lt;/span> &lt;span class="no">denom&lt;/span> &lt;span class="err">=&lt;/span> &lt;span class="no">_mm256_set1_ps&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">6&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="c1">;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="no">int&lt;/span> &lt;span class="no">j&lt;/span> &lt;span class="err">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="c1">; j &amp;lt; terms; j++) {
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//value += sign * number / denom;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">__m256&lt;/span> &lt;span class="no">tmp&lt;/span> &lt;span class="err">=&lt;/span> &lt;span class="no">_mm256_div_ps&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">number&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">denom&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="c1">;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">tmp&lt;/span> &lt;span class="err">=&lt;/span> &lt;span class="no">_mm256_mul_ps&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">tmp&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">_mm256_set1_ps&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">sign&lt;/span>&lt;span class="p">))&lt;/span>&lt;span class="c1">;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">value&lt;/span> &lt;span class="err">=&lt;/span> &lt;span class="no">_mm256_add_ps&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">value&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">tmp&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="c1">;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">sign&lt;/span> &lt;span class="p">*&lt;/span>&lt;span class="err">=&lt;/span> &lt;span class="p">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="c1">;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//denom *= (2*j+3)*(2*j+2);
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">denom&lt;/span> &lt;span class="err">=&lt;/span> &lt;span class="no">_mm256_mul_ps&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">denom&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">_mm256_set1_ps&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">*&lt;/span>&lt;span class="no">j&lt;/span>&lt;span class="err">+&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">)*(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">*&lt;/span>&lt;span class="no">j&lt;/span>&lt;span class="err">+&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">)))&lt;/span>&lt;span class="c1">;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//number *= x[i] * x[i];
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">number&lt;/span> &lt;span class="err">=&lt;/span> &lt;span class="no">_mm256_mul_ps&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">number&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">_mm256_mul_ps&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">origx&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">origx&lt;/span>&lt;span class="p">))&lt;/span>&lt;span class="c1">;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="err">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">_mm256_store_ps&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="err">&amp;amp;&lt;/span>&lt;span class="no">result&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="no">i&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="no">value&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="c1">;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//result[i] = value;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="err">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>编译成汇编后大致如下:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-asm" data-lang="asm">&lt;span class="line">&lt;span class="cl">&lt;span class="nf">vloadps&lt;/span> &lt;span class="no">xmm0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">addr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="no">r1&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">vmulps&lt;/span> &lt;span class="no">xmm1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">xmm0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">xmm0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">vmulps&lt;/span> &lt;span class="no">xmm2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">xmm1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">xmm0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="no">vstoreps&lt;/span> &lt;span class="no">addr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="no">xmm2&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="no">xmm0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>AVX代表高级矢量扩展, 256代表每次可以处理256位的数据, 也就是8个float.
有多个版本:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-md" data-lang="md">&lt;span class="line">&lt;span class="cl">AVX: 128位 = 4 &lt;span class="ge">* 4 *&lt;/span> 8 = 32字节
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">AVX2: 256位 = 8 &lt;span class="ge">* 4 *&lt;/span> 8 = 32字节
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">AVX512: 512位 = 16 &lt;span class="ge">* 4 *&lt;/span> 8 = 64字节
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>XMM寄存器是特殊的32字节 256位寄存器, 有16个, 从xmm0到xmm15. 用于支持vectorized SIMD指令.&lt;/p>
&lt;p>那么有没有办法让编译器自动将代码向量化呢?&lt;/p>
&lt;ul>
&lt;li>有,GCC的-O3选项可以自动向量化代码.&lt;/li>
&lt;/ul>
&lt;p>但只有非常结构化,精心编写的代码才能被自动向量化.&lt;/p>
&lt;h3 id="条件">条件&lt;/h3>
&lt;p>如果加入条件判断,如何向量化?&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c++" data-lang="c++">&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;span class="k">else&lt;/span>&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>SIMD可能的做法:
设置一个掩码, 用于标记哪些元素需要执行哪些不需要执行.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-md" data-lang="md">&lt;span class="line">&lt;span class="cl">x &lt;span class="p">&amp;lt;&lt;/span> &lt;span class="nt">0:&lt;/span> &lt;span class="na">1&lt;/span> &lt;span class="na">1&lt;/span> &lt;span class="na">0&lt;/span> &lt;span class="na">0&lt;/span> &lt;span class="na">1&lt;/span> &lt;span class="na">0&lt;/span> &lt;span class="na">0&lt;/span> &lt;span class="na">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">x &lt;/span>&lt;span class="o">=&lt;/span> &lt;span class="s">-x:&lt;/span> &lt;span class="na">1&lt;/span> &lt;span class="na">1&lt;/span> &lt;span class="na">0&lt;/span> &lt;span class="na">0&lt;/span> &lt;span class="na">1&lt;/span> &lt;span class="na">0&lt;/span> &lt;span class="na">0&lt;/span> &lt;span class="na">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">翻转:&lt;/span> &lt;span class="na">0&lt;/span> &lt;span class="na">0&lt;/span> &lt;span class="na">1&lt;/span> &lt;span class="na">1&lt;/span> &lt;span class="na">0&lt;/span> &lt;span class="na">1&lt;/span> &lt;span class="na">1&lt;/span> &lt;span class="na">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">x &lt;/span>&lt;span class="o">=&lt;/span> &lt;span class="s">x:&lt;/span> &lt;span class="na">0&lt;/span> &lt;span class="na">0&lt;/span> &lt;span class="na">1&lt;/span> &lt;span class="na">1&lt;/span> &lt;span class="na">0&lt;/span> &lt;span class="na">1&lt;/span> &lt;span class="na">1&lt;/span> &lt;span class="na">1&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>但大多时候只保留了一半的效率,因为每次有可能只有一半的数据需要执行.
不过这很好的保证了一致性,因为分支结束后又回到了同一个执行路径.
即保持一致性,远离分歧.&lt;/p>
&lt;p>coherent execution: 所有的线程都执行相同的指令.&lt;/p>
&lt;p>divergent: a lack of instruction stream coherence.&lt;/p>
&lt;p>对于生成这些矢量操作,要么有聪明的编译器,要么就是有耐心的程序员.&lt;/p>
&lt;h3 id="simd-execution-on-many-modern-gpus">SIMD execution on many modern GPUs&lt;/h3>
&lt;p>SPMD: Single Program Multiple Data&lt;/p>
&lt;p>GPU给的不是SIMD,而是SPMD. 单个程序,多个数据. 意味着程序的不同部分可以执行不同的指令.&lt;/p>
&lt;p>在这之下,还是用SIMD来实现大部分逻辑,采用异构的方式来实现并行.&lt;/p>
&lt;p>但有n个加法, 即两个包含n个值的向量相加.
实际上不是所有单位都在等待计算.而是会先计算出如何分配到块中,底层块的实际大小是32, 32values而不是32byte. 这个被称作SIMD宽度,一般是8-32.&lt;/p>
&lt;h3 id="gpu和cpu的差别">GPU和CPU的差别&lt;/h3>
&lt;p>CPU i7:&lt;/p>
&lt;ul>
&lt;li>4核&lt;/li>
&lt;li>8 SIMD ALUs per core&lt;/li>
&lt;li>每秒大概几千次浮点运算&lt;/li>
&lt;/ul>
&lt;p>GPU: RTX 1080&lt;/p>
&lt;ul>
&lt;li>20 cores&lt;/li>
&lt;li>32 SIMD ALUs per core&lt;/li>
&lt;li>每秒大概8m次浮点运算&lt;/li>
&lt;/ul>
&lt;p>GPU的核心摒弃了分支预测等只用做control,因此可以有更多的ALU.填充进来.&lt;/p>
&lt;p>大概是80:1的原始计算能力差异.&lt;/p>
&lt;h3 id="总结">总结&lt;/h3>
&lt;p>三种方法实现并行计算&lt;/p>
&lt;p>多核CPU:&lt;/p>
&lt;ul>
&lt;li>线程级实现并行&lt;/li>
&lt;/ul>
&lt;p>SIMD:&lt;/p>
&lt;ul>
&lt;li>指令级并行&lt;/li>
&lt;li>通过向量化指令实现&lt;/li>
&lt;li>但依赖于事先知道执行的指令优先级顺序&lt;/li>
&lt;/ul>
&lt;p>Superscaler:
exploit ILP within an instruction stream&lt;/p>
&lt;h2 id="paart2-accessing-memory">paart2 accessing memory&lt;/h2>
&lt;p>Memory latency: 从CPU到内存的时间&lt;/p>
&lt;ul>
&lt;li>example: DRAM访问时间 100 cycles, 100ns&lt;/li>
&lt;/ul>
&lt;p>Memory bandwidth: 从内存到CPU的时间&lt;/p>
&lt;ul>
&lt;li>example: 20GB/s 其实不是很快&lt;/li>
&lt;/ul>
&lt;p>Stall: CPU等待内存的时间
当cpu试图进行读取而内存不可用时，就会停等知道内存可用.&lt;/p>
&lt;p>缓存就是为了解决Stall的问题.&lt;/p>
&lt;p>在多级缓存中,靠近核心的缓存是私有的.
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l2/img/2023-10-05-16-43-06_hu13372060502363308935.webp 400w,
/blog/l2/img/2023-10-05-16-43-06_hu17389572238001779988.webp 760w,
/blog/l2/img/2023-10-05-16-43-06_hu14507491160188641777.webp 1200w"
src="https://ysyyhhh.github.io/blog/l2/img/2023-10-05-16-43-06_hu13372060502363308935.webp"
width="760"
height="424"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
这样可以通过写入读出L2缓存的数据来实现通讯,而不需要经过DRAM.&lt;/p>
&lt;p>缓存对延迟和带宽都有帮助.&lt;/p>
&lt;h3 id="prefecthing-reduces-stalls">Prefecthing reduces stalls&lt;/h3>
&lt;p>硬件通常通过预取来&lt;strong>减少延迟&lt;/strong>.
即预测下一次可能会访问的数据,并将其提前读取到缓存中.
不过可能会造成信息泄露&lt;/p>
&lt;p>使用预取的效果:
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l2/img/2023-10-05-16-47-27_hu12417978316493452032.webp 400w,
/blog/l2/img/2023-10-05-16-47-27_hu8822128309679776570.webp 760w,
/blog/l2/img/2023-10-05-16-47-27_hu627478282976819094.webp 1200w"
src="https://ysyyhhh.github.io/blog/l2/img/2023-10-05-16-47-27_hu12417978316493452032.webp"
width="760"
height="556"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="multi-threading-reduces-stalls">Multi-threading reduces stalls&lt;/h3>
&lt;p>让多个线程交替进行, 如asst1/prog2的实现&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l2/img/2023-10-05-16-53-05_hu11643600415470479687.webp 400w,
/blog/l2/img/2023-10-05-16-53-05_hu8115361217913554461.webp 760w,
/blog/l2/img/2023-10-05-16-53-05_hu18189741243445954556.webp 1200w"
src="https://ysyyhhh.github.io/blog/l2/img/2023-10-05-16-53-05_hu11643600415470479687.webp"
width="760"
height="284"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
这也是超线程的实现,在一个核心中多路复用多个指令流.
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l2/img/2023-10-05-16-52-35_hu8157910817429278478.webp 400w,
/blog/l2/img/2023-10-05-16-52-35_hu8863325502225311953.webp 760w,
/blog/l2/img/2023-10-05-16-52-35_hu12441154135282780728.webp 1200w"
src="https://ysyyhhh.github.io/blog/l2/img/2023-10-05-16-52-35_hu8157910817429278478.webp"
width="760"
height="563"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>对于CPU&amp;amp;GPU, 谁来组织线程是不同的做法.(操作系统 or 硬件)&lt;/p>
&lt;p>通常情况下内存要比其他因素更加限制速度&lt;/p></description></item><item><title>L4 Parallel Programing basics</title><link>https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/</link><pubDate>Fri, 01 Mar 2024 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/</guid><description>&lt;p>主要用三种方式实现并行程序(没有进行真正的优化)&lt;/p>
&lt;p>例子 n-body simulation&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-19-08-15_hu8669669288369783902.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-19-08-15_hu2474904881607189939.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-19-08-15_hu3830797662653187191.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-19-08-15_hu8669669288369783902.webp"
width="760"
height="566"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>创建并行程序的过程&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-19-12-34_hu2606505247421103274.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-19-12-34_hu388686235541542400.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-19-12-34_hu10988195175519778874.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-19-12-34_hu2606505247421103274.webp"
width="760"
height="569"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="1-decomposition">1. Decomposition&lt;/h3>
&lt;p>主要思想: 创造至少足够的任务让所有的处理单元都有事情做&lt;/p>
&lt;p>Amdahl&amp;rsquo;s Law: 串行部分的比例越大, 并行程序的加速比就越小,因为增加处理单元的数量并不能减少串行部分的时间&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-19-17-14_hu2938982224516847339.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-19-17-14_hu18308474121097933370.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-19-17-14_hu2953978744924134054.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-19-17-14_hu2938982224516847339.webp"
width="760"
height="570"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-19-25-06_hu1166217924997115293.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-19-25-06_hu18170830103215843531.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-19-25-06_hu13023697237381505884.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-19-25-06_hu1166217924997115293.webp"
width="760"
height="562"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>分解的任务更多是程序员的工作, 编译器还无法很好的帮助我们&lt;/p>
&lt;h3 id="2assignment">2.Assignment&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-19-27-56_hu14391237563580471045.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-19-27-56_hu616456940486576536.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-19-27-56_hu5440628955229842299.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-19-27-56_hu14391237563580471045.webp"
width="760"
height="568"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>需要考虑让每个处理单元尽可能减少沟通.&lt;/p>
&lt;p>有一种方法是随机分配,但会最大化沟通
还有一个极端是全部由一个处理单元完成,但是这样就没有并行了&lt;/p>
&lt;p>这是另一个挑战&lt;/p>
&lt;p>分配可以静态也可以动态发生&lt;/p>
&lt;p>静态: 在程序开始时就确定好.
动态: 在程序运行时分配
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-19-32-26_hu16331554757498085297.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-19-32-26_hu9761166086138627002.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-19-32-26_hu9809364414437767669.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-19-32-26_hu16331554757498085297.webp"
width="760"
height="562"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>静态分配的问题:&lt;/p>
&lt;ul>
&lt;li>无法适应不同的输入(如:工作量不均匀)&lt;/li>
&lt;li>无法适应不同的处理单元数量&lt;/li>
&lt;/ul>
&lt;p>动态分配: 通过消息传递来实现, 每个处理单元都有一个队列, 用来存放需要处理的任务(tasks). 当一个处理单元完成了一个任务, 就从队列中取出一个任务来处理
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-19-41-07_hu1349446049049587855.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-19-41-07_hu14576602086376855047.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-19-41-07_hu12572510538095988322.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-19-41-07_hu1349446049049587855.webp"
width="760"
height="526"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>缺点:
队列需要同步, 会有额外的开销&lt;/p>
&lt;h3 id="3-orchestration-编排阶段">3. Orchestration 编排阶段&lt;/h3>
&lt;p>编排的目标是:
减少沟通和同步的成本, preserve &lt;strong>locality&lt;/strong> of data reference, reduce overhead.&lt;/p>
&lt;h3 id="4mapping">4.mapping&lt;/h3>
&lt;p>这是程序员最不需要关心的, 交给编译器就好了
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-19-48-55_hu18041784481860567420.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-19-48-55_hu11189538820288683828.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-19-48-55_hu3525329770943181792.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-19-48-55_hu18041784481860567420.webp"
width="760"
height="574"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h2 id="example">example&lt;/h2>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-20-28-08_hu15506838275066927065.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-28-08_hu18199703063222441456.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-28-08_hu3772833976369314939.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-20-28-08_hu15506838275066927065.webp"
width="760"
height="568"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>顺序程序:
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-20-29-38_hu6735932064816553576.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-29-38_hu2111720748333443749.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-29-38_hu5170284977349441581.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-20-29-38_hu6735932064816553576.webp"
width="760"
height="579"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>那么如何并行执行呢?&lt;/p>
&lt;h3 id="step1-identify-dependenciesproblem-decomposition">Step1: identify dependencies(problem decomposition)&lt;/h3>
&lt;p>因为会迭代很多次,所以会引起不同迭代次数的数据竞争.&lt;/p>
&lt;p>有一种划分方法是沿着对角线:
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-20-32-11_hu13611180273895099756.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-32-11_hu5596510015077813585.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-32-11_hu5715492329580206114.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-20-32-11_hu13611180273895099756.webp"
width="760"
height="617"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>不足之处是:&lt;/p>
&lt;ul>
&lt;li>有些对角线很短, 负载不均衡&lt;/li>
&lt;li>需要额外的计算(对角线下标)&lt;/li>
&lt;/ul>
&lt;p>另一种方法是滚动数组:
用两个数组, 一个用来存放当前迭代的结果, 一个用来存放上一次迭代的结果&lt;/p>
&lt;p>这样计算时不会有数据竞争.&lt;/p>
&lt;p>但很多人不希望有额外的内存开销.&lt;/p>
&lt;p>事实上使用的是红黑排序.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-20-37-00_hu8291230226469297766.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-37-00_hu11805732514836799091.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-37-00_hu2676575889237740706.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-20-37-00_hu8291230226469297766.webp"
width="760"
height="566"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>每次迭代只更新红色的部分, 然后再翻转.
这样就不需要复制数组了.&lt;/p>
&lt;h3 id="step2-assign-tasks">Step2: assign tasks&lt;/h3>
&lt;p>我们不把每一个元素作为一个任务,而是把每一行作为一个任务.&lt;/p>
&lt;p>同时:
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-20-41-36_hu1837289861879791973.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-41-36_hu6044737169545763233.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-41-36_hu552359816603574820.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-20-41-36_hu1837289861879791973.webp"
width="760"
height="569"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>红黑排序有一个同步的步骤: 必须等待所有的红色部分都计算完毕, 才能开始计算黑色部分.&lt;/p>
&lt;p>为了最小化沟通, 相邻行作为捆包是更好的选择, 这样只在更新边界时需要沟通.&lt;/p>
&lt;h3 id="三种实现方法">三种实现方法&lt;/h3>
&lt;h4 id="data-parallel-expression-of-solver">Data-parallel expression of solver&lt;/h4>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-20-45-17_hu13662685671239148596.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-45-17_hu1627390284879226963.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-45-17_hu2330829201372895603.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-20-45-17_hu13662685671239148596.webp"
width="760"
height="568"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>这个的特点是系统做了很多工作, 程序只需要指定哪里需要并行.&lt;/p>
&lt;h4 id="shared-address-space-code">shared-address-space code&lt;/h4>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-20-49-07_hu10342410918501423371.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-49-07_hu12510020919460640719.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-49-07_hu11245359944098954398.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-20-49-07_hu10342410918501423371.webp"
width="760"
height="576"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>version1 :
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-20-49-41_hu9974608223223255749.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-49-41_hu8397588738503351654.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-49-41_hu1705930558014704543.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-20-49-41_hu9974608223223255749.webp"
width="760"
height="577"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>但是有个锁会使得程序变慢
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-20-51-52_hu5248278244539975209.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-51-52_hu14947264160442593785.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-51-52_hu2946796146468195175.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-20-51-52_hu5248278244539975209.webp"
width="760"
height="564"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>version2:
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-20-53-12_hu17124900516876097928.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-53-12_hu8054982778112452914.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-53-12_hu15327221378421388511.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-20-53-12_hu17124900516876097928.webp"
width="760"
height="574"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>有三个barrier来保证红黑顺序
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-20-54-07_hu16789937802425680759.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-54-07_hu3575241075486588842.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-54-07_hu17373999014078524940.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-20-54-07_hu16789937802425680759.webp"
width="760"
height="545"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
为什么是三个呢?&lt;/p>
&lt;p>每一部分都要被分割&lt;/p>
&lt;p>最后一个是为了diff的分割
第一个是为了myDiff的分割
第二个是为了diff的分割&lt;/p>
&lt;p>所以可以使用diff数组&lt;/p>
&lt;p>version3:
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-20-57-40_hu8862164751071542484.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-57-40_hu1255525217162913010.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-57-40_hu17825403583334167297.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-20-57-40_hu8862164751071542484.webp"
width="760"
height="566"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>barrier的问题:
barrier还是有点笨重, 这会强制所有线程到一个起跑线
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-20-59-07_hu5035559889237816704.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-59-07_hu8821564966927350594.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-59-07_hu17595225644428805985.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-20-59-07_hu5035559889237816704.webp"
width="760"
height="584"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>但如果有更精确的信息, 只需要等待依赖的线程就好了&lt;/p>
&lt;h4 id="message-passing-code">message-passing code&lt;/h4>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-21-00-57_hu8343288898847856546.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-21-00-57_hu487663540901926678.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-21-00-57_hu13798347729872320489.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-21-00-57_hu8343288898847856546.webp"
width="760"
height="574"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>需要有额外的划分,来存储相邻处理器的数据&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-21-02-04_hu9647767134237934075.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-21-02-04_hu6189396965867830938.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-21-02-04_hu7816626352685241341.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-21-02-04_hu9647767134237934075.webp"
width="760"
height="579"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>同时,在最后计算diff时,需要等待所有的处理器都计算完毕.
这里选中了一个processor zero来计算diff, 其他的处理器都发送自己的diff给它.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-21-04-12_hu13144508949625232900.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-21-04-12_hu7219794948977631306.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-21-04-12_hu15797052903953089676.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-21-04-12_hu13144508949625232900.webp"
width="760"
height="562"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>但沟通时有可能发生死锁. 因为每个处理器都在等待其他处理器的消息, 但是自己的消息又没有发送出去.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-21-06-02_hu13674929420786639542.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-21-06-02_hu11344768563742812061.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-21-06-02_hu13195445831239353655.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-21-06-02_hu13674929420786639542.webp"
width="760"
height="574"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>所以需要分奇偶来发送&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-21-07-24_hu7781534247472818916.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-21-07-24_hu10215756468887799073.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-21-07-24_hu9255617504047767105.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-21-07-24_hu7781534247472818916.webp"
width="760"
height="590"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p></description></item><item><title>L5 Work distribution and scheduling</title><link>https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/</link><pubDate>Fri, 01 Mar 2024 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/</guid><description>&lt;h2 id="三种分配策略的总结">三种分配策略的总结&lt;/h2>
&lt;h3 id="静态分配">静态分配&lt;/h3>
&lt;p>优点:&lt;/p>
&lt;ul>
&lt;li>几乎没有运行时的开销(关于分配)&lt;/li>
&lt;/ul>
&lt;p>缺点:&lt;/p>
&lt;ul>
&lt;li>不总是均匀的分配任务&lt;/li>
&lt;/ul>
&lt;p>什么时候使用:&lt;/p>
&lt;ul>
&lt;li>(最简单的例子) 当知道每个任务的工作量相当的时候&lt;/li>
&lt;li>当每个任务的工作量是可预测的,但不一定相等的时候&lt;/li>
&lt;/ul>
&lt;p>半静态分配&lt;/p>
&lt;ul>
&lt;li>场景: 当工作量会随时间发生改变,当变化比较慢时.(任务量不可预测)&lt;/li>
&lt;li>做法: 定期的重新分配任务
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-15-17-17-21_hu3008403049054463794.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-15-17-17-21_hu14731120730542166751.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-15-17-17-21_hu17289325771237681909.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-15-17-17-21_hu3008403049054463794.webp"
width="760"
height="574"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/li>
&lt;/ul>
&lt;h3 id="动态分配">动态分配&lt;/h3>
&lt;p>场景: 当每个任务的工作量或者任务的数量是不可预测的时候&lt;/p>
&lt;p>每个计算单元都要去获取任务&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-15-17-25-21_hu1368032926938752079.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-15-17-25-21_hu16772052656131795954.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-15-17-25-21_hu6343010503406755659.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-15-17-25-21_hu1368032926938752079.webp"
width="760"
height="552"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>但这样的实现, 每次的任务可能会很少,
会使得更多的开销在争夺锁(获取任务的锁)上面.&lt;/p>
&lt;p>有一个办法是一次性计算更多的任务.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-15-17-26-57_hu5833881602944408794.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-15-17-26-57_hu2834709672370128422.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-15-17-26-57_hu12264959687563893817.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-15-17-26-57_hu5833881602944408794.webp"
width="760"
height="535"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>但分配更多的任务可能会导致负载不平衡.&lt;/p>
&lt;p>因此需要在分配任务数量上要找一个平衡, 不花费过多的时间在争夺锁上, 也不会导致负载不平衡.&lt;/p>
&lt;p>&lt;strong>Schedule long tasks first&lt;/strong>
但如果有一个大任务在最后，将出现如下情况：
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-08-53-07_hu10230926095035017821.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-08-53-07_hu14686150513702580107.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-08-53-07_hu10356628661609947571.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-16-08-53-07_hu10230926095035017821.webp"
width="760"
height="567"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>因此，如果知道有一个大任务，可以提前处理，而不是放到最后一个.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-08-56-01_hu1621918394461418337.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-08-56-01_hu1164791779794963333.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-08-56-01_hu4625046108231851811.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-16-08-56-01_hu1621918394461418337.webp"
width="760"
height="566"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h4 id="work-stealing">Work stealing&lt;/h4>
&lt;p>当一个计算单元没有任务的时候, 从其他计算单元那里偷取任务.&lt;/p>
&lt;p>实现的一些问题:&lt;/p>
&lt;p>1.从哪个线程开始偷取任务呢?
有随机的, 也有从最后一个开始偷取的.&lt;/p>
&lt;p>2.应该偷取多少任务呢?
应该偷取尽可能多一些,这样可以减少偷取任务的次数.&lt;/p>
&lt;p>3.怎样检测一个计算单元是否有任务呢?
可能会循环遍历,&lt;/p>
&lt;p>4.使用本地队列(分布式队列)会更快(在有互斥锁的情况下)&lt;/p>
&lt;p>还有一种方式是使用特殊的数据结构来存储任务间的依赖关系, 从而可以在任务完成的时候, 自动的调度下一个任务.
缺点是额外开销
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-32-31_hu7166641800788347989.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-32-31_hu766320379355642196.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-32-31_hu13420095295553550461.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-32-31_hu7166641800788347989.webp"
width="760"
height="564"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h2 id="常见的并行编程模式">常见的并行编程模式&lt;/h2>
&lt;p>循环
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-42-32_hu13741811842573474479.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-42-32_hu15222458320347808415.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-42-32_hu14895337797366990540.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-42-32_hu13741811842573474479.webp"
width="760"
height="571"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>创建显示线程
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-43-32_hu18125993112644765585.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-43-32_hu15752079987674335999.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-43-32_hu6405559320701793712.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-43-32_hu18125993112644765585.webp"
width="760"
height="575"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>递归时的并行&lt;/p>
&lt;p>递归可以编写出简单的代码, 但是递归的并行化是比较困难的.&lt;/p>
&lt;p>因为递归的并行化需要在递归的每一层都要进行并行化, 并且需要在每一层都要进行同步.&lt;/p>
&lt;p>但只要有独立的子问题, 就可以创造很多潜在的并行性.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-45-15_hu14172364015787652933.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-45-15_hu6747056353515885661.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-45-15_hu2535906686577071460.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-45-15_hu14172364015787652933.webp"
width="760"
height="576"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h2 id="fork-join-pattern">Fork-Join pattern&lt;/h2>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-47-18_hu8611049300448897360.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-47-18_hu7704161734367416199.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-47-18_hu10402279733613162311.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-47-18_hu8611049300448897360.webp"
width="760"
height="567"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>cilk_spawn: 会创建一个新的线程, 并且在新的线程中执行函数, 并且不会阻塞当前的线程.&lt;/p>
&lt;p>cilk_sync: 会等待所有的子线程执行完毕, 并且会阻塞当前的线程.&lt;/p>
&lt;p>每个函数的结尾隐式的调用了cilk_sync.&lt;/p>
&lt;p>example:
有一个主线程+fork的线程.
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-49-40_hu11324876380609214000.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-49-40_hu10078487783917082617.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-49-40_hu13617329357184765813.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-49-40_hu11324876380609214000.webp"
width="760"
height="573"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>快排的例子:
在规模较小的时候, 使用串行的快排. 这样可以减少线程的创建和销毁的开销.
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-53-13_hu3015660515366087983.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-53-13_hu11381342424955931495.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-53-13_hu10282946952117885859.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-53-13_hu3015660515366087983.webp"
width="760"
height="560"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>不要忽略了抽象和实现的区别.&lt;/strong>
spawn不是生成一个具体的线程, 而是声明这里有一个可以并行的任务.&lt;/p>
&lt;p>任务的数量至少需要比硬件线程多,但也不能大于100倍.
8倍是一个比较好的选择.
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-01-49_hu14774320151071770566.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-01-49_hu16424662846058634362.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-01-49_hu3723962622488648304.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-01-49_hu14774320151071770566.webp"
width="760"
height="500"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h2 id="cilk的实现">Cilk的实现&lt;/h2>
&lt;p>假设我们要去实现clik_spawn 和 cilk_sync
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-04-28_hu7447692571492027232.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-04-28_hu8974168562065917686.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-04-28_hu4198302342609125234.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-04-28_hu7447692571492027232.webp"
width="760"
height="566"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>线程池的实现(CILB):&lt;/p>
&lt;p>thread1 需要找到一种方法来发现有新的任务可以执行.
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-15-52_hu12263950812356503857.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-15-52_hu7473321330908624370.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-15-52_hu16148235588242330865.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-15-52_hu12263950812356503857.webp"
width="760"
height="593"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>所以thread 0不能简单的调用foo, 它的作用是执行foo.&lt;/p>
&lt;p>但需要在执行foo前,把特殊的东西放入工作队列中.&lt;/p>
&lt;p>此时如果另一个线程突然变得空闲, 它就可以从工作队列中获取任务.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-26-10_hu6442079894081473816.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-26-10_hu9290200277838731507.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-26-10_hu6467966919452910557.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-26-10_hu6442079894081473816.webp"
width="760"
height="564"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>为什么不把foo放入队列, 直接执行bar呢?(上面是执行foo bar放入队列)&lt;/p>
&lt;p>这涉及到 continuation first(child stealing) 和 child first(continuation stealing) 的问题.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-34-20_hu968565991250457609.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-34-20_hu2817509384184398406.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-34-20_hu9530969792365300997.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-34-20_hu968565991250457609.webp"
width="760"
height="567"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-36-22_hu8159446113550339437.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-36-22_hu6161616581368565848.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-36-22_hu12306362127556912812.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-36-22_hu8159446113550339437.webp"
width="760"
height="570"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>continuation first会导致线程0的大量工作排队.(广度优先队列)
child first会导致其他线程把下一个任务偷走时, 会导致线程0的工作队列为空.(深度优先队列)&lt;/p>
&lt;p>实际上child first是合理的.(在递归中是最合适的)&lt;/p>
&lt;p>在递归程序中,会先将所有深度的任务放入队列中.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-48-23_hu16652583909772108632.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-48-23_hu10337571603158018231.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-48-23_hu1141930398760906564.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-48-23_hu16652583909772108632.webp"
width="760"
height="567"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>按照之前优先执行大任务的策略, 其他线程会优先从队列顶部(先入的)中偷取任务.
因为在分而治之的算法中, 大任务会被分解成小任务, 因此大任务会先被放入队列中.&lt;/p>
&lt;p>实际中使用了双端队列:&lt;/p>
&lt;ul>
&lt;li>从队列头部获取任务&lt;/li>
&lt;li>从队列尾部放入任务&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-52-42_hu4506843496912154624.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-52-42_hu8693744683448668572.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-52-42_hu2512762772386766013.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-52-42_hu4506843496912154624.webp"
width="760"
height="571"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>但之前有一个问题: 很多队列,该从哪个队列中获取任务呢?
也许是随机的. 偷取任务的时候, 不随机的更可能会引起负载不均衡.&lt;/p>
&lt;p>本地线程访问的是本地队列的尾部, 偷取时也是放入尾部.(偷其他队列的头部)
这样也有利于空间局部性.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-58-04_hu730133420434351813.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-58-04_hu14992992302285286615.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-58-04_hu13951061168031171524.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-58-04_hu730133420434351813.webp"
width="760"
height="567"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>那么如何实现同步呢?&lt;/p>
&lt;p>Example1: stalling join policy
拖延政策: 所有我创建的任务都必须完成后, 我才能继续执行.
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-11-01-00_hu14131336948733459577.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-11-01-00_hu13342175954870851217.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-11-01-00_hu17958644797646315598.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-16-11-01-00_hu14131336948733459577.webp"
width="760"
height="572"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>Example2: greedy join policy(cilk的实现方法)&lt;/p>
&lt;p>有一个跟踪数据结构,但那个东西可以四处移动.&lt;/p>
&lt;p>最后一个完成的线程会偷走这个数据结构&lt;/p>
&lt;p>所以一旦最后一个任务完成, 就可以继续执行了.&lt;/p>
&lt;p>这样不会浪费时间等待同步.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-11-04-26_hu5129180527319698179.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-11-04-26_hu14693399253607348085.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-11-04-26_hu14015748063948365147.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-16-11-04-26_hu5129180527319698179.webp"
width="760"
height="570"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>第一个方法实现起来更简单,但速度更慢.
因为它总是首线程只等待其他线程完成.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-11-09-58_hu2799091150252378349.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-11-09-58_hu12566568520989271673.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-11-09-58_hu13396057358256551616.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-16-11-09-58_hu2799091150252378349.webp"
width="760"
height="570"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-11-10-26_hu6456008849394868581.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-11-10-26_hu9026323879684968514.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-11-10-26_hu3623978222806166205.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-16-11-10-26_hu6456008849394868581.webp"
width="760"
height="421"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p></description></item><item><title>L6</title><link>https://ysyyhhh.github.io/blog/l6/</link><pubDate>Fri, 01 Mar 2024 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/blog/l6/</guid><description>&lt;p>虚拟文件系统&lt;/p>
&lt;p>/proc/cpuinfo&lt;/p>
&lt;ul>
&lt;li>model name&lt;/li>
&lt;li>cpu MHz - 频率&lt;/li>
&lt;li>cache size - 缓存大小&lt;/li>
&lt;li>siblings - 逻辑cpu数量&lt;/li>
&lt;li>processor - 逻辑cpu编号&lt;/li>
&lt;li>cpu cores - 物理cpu数量&lt;/li>
&lt;li>core id - 物理cpu编号&lt;/li>
&lt;li>&lt;/li>
&lt;/ul>
&lt;p>这样查看的cpu数量很多&lt;/p>
&lt;p>siblings是逻辑cpu的数量&lt;/p>
&lt;p>cpu cores是物理cpu的数量&lt;/p>
&lt;p>为什么报告的processor数量是40而siblings是20呢?
因为报告的processor包括超线程的逻辑cpu. 这样操作系统就可以直接根据逻辑cpu的数量来分配任务.&lt;/p>
&lt;p>Memory bandwidth - 内存带宽
Power consumption - 功耗
能源消耗实际上是一个很大的问题.
Intel code name - 代号
Functional units&lt;/p>
&lt;ul>
&lt;li>latency - 延迟&lt;/li>
&lt;li>issue time - 发射时间&lt;/li>
&lt;li>capacity - 容量&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="http://www.agner.org/optimize/microarchitecture.pdf" target="_blank" rel="noopener">微处理架构&lt;/a>&lt;/p>
&lt;h2 id="function-units">function units&lt;/h2>
&lt;ul>
&lt;li>latency - 延迟，执行一个指令所需要的时钟周期数(不包括等待)&lt;/li>
&lt;li>issue time - 发射时间，指令发射到执行所需要的时钟周期数(包括等待)&lt;/li>
&lt;li>capacity - 容量&lt;/li>
&lt;/ul>
&lt;p>优化的地方:&lt;/p>
&lt;ul>
&lt;li>搞清楚到底哪些代码是执行次数最多的(内部循环)(对实际使用情况来说)&lt;/li>
&lt;li>基本运算消耗时间: 除法 &amp;gt; 乘法 &amp;gt; 加法 &amp;gt; 位移&lt;/li>
&lt;/ul>
&lt;p>基本的程序:
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l6/img/2023-10-17-20-22-45_hu16384140902215742129.webp 400w,
/blog/l6/img/2023-10-17-20-22-45_hu18337542377736970995.webp 760w,
/blog/l6/img/2023-10-17-20-22-45_hu757787685692881523.webp 1200w"
src="https://ysyyhhh.github.io/blog/l6/img/2023-10-17-20-22-45_hu16384140902215742129.webp"
width="760"
height="362"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>合并重复计算的简单的提升:
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l6/img/2023-10-17-20-23-02_hu3429642273029752312.webp 400w,
/blog/l6/img/2023-10-17-20-23-02_hu16521155876778806723.webp 760w,
/blog/l6/img/2023-10-17-20-23-02_hu11867039954513997142.webp 1200w"
src="https://ysyyhhh.github.io/blog/l6/img/2023-10-17-20-23-02_hu3429642273029752312.webp"
width="760"
height="363"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l6/img/2023-10-17-20-24-13_hu694714283949146576.webp 400w,
/blog/l6/img/2023-10-17-20-24-13_hu4394260695781880594.webp 760w,
/blog/l6/img/2023-10-17-20-24-13_hu13066500280987280892.webp 1200w"
src="https://ysyyhhh.github.io/blog/l6/img/2023-10-17-20-24-13_hu694714283949146576.webp"
width="760"
height="389"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>将除法次数减少,(不依赖于内层循环的变量的计算拿出来)&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l6/img/2023-10-17-20-24-42_hu5097316574084694089.webp 400w,
/blog/l6/img/2023-10-17-20-24-42_hu8546702116238759833.webp 760w,
/blog/l6/img/2023-10-17-20-24-42_hu12568727997288044586.webp 1200w"
src="https://ysyyhhh.github.io/blog/l6/img/2023-10-17-20-24-42_hu5097316574084694089.webp"
width="760"
height="383"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>循环展开 loop unrolling&lt;/p>
&lt;p>如果每一次循环都要进行一次是否终止的测试,开销会很大.(尤其是一次循环的计算 相比于 循环次数来说很小 时)&lt;/p>
&lt;p>所以处理器从简单的策略开始,如预测循环的次数. 大部分都是基于统计预测的.&lt;/p>
&lt;p>如果可以预测循环的次数,就可以将循环展开. 每次循环多执行4 或 8 或&amp;hellip;次原来循环做的事情.&lt;/p>
&lt;p>但展开时不一定均匀,&lt;/p>
&lt;p>uniform可以使得循环展开的更好.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l6/img/2023-10-17-20-35-48_hu3138619730511597604.webp 400w,
/blog/l6/img/2023-10-17-20-35-48_hu13726065246080865100.webp 760w,
/blog/l6/img/2023-10-17-20-35-48_hu4571829099102038825.webp 1200w"
src="https://ysyyhhh.github.io/blog/l6/img/2023-10-17-20-35-48_hu3138619730511597604.webp"
width="760"
height="459"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l6/img/2023-10-17-20-39-50_hu18175992364963129812.webp 400w,
/blog/l6/img/2023-10-17-20-39-50_hu18253050517764449495.webp 760w,
/blog/l6/img/2023-10-17-20-39-50_hu11511416001899192010.webp 1200w"
src="https://ysyyhhh.github.io/blog/l6/img/2023-10-17-20-39-50_hu18175992364963129812.webp"
width="760"
height="452"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>为什么8维向量获得了超过8倍的加速呢?
因为uniform, 原本要做8次的判断,现在只需要做一次.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l6/img/2023-10-17-20-42-45_hu1609692394166020471.webp 400w,
/blog/l6/img/2023-10-17-20-42-45_hu307320200501152337.webp 760w,
/blog/l6/img/2023-10-17-20-42-45_hu6789781479355898912.webp 1200w"
src="https://ysyyhhh.github.io/blog/l6/img/2023-10-17-20-42-45_hu1609692394166020471.webp"
width="760"
height="306"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>常规优化提升了15倍
向量优化提升了5.4倍
总计提升了82倍&lt;/p>
&lt;p>向量化很好且是free的,但不能忽略了传统的优化&lt;/p>
&lt;p>传统的优化(213 program)使得速度提升了三倍&lt;/p>
&lt;p>要做到极致的优化,就比如要花3个星期的时间在编码风格上, 最后30分钟花在向量化上.&lt;/p>
&lt;p>但要看情况来决定编码风格的优化.
因为如果我们编写的代码不是执行次数最多(如内核,场景仿真,高频), 那么可能更需要的是可读性.&lt;/p>
&lt;p>可读性变差 可能会导致bug很容易被引入, 并且非常不容易被发现和维护.&lt;/p></description></item><item><title>L7</title><link>https://ysyyhhh.github.io/blog/l7/</link><pubDate>Fri, 01 Mar 2024 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/blog/l7/</guid><description>&lt;p>GPU&lt;/p>
&lt;h2 id="图形渲染">图形渲染&lt;/h2>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l7/img/2023-10-18-22-45-21_hu8779939371141224275.webp 400w,
/blog/l7/img/2023-10-18-22-45-21_hu676028763102042527.webp 760w,
/blog/l7/img/2023-10-18-22-45-21_hu5440692062751225118.webp 1200w"
src="https://ysyyhhh.github.io/blog/l7/img/2023-10-18-22-45-21_hu8779939371141224275.webp"
width="686"
height="519"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>图像中的每个对象都有很自然的并行性。&lt;/p></description></item><item><title>NoRBERT：使用迁移学习改进需求分类任务</title><link>https://ysyyhhh.github.io/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/</link><pubDate>Fri, 01 Mar 2024 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/</guid><description>&lt;p>NoRBERT: Transfer Learning for Requirements Classification
Tobias Hey， Jan Keim， Anne Koziolek， Walter F. Tichy
Karlsruhe Institute of Technology (KIT)&lt;/p>
&lt;h2 id="引用">引用&lt;/h2>
&lt;p>T. Hey, J. Keim, A. Koziolek and W. F. Tichy, &amp;ldquo;NoRBERT: Transfer Learning for Requirements Classification,&amp;rdquo; 2020 IEEE 28th International Requirements Engineering Conference (RE), Zurich, Switzerland, 2020, pp. 169-179, doi: 10.1109/RE48521.2020.00028.&lt;/p>
&lt;p>论文：https://sdq.kastel.kit.edu/publications/pdfs/hey2020.pdf
仓库：https://github.com/tobhey/NoRBERT&lt;/p>
&lt;h2 id="摘要">摘要&lt;/h2>
&lt;p>本文提出了NoRBERT，它使用了BERT模型进行微调，在需求工程领域进行迁移学习。他在PROMISE NFR数据集上，对功能性和非功能性需求的分类任务F1分数高达94％。对于分类非功能性需求的子类，超越了最近的方法，最常见的类别平均F1分数达到87%。在一个未见过的项目设置下，它比最近的方法高出15个百分点。此外，我们根据所包含的关注点，即功能、数据和行为，来分类功能性要求，标记了PROMISE NFR数据集中的功能性需求，并应用于测试NoRBERT，最终取得了高达92%的F1分数。NoRBERT提高了需求分类的准确性，并且可以很好地应用于未见过的项目。&lt;/p>
&lt;h2 id="1-引言">1 引言&lt;/h2>
&lt;p>需求的主要来源仍然是自然语言文档。对需求进行分类对于在项目早期识别出特定需求（如与安全相关的需求）非常重要。尽管已有的自动分类方法在多样化数据集上表现不错，但它们在未见过的项目上的性能会下降，因为需求的表述和结构依赖于项目和作者，而现有方法缺乏泛化能力。为了解决这个问题，我们探索了迁移学习方法，这种方法在NLP领域广泛应用，通过在大型数据集上训练来捕捉文本的深层含义，并能针对特定任务进行微调，从而在少量数据下实现更好的性能和泛化。
我们提出了NoRBERT方法，它基于BERT模型。BERT是一种预训练在大型文本语料库上的语言模型。BERT可以通过提供少量数据在特定任务上进行微调。我们使用NoRBERT在PROMISE NFR数据集上进行需求分类，并测试了其在重新标记的NFR数据集上的泛化能力。此外，我们还使用NoRBERT根据Glinz提出的关注点对功能性需求进行分类。这种方法在需求工程中特别有用，因为它可以在有限的标记数据情况下提供有效的分类。
本文的贡献包括以下三方面：
我们研究了通过迁移学习对已知和未知项目的需求进行分类的改进程度。
我们提供了一个新的数据集，根据功能、数据和行为的关注点进一步对功能性需求进行分类。
我们评估了基于迁移学习的方法在新数据集和任务上的表现。&lt;/p>
&lt;h2 id="2-技术介绍">2 技术介绍&lt;/h2>
&lt;h3 id="21相关工作">2.1相关工作&lt;/h3>
&lt;p>在需求工程领域，功能性需求与非功能性需求的区分是一个广泛研究的主题。功能性需求指的是系统必须执行的具体任务，而非功能性需求则涉及系统的质量标准，如性能、可靠性等，它们没有明确的执行标准。一些研究者将非功能性需求视为质量目标，而另一些则将其归类为系统属性或约束。
自动从文档中提取和分类需求是研究者关注的重点，已经发展出多种方法。例如，Cleland-Huang等人利用信息检索技术，通过识别指示词来分类需求，但这种方法在精确度上有所欠缺。Hussain等人通过使用特定词汇和决策树分类器改进了需求分类。Kurtanović和Maleej则采用自动化特征选择来预测需求类别。还有研究者使用深度学习技术，如卷积神经网络（CNN），来分类需求。
尽管这些方法展示了不同技术的潜力，但它们在实际应用中可能存在局限性，如过度依赖特定数据集、对措辞和句子结构敏感，或需要手动预处理。此外，这些方法在泛化到新项目上的能力上也存在不足。为了解决这些问题，我们尝试迁移学习方法，以期望在较少的训练数据下实现更好的性能和泛化能力。&lt;/p>
&lt;h3 id="22-bert介绍">2.2 BERT介绍&lt;/h3>
&lt;p>BERT（Bidirectional Encoder Representations from Transformers）是一种语言模型（LM）。用于预测词序列中词的概率，具有迁移学习的能力，即能在微调后适应不同任务。它起源于词嵌入技术，如word2vec，但通过使用ELMo的双向LSTM解决了word2vec忽略词义歧义的问题。BERT采用预训练和微调的方法进一步发展了语言模型，。
BERT的核心是Transformer架构，它用自注意力编码器-解码器结构替代了LSTM。自注意力层让模型能够识别并赋予相关词更高的权重，而忽略不相关的词。Transformer的多头注意力机制使模型能同时关注不同位置的词，提高了对词义的理解。
BERT的训练结合了双向预训练和掩码语言建模。在训练中，一部分输入词被掩码，模型需要预测这些词，同时学习判断句子是否可能连续。这种训练方法使BERT在多个NLP任务上取得了优异的表现。
BERT有两个版本：基础模型和大模型，分别具有不同数量的编码器层、隐藏单元和注意力头，参数数量也有所不同。基础模型有1.1亿参数，而大模型有3.4亿参数。BERT最初是在英文维基百科和BooksCorpus上训练的。BERT和类似的方法目前正在取代传统的自然语言处理系统。Tenney等人对BERT的不同层次和底层学习结构的分析表明，BERT重塑了类似于NLP流水线的相似结构。
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-06-42_hu11743309384370604050.webp 400w,
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-06-42_hu5293664041445464034.webp 760w,
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-06-42_hu272057229341672845.webp 1200w"
src="https://ysyyhhh.github.io/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-06-42_hu11743309384370604050.webp"
width="522"
height="293"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
图1：用于微调 BERT 进行分类的架构。
图1展示了如何使用BERT进行分类。输入被分词。BERT的第一个输入标记始终是特殊标记[CLS]。标记[SEP]是一个特殊的分隔符标记，例如用于分隔句子，而标记[PAD]用于填充。对于分类和类似的下游任务，BERT产生的唯一输出是BERT为第一个标记([CLS])产生的输出，这是所有标记的聚合输出。这个聚合输出可以输入到一个单层前馈神经网络中，该网络使用softmax为不同类别分配概率。&lt;/p>
&lt;h2 id="3-实验评估">3 实验评估&lt;/h2>
&lt;h3 id="31-实验设置">3.1 实验设置&lt;/h3>
&lt;p>研究问题。在本文中，我们研究以下研究问题：
RQ1：迁移学习在需求分类中的表现如何？
RQ2：迁移学习是否提高了在未见项目上对需求进行分类的性能？
RQ3：迁移学习方法能够多大程度上检测到功能性需求的子类？
评估数据集。为了回答RQ1和RQ2，我们利用了两个现有的数据集。一个是广泛使用的PROMISE NFR数据集，该数据集在RE'17数据挑战中进行了处理，另一个是由Dalpiaz等人提供了一个重新标记的版本。前者来自15个项目的625个需求。这625个需求包括255个功能性需求和370个非功能性需求。表I显示了数据集中类别的分布以及每个类别需求的平均长度。每个需求只被标记为一个类别（F或11个NFR子类之一）。这些类别的分布不均匀。该数据集中F类要比NFR类少115个，且NFR子类的数量差异很大，从可用性的67个到可移植性的1个不等。可用性、安全性、操作性和性能是超过50个示例的类别，而容错性、法律性、可维护性和可移植性的类别则低于20个。
表I：原始 NFR 数据集的分布
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-06-59_hu12843035158797477820.webp 400w,
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-06-59_hu12703239149075297949.webp 760w,
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-06-59_hu15642179989461252779.webp 1200w"
src="https://ysyyhhh.github.io/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-06-59_hu12843035158797477820.webp"
width="554"
height="377"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
由于数据集中F和NFR之间的区分有争议，并且数据集包含重复和错误标记的需求，Dalpiaz等人提供了一个重新标记的数据集。表II展示了数据集的概述。它仅由原始625个需求中的612个组成，并且仅使用了两个类别。一个需求可以具有功能性（F）或质量方面（Q）或两者都有。80个需求两者都有。230个需求仅具有功能性方面（OnlyF），而302个需求仅包含质量方面（OnlyQ）。
表II：重新标记的 NFR 数据集的分布
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-07-15_hu7145679011130613071.webp 400w,
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-07-15_hu14426580907806310369.webp 760w,
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-07-15_hu16472316489364980236.webp 1200w"
src="https://ysyyhhh.github.io/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-07-15_hu7145679011130613071.webp"
width="554"
height="195"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
对比方法。基于数据集，我们将我们的方法应用于以下任务：
任务1：在原始NFR数据集上对F/NFR进行二元分类。
任务2：在原始NFR数据集上对四个最常见的NFR子类（US，SE，O，PE）进行二元和多类分类。
任务3：在原始NFR数据集中对所有NFR子类进行多类分类。
任务4：使用Dalpiaz等人提供的重新标记的NFR数据集，根据功能和质量方面对需求进行二元分类。
评估指标。对于所有任务，使用精确率（P）、召回率（R）和F1分数（F1）。对于多类分类，还报告了预测类别的加权平均F1分数（A）。
采用不同的设置来评估这些任务，包括使用.75-split描述了一个单次分成75%训练和25%测试集分割的数据集，以及使用了分层的10折交叉验证，即将数据集分割为10次，其中90%为训练集，10%为测试集，并对结果进行平均。分层分割确保数据集中类别的分布在训练集和测试集中保持一致。
为了进一步研究方法的可迁移性，使用了两种特定于项目的折叠策略。使用p-fold描述了Dalpiaz等人使用的项目级交叉验证，将数据集分割为10次，其中3个项目作为测试集，12个项目作为训练集，确保功能和质量方面的均匀分布。此外，还使用了一种留一项目交叉验证（loPo），即在n-1个项目上进行n次训练，并在留出的项目上进行测试。对于像NFR子类这样高度不平衡的二元任务，我们尝试了欠采样和过采样策略。我们还尝试了早期停止（ES）和不同的训练周期数。早期停止是一种常用的正则化技术，用于避免迭代学习器过拟合。&lt;/p>
&lt;h3 id="32norbert-使用bert进行非功能性和功能性需求分类">3.2NORBERT: 使用BERT进行非功能性和功能性需求分类&lt;/h3>
&lt;p>我们使用BERT的微调版本来研究迁移学习对需求分类任务的影响。
我们使用了两种不同的预训练BERT模型，基础和大型模型，都是带词性的版本。我们还尝试了不带词性的模型，但带词性的模型表现更好。这可能是因为需求中使用的命名实体被误认为是普通名词。我们使用BERT分词器，不对需求进行预处理。在预训练模型的基础上，我们定义了输出层，即分类头。我们使用BERT的序列中的第一个标记[CLS]的输出。这个输出被输入到由一个单层的线性神经元组成的前馈神经网络的分类头。输出直接计算自加权输入的总和（再加上一些偏差）。我们使用softmax函数为不同的标签获得概率分布。在训练过程中，我们使用交叉熵损失函数，并使用以下公式量化预测分布与真实分布的接近程度。：&lt;/p>
&lt;p>H(p，q)=-∑_x▒〖p(x) log⁡〖q(x)〗 〗&lt;/p>
&lt;p>p(x)表示目标概率，q(x)表示实际概率，x代表不同的标签。对于正确标签，p(x)设为1，其他错误标签设为0。损失函数旨在惩罚不准确或不确定的预测，同时奖励那些准确的自信预测。
我们使用AdamW优化器而非传统的随机梯度下降来更新网络权重。AdamW引入了权重衰减校正，但不补偿偏差。我们设置权重衰减为0.01，最大学习率为2e-05，与BERT原始论文中的设置相同。实验表明，批量大小16在所有测试中表现最佳。我们根据模型大小设定最大序列长度，以优化性能并避免内存问题。
在微调NoRBERT的超参数时，我们认为增加训练周期可以提高模型对训练数据的拟合度，但也可能增加过拟合的风险。实验显示，对于二元分类，10到32个训练周期，对于多类分类，10到64个训练周期效果最佳。&lt;/p>
&lt;h3 id="33任务1分类功能性和非功能性需求">3.3任务1分类功能性和非功能性需求&lt;/h3>
&lt;p>对于第一个任务，我们想要衡量NoRBERT在原始PROMISE NFR数据库上将需求分类为功能性（F）或非功能性（NFR）的性能。
我们使用分层10折交叉验证设置来回答关于迁移学习在需求分类性能方面的RQ1。我们训练了二元分类模型，即预测一个需求是F还是NFR，并与其他最新方法进行比较。
表III：在 PROMISE NFR 数据集上的 F/NFR 分类。粗体数值显示每个类别的每个指标的最高得分。
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-07-28_hu14754103410436216965.webp 400w,
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-07-28_hu10811893608195072502.webp 760w,
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-07-28_hu6393584586410258573.webp 1200w"
src="https://ysyyhhh.github.io/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-07-28_hu14754103410436216965.webp"
width="507"
height="360"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
表III显示了我们的结果与其它方法报告的结果的比较。NoRBERT 在功能性需求和非功能性需求的 F1 分数上分别为 90% 和 93%。在NFR上，除了依赖手动提供的字典和规则进行数据预处理的Abad等人的方法外，NoRBERT超过了所有其他方法。NoRBERT与之相比不需要手动预处理，因此可以轻松地迁移到任何其他数据集。
我们的10折交叉验证结果显示，模型性能不受BERT模型选择或训练周期数的显著影响。Kurtanovi ´c和Maleej在功能性需求上取得了更高的F1分数，但他们的方法可能存在过拟合问题。
表III中的结果也有助于回答关于我们方法泛化能力的RQ2。10折没有考虑到数据集包含不同项目、不同领域和措辞。为了评估在未见过的项目上的性能，我们使用了特定于项目的设置（loPo和p-fold）。结果与10折评估相似或更好。这表明NoRBERT能够从训练期间看到的措辞中泛化出来。在不同项目和领域的数据集上，NoRBERT也能保持稳定性能。这与需要针对每个项目调整的手动字典和规则定义方法形成鲜明对比。&lt;/p>
&lt;h3 id="34-非功能性需求子类的分类">3.4 非功能性需求子类的分类&lt;/h3>
&lt;p>为了解决PROMISE NFR数据库中定义的非功能性需求（NFR）子类的分类任务。首先研究了数据库中四个最频繁的NFR子类的分类（任务2）。接着还研究了所有NFR子类的分类（任务3）。&lt;/p>
&lt;h4 id="a-任务2-最常见nfr子类的分类">A. 任务2: 最常见NFR子类的分类&lt;/h4>
&lt;p>我们使用NoRBERT对四种最常见的NFR进行了二元和多类分类。结果显示，NoRBERT在二元分类中取得了高达83%的加权平均F1分数，在多类分类中达到了87%。NoRBERT在大多数类别上的表现都超过了Kurtanovi´c和Maleej的模型。此外，NoRBERT在不同设置下的表现也有所不同，最佳二元分类结果是在16个周期、过采样和早停的情况下获得的。
表V: NFR 数据集上所有 NFR 子类的多类别分类。16、32 和 50 表示使用的时代数，bin 表示二元分类，mult 表示多类分类，B 和 L 分别表示使用的 BERT 模型（基础/大型）。bin16 还额外使用了 OS，multiL32 使用了 ES。LDA 和 NB（朴素贝叶斯）是指 Abad 等人的方法，其中有（P）或没有（UP）预处理过的数据。
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-07-38_hu14192244709421293268.webp 400w,
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-07-38_hu15847442993353020833.webp 760w,
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-07-38_hu13853825738858592780.webp 1200w"
src="https://ysyyhhh.github.io/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-07-38_hu14192244709421293268.webp"
width="554"
height="179"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h4 id="b-任务3-所有nfr子类的多类分类">B. 任务3: 所有NFR子类的多类分类&lt;/h4>
&lt;p>我们使用NoRBERT对所有NFR子类别进行了多类分类。多类分类器尤其是在代表数量较少的类别上表现良好。所有多类模型在平均性能上都优于相应的二元分类器。基于BERT-large的模型在这项任务上表现最佳，这可能是因为它们具有更大的参数空间，能够更好地处理语言的微妙差异。NoRBERT在这项任务上的表现超过了Navarro-Almanza等人的方法，这表明迁移学习在这项任务上优于基于词嵌入的深度学习。
我们还探讨了NoRBERT在未见过的项目上的性能（RQ2）。在p折和loPo设置中，NoRBERT的性能略有下降，但多类分类器仍然优于二元分类器。尽管在loPo设置中NoRBERT的表现略逊于p折，但多类分类器和大型模型在所有设置中都优于二元分类器。
NoRBERT在分类NFR子类别方面表现出色，即使在训练数据有限的情况下也能识别出代表性不足的子类别。NoRBERT提供了一种可行的方法来替代手动数据预处理。&lt;/p>
&lt;h3 id="35-任务4-功能性和质量方面的分类">3.5 任务4: 功能性和质量方面的分类&lt;/h3>
&lt;p>功能性（F）和非功能性需求（NFR）之间的区别并不总是清晰的，一些需求包含了两者的方面。因此，我们在Dalpiaz等人提供的重新标记的PROMISE NFR数据库上衡量NoRBERT的性能[9]，并将NoRBERT与Kurtanovi´c和Maleej[8]的方法进行比较。
表 VI：重新标记的 PROMISE NFR 数据集中类的二元分类。粗体数值代表每个类别每个指标的最高分。星号标记的 F1 分数与其他出版物报道的精度和召回率不匹配。
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-07-44_hu15464154056048460631.webp 400w,
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-07-44_hu5672182091813597099.webp 760w,
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-07-44_hu9358388563451603042.webp 1200w"
src="https://ysyyhhh.github.io/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-07-44_hu15464154056048460631.webp"
width="554"
height="213"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
表VI显示了在重新标记集上训练的二元分类器的结果。我们使用与Dalpiaz等人相同的设置，即.75-split、10-fold、p-fold和随机种子（42），此外还评估了loPo设置。NoRBERT在所有这些设置中都优于其他方法。因此，迁移学习方法明显提高了分类需求的性能（RQ1）。
在.75分割中，NoRBERT的基础模型在纯功能或质量类别上表现更佳，而大型模型在其他类别上表现更好。在10折交叉验证中，NoRBERT的最佳模型平均优于Dalpiaz等人的最佳模型10个百分点，尤其在仅含功能方面的需求上（F1得分91% vs 73%）。p折和loPo的结果显示NoRBERT在未见项目上的迁移能力强。与Kurtanovi´c和Maleej的方法相比，NoRBERT在处理未见项目上表现更好，平均F1得分高出15个百分点。
这表明NoRBERT具有良好的泛化能力，无需重新训练即可在实际项目中使用。我们认为，在评估需求分类方法时，应更重视其在未见项目上的表现。&lt;/p>
&lt;h3 id="36功能性需求的分类">3.6功能性需求的分类&lt;/h3>
&lt;p>NoRBERT在分类非功能性需求上表现出了良好的效果。现在研究它在分类功能性需求方面的表现。功能性需求通常根据它们所属的产品部分（例如用户界面或业务逻辑）来分类。有些模型则采用基于关注点的方法，包括功能性和行为性需求以及数据。如果我们想要开发能够自动理解功能性需求的系统，比如自动化追踪或建模系统，那么了解功能性需求的子类别就很重要，因为它们定义了需求可能的实现方式。
我们采用了Glinz提出的基于关注点的模型，它帮助我们理解功能性需求是描述系统的功能、系统展示的行为，还是仅仅是数据和数据结构。我们使用以下子类别：
功能：系统应执行的功能。 例子：系统应允许房地产经纪人查询MLS信息。
数据：应成为系统状态一部分的数据项或数据结构。 例子：审计报告应包括估计中使用的回收部件总数。
行为：系统展示的行为或由一个或多个刺激触发的反应。 例子：如果射门被标记为命中，产品应允许进攻球员定义射门。
需求可能包含多个关注点，这些类别可能会重叠，例如，“只有注册客户可以购买流媒体电影”。它既包含功能也包含行为。
为了回答RQ3，即迁移学习方法是否能够识别功能性需求中的关注点，由两位作者独立手动标记了PROMISE NFR数据集中的310个功能性需求。我们使用了Krippendorff的α（Kα）来衡量标注者间的一致性，发现功能和数据类别的一致性超过了0.8，而行为类别的一致性为0.752，虽然略低，但仍然是可接受的。
表VII: 功能性需求数据集概述
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-07-53_hu9531135204819338839.webp 400w,
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-07-53_hu11157470917726282824.webp 760w,
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-07-53_hu3186934934292638222.webp 1200w"
src="https://ysyyhhh.github.io/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-07-53_hu9531135204819338839.webp"
width="554"
height="127"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
表VII显示了项目中类别的分布。需求的数量少于每个项目中类别代表的数量，因为每个需求可能包含多个关注点。项目11到14包含的需求数量较少，因为它们主要由非功能性需求组成。
A. 在功能性需求数据集上评估NoRBERT
我们使用标记好的数据集来评估NoRBERT在分类功能性需求上的表现。我们训练了二元分类模型，并在10折交叉验证和loPo（低代表性项目）设置下进行了评估。
表 VIII：使用 NoRBERT 在新数据集上对功能性需求子类进行二元分类，采用 10 折交叉验证和 loPo 设置。粗体数值代表每个类别每个指标的最高分。b 和 l 分别代表基础模型和大型模型
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-08-03_hu14935307561922807446.webp 400w,
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-08-03_hu3109072013953705198.webp 760w,
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-08-03_hu3225054059776273243.webp 1200w"
src="https://ysyyhhh.github.io/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-08-03_hu14935307561922807446.webp"
width="554"
height="338"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
表VIII结果显示，NoRBERT在功能和行为类别上表现良好，但在数据类别上的召回率较低。这可以归因于这个类别缺乏训练数据和数据集的不平衡。我们发现欠采样和过采样对不同类别的影响不同。
在loPo设置中，NoRBERT的表现与10折交叉验证相似，功能类别的F1分数甚至略有提高，但数据类别的性能下降到了56%。尽管如此，与10折交叉验证相比，这个结果仍然是好的。我们还发现，在loPo设置中，大型模型在所有类别上的表现优于基础模型，这可能是因为loPo设置要求更好的泛化能力。
为了回答RQ3，我们可以得出结论，对于这些数据量，NoRBERT在处理功能性需求方面表现不错，尤其是在功能和行为类别上。虽然数据类别的表现有待提高，但通过更多的训练数据，NoRBERT的性能有望进一步提升。这可能有助于能够改进诸如追踪链接恢复或自动化建模等方法。&lt;/p></description></item><item><title>P0 [C++ Primer](https://15445.courses.cs.cmu.edu/fall2022/project0/)</title><link>https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/</link><pubDate>Fri, 01 Mar 2024 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/</guid><description>&lt;h1 id="l1-relational-model--relational-algebra">L1 Relational Model &amp;amp; Relational Algebra&lt;/h1>
&lt;h2 id="11-databases">1.1 Databases&lt;/h2>
&lt;p>数据库：an organized collection of inter-related data that models some aspect of the real-world&lt;/p>
&lt;p>数据库管理系统 DBMS：the software that manages a database&lt;/p>
&lt;h2 id="12-flat-file-strawman">1.2 Flat File Strawman&lt;/h2>
&lt;p>数据库常常以CSV(comma-separated value)文件的形式存储，由DBMS进行管理。每次应用程序要读取或者更新记录时，都必须解析文件(parse files)。&lt;/p>
&lt;h2 id="13-database-management-system">1.3 Database Management System&lt;/h2>
&lt;ul>
&lt;li>A general-purpose(通用) &lt;strong>DBMS&lt;/strong> is designed to allow the definition, creation, querying, update, and administration of databases in accordance with some &lt;strong>data model&lt;/strong>.&lt;/li>
&lt;li>A &lt;strong>data model&lt;/strong> is a collection of concepts for describing the data in database
&lt;ul>
&lt;li>Examples: &lt;strong>relational&lt;/strong> (most common), NoSQL (&lt;strong>key/value&lt;/strong>, graph), array/matrix/vectors&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>A &lt;strong>schema&lt;/strong>(模式) is a description of a particular collection of data based on a &lt;strong>data model&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>早期，数据库应用很难建立和维护，因为逻辑层和物理层之间存在着紧密的耦合。&lt;/p>
&lt;ul>
&lt;li>逻辑层： 描述了数据库有哪些实体和属性。&lt;/li>
&lt;li>物理层： 是这些实体和属性的存储方式。&lt;/li>
&lt;/ul>
&lt;p>所以早期的数据库，一旦改变了物理层，逻辑层也得跟着变。&lt;/p>
&lt;h2 id="14-relational-model">1.4 Relational Model&lt;/h2>
&lt;p>人们每次改变物理层都要重新写数据管理系统，故Ted Codd注意到后提出了关系模型。&lt;/p>
&lt;p>The relational model defines a database abstraction based on relations to avoid &lt;strong>maintenance overhead&lt;/strong>(维护开销).&lt;/p>
&lt;p>三要点:&lt;/p>
&lt;ul>
&lt;li>Store database in simple data structures (relations).&lt;/li>
&lt;li>Access data through high-level language, DBMS &lt;strong>figures out&lt;/strong>(找出) best execution strategy.&lt;/li>
&lt;li>Physical storage &lt;strong>left up to&lt;/strong>(取决于) the DBMS implementation.&lt;/li>
&lt;/ul>
&lt;p>三概念&lt;/p>
&lt;p>The relational data model defines three concepts:&lt;/p>
&lt;ul>
&lt;li>Structure: The definition of relations and their contents. This is the attributes the relations have and the values that those attributes can hold.&lt;/li>
&lt;li>&lt;strong>Integrity&lt;/strong>(完整性): Ensure the database’s contents satisfy constraints.
&lt;ul>
&lt;li>实体完整性 entity integrity:主属性不能为空&lt;/li>
&lt;li>参照完整性 referential integrity: 外键的值必须存在&lt;/li>
&lt;li>用户定义的完整性
&lt;ul>
&lt;li>An example constraint would be that any value for the year attribute has to be a number.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Manipulation: How to access and modify a database’s contents.&lt;/li>
&lt;/ul>
&lt;p>关系:&lt;/p>
&lt;p>&lt;strong>A relation&lt;/strong> is an &lt;strong>unordered&lt;/strong> set that contains the relationship of attributes that represent entities. So the DBMS can store them in any way it wants, allowing for &lt;strong>optimization&lt;/strong>(允许优化).&lt;/p>
&lt;p>元组:&lt;/p>
&lt;p>&lt;strong>A tuple&lt;/strong> is a set of &lt;strong>attribute values&lt;/strong> (also known as its &lt;strong>domain&lt;/strong> 域 一组相同数据类型的值的集合) in the relation. &lt;strong>Originally&lt;/strong>, values had to be atomic or scalar(标量), but &lt;strong>now&lt;/strong> values can also be lists or &lt;strong>nested&lt;/strong>(嵌套) data structures. Every attribute can be a special value, &lt;strong>NULL&lt;/strong>, which means for a given tuple the attribute is &lt;strong>undefined&lt;/strong>.&lt;/p>
&lt;p>关系:&lt;/p>
&lt;p>&lt;strong>A relation&lt;/strong> with n attributes is called &lt;strong>an n-ary relation&lt;/strong>.&lt;/p>
&lt;p>键&lt;/p>
&lt;p>&lt;strong>A relation’s primary key&lt;/strong> uniquely identifies a single tuple.&lt;/p>
&lt;ul>
&lt;li>Some DBMSs automatically create an internal primary key if you do not define one.&lt;/li>
&lt;li>A lot of DBMSs have support for autogenerated keys so an application does not have to &lt;strong>manually increment&lt;/strong>(手动增加) the keys, but a primary key is still required for some DBMSs.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>A foreign key&lt;/strong> specifies that an attribute from one relation has to map to a tuple in another relation.&lt;/p>
&lt;h2 id="15-data-manipulation-languages-dmls">1.5 Data Manipulation Languages (DMLs)&lt;/h2>
&lt;p>Methods to store and retrieve information from a database.&lt;/p>
&lt;p>There are two classes of languages for this:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Procedural&lt;/strong>(程序上的): The query &lt;strong>specifies the (high-level) strategy&lt;/strong> the DBMS should use to find &lt;strong>the desired result based on sets / bags.&lt;/strong> (relational &lt;strong>algebra&lt;/strong> 代数)&lt;/li>
&lt;li>Non-Procedural (&lt;strong>Declarative&lt;/strong> 声明): The query specifies only what data is wanted and not how to find it. (relational &lt;strong>calculus&lt;/strong> 微积分/关系演算)&lt;/li>
&lt;/ul>
&lt;p>一般现在都是用第二种的，我不管DBMS用什么&lt;strong>策略&lt;/strong>，我只需要你给我我想要的数据。&lt;/p>
&lt;h2 id="16-relational-algebra-关系代数">1.6 Relational Algebra 关系代数&lt;/h2>
&lt;p>&lt;strong>Relational Algebra&lt;/strong> is a set of fundamental operations to &lt;strong>retrieve&lt;/strong>(检索) and manipulate tuples in a relation.&lt;/p>
&lt;p>Each operator &lt;strong>takes in&lt;/strong>(需要) one or more relations as inputs, and outputs a new relation. To write queries we can “&lt;strong>chain&lt;/strong>(链)” these operators together to create more complex operations.&lt;/p>
&lt;p>5种基本&lt;strong>关系操作&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>选择,投影,并,差,笛卡儿积&lt;/li>
&lt;/ul>
&lt;p>传统&lt;strong>集合运算&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>二目运算: 并,差,交,笛卡尔积&lt;/li>
&lt;/ul>
&lt;p>专门的&lt;strong>关系运算&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>选择selection ,投影projection,连接 join,除 dividen&lt;/li>
&lt;/ul>
&lt;p>选择:在&lt;strong>关系R&lt;/strong>中,选择符合条件的&lt;strong>元组&lt;/strong>,是从行的角度进行运算.&lt;/p>
&lt;p>投影:在&lt;strong>关系R&lt;/strong>中,选择出&lt;strong>若干属性列&lt;/strong>组成新的关系,从列的角度&lt;/p>
&lt;p>连接:两个关系的&lt;strong>笛卡尔积&lt;/strong>中,选取属性中满足一定条件的元组&lt;/p>
&lt;ul>
&lt;li>自然连接 内连接: 不保留悬浮元组.&lt;/li>
&lt;li>外连接 outer join : 保留&lt;strong>悬浮元组&lt;/strong>(填NULL)的连接&lt;/li>
&lt;li>左连接 left outer join: 只保留&lt;strong>左边关系R&lt;/strong>中的悬浮空组.&lt;/li>
&lt;li>右连接 right outer join: 只保留&lt;strong>右边关系R&lt;/strong>中的悬浮空组.&lt;/li>
&lt;/ul>
&lt;p>除: R除以S得到T, 则T包含所有&lt;strong>在R而不在S&lt;/strong>的&lt;strong>属性及其值&lt;/strong>. 且T和S的所有组合都在R中.&lt;/p>
&lt;h1 id="l2-modern-sql">L2 Modern SQL&lt;/h1>
&lt;h2 id="21-relation-languages">2.1 Relation Languages&lt;/h2>
&lt;p>用户只需要使用声明性语言（即SQL）来指定他们想要的结果。DBMS 负责确定产生该答案的最有效计划。&lt;/p>
&lt;p>关系代数基于 sets (unordered, no duplicates)。 SQL基于 bags (unordered, allows duplicates)&lt;/p>
&lt;h2 id="22-sql-history">2.2 SQL History&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>SEQUEL Structured English Query Language&lt;/p>
&lt;p>SQL Structured Query Language&lt;/p>
&lt;/li>
&lt;li>
&lt;p>该语言由不同类别的命令组成：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>DML&lt;/strong> Data Manipulation Language &lt;code>SELECT, INSERT, UPDATE, DELETE&lt;/code>&lt;/li>
&lt;li>&lt;strong>DDL&lt;/strong> Data Definition Language Schema definitions for tables, indexes, views, and other objects.&lt;/li>
&lt;li>&lt;strong>DCL&lt;/strong> Data Control Language Security, access controls.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>SQL仍在不断发展的&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="23-join">2.3 Join&lt;/h2>
&lt;p>结合一个或多个表的列，产生一个新的表。用来表达涉及跨越多个表的数据的查询&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">CREATE TABLE student (
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> sid INT PRIMARY KEY,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> name VARCHAR(16),
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> login VARCHAR(32) UNIQUE,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> age SMALLINT,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> gpa FLOAT
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">CREATE TABLE course (
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> cid VARCHAR(32) PRIMARY KEY,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> name VARCHAR(32) NOT NULL
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">CREATE TABLE enrolled (
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> sid INT REFERENCES student (sid),
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> cid VARCHAR(32) REFERENCES course (cid),
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> grade CHAR(1)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">找出在15-721拿到A的学术
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">SELECT s.name
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">FROM enrolled AS e, student AS s
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">WHERE e.grade = &amp;#39;A&amp;#39; AND e.cid = &amp;#39;15-721&amp;#39;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">AND e.sid = s.sid;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="24-aggregates-聚合函数">2.4 Aggregates 聚合函数&lt;/h2>
&lt;p>聚合函数接受一组列表，然后产生一个单一的标量值作为其输出。基本上只能在SELECT输出列表中使用！&lt;/p>
&lt;p>函数：&lt;/p>
&lt;ul>
&lt;li>&lt;code>AVG&lt;/code>&lt;/li>
&lt;li>&lt;code>MIN&lt;/code>&lt;/li>
&lt;li>&lt;code>MAX&lt;/code>&lt;/li>
&lt;li>&lt;code>COUNT&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>当使用goup时,聚合函数输出为每个组的输出.&lt;/p>
&lt;p>having 在聚合计算的基础过滤输出结果.而不是where&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SELECT AVG(s.gpa) AS avg_gpa, e.cid
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">FROM enrolled AS e, student AS s
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">WHERE e.sid = s.sid
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">GROUP BY e.cid
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">HAVING avg_gpa &amp;gt; 3.9;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="25-sting-operation">2.5 Sting Operation&lt;/h2>
&lt;p>&lt;strong>SQL标准&lt;/strong>是&lt;strong>区分大小写&lt;/strong>的，而且只能是&lt;strong>单引号&lt;/strong>！有一些函数可以处理字符串，可以在查询的任何部分使用。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>Pattern Matching&lt;/strong>:&lt;/p>
&lt;p>Like 关键字&lt;/p>
&lt;ul>
&lt;li>&lt;code>%&lt;/code> : matches any substrings (including empty).&lt;/li>
&lt;li>&lt;code>_&lt;/code> : matches any one character&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>String Function:&lt;/strong> &lt;code>SUBSTRING(S, B, E)&lt;/code> &lt;code>UPPER(S)&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Concatenation&lt;/strong>(连接) : &lt;code>||&lt;/code> concatenate two or more strings together into a single string&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="26-date-and-time">2.6 Date and Time&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>时间函数&lt;/p>
&lt;ul>
&lt;li>当前日期时间 &lt;code>NOW()&lt;/code>, &lt;code>CURRENT_TIMESTAMP()&lt;/code>&lt;/li>
&lt;li>当前UNIX时间戳 &lt;code>UNIX_TIMESTAMP()&lt;/code>&lt;/li>
&lt;li>当前日期 &lt;code>CURRENT_DATE()&lt;/code>&lt;/li>
&lt;li>当前时间 &lt;code>CURRENT_TIME()&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>日期时间转换函数&lt;/p>
&lt;ul>
&lt;li>当前时间戳转换为北京时间 &lt;code>FROM_UNIXTIME()&lt;/code>&lt;/li>
&lt;li>北京时间转换为时间戳 &lt;code>UNIX_TIMESTAMP()&lt;/code>&lt;/li>
&lt;li>时间中解析年月日时间 &lt;code>DATE_FORMAT(date, format)&lt;/code>&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">select DATE_FORMAT(&amp;#39;2021-01-01 08:30:50&amp;#39;,&amp;#39;%Y-%m-%d&amp;#39;)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>日期时间运算函数&lt;/p>
&lt;ol>
&lt;li>
&lt;p>在某个时间的基础上加上或者减去某个时间 &lt;code>DATE_ADD(date,INTERVAL expr unit)&lt;/code> &lt;code>DATE_SUB(date,INTERVAL expr unit)&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>返回两个日期值之间的天数 &lt;code>DATEDIFF(expr1,expr2))&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">select DATEDIFF(&amp;#39;2021-01-02&amp;#39;,&amp;#39;2021-01-01&amp;#39;)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>时间差函数 &lt;code>TIMESTAMPDIFF(unit,datetime_expr1,datetime_expr2)&lt;/code>&lt;/p>
&lt;p>unit：天(DAY)、小时(HOUR），分钟(MINUTE)和秒(SECOND)，TIMESTAMPDIFF函数比DATEDIFF函数用起来更加灵活&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;h2 id="27-output-redirection">2.7 Output Redirection&lt;/h2>
&lt;p>你可以告诉DBMS将查询结果存储到另一个表中，而不是将查询结果返回给客户端（例如，终端）。结果存储到另一个表中。然后你可以在随后的查询中访问这些数据&lt;/p>
&lt;ul>
&lt;li>
&lt;p>New Table: 将查询的输出存储到一个新的（永久）表中。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SELECT DISTINCT cid INTO CourseIds FROM enrolled;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>Exustubg Table:&lt;/p>
&lt;p>将&lt;strong>查询的输出存储到数据库中已经存在的表&lt;/strong>中。该表 目标表必须有与目标表相同数量和相同类型的列，但输出查询中的列名不需要匹配。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">INSERT INTO CourseIds (SELECT DISTINCT cid FROM enrolled)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;h2 id="28-output-control">2.8 Output Control&lt;/h2>
&lt;p>可以用ORDER BY来对输出进行排序,后面可以加&lt;code>DESC&lt;/code>, &lt;code>ASC&lt;/code>来指定排序策略&lt;/p>
&lt;p>输出的数量可以用&lt;code>LIMIT n&lt;/code> 进行指定,当然也可以用&lt;code>OFFSET&lt;/code> 来提供一个bias。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">ELECT sid, grade FROM enrolled WHERE cid = &amp;#39;15-721&amp;#39;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ORDER BY grade;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">SELECT sid, name FROM student WHERE login LIKE &amp;#39;%@cs&amp;#39;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">LIMIT 20 OFFSET 10;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="29-nested-queries">2.9 Nested Queries&lt;/h2>
&lt;p>在其他查询中调用查询，在单个查询中执行更复杂的逻辑。嵌套查询往往难以优化。&lt;/p>
&lt;p>外部查询的范围包括在内部查询中（即&lt;strong>内部查询可以访问来自外部查询&lt;/strong>），反之不行。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>内部查询几乎可以出现在一个查询的任何部分。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;code>SELECT&lt;/code> Output Targets&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SELECT (SELECT 1) AS one FROM student;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;code>FROM&lt;/code> &lt;strong>Clause&lt;/strong>(条件):&lt;/p>
&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SELECT name
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> FROM student AS s, (SELECT sid FROM enrolled) AS e
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> WHERE s.sid = e.sid;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="3">
&lt;li>&lt;code>WHERE&lt;/code> Clause&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SELECT name FROM student
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> WHERE sid IN ( SELECT sid FROM enrolled );
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>例子： 获取在15-445中注册的学生名字&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SELECT name FROM student
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> WHERE sid IN (
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> SELECT sid FROM enrolled
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> WHERE cid = &amp;#39;15-445&amp;#39;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>请注意，根据它在查询中出现的位置，sid有不同的范围。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>例子： 找到注册了至少一门课的最大的学生id&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SELECT student.sid, name
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> FROM student
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> JOIN (SELECT MAX(sid) AS sid
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> FROM enrolled) AS max_e
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ON student.sid = max_e.sid;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;h3 id="nested-query-results-expressions">Nested Query Results Expressions:&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>关键字：&lt;/p>
&lt;ul>
&lt;li>&lt;code>ALL&lt;/code> Must satisfy expression for all rows in sub-query&lt;/li>
&lt;li>&lt;code>ANY&lt;/code> Must satisfy expression for at least one row in sub-query.&lt;/li>
&lt;li>&lt;code>IN&lt;/code> Equivalent to =ANY().&lt;/li>
&lt;li>&lt;code>EXISTS&lt;/code> At least one row is returned.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>例子： 找到所有没有学生注册的课&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SELECT * FROM course
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> WHERE NOT EXISTS(
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> SELECT * FROM enrolled
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> WHERE course.cid = enrolled.cid
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;h2 id="210-window-functions">2.10 Window Functions&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>函数： 窗口函数可以是我们上面讨论的任何一个聚合函数。也有一些特殊的窗口函数。&lt;/p>
&lt;ol>
&lt;li>&lt;code>ROW_NUMBER&lt;/code>: 当前列的数字&lt;/li>
&lt;li>&lt;code>RANK&lt;/code>: 当前列的顺序&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>Grouping: &lt;strong>OVER子句指定了在计算窗口函数时如何对图元进行分组&lt;/strong>。使用&lt;strong>PARTITION BY&lt;/strong>来指定分组&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SELECT cid, sid, ROW_NUMBER() OVER (PARTITION BY cid)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> FROM enrolled ORDER BY cid;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们也可以在OVER中放入ORDER BY，以确保结果的确定性排序，即使数据库内部发生变化。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SELECT *, ROW_NUMBER() OVER (ORDER BY cid)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> FROM enrolled ORDER BY cid;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;strong>重要提示：&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>DBMS在窗函数排序后计算&lt;code>RANK&lt;/code>，而在排序前计算&lt;code>ROW_NUMBER&lt;/code>。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>找到每门课程中成绩第二高的学生&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SELECT * FROM (
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> SELECT *, RANK() OVER (PARTITION BY cid
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ORDER BY grade ASC) AS rank
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> FROM enrolled) AS ranking
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">WHERE ranking.rank = 2;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="211-commom-table-expressions">2.11. Commom Table Expressions&lt;/h2>
&lt;p>在编写更复杂的查询时，通用表表达式（CTE）是窗口或嵌套查询的一种替代方法。复杂的查询时，可以替代窗口或嵌套查询。它们提供了一种方法来为用户在一个更大的查询中编写辅助语句.&lt;/p>
&lt;p>可以理解为一个辅助表。&lt;/p>
&lt;p>&lt;code>WITH&lt;/code>子句将内部查询的输出与一个具有该名称的临时结果绑定。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>例子： 生成一个名为cteName的CTE，其中包含一个单一属性设置为 &amp;ldquo;1 &amp;ldquo;的元组。从这个CTE中选择所有属性。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">WITH cteName AS (
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> SELECT 1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">SELECT * FROM cteName;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们可以在AS之前将输出列绑定到名称上&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">WITH cteName (col1, col2) AS (
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> SELECT 1, 2
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">SELECT col1 + col2 FROM cteName;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>一个查询可能包含多个CTE声明&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">WITH cte1 (col1) AS (SELECT 1), cte2 (col2) AS (SELECT 2)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">SELECT * FROM cte1, cte2;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>递归能力 在WITH后面&lt;strong>添加RECURSIVE关键字&lt;/strong>允许CTE引用自己。这使得在SQL查询中可以实现递归。有了递归的CTE，SQL被证明是图灵完备的，这意味着它在计算上的表现力不亚于更多的通用编程语言&lt;/p>
&lt;/li>
&lt;li>
&lt;p>例子：打印从1到10的数字&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">WITH RECURSIVE cteSource (counter) AS (
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ( SELECT 1 )
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> UNION
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ( SELECT counter + 1 FROM cteSource
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> WHERE counter &amp;lt; 10 )
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">SELECT * FROM cteSource;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;h1 id="homework-1---sql">Homework #1 - SQL&lt;/h1>
&lt;p>CASE 语句&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SELECT name,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> CASE
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> when died is not null
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> then died-born
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> else &amp;#39;2022&amp;#39; - born
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> END as age
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">FROM people
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">where born &amp;gt;= &amp;#39;1900&amp;#39;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ORDER by age DESC,name
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">LIMIT 20;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>CAST AS TEXT 转换成字符串，字符串连接用 ||&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">select
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">CAST(titles.premiered/10*10 AS TEXT) || &amp;#39;s&amp;#39; as decade,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">round(avg(rating),2) as avg,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">max(rating) as top,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">min(rating) as min,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">count(*) as NUM_RELEASES
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">from ratings
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">join titles on titles.title_id = ratings.title_id
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">where decade is not null
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">GROUP by decade
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">order by avg DESC,decade
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">limit 20;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>第一个with后，用,隔开&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">with person_title as (
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> select people.name,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> people.person_id,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> crew.title_id
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> from people
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> join crew on crew.person_id = people.person_id
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> join titles on titles.title_id = crew.title_id
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> where born = 1955 and titles.type = &amp;#34;movie&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">),
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">person_avg as (
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> select person_title.name,round(avg(rating),2) as avg
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> from RATINGS
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> join person_title on person_title.title_id = ratings.title_id
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> group by person_title.person_id
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">),
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">quantiles as (
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> select * ,NTILE(10) OVER (ORDER BY avg ASC) as QuantileRating from person_avg
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">select
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">name,avg
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">from quantiles
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">where QuantileRating = 9
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">order by avg DESC,name;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>把表格数据压缩成一行，用，隔开&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">with p as(
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> select akas.title as dubbed
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> from titles
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> join akas on akas.title_id = titles.title_id
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> where primary_title = &amp;#34;House of the Dragon&amp;#34; and type = &amp;#34;tvSeries&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> group by primary_title,dubbed
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> order by dubbed
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">select GROUP_CONCAT(dubbed,&amp;#39;, &amp;#39;) from p;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="l3--4database-storage">L3 -4Database Storage&lt;/h1>
&lt;h2 id="31-storage">3.1 Storage&lt;/h2>
&lt;p>The DBMS assumes that the primary storage location of the database is on non-volatile disk.&lt;/p>
&lt;p>The DBMS&amp;rsquo;s components manage the movement of data between non-volatile and volatile storage.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222153223421" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222153223421_hu7796160831772938740.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222153223421_hu12119969982241288312.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222153223421_hu4730550984946241252.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222153223421_hu7796160831772938740.webp"
width="760"
height="456"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>Volatile Devices:&lt;/p>
&lt;ul>
&lt;li>Volatile means that if you pull the power from the machine, then the data is lost.&lt;/li>
&lt;li>Volatile storage supports fast &lt;strong>random access&lt;/strong> with byte-addressable locations. This means that the program can jump to any byte address and get the data that is there.&lt;/li>
&lt;li>For our purposes, we will always refer to this storage class as “memory.”&lt;/li>
&lt;/ul>
&lt;p>Non-Volatile Devices:&lt;/p>
&lt;ul>
&lt;li>Non-volatile means that the storage device does not require continuous power in order for the device to retain the bits that it is storing.&lt;/li>
&lt;li>It is also block/page addressable. This means that &lt;strong>in order to read a value at a particular offset&lt;/strong>, the program &lt;strong>first has to load the 4 KB page into memory&lt;/strong> that holds the value the program wants to read.&lt;/li>
&lt;li>Non-volatile storage is &lt;strong>traditionally better at sequential access&lt;/strong> (reading multiple contiguous chunks of data at the same time).&lt;/li>
&lt;li>We will refer to this as “disk.” We will not make a (major) distinction between solid-state storage (SSD) and spinning hard drives (HDD).&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222153508116" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222153508116_hu8213255666573324971.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222153508116_hu6124948602391582207.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222153508116_hu9885358995143815418.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222153508116_hu8213255666573324971.webp"
width="746"
height="467"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h2 id="32-disk-oriented-dbms-overview">3.2 Disk-Oriented DBMS Overview&lt;/h2>
&lt;p>The database is &lt;strong>all on disk&lt;/strong>, and the data in database files is organized into pages, with the first page being the directory page.&lt;/p>
&lt;p>To operate on the data, the DBMS needs to bring the data into memory. It does this by &lt;strong>having a buffer pool&lt;/strong> that &lt;strong>manages the data movement back and forth&lt;/strong> between disk and memory&lt;/p>
&lt;p>The DBMS also has an &lt;strong>execution engine&lt;/strong> that will execute queries. The execution engine will &lt;strong>ask the buffer pool for a specific page&lt;/strong>, and the buffer pool will take care of bringing that page into memory and &lt;strong>giving the execution engine a pointer&lt;/strong> to that page in memory.&lt;/p>
&lt;p>The buffer pool manager will &lt;strong>ensure&lt;/strong> that &lt;strong>the page is there while the execution engine operates on that part of memory&lt;/strong>.&lt;/p>
&lt;h2 id="33-dbms-vs-os">3.3 DBMS vs OS&lt;/h2>
&lt;ul>
&lt;li>DBMS的一个&lt;strong>高级设计目标是支持超过可用内存量&lt;/strong>的数据库。因为访问disk的代价很大，所以使用disk应该要小心。我们不希望从磁盘上访问数据时停顿太久，从而拖慢其他一切。我们希望DBMS能够处理在等待从磁盘获取数据时，能够处理其他查询。&lt;/li>
&lt;li>这个高层次的设计目标就像虚拟内存一样，有一个大的地址空间和一个供操作系统从磁盘引入页面的地方。&lt;/li>
&lt;li>实现这种虚拟内存的方法之一是使用mmap来映射进程地址空间中的文件内容，这使得操作系统负责在磁盘和内存之间来回移动页面。 但不幸的是，如果&lt;strong>mmap遇到页面故障，进程将会被阻塞&lt;/strong>。
&lt;ul>
&lt;li>如果你需要写入，你永远不想在你的DBMS中使用mmap。&lt;/li>
&lt;li>DBMS（几乎）总是想自己控制事情，而且可以做得更好，因为它知道更多关于被访问的数据和被处理的查询。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>可以通过使用操作系统：
&lt;ul>
&lt;li>&lt;code>madvise&lt;/code>: 告诉操作系统你打算何时读某些页面。&lt;/li>
&lt;li>&lt;code>mlock&lt;/code>: 告诉操作系统不要把内存范围换到磁盘上。&lt;/li>
&lt;li>&lt;code>msync&lt;/code>: 告诉操作系统将内存范围刷新到磁盘。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>出于正确性和性能的考虑，我们不建议在DBMS中使用&lt;/strong>&lt;code>mmap&lt;/code>。&lt;/p>
&lt;h2 id="34-file-storage">3.4 File Storage&lt;/h2>
&lt;ul>
&lt;li>在其最基本的形式中，DBMS将&lt;strong>数据库存储为磁盘上的文件&lt;/strong>。有些可能使用文件层次结构，有些则可能使用单个文件&lt;/li>
&lt;li>操作系统对这些文件的内容一无所知。&lt;strong>只有DBMS知道如何解读它们的内容&lt;/strong>，因为它是以DBMS特有的方式编码的。&lt;/li>
&lt;li>DBMS的存储管理器负责管理数据库的文件。它将文件表示为一个 页的集合。它还跟踪哪些数据被读和写到了页面上，以及这些页面有多少可用空间。这些页面中还有多少可用空间。&lt;/li>
&lt;/ul>
&lt;h2 id="35-database-pages">3.5 Database Pages&lt;/h2>
&lt;ul>
&lt;li>DBMS将数据库组织在&lt;strong>一个或多个文件中的固定大小的数据块&lt;/strong>，称为页。页面可以包含不同种类的数据（tuple、indexes等）。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;ul>
&lt;li>大多数系统不会将这些类型混合在一页中。 有些系统会要求页面是自成一体（self-contained）的，也就是说，阅读每个页面所需的所有信息都在页面本身。读取每一页的所有信息都在页面本身&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;ul>
&lt;li>Each page is given a unique identifier.
&lt;ul>
&lt;li>The DBMS uses an indirection layer to map page IDs to physical locations.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>There are three different &lt;strong>notions&lt;/strong> of &amp;ldquo;pages&amp;rdquo; in a DBMS:&lt;/p>
&lt;ul>
&lt;li>Hardware Page (usually 4KB)&lt;/li>
&lt;li>OS Page (usually 4KB)&lt;/li>
&lt;li>Database Page (512B-16KB)&lt;/li>
&lt;/ul>
&lt;p>存储设备保证写的操作是atomic 原子的。 这意味着，如果我们的数据库页面比我们的硬件页面大，DBMS将不得不采取额外的措施 以确保数据被安全地写出来。 因为当系统崩溃时，程序可能已经完成了将数据库页面写入磁盘的一部分&lt;/p>
&lt;p>Different DBMSs manage pages in files on disk in different ways.&lt;/p>
&lt;ul>
&lt;li>Heap File Organization&lt;/li>
&lt;li>Tree File Organization&lt;/li>
&lt;li>Sequential / Sorted File Organization (ISAM)&lt;/li>
&lt;li>Hashing File Organization&lt;/li>
&lt;/ul>
&lt;p>At this point in the &lt;strong>hierarchy&lt;/strong>(层次结构) we don&amp;rsquo;t need to know anything about what is inside of the pages.&lt;/p>
&lt;h2 id="36-database-heap">3.6 Database Heap&lt;/h2>
&lt;p>A &lt;strong>heap file&lt;/strong> is an &lt;strong>unordered&lt;/strong> collection of pages with tuples that are stored in random order.&lt;/p>
&lt;ul>
&lt;li>Create / Get / Write / Delete Page&lt;/li>
&lt;li>Must also support iterating over all pages.&lt;/li>
&lt;/ul>
&lt;p>DBMS可以通过使用页面的链接列表或页面目录在磁盘上找到一个给定的页面ID&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Linked List: Header page持有指向自由页列表和数据页列表的指针。然而，如果 DBMS正在寻找一个特定的页面，它必须在数据页列表上进行顺序扫描，直到它找到它要找的页面。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Page Directory:&lt;/p>
&lt;p>DBMS维护特殊的页面，跟踪数据页的位置以及每页的可用空间。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222155657027" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222155657027_hu2100378089148575349.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222155657027_hu15547366876650536019.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222155657027_hu5279068955605927013.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222155657027_hu2100378089148575349.webp"
width="760"
height="413"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222155526907" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222155526907_hu13976113084470132401.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222155526907_hu5959215358647435408.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222155526907_hu14178474351924939837.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222155526907_hu13976113084470132401.webp"
width="760"
height="214"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>Need &lt;strong>meta-data&lt;/strong> to keep track of what pages exist in multiple files and which ones have free space.&lt;/p>
&lt;h2 id="37-page-layout">3.7 Page Layout&lt;/h2>
&lt;ul>
&lt;li>每个页面都包括一个header，记录关于页面内容的元数据。
&lt;ul>
&lt;li>Page size&lt;/li>
&lt;li>Checksum&lt;/li>
&lt;li>DBMS version&lt;/li>
&lt;li>Transaction visibility&lt;/li>
&lt;li>Self-containment(自成一体) (Some systems like Oracle require this.)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>For any page storage architecture, we now need to decide &lt;strong>how to organize the data inside of the page.&lt;/strong>&lt;/p>
&lt;p>We are still assuming that we are only storing &lt;strong>tuples&lt;/strong>.&lt;/p>
&lt;p>Two approaches:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Tuple&lt;/strong>-oriented (其实是 &lt;strong>slotted-page&lt;/strong>)
&lt;ul>
&lt;li>页面将slots映射到offsets,slot array 记录对应tuple的便宜量&lt;/li>
&lt;li>Header keeps track of the number of used slots, the offset of the starting location of the last used slot, and a slot array, which keeps track of the location of the start of each tuple.&lt;/li>
&lt;li>To add a tuple, the slot array will grow from the beginning to the end, and the data of the tuples will grow from end to the beginning. The page is considered full when the slot array and the tuple data meet&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Log-structured&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222161048229" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161048229_hu17813580081936859766.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161048229_hu1924567312344690667.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161048229_hu10686169228529227031.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161048229_hu17813580081936859766.webp"
width="760"
height="412"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h2 id="38-tuple-layout">3.8 Tuple Layout&lt;/h2>
&lt;p>tuple 内部的结构&lt;/p>
&lt;p>tuples本质上是一个字节序列。DBMS的工作是将这些字节解释为属性类型和值。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Tuple Header：包含了tuple的元数据&lt;/p>
&lt;ul>
&lt;li>DBMS的并发控制协议的可见性信息。关于哪个事务创建/修改了该元组&lt;/li>
&lt;li>NULL值的位图。&lt;/li>
&lt;li>注意，DBMS不需要在这里存储关于数据库模式的元数据。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Tuple Data：数据的实际属性&lt;/p>
&lt;ul>
&lt;li>属性通常按照你创建表时指定的顺序存储&lt;/li>
&lt;li>大多数DBMS不允许一个tuple超过一个页面的大小。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Unique Identifier&lt;/p>
&lt;ul>
&lt;li>数据库中的每个tuple都被分配一个唯一的标识符&lt;/li>
&lt;li>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222161450033" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161450033_hu12174111953764980865.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161450033_hu3513142025496111924.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161450033_hu14347201732218711664.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161450033_hu12174111953764980865.webp"
width="315"
height="415"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/li>
&lt;li>一般是：&lt;code>page_id + (offset or slow)&lt;/code>&lt;/li>
&lt;li>一个应用程序&lt;strong>不能&lt;/strong>依赖这些ID来表示任何东西&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>De-normalized Tuple Data:&lt;/p>
&lt;p>如果两个表是相关的，DBMS可以 &amp;ldquo;pre-join&amp;quot;它们，所以这些表最终会出现在 在同一个页面上。这使得读取速度加快，因为DBMS只需要加载一个页面而不是两个 独立的页面。然而，这使得更新更加昂贵，因为DBMS需要更多的空间给每个 tuples&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222161346650" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161346650_hu13250669340730992244.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161346650_hu7912738979499212015.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161346650_hu5991981445811217559.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161346650_hu13250669340730992244.webp"
width="760"
height="401"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="39-log-structured-storage">3.9 Log-Structured Storage&lt;/h2>
&lt;p>（也叫Append-only Sequence of Data） 参考: &lt;a href="https://www.cnblogs.com/muzhongjiang/p/15151758.html" target="_blank" rel="noopener">Log-Structured 结构&lt;/a>&lt;/p>
&lt;ul>
&lt;li>与Slotted-Page Design有关的问题是：
&lt;ul>
&lt;li>
&lt;p>Fragmentation: 删除tuple会在page中留下空隙。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Useless Disk I/O:&lt;/p>
&lt;p>由于非易失性存储的block-oriented的性质，需要读取整个块来获取tuple。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Random Disk I/O: 磁盘阅读器可能不得不跳到20个不同的地方来更新20个不同的tuples，这可能会非常慢。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>如果我们在一个&lt;strong>只允许创建新数据而不允许覆盖&lt;/strong>的系统上工作呢？日志结构的存储模型与这个假设相配合，解决了上面列出的一些问题。&lt;/p>
&lt;p>&lt;strong>Log-Structured Storage:&lt;/strong> DBMS不存储tuples，&lt;strong>只存储日志记录&lt;/strong>。&lt;/p>
&lt;ul>
&lt;li>将数据库如何被修改的记录存储到文件中（放入和删除）。每条日志包含tuples的唯一标识符&lt;/li>
&lt;li>要读取一条记录，DBMS会&lt;strong>从最新的到最旧的逆向扫描日志文件&lt;/strong>，并 &amp;ldquo;重新创建 &amp;ldquo;这个 tuple。&lt;/li>
&lt;li>写的快，读的可能慢。磁盘写入是连续的，现有的页面是不可改变的，这导致了随机磁盘I/O的减少。&lt;/li>
&lt;li>在append-only的存储上工作得很好，因为DBMS不能回溯并更新数据。&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222161821846" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161821846_hu6908139419814865804.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161821846_hu14811478523624699609.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161821846_hu12554548136374072494.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161821846_hu6908139419814865804.webp"
width="424"
height="434"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>The log will grow forever. The DBMS needs to periodically &lt;strong>compact&lt;/strong>(紧凑) pages to reduce wasted space.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222161836461" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161836461_hu17517943357915247461.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161836461_hu17257019485682480963.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161836461_hu11770330454468125879.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161836461_hu17517943357915247461.webp"
width="760"
height="276"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;ul>
&lt;li>由于不再需要时间信息，数据库可以&lt;strong>将日志压缩到一个按id排序的表&lt;/strong>中。这些被称为分类字符串表（SSTables），它们可以使tuple搜索非常快。&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222161958064" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161958064_hu18238635243006012298.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161958064_hu11481561422820459006.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161958064_hu2276643878385091739.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161958064_hu18238635243006012298.webp"
width="350"
height="325"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;ul>
&lt;li>紧凑化的问题是，DBMS最终会出现写入放大的情况。(&lt;strong>它一次又一次地重写相同的数据&lt;/strong>）。&lt;/li>
&lt;/ul>
&lt;p>Compaction coalesces larger log files into smaller files by removing unnecessary records.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222162056924" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222162056924_hu16013414438712494549.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222162056924_hu9535685654041197718.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222162056924_hu16445243547172337404.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222162056924_hu16013414438712494549.webp"
width="760"
height="234"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>Log-structured storage managers are more common today. This is partly due to the &lt;strong>proliferation&lt;/strong>(扩散) of RocksDB.&lt;/p>
&lt;h2 id="311-data-representation">3.11 Data Representation&lt;/h2>
&lt;p>A tuple is essentially a sequence of bytes.&lt;/p>
&lt;p>It&amp;rsquo;s the job of the DBMS to &lt;strong>interpret&lt;/strong> those bytes into attribute types and values.&lt;/p>
&lt;p>The DBMS&amp;rsquo;s &lt;strong>catalogs&lt;/strong>(目录) contain the schema information about tables(数据表示方案) that the system uses to figure out the tuple&amp;rsquo;s layout.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222162403262" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222162403262_hu12883989238030187807.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222162403262_hu3468431937809031378.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222162403262_hu2839969061708957533.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222162403262_hu12883989238030187807.webp"
width="640"
height="327"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;ul>
&lt;li>&lt;strong>INTEGER, BIGINT, SMALLINT, TINYINT.&lt;/strong> (Integers)大多数DBMS使用IEEE-754标准规定的 &amp;ldquo;native &amp;ldquo;C/C++类型来存储整数。这些值是&lt;strong>固定长度&lt;/strong>的。&lt;/li>
&lt;li>&lt;strong>FLOAT, REAL&lt;/strong> (Variable Precision Numbers) 这些是不精确的、可变精度的数字类型, &amp;ldquo;native &amp;ldquo;C/C++类型,这些值也是&lt;strong>固定长度&lt;/strong>的。
&lt;ul>
&lt;li>&lt;strong>变精度数的运算比任意精度数的运算更快&lt;/strong>，因为CPU可以直接对其执行指令。然而，在进行计算时&lt;strong>可能会出现精度损失&lt;/strong>！&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>NUMERIC, DECIMAL.&lt;/strong>(Fixed-Point Precision Numbers) 通常&lt;strong>以精确的、可变长度&lt;/strong>的二进制表示法（像一个字符串）来存储.带有&lt;strong>额外的元数据&lt;/strong>，这些数据将告诉系统诸如&lt;strong>数据的长度和小数点应该在哪里&lt;/strong>。&lt;/li>
&lt;li>当误差不可接受的时候，DBMS就要付出性能的代价来提高精度。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>VARCHAR, VARBINARY, TEXT, BLOB&lt;/strong> Variable-Length Data&lt;/p>
&lt;ul>
&lt;li>代表任意长度的数据类型。它们通常是用一个header来存储的，这个header可以追踪到字符串的长度，以便于跳转到下一个值。它还可能包含一个数据的校验和。&lt;/li>
&lt;li>&lt;strong>大多数DBMS不允许一个tuple超过一个页面的大小。&lt;/strong> &lt;strong>但是！那些允许的系统将数据存储在一个特殊的 &amp;ldquo;溢出 &amp;ldquo;页&lt;/strong>上，并让tuple包含一个对该页的引用。这些溢出页可以包含指向其他溢出页的指针，直到所有的数据都可以被存储。(类似分级页表)&lt;/li>
&lt;li>有些系统会让你把这些大的数值存储在一个外部文件中，然后元组会包含一个指向该文件的指针。例如，如果数据库存储的是照片信息，DBMS可以将照片存储在外部文件中，而不是让它们占用DBMS中的大量空间。这样做的一个缺点是，DBMS&lt;strong>不能操作这个文件的内容&lt;/strong>。因此，No durability protections. No transaction protections.没有耐久性或交易保护。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>TIME, DATE, TIMESTAMP.&lt;/strong> Dates and Times 不同的系统对日期/时间的表示方法不同。通常情况下，它们被表示为一些单位时间 (自unix时代的（微/毫）秒）。&lt;/p>
&lt;p>&lt;strong>System Catalogs&lt;/strong>&lt;/p>
&lt;p>为了使DBMS能够识别tuple的内容，它维护了 INFORMATION_SCHEMA&lt;strong>内部目录&lt;/strong>来告诉它关于数据库的元数据。&lt;strong>元数据将包含关于数据库有哪些表和列的信息&lt;/strong>，以及它们的类型和值的顺序。&lt;/p>
&lt;p>大多数DBMS将其目录以其表的格式存储在自己的内部。他们使用 特殊代码来 &amp;ldquo;bootstrap &amp;ldquo;这些目录表。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222163207453" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222163207453_hu4925395296936929032.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222163207453_hu18174806379179899083.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222163207453_hu6746432552511524901.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222163207453_hu4925395296936929032.webp"
width="651"
height="380"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222163222109" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222163222109_hu5247727719473036458.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222163222109_hu8496664307613451001.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222163222109_hu5073900410869059073.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222163222109_hu5247727719473036458.webp"
width="661"
height="367"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h1 id="l5-storage-models--compression">L5 Storage Models &amp;amp; Compression&lt;/h1>
&lt;h2 id="51-database-workloads">5.1 Database Workloads&lt;/h2>
&lt;p>OLTP: Online Transaction Processing&lt;/p>
&lt;ul>
&lt;li>
&lt;p>An OLTP workload is characterized by &lt;strong>fast, short running operations&lt;/strong>, simple queries that &lt;strong>operate on single entity at a time&lt;/strong>, and &lt;strong>repetitive operations&lt;/strong>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>An OLTP workload will typically handle &lt;strong>more writes than reads&lt;/strong>.&lt;/p>
&lt;blockquote>
&lt;p>An example of an OLTP workload is the Amazon storefront. Users can add things to their cart, they can make purchases, but the actions only affect their account.&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ul>
&lt;p>OLAP: Online Analytical Processing&lt;/p>
&lt;ul>
&lt;li>
&lt;p>An OLAP workload is characterized by &lt;strong>long running(长期运行), complex queries, reads on large portions&lt;/strong> of the database.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>In OLAP workloads, the database system is analyzing and &lt;strong>deriving&lt;/strong>(推导/添加) new data from existing data collected on the OLTP side.&lt;/p>
&lt;blockquote>
&lt;p>An example of an OLAP workload would be Amazon computing the most bought item in Pittsburgh on a day when its raining.&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ul>
&lt;p>HTAP: Hybrid Transaction + Analytical Processing&lt;/p>
&lt;p>A new type of workload which has become popular recently is HTAP, which is like &lt;strong>a combination which tries to do OLTP and OLAP together&lt;/strong> on the same database.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222165717923" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222165717923_hu214267011208431776.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222165717923_hu14741765878103601401.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222165717923_hu6163085838063827820.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222165717923_hu214267011208431776.webp"
width="760"
height="421"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h2 id="52-storage-models">5.2 Storage Models&lt;/h2>
&lt;h3 id="n-ary-storage-model-nsm">N-Ary Storage Model (NSM)&lt;/h3>
&lt;p>In the n-ary storage model, the DBMS &lt;strong>stores all of the attributes for a single tuple contiguously in a single page&lt;/strong>&lt;/p>
&lt;p>This approach is &lt;strong>ideal for OLTP workloads&lt;/strong> where requests are insert-heavy and transactions tend to operate only an individual entity.&lt;/p>
&lt;p>It is ideal because it takes only one fetch to be able to get all of the attributes for a single tuple.&lt;/p>
&lt;p>Advantages:&lt;/p>
&lt;ul>
&lt;li>Fast inserts, updates, and deletes.&lt;/li>
&lt;li>Good for queries that need the entire tuple.&lt;/li>
&lt;/ul>
&lt;p>Disadvantages:&lt;/p>
&lt;ul>
&lt;li>Not good for &lt;strong>scanning large portions of the table&lt;/strong> and/or &lt;strong>a subset of the attributes.&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222164813494" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222164813494_hu4946890907421464029.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222164813494_hu748762322020453191.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222164813494_hu8183508440167824871.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222164813494_hu4946890907421464029.webp"
width="684"
height="464"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="decomposition-分解-storage-model-dsm">Decomposition 分解 Storage Model (DSM)&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222165051507" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222165051507_hu562669349804584714.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222165051507_hu17654209978579804137.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222165051507_hu16102917543435418739.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222165051507_hu562669349804584714.webp"
width="712"
height="388"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>This model is &lt;strong>ideal for OLAP&lt;/strong> workloads with many read-only queries that perform large scans over a subset of the table’s attributes.&lt;/p>
&lt;p>Advantages:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Reduces the amount of I/O wasted&lt;/strong> because the DBMS only reads the data that it needs for that query.&lt;/li>
&lt;li>Better query processing and data compression&lt;/li>
&lt;/ul>
&lt;p>Disadvantages:&lt;/p>
&lt;ul>
&lt;li>Slow for point queries, inserts, updates, and deletes because of tuple splitting/&lt;strong>stitching&lt;/strong>(缝合).&lt;/li>
&lt;/ul>
&lt;p>To &lt;strong>put the tuples back together&lt;/strong> when using a column store,there are two common approaches:&lt;/p>
&lt;p>fixed-length offsets(most common): Each value is the same length for an attribute&lt;/p>
&lt;p>Embedded Tuple Ids:Each value is stored with its tuple id in a column&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222165430923" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222165430923_hu710592552950232333.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222165430923_hu813336452705648623.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222165430923_hu13342472785444406665.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222165430923_hu710592552950232333.webp"
width="760"
height="377"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h2 id="53-database-compression">5.3 Database Compression&lt;/h2>
&lt;blockquote>
&lt;ul>
&lt;li>
&lt;p>压缩操作被在&lt;strong>disk-based&lt;/strong> DBMSs广泛应用。因为disk的I/O总是瓶颈，所以压缩可以让系统提升性能，尤其是只读analyt Managical workloads上。&lt;/p>
&lt;p>如果事先对tuples进行了压缩，DBMS可以获取更多有用的tuple，但代价是要付出更大的压缩和解压的计算开销。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>内存中的DBMS更加复杂，因为它们不必从磁盘中获取数据来执行一个查询。 内存比磁盘快得多，但压缩数据库可以减少DRAM需求和处理。&lt;/p>
&lt;p>而且必须在速度和压缩率中取得一个平衡。压缩数据库可以减少DRAM的需求和查询执行过程中的CPU成本。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果数据集是完全随机的bits，那么我们没有办法进行压缩。然而，现实世界中的数据集有一些key properties 是可以进行压缩的。&lt;/p>
&lt;ul>
&lt;li>数据集往往具有高度倾斜的属性值分布（例如，Brown语料库的Zipfian分布）。&lt;/li>
&lt;li>数据集往往在同一元组的属性之间有很高的相关性（例如，邮政编码到城市。订单日期与发货日期）。 Manag&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Given this, we want a database compression scheme to have the following properties:&lt;/p>
&lt;ul>
&lt;li>Must produce &lt;strong>fixed-length values&lt;/strong>. The only exception is var-length data stored in separate pools. This because the DBMS should follow word-&lt;strong>alignment&lt;/strong>(对齐) and be able to access data using offsets.&lt;/li>
&lt;li>Allow the DBMS to &lt;strong>postpone&lt;/strong>(推迟) decompression as long as possible during query execution (late materialization).&lt;/li>
&lt;li>Must be &lt;strong>a lossless scheme&lt;/strong> because people do not like losing data. Any kind of lossy compression has to be performed at the application level.&lt;/li>
&lt;/ul>
&lt;h3 id="compression-granularity">Compression Granularity&lt;/h3>
&lt;p>在给DBMS增加压缩功能之前，我们需要决定我们要压缩什么样的数据。这个决定决定了压缩方案的可用性。有四个级别的压缩 Manag颗粒度（granularity）&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Block Level: 压缩同一张表的tuple块。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Tuple Level: 压缩整个tuples的内容（仅NSM）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Attribute Level: 在一个tuple内压缩单个属性值。可以针对同一tuple的多个属性。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Columnar Level:&lt;/p>
&lt;p>为多个tuple存储的一个或多个属性压缩多个值 (只限于DSM)。这允许更复杂的压缩方案。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="54-naive-compression">5.4 Naive Compression&lt;/h2>
&lt;p>DBMS使用一个&lt;strong>通用的算法&lt;/strong>对数据进行压缩 (e.g., gzip, LZO, LZ4, Snappy, Brotli, Oracle OZIP, Zstd)。 尽管DBMS可以使用几种压缩算法，但工程师们往往选择那些经常提供较低压缩率以换取更快的压缩/解压的算法。&lt;/p>
&lt;p>naive compression例子： &lt;strong>MySQL InnoDB&lt;/strong>&lt;/p>
&lt;p>DBMS对磁盘页面进行压缩，将其压缩到2KB的幂数，并将其存储到缓冲池中。然而，每次DBMS试图读取数据时，缓冲池中的压缩数据必须被解压&lt;/p>
&lt;p>缺点:&lt;/p>
&lt;ul>
&lt;li>由于访问数据&lt;strong>需要对压缩的数据进行解压&lt;/strong>，这就限制了压缩方案的范围。 如果目标是将整个表压缩成一个巨大的块，使用naive compression 方案是不可能的，因为每次访问都需要对整个表进行压缩/解压缩。 因此，对于MySQL来说，由于压缩范围有限，它将表分解成更小的块状。&lt;/li>
&lt;li>naive方案也没有考虑到数据的高级含义或语义。 该算法既不考虑数据的结构，也不考虑查询打算如何访问 数据。因此，这就&lt;strong>失去了利用late materialization 的机会&lt;/strong>，因为DBMS不能知道它何时能够延迟数据的解压。&lt;/li>
&lt;/ul>
&lt;h2 id="55-columnar-compression-柱状压缩">5.5 Columnar Compression 柱状压缩**&lt;/h2>
&lt;h3 id="run-length-encoding">Run-length Encoding&lt;/h3>
&lt;p>Compress runs of the same value in a single column into triplets:&lt;/p>
&lt;ul>
&lt;li>The value of the attribute.&lt;/li>
&lt;li>The start position in the column segment.&lt;/li>
&lt;li>The # of elements in the run.&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222170534215" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222170534215_hu885230326921509639.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222170534215_hu3838772157738957714.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222170534215_hu12434180610796006129.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222170534215_hu885230326921509639.webp"
width="727"
height="383"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>Requires the columns to be sorted &lt;strong>intelligently&lt;/strong>(智能) to maximize compression opportunities.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222170706032" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222170706032_hu194162435533306192.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222170706032_hu7873244923486880044.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222170706032_hu6361187643502549011.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222170706032_hu194162435533306192.webp"
width="693"
height="406"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="bit-packing-encoding">Bit-Packing Encoding&lt;/h3>
&lt;p>When values for an attribute are &lt;strong>always less than the value&amp;rsquo;s declared largest size,&lt;/strong> &lt;strong>store them as smaller data type&lt;/strong>.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222170800172" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222170800172_hu3369281651380434001.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222170800172_hu14801751240192211110.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222170800172_hu11935344353674173066.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222170800172_hu3369281651380434001.webp"
width="760"
height="189"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>Bit-packing variant that uses a &lt;strong>special marker&lt;/strong> to indicate when a value exceeds largest size and then maintain a look-up table to store them.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222170818530" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222170818530_hu17644046622595400355.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222170818530_hu12745241936590863934.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222170818530_hu13568397779365042069.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222170818530_hu17644046622595400355.webp"
width="760"
height="187"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="bitmap-encoding">Bitmap Encoding&lt;/h3>
&lt;p>Store a separate bitmap for each unique value for an attribute where &lt;strong>an offset in the vector corresponds to a tuple.&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>The i th position in the Bitmap corresponds to the i th tuple in the table.&lt;/li>
&lt;li>Typically segmented into chunks to avoid allocating large blocks of contiguous memory. Only practical &lt;strong>if the value cardinality(基数) is low&lt;/strong>. Some DBMSs provide bitmap indexes.&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222171138540" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222171138540_hu3173024202711957471.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222171138540_hu14692853137584565305.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222171138540_hu4161045813615539929.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222171138540_hu3173024202711957471.webp"
width="760"
height="387"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="delta-encoding">Delta Encoding&lt;/h3>
&lt;p>&lt;strong>Recording the difference&lt;/strong> between values that follow each other in the same column.&lt;/p>
&lt;ul>
&lt;li>Store base value in-line or in a separate look-up table.&lt;/li>
&lt;li>&lt;strong>Combine with RLE to get even better compression ratios.&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222171254392" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222171254392_hu17533952213451925143.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222171254392_hu760582327132894795.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222171254392_hu8514774630085554203.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222171254392_hu17533952213451925143.webp"
width="760"
height="230"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="incremental-encoding">Incremental Encoding&lt;/h3>
&lt;p>Type of delta encoding that &lt;strong>avoids duplicating common prefixes/suffixes between consecutive tuples&lt;/strong>. This works best with sorted data.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222171338403" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222171338403_hu6455346457334116310.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222171338403_hu313408883584357097.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222171338403_hu15941526084400006217.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222171338403_hu6455346457334116310.webp"
width="760"
height="212"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="dictionary-encoding">Dictionary Encoding&lt;/h3>
&lt;p>Build a data structure that &lt;strong>maps variable-length values to a smaller integer identifier.&lt;/strong>&lt;/p>
&lt;p>Replace those values with their corresponding identifier in the dictionary data structure.&lt;/p>
&lt;ul>
&lt;li>Need to support fast encoding and decoding.
&lt;ul>
&lt;li>Encode/Locate: For a given uncompressed value, convert it into its compressed form.&lt;/li>
&lt;li>Decode/Extract: For a given compressed value, convert it back into its original form.&lt;/li>
&lt;li>No magic hash function will do this for us.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Need to also support range queries.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Most widely used compression scheme in DBMSs.&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222171632448" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222171632448_hu14953310478364488675.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222171632448_hu9568464044745016902.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222171632448_hu17375237848614195536.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222171632448_hu14953310478364488675.webp"
width="760"
height="357"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h1 id="homework-2-storage--indexeshttps15445coursescscmuedufall2022fileshw2-cleanpdf">Homework #2 &lt;a href="https://15445.courses.cs.cmu.edu/fall2022/files/hw2-clean.pdf" target="_blank" rel="noopener">Storage &amp;amp; Indexes&lt;/a>&lt;/h1>
&lt;h2 id="question-1-storage-models">Question 1: Storage Models&lt;/h2>
&lt;p>a database with a single table &lt;strong>R(q_id,txns,total,failed)&lt;/strong>, where q_id is the &lt;strong>primary key&lt;/strong>, and &lt;strong>all attributes are the same fixed width.&lt;/strong>&lt;/p>
&lt;p>Suppose R has 20,000 tuples that fit into 100 pages, &lt;strong>Ignore any additional storage&lt;/strong> overhead for the table (e.g., page headers, tuple headers).&lt;/p>
&lt;p>Assumptions:&lt;/p>
&lt;ul>
&lt;li>The DBMS does &lt;strong>not have any additional meta-data&lt;/strong> (e.g., sort order, zone maps).&lt;/li>
&lt;li>R does &lt;strong>not have any indexes&lt;/strong> (including for primary key q_id)&lt;/li>
&lt;li>&lt;strong>None&lt;/strong> of R’s pages are already &lt;strong>in the buffer pool&lt;/strong>.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SELECT total - failed FROM R
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">WHERE q id = 96 AND txns &amp;gt; 420;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="a-suppose-the-dbms-uses-the-decomposition-storage-model-dsm-with-implicit-offsets">(a) Suppose the DBMS uses the decomposition storage model (DSM) with implicit offsets&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>i What is the &lt;strong>minimum number of pages&lt;/strong> that the DBMS will potentially have to read from disk to answer this query?&lt;/p>
&lt;p>题意是存在这样一条记录,找到该条记录最少的磁盘读次数.&lt;/p>
&lt;p>官方解答是: 4 pages. 1 to find the primary key, + 3 to access txns, total, failed at their corresponding offsets.&lt;/p>
&lt;p>因为使用分解存储模式DSM, 按列存储.&lt;/p>
&lt;p>因此找到主键后就可以通过偏移量找其他属性的值. 读盘次数的限制在找主键上.&lt;/p>
&lt;p>显然,找主键至少需要一次读盘.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ii What is the &lt;strong>maximum number of pages&lt;/strong> that the DBMS will potentially have to read from disk to answer this query?&lt;/p>
&lt;p>官方解答: 28 pages. &lt;strong>There are 25 pages per attribute.&lt;/strong> In the worst case, we scan through all 25 pages to find the primary key, and then + 3 to access txns, total, failed at their corresponding offsets.&lt;/p>
&lt;p>上题可知,找主键次数决定了读盘次数.&lt;/p>
&lt;p>也就是当q_id = 96的记录越靠后, 找主键次数越多.&lt;/p>
&lt;p>因为没有顺序,所以96是无用的信息.&lt;/p>
&lt;p>同时因为&lt;strong>有四个属性,且所有属性大小固定&lt;/strong>. 所以当每个属性都占25页时,且q_id=26所在的记录是最后一个(25),找主键次数最大为25次.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="bsuppose-the-dbms-uses-the-n-ary-storage-model-nsm">(b)Suppose the DBMS uses the N-ary storage model (NSM)&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>i. What is the minimum number of pages that the DBMS will potentially have to read from disk to answer this query?&lt;/p>
&lt;p>Solution: We find the tuple with the matching primary key on the first page. No need to look in other pages since all attributes are stored together.&lt;/p>
&lt;p>在第一页&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ii. [4 points] What is the maximum number of pages that the DBMS will potentially have to read from disk to answer this query?&lt;/p>
&lt;p>在最后一页 100&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="question-2-cuckoo-hashing">Question 2: Cuckoo Hashing&lt;/h2>
&lt;p>几道哈希表计算的题目,较简单&lt;/p>
&lt;p>2进制：0b，8进制：0o，10进制：无前缀，16进制：0x&lt;/p>
&lt;h2 id="question-3-extendible-hashing">Question 3: Extendible Hashing&lt;/h2>
&lt;p>Consider an extendible hashing structure such that:&lt;/p>
&lt;ul>
&lt;li>Each bucket can hold up to two records.&lt;/li>
&lt;li>The hashing function uses the lowest g bits, where g is the global depth.&lt;/li>
&lt;/ul>
&lt;p>题目是一个二进制可扩展哈希. 哈希函数是二进制最低g位.&lt;/p>
&lt;p>每个哈希值对应一个桶, 每个桶最多两个, 所有刚好就是二进制.&lt;/p>
&lt;h3 id="a-starting-from-an-empty-table-insert-keys-15-14-23-11-9">(a) Starting from an empty table, insert keys 15, 14, 23, 11, 9.&lt;/h3>
&lt;p>二进制表示&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">15: 00001111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">14: 00001110
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">23: 00010111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">11: 00001011
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">9 : 00001001
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>插入步骤(括号内为局部深度,全局深度为最大局部深度)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">插入15
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">全局: 1; 桶 1(1):15
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">14
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">全局: 1; 桶 1(1):15 ; 0(1):14
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">23
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">全局: 1; 桶 1(1):15,23; 0(1):14
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">11
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">全局: 1; 桶 1(1):15,23,11; 0(1):14
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">桶1此时有三条记录,需要扩展深度,扩展为2
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">全局: 2; 桶 11(2):15,23,11; 01(2):; 0(1):14
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">桶11此时有三条记录,需要扩展深度,扩展为3
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">全局: 3; 桶 111(3):15,23; 011(3):11;01(2):; 0(1):14
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">9
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">全局: 3; 桶 111(3):15,23; 011(3):11; 0(1):14; 01(2):9;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>
&lt;p>i. What is the global depth of the resulting table?&lt;/p>
&lt;p>显然,当g至少等于3的时候才能使得同一个哈希值最多对应两个记录.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ii. [4 points] What is the local depth the bucket containing 15?&lt;/p>
&lt;p>为3&lt;/p>
&lt;/li>
&lt;li>
&lt;p>iii. [4 points] What is the local depth of the bucket containing 14?&lt;/p>
&lt;p>为1&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="b-starting-from-the-result-in-a-you-insert-keys-12-5-7-13-2">(b) Starting from the result in (a), you insert keys 12, 5, 7, 13, 2.&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">15: 00001111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">14: 00001110
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">23: 00010111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">11: 00001011
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">9 : 00001001
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">此时 全局: 3; 桶 111(3):15,23; 011(3):11; 0(1):14; 01(2):9;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">12: 00001010
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">5 : 00000101
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">7 : 00000111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">13: 00001101
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">2 : 00000010
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">12
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">全局: 3; 桶 111(3):15,23; 011(3):11; 0(1):14,12; 01(2):9;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">5
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">全局: 3; 桶 111(3):15,23; 011(3):11; 0(1):14,12; 01(2):9;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">7
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">全局: 3; 桶 111(3):15,23; 011(3):11; 0(1):14,12; 1(1):9,5;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">此时111桶有3个,增加深度为4
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">全局: 4; 桶 1111(4):15;0111(4):23,7; 011(3):11; 0(1):14,12; 1(1):9,5;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">13
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">全局: 4; 桶 1111(4):15;0111(4):23,7; 011(3):11; 0(1):14,12; 1(1):9,5;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">01(2):13;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">2
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">全局: 4; 桶 1111(4):15;0111(4):23,7; 011(3):11; 0(1):14,12; 1(1):9,5;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">01(2):13;01(2):2
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>
&lt;p>i. [4 points] Which key will first cause a split (without doubling the size of the table)?&lt;/p>
&lt;p>这里的split操作指的是&lt;strong>增加桶的数量&lt;/strong>,而不double.也就是不增加全局深度.(增加全局深度会翻一倍)&lt;/p>
&lt;p>所以是13第一个增加了桶的数量.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ii. [4 points] Which key will first make the table double in size?&lt;/p>
&lt;p>7&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="c-now-consider-the-table-below-along-with-the-following-deletion-rules">(c) Now consider the table below, along with the following deletion rules:&lt;/h3>
&lt;ol>
&lt;li>If two buckets satisfy the following:&lt;/li>
&lt;/ol>
&lt;p>(a) They have the same local depth d&lt;/p>
&lt;p>(b) They share the first d − 1 bits of their indexes (e.g. b010 and b110 share the first 2 bits)&lt;/p>
&lt;p>(c) Their constituent elements fit in a single bucket. Then they can be merged into a single bucket with local depth d − 1.&lt;/p>
&lt;ol start="2">
&lt;li>If the global depth g becomes strictly greater than all local depths, then the table can be halved in size. The resulting global depth is g − 1.&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">00
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">28:11100
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">8 :01000
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">01
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">25:11001
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">10
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">30:11110
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">22:10110
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">18:10010
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">011
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">11:01011
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">27:11011
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">23:10111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">7 :00111
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Starting from the table above, delete keys 25, 18, 22, 27, 7.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">delete 25
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">00
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">28:11100
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">8 :01000
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">10
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">30:11110
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">22:10110
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">18:10010
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">011
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">11:01011
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">27:11011
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">23:10111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">7 :00111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">delete 18
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">00
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">28:11100
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">8 :01000
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">10
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">30:11110
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">22:10110
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">011
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">11:01011
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">27:11011
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">23:10111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">7 :00111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">delete 22
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">00
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">28:11100
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">8 :01000
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">10
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">30:11110
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">011
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">11:01011
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">27:11011
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">23:10111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">7 :00111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">此时00 和 10可进行合并
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">0
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">28:11100
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">8 :01000
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">30:11110
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">011
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">11:01011
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">27:11011
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">23:10111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">7 :00111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">delete 27
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">0
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">28:11100
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">8 :01000
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">30:11110
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">011
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">11:01011
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">23:10111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">7 :00111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">此时 011 和 111可合并为11,一次合并最多减少1, 此时global depth = 2
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">0
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">28:11100
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">8 :01000
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">30:11110
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">11
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">11:01011
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">23:10111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">7 :00111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">delete 7
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">0
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">28:11100
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">8 :01000
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">30:11110
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">11
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">11:01011
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">23:10111
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>i. Which deletion first causes a reduction in a local depth.&lt;/li>
&lt;/ul>
&lt;p>22&lt;/p>
&lt;ul>
&lt;li>
&lt;p>ii. Which deletion first causes a reduction in global depth.&lt;/p>
&lt;p>27&lt;/p>
&lt;p>Solution: Deleting 27 from bucket b011 allows it to merge with b111. Since these two buckets are the only ones of depth d = 3, this merge reduces the global depth to d = 2&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="question-4-btree">Question 4: B+Tree&lt;/h2>
&lt;p>还行,就是有个奇怪的点. 索引节点的值一般会出现在叶子节点上.&lt;/p>
&lt;p>最后一题是找出指定的节点 非法的地方.&lt;/p>
&lt;h1 id="p1">P1&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">1: 0001
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">2: 0010
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">3: 0011
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">4: 0100
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">5: 0101
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">6: 0110
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">7: 0111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">8: 1000
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">9: 1001
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">1 2 3 4
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">全局1 1(1):1,3;0(1):2,4;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">5
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">全局1 1(1):1,3,5;0(1):2,4;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">全局2 01(2):1,5;11(2)3;0(1):2,4;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">6
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">全局2 01(2):1,5;11(2)3;00(2):4;10(2):2,6;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">7
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">全局2 01(2):1,5;11(2)3,7;00(2):4;10(2):2,6;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">8
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">全局2 01(2):1,5;11(2)3,7;00(2):4,8;10(2):2,6;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">9
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">全局2 01(2):1,5,9;11(2)3,7;00(2):4,8;10(2):2,6;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">全局3 001(3):1,9;101(3):5;11(2)3,7;00(2):4,8;10(2):2,6;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="lru-k">LRU-K&lt;/h2>
&lt;p>The LRU-K algorithm &lt;strong>evicts&lt;/strong>(剔除) a frame whose &lt;strong>backward k-distance&lt;/strong> is maximum of all frames in the replacer.&lt;/p>
&lt;p>&lt;strong>Backward k-distance&lt;/strong> is computed as the &lt;strong>difference&lt;/strong> in time between current timestamp and the timestamp of kth previous access.&lt;/p>
&lt;p>A frame with less than k historical accesses is given +inf as its backward k-distance. When &lt;strong>multipe frames have +inf backward k-distance&lt;/strong>, the replacer evicts the frame &lt;strong>with the earliest timestamp&lt;/strong>.&lt;/p>
&lt;p>先弄清楚逻辑在写，不要把时间花在无意义的bug上。&lt;/p>
&lt;h1 id="p2-btree">P2 B+Tree&lt;/h1>
&lt;h2 id="概述">概述&lt;/h2>
&lt;p>内部节点：索引作用&lt;/p>
&lt;p>叶子节点：包含真正的数据实体&lt;/p>
&lt;p>由于树是动态增长和收缩，所以要处理 split 和 merge&lt;/p>
&lt;blockquote>
&lt;p>Since the tree structure grows and shrink dynamically, you are required to handle the logic of split and merge.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>Checkpoint #1 — Due Date: Oct 11 @ 11:59pm&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&lt;a href="https://15445.courses.cs.cmu.edu/fall2022/project2/#b&amp;#43;tree-pages" target="_blank" rel="noopener">Task #1 - B+Tree Pages&lt;/a>&lt;/strong>&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://15445.courses.cs.cmu.edu/fall2022/project2/#b&amp;#43;tree-structure" target="_blank" rel="noopener">Task #2 - B+Tree Data Structure (Insertion, Deletion, Point Search)&lt;/a>&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Checkpoint #2 — Due Date: Oct 26 @ 11:59pm&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&lt;a href="https://15445.courses.cs.cmu.edu/fall2022/project2/#index-iterator" target="_blank" rel="noopener">Task #3 - Index Iterator&lt;/a>&lt;/strong>&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://15445.courses.cs.cmu.edu/fall2022/project2/#concurrent_index" target="_blank" rel="noopener">Task #4 - Concurrent Index&lt;/a>&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>该project 要依赖于上一个 buffer pool 的正确实现。&lt;/p>
&lt;p>由于第一个检查点与第二个检查点密切相关，在第二个检查点中，您将在现有的B+索引中实现索引抓取，因此我们传入了一个名为transaction的指针参数，其默认值为nullptr。在任务#4之前，您不需要更改或调用与参数相关的任何函数。&lt;/p>
&lt;h2 id="task-1---btree-pages">Task #1 - B+Tree Pages&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>&lt;a href="https://15445.courses.cs.cmu.edu/fall2022/project2/#b&amp;#43;tree-page" target="_blank" rel="noopener">B+Tree Parent Page&lt;/a>&lt;/strong>&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://15445.courses.cs.cmu.edu/fall2022/project2/#b&amp;#43;tree-internal-page" target="_blank" rel="noopener">B+Tree Internal Page&lt;/a>&lt;/strong>&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://15445.courses.cs.cmu.edu/fall2022/project2/#b&amp;#43;tree-leaf-page" target="_blank" rel="noopener">B+Tree Leaf Page&lt;/a>&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h3 id="btree-parent-page">B+Tree Parent Page&lt;/h3>
&lt;p>ParenPage 被 Internal Page 和 Leaf Page所继承。&lt;/p>
&lt;p>并且只包含了 子类 所共享的信息。&lt;/p>
&lt;p>&lt;strong>可以规定&lt;/strong> &lt;code>parent_page_id_&lt;/code> 为 &lt;code>INVALID_PAGE_ID&lt;/code> 表示根节点。&lt;/p>
&lt;p>| Variable Name | Size | Description | | &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; | &amp;mdash;- | &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; | | page_type_ | 4 | Page Type (internal or leaf) | | lsn_ | 4 | Log sequence number (Used in Project 4) | | size_ | 4 | Number of Key &amp;amp; Value pairs in page | | max_size_ | 4 | Max number of Key &amp;amp; Value pairs in page | | parent_page_id_ | 4 | Parent Page Id | | page_id_ | 4 | Self Page Id |&lt;/p>
&lt;h3 id="btree-internal-page">B+Tree Internal Page&lt;/h3>
&lt;ul>
&lt;li>不存储真实数据。只存储 m个有序 key和m+1个child 指针。&lt;/li>
&lt;li>因为key的数量和指针数量不相等。第一个key被设定为invalid。所有方法需要从第二个key开始（下标为1）&lt;/li>
&lt;li>实际存储如下&lt;/li>
&lt;li>键,指针,键,指针,&amp;hellip;,键,指针.&lt;/li>
&lt;li>此时有m+1个键,为了保证只有m个键,所以第一个键设置为无效的.&lt;/li>
&lt;/ul>
&lt;p>key的数量限制&lt;/p>
&lt;ul>
&lt;li>在任何时间，最少装了一半（half-full）。&lt;/li>
&lt;li>删除时，两个 half-full可以被joined 成为一个合法的 Internal Page
&lt;ul>
&lt;li>或者被重新分配来避免merge&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>当插入到一个fullpage时，可以被split成两个。&lt;/li>
&lt;li>This is an example of one of the many design choices that you will make in the implementation of the B+ Tree.&lt;/li>
&lt;/ul>
&lt;p>三个泛型 KeyType, ValueType, KeyComparator。&lt;/p>
&lt;p>&lt;strong>KeyType&lt;/strong> 不一定直接可用大于小于号比较，所以引入了 KeyComparator，从 cpp 文件中的实例化可以看出用的是 GenericKey 和 GenericComparator，查看二者源码可以得到以下信息：&lt;/p>
&lt;p>&lt;strong>GenericKey&lt;/strong> 可以调用 ToString() 函数得到其 int64 表示，然后用 **%ld 格式符打印。**这对我们后面调试时非常重要。 GenericComparator 的比较规则是：左边小于右边时，返回 -1；左边大于右边时，返回 1；相等返回 0。&lt;/p>
&lt;p>&lt;strong>ValueType&lt;/strong> 代表的是指向子页面的指针，从实例化可以看出实际只用了 page_id_t，也就是 &lt;strong>int&lt;/strong>。&lt;/p>
&lt;p>数据存储上，其理论结构应为 &amp;lt;指针，键，指针，键…，键，指针&amp;gt;，为方便存储，实际上&lt;strong>在头部多补了一个无效键&lt;/strong>，从而可以用一个 pair 的数组存储：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">#define MappingType std::pair&amp;lt;KeyType, ValueType&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">class BPlusTreeInternalPage : public BPlusTreePage {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">private:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // Flexible array member for page data.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> MappingType array_[1];
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>array_[1] 等价与 pair类型的指针.指向pair数组. 数组的每一个元素是&amp;lt;键,值&amp;gt;&lt;/p>
&lt;p>在内部节点中,值代表指针.(第一个元素的键是无效的,但值是存在的).&lt;/p>
&lt;p>因为节点对象使用的是预先分配好的固定空间，array_ 可以控制从该位置开始到 Page 的 data 结束为止的这一段空间。&lt;/p>
&lt;p>因此，节点对象的生命周期也不是由 new 和 delete，而是由 BufferPoolManager 管理.&lt;/p>
&lt;ul>
&lt;li>取一个页面，用 FetchPage；&lt;/li>
&lt;li>使用结束归还一个页面，用 UnpinPage。&lt;/li>
&lt;li>page_id_ 不仅是 B+ 树中节点的编号，同时也是这个节点使用的 Page 在 BufferPool 中的编号。&lt;/li>
&lt;/ul>
&lt;h3 id="btree-leaf-page">B+Tree Leaf Page&lt;/h3>
&lt;ul>
&lt;li>存储 m个有序key，m个 value 实体&lt;/li>
&lt;li>在这次实现中，value 仅仅是64位的record_id, 被用于定位真实的tuples的存储位置.
&lt;ul>
&lt;li>see &lt;code>RID&lt;/code> class defined under in &lt;code>src/include/common/rid.h&lt;/code>.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>对于键值对的数量限制与Internal Page一致.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>重要&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>尽管叶子节点和内部节点有相同类型的key.但他们值的类型不一样.
&lt;ul>
&lt;li>所以&lt;strong>max_size 也应该是不同的&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>每个节点的 &lt;strong>data_&lt;/strong>,都是从buffer pool 中fetch得到的 内存页面.
&lt;ul>
&lt;li>所以当写或读时,要先使用唯一的page_id,从buffer pool 中fetch 出来.&lt;/li>
&lt;li>然后使用 reinterpret cast, 转换成 叶子节点或内部节点.&lt;/li>
&lt;li>并且要在读或写操作结束后,unpin这个页面.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="task-2---btree-data-structure">Task #2 - B+Tree Data Structure&lt;/h2>
&lt;ul>
&lt;li>只支持 unique keys. 也就是说,当有重复的key插入时, 不进行任何操作并返回false&lt;/li>
&lt;li>同时当删除操作导致 页面key数量低于阈值时, 需要正确地执行 merge 和 redistribute(也叫做 coalescing) 操作.&lt;/li>
&lt;/ul>
&lt;p>对于checkpoint , B+Tree Index 只需要支持 &lt;strong>insertions&lt;/strong> (&lt;code>Insert()&lt;/code>), &lt;strong>point search&lt;/strong> (&lt;code>GetValue()&lt;/code>), and &lt;strong>deletes&lt;/strong> (&lt;code>Delete()&lt;/code>)&lt;/p>
&lt;p>插入操作 引起 split操作的情况:&lt;/p>
&lt;ul>
&lt;li>插入操作后, 叶子节点中 pair的数量 等于 max_size&lt;/li>
&lt;li>插入 操作前, 内部节点 孩子数量等于 max_size&lt;/li>
&lt;/ul>
&lt;p>因为写操作会导致, root_page_id的改变,所以也要在 &lt;strong>header page&lt;/strong> 同时更新 root_page_id (&lt;code>src/include/storage/page/header_page.h&lt;/code>).&lt;/p>
&lt;p>更新的方法是调用 &lt;code>UpdateRootPageId&lt;/code> (已经提供了)&lt;/p>
&lt;p>需要隐藏类型和比较.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">template &amp;lt;typename KeyType,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> typename ValueType,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> typename KeyComparator&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">class BPlusTree{
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // ---
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>KeyType&lt;/code>: 索引中key的类型,只可能是 &lt;code>GenericKey&lt;/code>.
&lt;ul>
&lt;li>GeneriKey真实的size是特定的.&lt;/li>
&lt;li>是通过模板参数指定和实例化的，并取决于索引属性的数据类型.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>ValueType&lt;/code>: 索引中值的类型. 只可能是 64-bit RID.&lt;/li>
&lt;li>&lt;code>KeyComparator&lt;/code>: 用来比较两个KeyType实例 大小关系. 左边小于右边时，返回 -1；左边大于右边时，返回 1；相等返回 0。&lt;/li>
&lt;/ul>
&lt;h2 id="checkpoint-1查找插入和删除">Checkpoint 1：查找，插入和删除&lt;/h2>
&lt;h3 id="约定">约定&lt;/h3>
&lt;p>这里约定 内部节点array中key 与子节点的关系.&lt;/p>
&lt;ul>
&lt;li>左子节点的keys &amp;lt;= 父节点的keys&lt;/li>
&lt;li>右子节点的keys &amp;gt; 父节点的keys&lt;/li>
&lt;/ul>
&lt;h3 id="查找">查找&lt;/h3>
&lt;p>给定key，返回查找的页面。&lt;/p>
&lt;p>页面的数据存在叶子节点中。&lt;/p>
&lt;p>因此要从根节点开始，一层一层往下找&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="n">findValue&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="n">Page&lt;/span> &lt;span class="n">page&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">KeyType&lt;/span> &lt;span class="n">key&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//二分查找 page的array中,找到最大的小于等于key的 pair
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">pair&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">GetLeaf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Page&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">KeyType&lt;/span> &lt;span class="n">key&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Page&lt;/span> &lt;span class="n">now&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">now&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">type&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">leaf&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">now&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">findValue&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">now&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">now&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">GetValue&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">KeyType&lt;/span> &lt;span class="n">key&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Page&lt;/span> &lt;span class="n">now&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">GetLeaf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//现在now为叶子节点,在叶子节点中找对应的值.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">findValue&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">now&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//如果返回值的key不相等则没找到.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//相等则返回找到
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="插入叶子节点">插入(叶子节点)&lt;/h3>
&lt;p>因为以下的操作都基于至少有一个根节点的情况.&lt;/p>
&lt;p>因此在最开始要判断是否为空树,如为空树则创建根, 直接返回&lt;/p>
&lt;p>首先看键存不存在,如果已经存在,则直接返回.&lt;/p>
&lt;p>因为B+树的真实数据存在叶子节点中. 因此插入的第一步就是在找到对应叶子节点,并**插入(叶子节点)**到对应位置.&lt;/p>
&lt;p>此后可能会引起分裂.&lt;/p>
&lt;ol>
&lt;li>先直接**插入(叶子节点)**到叶子节点中.&lt;/li>
&lt;li>当发现**插入(叶子节点)**后, 叶子节点的pair数量等于max_size时进行分裂.&lt;/li>
&lt;/ol>
&lt;p>split(page) 操作&lt;strong>这里不分内部叶子节点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>当前节点是full page,因此可以将当前节点分裂成 (左子节点 half full, 新父节点 , half full)&lt;/li>
&lt;li>其中新父节点的值是左子节点的最后一个.&lt;/li>
&lt;li>新父节点 需要 &lt;strong>插入(内部节点)&lt;/strong> 到原来的父节点中.
&lt;ul>
&lt;li>&lt;strong>插入(内部节点)前&lt;/strong>, 要判断 &lt;strong>原父节点的孩子数量是否等于max_size&lt;/strong>&lt;/li>
&lt;li>如果等于, 则先&lt;strong>将原父节点分裂&lt;/strong> 后.&lt;/li>
&lt;li>再执行当前的**插入(内部节点)**操作.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>特殊的. 如果page是根节点, 即没有原父亲节点.
&lt;ul>
&lt;li>则将 根节点 更新成新父节点后, 返回即可.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>插入(内部节点)&lt;/strong> : 因为在插入前已经处理好了插入操作的合法性,因此直接插入即可.&lt;/p>
&lt;p>伪代码:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="n">SetRoot&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">page_id&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">root_page_id&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">page_id&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//一定要调用 UpdateRootPageId
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">split&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">page&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//分裂出下面三个节点
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">left_page&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">right_page&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">new_parent_page&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="c1">//key为左节点的最后一个key, value为指向左节点的指针
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//判断是否为根节点
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">page&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">type&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">rootType&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">SetRoot&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">new_parent_page&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">page_id&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//获取父亲节点
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">parent_page&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">parent_page&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">isFull&lt;/span>&lt;span class="p">()){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">split&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">parent_page&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//将new_parent_page 插入到 parent_page中
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">parent_page&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">insert&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">Insert&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//判断是否为空树
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">valid&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Page&lt;/span> &lt;span class="n">new_page&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Page&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">SetRoot&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">newpage&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">page_id&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//先查找
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">Page&lt;/span> &lt;span class="n">leaf_page&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">GetLeaf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//直接调用叶子节点的插入
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">leaf_page&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Insert&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">leaf_page&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">Page&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">page&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="p">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">LeafPage&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">Insert&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Page&lt;/span> &lt;span class="n">new_page&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//直接插入,同时只需要更新指向 new_page 和 new_page的 next
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//满了就分裂.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">isFull&lt;/span>&lt;span class="p">()){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">split&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">InternalPage&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">Insert&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Page&lt;/span> &lt;span class="n">new_page&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//直接插入,但array中key的有效位置是从1开始
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//上面代码还需要考虑
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//页面的创建和释放
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="删除">删除&lt;/h3>
&lt;p>B+树最难的地方。但比起splay来说还是简单太多了。并且因为B+树只有叶子节点存值。在内部节点的删除上比B树简单了很多。&lt;/p>
&lt;p>删除的核心操作：&lt;/p>
&lt;ol>
&lt;li>叶子节点/内部节点删除元素后;
若小于下限,则按下面的优先级考虑;&lt;/li>
&lt;li>如相邻兄弟结点丰满（即 元素个数 大于 下限+1），则向兄弟结点&lt;strong>借&lt;/strong>一个元素。（具体是 先从相邻方向上的父亲结点变成借来的元素左右(这里具体要看借左边还是右边)，而后对应相邻的兄弟补回这个元素）。否则：&lt;/li>
&lt;li>与相邻的兄弟结点 &lt;strong>合并&lt;/strong>&lt;/li>
&lt;/ol>
&lt;p>父亲节点被删除后, 需要继续执行上面的操作.&lt;/p>
&lt;p>叶子节点和内部节点的差异:&lt;/p>
&lt;ul>
&lt;li>借
&lt;ul>
&lt;li>内部节点和B树操作一样, 先&lt;strong>从相邻方向上的父亲结点拿一个元素&lt;/strong>，而后&lt;strong>对应相邻的兄弟补回这个元素&lt;/strong>&lt;/li>
&lt;li>叶子节点的父亲只是索引节点,因此 把兄弟节点的元素拿来后, 父亲节点的值根据 从左边/右边拿 变成相应的合法的值即可.&lt;/li>
&lt;li>借的操作都&lt;strong>不会涉及父亲节点的删除&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>合并
&lt;ul>
&lt;li>内部节点和B树操作一样, 将兄弟和父亲节点一起合并. (也相当于删除了父亲节点)下限+(下限-1) + 1 等于上限,因此合法&lt;/li>
&lt;li>叶子节点是 两个叶子节点合并后直接删除父亲节点.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>特殊地,如果删除的是根节点的元素，且根结点只有一个元素，则&lt;strong>下降一层&lt;/strong>退出。&lt;/p>
&lt;ul>
&lt;li>因为只有一个待删除的元素，说明目前只有一个儿子结点（刚刚合并了）。&lt;/li>
&lt;li>直接将儿子结点作为根节点。&lt;/li>
&lt;/ul>
&lt;p>伪代码&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//tree的Remove操作
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">Remove&lt;/span>&lt;span class="p">(){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//1.判断是否为空
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">empty&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//返回
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//2.找到叶子结点，并在叶子结点中删除该元素
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">leaf_page&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="c1">//找到叶子节点
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//TODO 删除元素
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//3.判断叶子结点元素个数是是否小于下限
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span> &lt;span class="err">小于&lt;/span> &lt;span class="err">下限&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">UnderFlow&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">Underflow&lt;/span>&lt;span class="p">(){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//3.0 判断是否为根节点
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">IsRoot&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//根节点的下限是1.说明应该减少一层.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//3.0.1a找到根节点唯一的子节点.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//该子节点变为根节点.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//3.0.1b 根节点没有子节点
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//直接删除,树变成空树.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//3.1a. 找兄弟节点借
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">Borrow&lt;/span>&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//3.1a.1a找左兄弟节点借
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">borrow&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">left_&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//3.1a.1b左兄弟不能借，就找右兄弟节点借
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">borrow&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">right_&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//3.1b.借失败了，就准备合并
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">union&lt;/span>&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//3.1b.1a 左兄弟结点存在,就找左兄弟节点合并
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">have&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">left&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="k">union&lt;/span>&lt;span class="err">(&lt;/span>&lt;span class="nc">left_&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//3.1b.1b 没有左兄弟节点, 找右兄弟节点合并.(除根节点外肯定至少有一个兄弟节点)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">union&lt;/span>&lt;span class="err">(&lt;/span>&lt;span class="nc">right_&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">borrow&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">bro_page&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//如果兄弟节点的 size &amp;lt;= 下限,不能借
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">bro_page&lt;/span> &lt;span class="n">size&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="err">下限&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//否则可以借
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//是叶子结点
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//直接拿 对应兄弟结点最靠近的元素
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//是内部结点
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//加入的元素 = 中间父亲结点对应的元素
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//中间父亲结点对应的元素 = 兄弟结点最靠近的元素.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//兄弟结点最靠近的元素删除
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">union&lt;/span>&lt;span class="err">(&lt;/span>&lt;span class="nc">bro_page&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//是叶子结点
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//两个结点合并成一个结点
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//是内部结点
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//好像都是直接把右合并到左就可以.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//删除父亲结点中间的元素.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//如果父亲结点size 小于等于 下限
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//父亲结点采取下溢操作
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Why parallelism? Why efficiency?</title><link>https://ysyyhhh.github.io/blog/why-parallelism-why-efficiency/</link><pubDate>Fri, 01 Mar 2024 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/blog/why-parallelism-why-efficiency/</guid><description>&lt;h2 id="parallelism">Parallelism&lt;/h2>
&lt;p>加速比 Speed up 是指：
程序在单处理器上运行的时间 / 程序在多处理器上运行的时间&lt;/p>
&lt;p>我们一般会期望用两倍的硬件得到两倍的速度提升,但是实际上并不是这样的。&lt;/p>
&lt;p>制约性能提升可能的因素有:&lt;/p>
&lt;ul>
&lt;li>资源分配不均匀&lt;/li>
&lt;li>通信开销&lt;/li>
&lt;li>短板效应&lt;/li>
&lt;li>共享资源读写冲突&lt;/li>
&lt;/ul>
&lt;p>为什么要去了解硬件？&lt;/p>
&lt;ul>
&lt;li>什么是限制性能的因素？&lt;/li>
&lt;li>导致性能瓶颈的原因是什么？&lt;/li>
&lt;/ul>
&lt;h2 id="efficiency">Efficiency&lt;/h2>
&lt;p>fast != efficient&lt;/p>
&lt;ul>
&lt;li>什么是效率？
尽可能地利用资源，减少浪费&lt;/li>
&lt;/ul>
&lt;p>比如按时间租用服务器。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>并行程序的挑战：&lt;/p>
&lt;ul>
&lt;li>负载均衡 Load balance&lt;/li>
&lt;li>通信延迟 Communication latency&lt;/li>
&lt;li>集体工作时，真正用于计算的时间很少&lt;/li>
&lt;/ul></description></item><item><title>Nvidia</title><link>https://ysyyhhh.github.io/showcase/nvidia/</link><pubDate>Sat, 17 Feb 2024 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/showcase/nvidia/</guid><description/></item><item><title>openai 相关QA</title><link>https://ysyyhhh.github.io/blog/openai-%E7%9B%B8%E5%85%B3qa/</link><pubDate>Fri, 08 Dec 2023 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/blog/openai-%E7%9B%B8%E5%85%B3qa/</guid><description>&lt;h2 id="无法连接">无法连接&lt;/h2>
&lt;p>Q:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">openai.error.APIConnectionError: Error communicating with OpenAI: HTTPSConnectionPool&lt;span class="o">(&lt;/span>&lt;span class="nv">host&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;api.openai.com&amp;#39;&lt;/span>, &lt;span class="nv">port&lt;/span>&lt;span class="o">=&lt;/span>443&lt;span class="o">)&lt;/span>: Max retries exceeded with url: /v1/chat/completions &lt;span class="o">(&lt;/span>Caused by ProxyError&lt;span class="o">(&lt;/span>&lt;span class="s1">&amp;#39;Unable to connect to proxy&amp;#39;&lt;/span>, SSLError&lt;span class="o">(&lt;/span>SSLZeroReturnError&lt;span class="o">(&lt;/span>6, &lt;span class="s1">&amp;#39;TLS/SSL connection has been closed (EOF) (_ssl.c:1131)&amp;#39;&lt;/span>&lt;span class="o">))))&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>A:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">问题出在模块 urllib3 的版本，报错的是 1.26.3，没报错的是 1.25.11
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">在原报错环境中使用下面命令重装低版本 urllib3：
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">pip install &lt;span class="nv">urllib3&lt;/span>&lt;span class="o">==&lt;/span>1.25.11
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">然后测试果然就没问题了。
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title/><link>https://ysyyhhh.github.io/docs/guide/%E5%BC%80%E5%8F%91/%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/guide/%E5%BC%80%E5%8F%91/%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/</guid><description>&lt;h2 id="git">git&lt;/h2>
&lt;p>测试环境&lt;/p>
&lt;ul>
&lt;li>自动化部署&lt;/li>
&lt;li>一键转移到生成环境&lt;/li>
&lt;/ul>
&lt;h2 id="部署">部署&lt;/h2>
&lt;h2 id="项目代码">项目代码&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>测试代码&lt;/p>
&lt;ul>
&lt;li>编码风格测试&amp;amp;修正&lt;/li>
&lt;li>功能测试&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Dockerfile&lt;/p>
&lt;/li>
&lt;li>
&lt;p>docker-compose&lt;/p>
&lt;/li>
&lt;li>
&lt;p>测试脚本&lt;/p>
&lt;/li>
&lt;li>
&lt;p>部署脚本&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="前端代码结构">前端代码结构&lt;/h2>
&lt;h3 id="优点">优点&lt;/h3>
&lt;p>接口可以根据环境自动替换:&lt;/p>
&lt;ul>
&lt;li>开发环境的接口&lt;/li>
&lt;li>生产环境&lt;/li>
&lt;/ul>
&lt;h3 id="1docker-runsh">1.docker-run.sh&lt;/h3>
&lt;p>描述: 部署脚本在git clone之后运行的脚本&lt;/p>
&lt;p>内容: 包括docker的构建和运行&lt;/p>
&lt;p>示例&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">docker-compose down
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker rmi digitalmapadmin-frontend
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker build -t digitalmapadmin-frontend .
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker-compose pull
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker-compose up -d
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="2docker-composeyaml">2.docker-compose.yaml&lt;/h3>
&lt;p>描述: docker-run.sh 会用到docker-compose指令&lt;/p>
&lt;p>内容:&lt;/p>
&lt;ul>
&lt;li>Dockerfile 路径&lt;/li>
&lt;li>端口&lt;/li>
&lt;li>环境变量
&lt;ul>
&lt;li>&lt;strong>生产环境下的后端接口&lt;/strong> # 这样可以在部署时 自动替换成生产环境的后端接口.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-dockerfile" data-lang="dockerfile">&lt;span class="line">&lt;span class="cl">version: &lt;span class="s1">&amp;#39;3.0&amp;#39;&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>services:&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span> frontend:&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span> build:&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span> context: .&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span> dockerfile: ./Dockerfile&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span> ports:&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span> - 8004:80&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span> environment:&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span> - &lt;span class="nv">NODE_ENV&lt;/span>&lt;span class="o">=&lt;/span>production&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span> - &lt;span class="nv">VITE_APP_TITLE&lt;/span>&lt;span class="o">=&lt;/span>数据资源管理平台&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span> - &lt;span class="nv">VITE_APP_BASE_API&lt;/span>&lt;span class="o">=&lt;/span>/api&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span> - &lt;span class="nv">VITE_SERVE&lt;/span>&lt;span class="o">=&lt;/span>http://121.40.252.139:8089/&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="3dockerfile">3.Dockerfile&lt;/h3>
&lt;p>描述: 根据项目构建docker 镜像&lt;/p>
&lt;p>内容:&lt;/p>
&lt;ul>
&lt;li>获取dist:
&lt;ul>
&lt;li>安装 npm: 并进行npm install&lt;/li>
&lt;li>npm run build&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>用nginx运行项目
&lt;ul>
&lt;li>配置nginx&lt;/li>
&lt;li>启动项目&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">FROM node:lts-alpine
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">WORKDIR /app
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 先将package.json和package-lock.json拷贝到工作目录中
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">COPY package*.json ./
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">RUN npm install
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 将当前目录下的所有文件拷贝到工作目录中
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">COPY . .
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">RUN npm run build
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">FROM nginx:alpine
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 将打包后的dist目录下全部文件拷贝到nginx的html/目录下
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># COPY ./dist/ /usr/share/nginx/html/
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">COPY --from=0 /app/dist /usr/share/nginx/html
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 删除nginx中之前的配置
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">RUN rm /etc/nginx/conf.d/default.conf
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 拷贝当前的文件到nginx中
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">COPY nginx.conf /etc/nginx/nginx.conf
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">COPY default.conf.template /etc/nginx/conf.d
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 启动nginx
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">CMD /bin/sh -c &amp;#34;envsubst &amp;#39;80&amp;#39; &amp;lt; /etc/nginx/conf.d/default.conf.template &amp;gt; /etc/nginx/conf.d/default.conf&amp;#34; &amp;amp;&amp;amp; nginx -g &amp;#39;daemon off;&amp;#39;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;/li>
&lt;/ul></description></item><item><title/><link>https://ysyyhhh.github.io/docs/guide/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/guide/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</guid><description>&lt;h1 id="用hugo--github-pagesaction--py--任务计划程序-搭建-全自动化markdown笔记转博客">用Hugo + Github Pages/Action + py + 任务计划程序 搭建 全自动化markdown笔记转博客&lt;/h1>
&lt;h4 id="tldr">TL;DR&lt;/h4>
&lt;blockquote>
&lt;ol>
&lt;li>背景: 已使用nextcloud和typora写笔记&lt;/li>
&lt;li>需求: 将笔记转换为博客.(且因为本人太懒,😂 所以需要全自动化)
&lt;ol>
&lt;li>在nextcloud中, 专门设置一个文件夹&amp;quot;笔记&amp;quot; 转换为博客文件夹&lt;/li>
&lt;li>不能改变原来记笔记的方式&lt;/li>
&lt;li>不能有任何新增的操作&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>方案:
&lt;ol>
&lt;li>使用hugo搭建博客&lt;/li>
&lt;li>使用Github pages部署博客&lt;/li>
&lt;li>使用Github Actions自动化部署&lt;/li>
&lt;li>使用py脚本将笔记转换为博客&lt;/li>
&lt;li>使用任务计划程序定时执行py脚本&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;h2 id="使用hugo搭建博客">使用hugo搭建博客&lt;/h2>
&lt;p>参考:
&lt;a href="https://gohugo.io/getting-started/quick-start/" target="_blank" rel="noopener">hugo官网&lt;/a>
&lt;a href="https://zhuanlan.zhihu.com/p/568470172" target="_blank" rel="noopener">Hugo+Github Pages+Github Action博客方案之二&lt;/a>
&lt;a href="https://zhuanlan.zhihu.com/p/568764664" target="_blank" rel="noopener">Hugo+Github Pages+Github Action博客方案之三&lt;/a>
&lt;a href="https://github.com/adityatelange/hugo-PaperMod/wiki/Installation" target="_blank" rel="noopener">PaperMod主题&lt;/a>&lt;/p>
&lt;h4 id="创建github仓库">创建github仓库&lt;/h4>
&lt;p>要创建两个仓库&lt;/p>
&lt;ol>
&lt;li>一个仓库用于存放博客源码&lt;/li>
&lt;li>一个仓库用于存放博客静态文件&lt;/li>
&lt;/ol>
&lt;h6 id="创建博客静态文件仓库">创建博客静态文件仓库&lt;/h6>
&lt;p>设置仓库名为: &lt;code>用户名.github.io&lt;/code>
&lt;a href="https://github.com/ysyyhhh/ysyyhhh.github.io" target="_blank" rel="noopener">我的博客仓库&lt;/a>&lt;/p>
&lt;h6 id="创建博客源码仓库">创建博客源码仓库&lt;/h6>
&lt;p>设置仓库名为: &lt;code>hugo-blog&lt;/code> // 仓库名可以自定义
&lt;a href="https://github.com/ysyyhhh/hugo-blog" target="_blank" rel="noopener">我的博客源码仓库&lt;/a>&lt;/p>
&lt;h4 id="安装hugo">安装hugo&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">scoop install hugo
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="创建hugo博客">创建hugo博客&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">hugo new site hugo-blog
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="安装主题">安装主题&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="nb">cd&lt;/span> hugo-blog &lt;span class="c1">## 进入博客目录, 这个是博客源码仓库&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git init
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git submodule add --depth&lt;span class="o">=&lt;/span>&lt;span class="m">1&lt;/span> https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git submodule update --init --recursive &lt;span class="c1">## needed when you reclone your repo (submodules may not get cloned automatically)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="配置主题">配置主题&lt;/h4>
&lt;p>这里使用yaml格式的配置文件, 也可以使用toml格式的配置文件
所以需要删除config.toml文件, 并创建config.yaml文件&lt;/p>
&lt;p>config.yaml:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">baseURL&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">title&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ysyy&amp;#39;s blog&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">theme&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">PaperMod&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">languageCode&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">zh-cn&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://github.com/adityatelange/hugo-PaperMod/wiki/Installation#sample-configyml" target="_blank" rel="noopener">剩余配置参考&lt;/a>&lt;/p>
&lt;h4 id="创建文章">创建文章&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">hugo new posts/first/hello-world.md
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="本地预览">本地预览&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">hugo server -D
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="生成静态文件">生成静态文件&lt;/h4>
&lt;p>生成静态文件, 生成的静态文件在 &lt;code>public&lt;/code>文件夹中。
之后我们将这个文件夹中复制到博客静态文件仓库中&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">hugo
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="部署到github-pages">部署到github pages&lt;/h4>
&lt;p>创建静态文件夹&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">git clone git@用户名.github.io.git
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">cd&lt;/span> 用户名.github.io
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cp -r hugo-blog/public/* ./
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>提交到github&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">git add .
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git commit -m &lt;span class="s2">&amp;#34;first commit&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git push origin main
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="配置github-pages">配置github pages&lt;/h4>
&lt;p>在github中的 &lt;code>用户名.github.io&lt;/code>仓库中,
点击 &lt;code>Settings&lt;/code>选项卡, 找到 &lt;code>GitHub Pages&lt;/code>选项,
将 &lt;code>Source&lt;/code>选项设置为 &lt;code>main&lt;/code>分支, 点击 &lt;code>Save&lt;/code>按钮,
这样就可以通过 &lt;code>https://用户名.github.io&lt;/code>访问博客了&lt;/p>
&lt;h2 id="使用github-actions自动化部署">使用Github Actions自动化部署&lt;/h2>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/568764664" target="_blank" rel="noopener">参考&lt;/a>&lt;/p>
&lt;p>如果每一次更新/发布新博客都需要手动执行上面的步骤, 那么就太麻烦了, 所以我们需要自动化部署&lt;/p>
&lt;p>在博客源码仓库的根目录下创建
&lt;code>.github/workflows/deploy.yml&lt;/code>文件&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ysyyblog&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">on&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">push&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">branches&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="l">main&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">jobs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">build-deploy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">runs-on&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ubuntu-20.04&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c"># runs-on: macos-latest&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">steps&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">uses&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">actions/checkout@v3&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">with&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">submodules&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># Fetch Hugo themes (true OR recursive)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">fetch-depth&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">0&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># Fetch all history for .GitInfo and .Lastmod&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Setup Hugo&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">uses&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">peaceiris/actions-hugo@v2&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">with&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">hugo-version&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;latest&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c"># extended: true&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Build&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">run&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">hugo --minify&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Deploy&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">uses&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">peaceiris/actions-gh-pages@v3&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">with&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">personal_token&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">${{ secrets.PERSONAL_TOKEN }}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># 另外还支持 deploy_token 和 github_token&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">external_repository&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ysyyhhh/ysyyhhh.github.io&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># 修改为你的 静态文件GitHub Pages 仓库&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">publish_dir&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">./public&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c"># keep_files: false&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">publish_branch&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">main&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c"># 如果使用自定义域名，还需要添加下面一行配置&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c"># cname: www&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="创建personal_token">创建personal_token&lt;/h3>
&lt;p>在github主页的右上角点击头像, 点击 &lt;code>Settings&lt;/code>选项卡, 找到 &lt;code>Developer settings&lt;/code>选项,&lt;/p>
&lt;p>找到 &lt;code>Personal access tokens&lt;/code>选项, 点击 &lt;code>Generate new token&lt;/code>按钮, 创建一个新的token&lt;/p>
&lt;h3 id="配置personal_token">配置personal_token&lt;/h3>
&lt;p>在hugo-blog仓库中, 点击 &lt;code>Settings&lt;/code>选项卡, 找到 &lt;code>Secrets&lt;/code>选项, 点击 &lt;code>New repository secret&lt;/code>按钮,&lt;/p>
&lt;p>新增一个名为 &lt;code>PERSONAL_TOKEN&lt;/code>的secret, 值为上面创建的personal_token&lt;/p>
&lt;h3 id="测试自动化部署">测试自动化部署&lt;/h3>
&lt;p>在本地的hugo-blog仓库中, 修改 &lt;code>content/posts/first/hello-world.md&lt;/code>文件, 然后提交到github&lt;/p>
&lt;p>可以在 &lt;code>Actions&lt;/code>选项卡中查看自动化部署的状态&lt;/p>
&lt;p>如果在 &lt;code>Actions&lt;/code>选项卡中看到了 &lt;code>build-deploy&lt;/code>任务, 且状态为 &lt;code>success&lt;/code>, 那么就说明自动化部署成功了&lt;/p>
&lt;p>可以在 &lt;code>用户名.github.io&lt;/code>仓库中查看是否已经更新.&lt;/p>
&lt;h2 id="使用任务计划程序和py脚本实现全自动化">使用任务计划程序和py脚本实现全自动化&lt;/h2>
&lt;p>上面的步骤已经让我们发布笔记的过程变成:&lt;/p>
&lt;ol>
&lt;li>使用hugo new / 直接编辑 content的文件 来创建笔记&lt;/li>
&lt;li>提交到hugo-blog仓库&lt;/li>
&lt;/ol>
&lt;p>然后hugo-blog仓库就会自动部署到用户名.github.io仓库中&lt;/p>
&lt;p>虽然已经只剩两步了,但遵循能自动化就自动化的原则, 我们还是要把这两步也自动化&lt;/p>
&lt;h3 id="使用py脚本将笔记转换为博客">使用py脚本将笔记转换为博客&lt;/h3>
&lt;p>安装python这些步骤就省去了,这里直接给出py脚本&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="s1">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1">每天定时更新博客内容
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1">1.进入项目根目录: D:/program_about/hugo/hugo-blog
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1">2. 将D:/nextcloud/笔记/下的文件同步到 ./content/posts/下
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1">3. 执行./push.bat 或 git add . &amp;amp;&amp;amp; git commit -m &amp;#34;update&amp;#34; &amp;amp;&amp;amp; git push
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1">&amp;#39;&amp;#39;&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">os&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">shutil&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">create_index&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s1">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1"> name = A.md
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1"> 在root下生成&amp;#39;A&amp;#39;文件夹
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1"> 将A.md移动到A文件夹下，并重命名为index.md
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1"> 如果 存在 root + &amp;#39;/img&amp;#39; 的文件夹
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1"> 将 root + &amp;#39;/img&amp;#39; 复制到 root + &amp;#39;/A/img&amp;#39; 下
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1"> &amp;#39;&amp;#39;&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 生成文件夹&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">dir_name&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">split&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;.&amp;#39;&lt;/span>&lt;span class="p">)[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">dir_name&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">os&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">mkdir&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">os&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">dir_name&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 移动文件&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">shutil&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">move&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">os&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="n">os&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">dir_name&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s1">&amp;#39;index.md&amp;#39;&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 处理img&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">os&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">exists&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">os&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s1">&amp;#39;img&amp;#39;&lt;/span>&lt;span class="p">)):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">shutil&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">copytree&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">os&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s1">&amp;#39;img&amp;#39;&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="n">os&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">dir_name&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s1">&amp;#39;img&amp;#39;&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">adjust&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">dir&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">os&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">chdir&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">dir&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s1">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1"> 将所有下面的格式
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1"> - A.md
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1"> - img
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1"> - A-1.png
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1"> 转换成
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1"> - A
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1"> - index.md
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1"> - img
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1"> - A-1.png
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1"> 如果遇到&amp;#34;.md&amp;#34;文件,直接删除
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1"> &amp;#39;&amp;#39;&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">dirs&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">files&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">os&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">walk&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;.&amp;#34;&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">root&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">os&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">dir&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">name&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">files&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">name&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="s1">&amp;#39;.md&amp;#39;&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">os&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">remove&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">os&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">continue&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">endswith&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;.md&amp;#39;&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">create_index&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">name&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">dirs&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 递归调用&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">adjust&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">os&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">sync&lt;/span>&lt;span class="p">():&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">root_path&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s1">&amp;#39;D:/program_about/hugo/hugo-blog&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">os&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">chdir&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root_path&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 当文件已存在时，无法创建该文件。: &amp;#39;./content/posts/&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">shutil&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">rmtree&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;./content/posts/&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># git中也要删除&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">os&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">system&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;git rm -r ./content/posts/&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">shutil&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">copytree&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;D:/nextcloud/笔记/&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s1">&amp;#39;./content/posts/&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 把所有文件夹和文件的名称大写转换为小写&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">os&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">chdir&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;./content/posts/&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">dirs&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">files&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">os&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">walk&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;.&amp;#34;&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">name&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">files&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">new_name&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">lower&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">os&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">rename&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">os&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="n">os&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">new_name&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">name&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">dirs&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">new_name&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">lower&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">os&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">rename&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">os&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="n">os&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">new_name&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 调整文件夹结构&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">adjust&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root_path&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="s1">&amp;#39;./content/posts/&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 上传到git&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># os.chdir(&amp;#39;./content/posts/&amp;#39;)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">os&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">chdir&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;D:/program_about/hugo/hugo-blog&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">os&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">system&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;git add ./content/posts/&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">os&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">system&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;git commit -m &amp;#34;update&amp;#34;&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">os&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">system&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;git push&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">os&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">chdir&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;D:/program_about/hugo/hugo-blog&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;sync done&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="vm">__name__&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="s1">&amp;#39;__main__&amp;#39;&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">sync&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>将上面的路径修改为自己的路径, 然后保存为 &lt;code>sync.py&lt;/code>文件
可以执行py脚本,测试一下&lt;/p>
&lt;h4 id="关于图片路径问题">关于图片路径问题&lt;/h4>
&lt;p>&lt;a href="https://discourse.gohugo.io/t/image-path-with-relative-urls/21970/3" target="_blank" rel="noopener">参考方案&lt;/a>&lt;/p>
&lt;p>因为我平时的图片路径是&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-markdown" data-lang="markdown">&lt;span class="line">&lt;span class="cl">&lt;span class="k">-&lt;/span> A.md
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">-&lt;/span> img
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">-&lt;/span> A-1.png
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>但是hugo会将A.md文件转换为A文件夹, 所以此时是无法访问A-1.png的.&lt;/p>
&lt;p>这里是通过改变相对路径关系来解决的, 即代码中的adjust()&lt;/p>
&lt;p>当然如果你有图床就不需要这么麻烦了&lt;/p>
&lt;h3 id="使用任务计划程序定时执行py脚本">使用任务计划程序定时执行py脚本&lt;/h3>
&lt;p>参考
这里我使用的是win10自带的任务计划程序, 其他系统的任务计划程序也是类似的&lt;/p>
&lt;p>以下步骤由Claude生成&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-markdown" data-lang="markdown">&lt;span class="line">&lt;span class="cl">下面是如何使用Windows任务计划程序来配置定时每天执行Python脚本的步骤:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">打开任务计划程序(Windows + R 输入taskschd.msc回车)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">点击&amp;#34;操作&amp;#34;栏中的&amp;#34;创建基本任务&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">输入任务名称,选择触发器为每天定时,设置执行时间
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">在操作栏中,点击“新建”
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">选择“启动一个程序”
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">在“程序/脚本”框中输入Python解释器的路径,例如C:\Python37\python.exe
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">在“添加参数(可选)”中输入python脚本文件的完整路径,例如C:\Users\username\script.py
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">点击“确定”保存此操作
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">在下一页中选择用户账号,例如“当前用户”
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">点击“确定”完成创建任务
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">根据需要配置触发器记录和其他选项
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">点击“确定”保存任务
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">任务将在设定的时间自动执行python脚本文件
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">每次修改脚本后需要停止原有任务,然后再新建一个相同的任务来加载修改后的脚本代码。
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">需要注意python interpreter路径和脚本路径的正确性。定时执行格式也需要正确,这样就可以实现Windows系统中的自动定时任务执行Python脚本了。
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title/><link>https://ysyyhhh.github.io/docs/guide/%E9%83%A8%E7%BD%B2/docker%E7%9B%B8%E5%85%B3%E7%9A%84%E9%83%A8%E7%BD%B2%E8%A7%84%E8%8C%83/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/guide/%E9%83%A8%E7%BD%B2/docker%E7%9B%B8%E5%85%B3%E7%9A%84%E9%83%A8%E7%BD%B2%E8%A7%84%E8%8C%83/</guid><description>&lt;h1 id="docker-相关的部署规范">docker 相关的部署规范&lt;/h1>
&lt;h2 id="1命名规范">1.命名规范&lt;/h2>
&lt;h3 id="11镜像命名规范">1.1.镜像命名规范&lt;/h3>
&lt;p>镜像命名规范：&lt;code>&amp;lt;小组名&amp;gt;/&amp;lt;项目名&amp;gt;/&amp;lt;镜像名&amp;gt;:&amp;lt;版本号&amp;gt;&lt;/code>&lt;/p>
&lt;p>版本号：&lt;code>&amp;lt;主版本号&amp;gt;.&amp;lt;次版本号&amp;gt;.&amp;lt;修订号&amp;gt;&lt;/code> eg: &lt;code>1.0.0&lt;/code>&lt;/p>
&lt;h3 id="12容器命名规范">1.2.容器命名规范&lt;/h3>
&lt;p>容器命名规范：&lt;code>&amp;lt;小组名&amp;gt;-&amp;lt;项目名&amp;gt;-&amp;lt;容器名&amp;gt;-&amp;lt;版本号&amp;gt;&lt;/code>&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/guide/%E9%83%A8%E7%BD%B2/%E5%88%A9%E4%BA%8E%E9%83%A8%E7%BD%B2%E7%9A%84%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/guide/%E9%83%A8%E7%BD%B2/%E5%88%A9%E4%BA%8E%E9%83%A8%E7%BD%B2%E7%9A%84%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/</guid><description>&lt;h1 id="利于部署的开发规范手册">利于部署的开发规范手册&lt;/h1>
&lt;p>本规范用于在开发过程中，使得项目能够更好的部署，更好的维护。&lt;/p>
&lt;p>使用时间: 当项目开始开发时，就应该遵守本规范。&lt;/p>
&lt;p>核心要点:&lt;/p>
&lt;ul>
&lt;li>管理依赖库&lt;/li>
&lt;li>使用docker&lt;/li>
&lt;li>端口、ip地址等使用环境变量&lt;/li>
&lt;li>路径不能写死！尤其是绝对路径和根目录等，需要放在环境变量中！！&lt;/li>
&lt;/ul>
&lt;h2 id="后端">后端&lt;/h2>
&lt;h3 id="python项目">python项目&lt;/h3>
&lt;p>python常见的依赖库管理有:&lt;/p>
&lt;ul>
&lt;li>poetry&lt;/li>
&lt;li>requirements.txt&lt;/li>
&lt;li>pipenv&lt;/li>
&lt;/ul>
&lt;h4 id="poetry">poetry&lt;/h4>
&lt;p>初始化&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">poetry init
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>安装依赖&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">poetry install
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用poetry运行项目&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">poetry run python main.py
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>添加依赖&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">poetry add &amp;lt;package&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>dockerfile示例&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-dockerfile" data-lang="dockerfile">&lt;span class="line">&lt;span class="cl">&lt;span class="k">FROM&lt;/span>&lt;span class="s"> python:3.8.5-slim-buster&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">WORKDIR&lt;/span>&lt;span class="s"> /app&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 拷贝依赖文件&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">COPY&lt;/span> pyproject.toml poetry.lock ./&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 设置国内源&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> pip config &lt;span class="nb">set&lt;/span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 安装poetry&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> pip install poetry&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 安装依赖&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> poetry config virtualenvs.create &lt;span class="nb">false&lt;/span> &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> poetry install --no-dev --no-interaction --no-ansi&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># tips: 先只拷贝依赖文件，再安装依赖，可以利用docker的缓存机制，加快构建速度. &lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># (防止只是项目文件改变，而依赖文件没有改变，导致重新安装依赖)&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 拷贝项目文件&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">COPY&lt;/span> . .&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 运行项目&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">CMD&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;poetry&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;run&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;python&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;main.py&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="requirementstxt">requirements.txt&lt;/h4>
&lt;p>导出依赖&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">pip freeze &amp;gt; requirements.txt
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>安装依赖&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">pip install -r requirements.txt
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>dockerfile示例&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-dockerfile" data-lang="dockerfile">&lt;span class="line">&lt;span class="cl">&lt;span class="k">FROM&lt;/span>&lt;span class="s"> python:3.8.5-slim-buster&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">WORKDIR&lt;/span>&lt;span class="s"> /app&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 拷贝依赖文件&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">COPY&lt;/span> requirements.txt ./&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 设置国内源&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> pip config &lt;span class="nb">set&lt;/span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 安装依赖&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> pip install -r requirements.txt&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 拷贝项目文件&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">COPY&lt;/span> . .&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 运行项目&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">CMD&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;python&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;main.py&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="pipenv">pipenv&lt;/h4>
&lt;p>初始化&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">pipenv --python 3.8
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>安装依赖&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">pipenv install
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用pipenv运行项目&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">pipenv run python main.py
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>添加依赖&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">pipenv install &amp;lt;package&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>dockerfile示例&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-dockerfile" data-lang="dockerfile">&lt;span class="line">&lt;span class="cl">&lt;span class="k">FROM&lt;/span>&lt;span class="s"> python:3.8.5-slim-buster&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">WORKDIR&lt;/span>&lt;span class="s"> /app&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 设置国内源&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> pip config &lt;span class="nb">set&lt;/span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 拷贝依赖文件&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">COPY&lt;/span> Pipfile Pipfile.lock ./&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 安装依赖&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> pip install pipenv &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> pipenv install --system --deploy --ignore-pipfile&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 拷贝项目文件&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">COPY&lt;/span> . .&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 运行项目&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">CMD&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;pipenv&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;run&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;python&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;main.py&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="springboot项目">SpringBoot项目&lt;/h3>
&lt;p>&lt;a href="https://developer.aliyun.com/article/65274" target="_blank" rel="noopener">参考&lt;/a>
这里都以maven作为依赖管理工具。&lt;/p>
&lt;p>主要保留pom.xml文件&lt;/p>
&lt;p>dockerfile示例&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-dockerfile" data-lang="dockerfile">&lt;span class="line">&lt;span class="cl">&lt;span class="c"># 第一阶段: 构建jar包&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="s"> maven:3.6.3-jdk-8-slim AS build&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">WORKDIR&lt;/span>&lt;span class="s"> /app&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">COPY&lt;/span> pom.xml ./&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 设置国内源&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> mvn -B -e -C -T 1C org.apache.maven.plugins:maven-dependency-plugin:3.1.2:go-offline&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 拷贝项目文件&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">COPY&lt;/span> . .&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 构建jar包&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> mvn clean install -DskipTests&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 第二阶段: 运行jar包&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="s"> openjdk:8-jdk-alpine&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">WORKDIR&lt;/span>&lt;span class="s"> /app&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 拷贝第一阶段构建的jar包&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">COPY&lt;/span> --from&lt;span class="o">=&lt;/span>build /app/target/demo-0.0.1-SNAPSHOT.jar ./&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 运行项目&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">CMD&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;java&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;-jar&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;target/demo-0.0.1-SNAPSHOT.jar&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="数据库">数据库&lt;/h3>
&lt;p>通常后端要连接数据库，这里只是简单的示例，实际项目中应该使用&lt;a href="#%e5%b0%81%e8%a3%85%e6%95%b4%e4%b8%aa%e9%a1%b9%e7%9b%ae">docker-compose&lt;/a>来管理多个容器。&lt;/p>
&lt;p>dockerfile示例&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-dockerfile" data-lang="dockerfile">&lt;span class="line">&lt;span class="cl">&lt;span class="k">FROM&lt;/span>&lt;span class="s"> mysql:8.0.22&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 设置时区&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">ENV&lt;/span> &lt;span class="nv">TZ&lt;/span>&lt;span class="o">=&lt;/span>Asia/Shanghai&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 设置root密码&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">ENV&lt;/span> &lt;span class="nv">MYSQL_ROOT_PASSWORD&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">123456&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c"># 设置数据库名&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">ENV&lt;/span> &lt;span class="nv">MYSQL_DATABASE&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="nb">test&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c"># 设置用户名&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">ENV&lt;/span> &lt;span class="nv">MYSQL_USER&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="nb">test&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c"># 设置密码&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">ENV&lt;/span> &lt;span class="nv">MYSQL_PASSWORD&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">123456&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c"># 设置端口&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">EXPOSE&lt;/span>&lt;span class="s"> 3306&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>单独运行mysql&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">docker run -d -p 3306:3306 --name mysql -v /path/to/mysql/data:/var/lib/mysql mysql:8.0.22
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="前端">前端&lt;/h2>
&lt;p>前端使用npm作为依赖管理工具, 使用nginx作为web服务器。&lt;/p>
&lt;p>必要的文件:&lt;/p>
&lt;ul>
&lt;li>package.json # 依赖文件&lt;/li>
&lt;li>package-lock.json # 锁定依赖版本&lt;/li>
&lt;li>nginx.conf # nginx配置文件&lt;/li>
&lt;li>dockerfile&lt;/li>
&lt;/ul>
&lt;h3 id="npm">npm&lt;/h3>
&lt;p>npm初始化&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">npm init
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>安装依赖&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">npm install
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>添加依赖(默认添加到dependencies, 添加到devDependencies需要加上&amp;ndash;save-dev参数(或者-D)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">npm install &amp;lt;package&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="nginx">nginx&lt;/h3>
&lt;p>nginx.conf示例&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-nginx" data-lang="nginx">&lt;span class="line">&lt;span class="cl">&lt;span class="k">server&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">listen&lt;/span> &lt;span class="mi">80&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">server_name&lt;/span> &lt;span class="s">localhost&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">root&lt;/span> &lt;span class="s">/usr/share/nginx/html&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">index&lt;/span> &lt;span class="s">index.html&lt;/span> &lt;span class="s">index.htm&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">location&lt;/span> &lt;span class="s">/&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">try_files&lt;/span> &lt;span class="nv">$uri&lt;/span> &lt;span class="nv">$uri/&lt;/span> &lt;span class="s">/index.html&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="docker">docker&lt;/h3>
&lt;p>docker &lt;a href="https://cloud.tencent.com/developer/article/2246201" target="_blank" rel="noopener">使用多阶段构建&lt;/a>&lt;/p>
&lt;p>dockerfile示例&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-dockerfile" data-lang="dockerfile">&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 第一阶段: 构建项目&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="s"> node:lts-alpine as build&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">WORKDIR&lt;/span>&lt;span class="s"> /app&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 拷贝依赖文件&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">COPY&lt;/span> package.json package-lock.json ./&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 安装依赖&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> npm install&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 拷贝项目文件&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">COPY&lt;/span> . .&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 构建项目&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> npm run build&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 第一段构建完成, 获得/app/build文件夹&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 使用nginx作为web服务器&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="s"> nginx:1.19.4-alpine&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 拷贝nginx配置文件&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">COPY&lt;/span> nginx.conf /etc/nginx/conf.d/default.conf&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 拷贝第一阶段构建的项目文件&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">COPY&lt;/span> --from&lt;span class="o">=&lt;/span>build /app/build /usr/share/nginx/html&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 运行nginx&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">CMD&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;nginx&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;-g&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;daemon off;&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="项目部署-todo">项目部署 TODO&lt;/h2>
&lt;h3 id="封装整个项目单个项目时">封装整个项目(单个项目时)&lt;/h3>
&lt;p>经过上面的步骤已经将前后端 数据库封装到docker中了,但每次启动项目都需要手动启动三个容器, 这里使用docker-compose来管理多个容器。&lt;/p>
&lt;p>docker-compose.yml示例&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">version&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;3.8&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">services&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">mysql&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">mysql:8.0.22&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">environment&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">TZ&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Asia/Shanghai&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">MYSQL_ROOT_PASSWORD&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">123456&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">MYSQL_DATABASE&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">test&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">MYSQL_USER&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">test&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">MYSQL_PASSWORD&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">123456&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">ports&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="m">3306&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="m">3306&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">volumes&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="l">./mysql/data:/var/lib/mysql&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">backend&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">build&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">./backend&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">ports&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="m">8080&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="m">8080&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">depends_on&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="l">mysql&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">frontend&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">build&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">./frontend&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">ports&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="m">80&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="m">80&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">depends_on&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="l">backend&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="整个项目作为k8s的一个服务多个项目时">整个项目作为k8s的一个服务(多个项目时)&lt;/h3>
&lt;p>上面是使用docker-compose来管理 一个项目的多个容器.&lt;/p>
&lt;p>但如果有多个项目, 每个项目都有多个容器, 这时候就需要使用k8s来管理了.&lt;/p>
&lt;p>我们把一个项目(多个容器)作为一个k8s的一个服务.&lt;/p>
&lt;p>k8s的配置文件示例&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Service&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">test&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">labels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">app&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">test&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">ports&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">port&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">80&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">targetPort&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">80&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">protocol&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">TCP&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">selector&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">app&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">test&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">type&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">NodePort&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nn">---&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">apps/v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Deployment&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">test&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">labels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">app&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">test&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">replicas&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">selector&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">matchLabels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">app&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">test&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">template&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">labels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">app&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">test&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">containers&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">mysql&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">mysql:8.0.22&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">env&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">TZ&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">value&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Asia/Shanghai&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">MYSQL_ROOT_PASSWORD&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">value&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">123456&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">MYSQL_DATABASE&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">value&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">test&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">MYSQL_USER&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">value&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">test&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">MYSQL_PASSWORD&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">value&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">123456&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">ports&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">containerPort&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">3306&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">volumeMounts&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">mysql-data&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">mountPath&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/var/lib/mysql&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">backend&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">backend:latest&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">ports&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">containerPort&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">8080&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">env&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">MYSQL_HOST&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">value&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">mysql&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">MYSQL_PORT&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">value&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;3306&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">MYSQL_DATABASE&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">value&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">test&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">MYSQL_USER&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">value&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">test&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">MYSQL_PASSWORD&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">value&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">123456&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">frontend&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">frontend:latest&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">ports&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">containerPort&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">80&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">volumes&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">mysql-data&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">hostPath&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">path&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/path/to/mysql/data&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title/><link>https://ysyyhhh.github.io/docs/guide/%E9%83%A8%E7%BD%B2/%E9%83%A8%E7%BD%B2%E6%89%8B%E5%86%8C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/guide/%E9%83%A8%E7%BD%B2/%E9%83%A8%E7%BD%B2%E6%89%8B%E5%86%8C/</guid><description>&lt;h1 id="部署手册">部署手册&lt;/h1>
&lt;h2 id="docker-镜像上传到私有仓库">docker 镜像上传到私有仓库&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker build -t image .
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker login -u username -p password registry.cn-hangzhou.aliyuncs.com
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># docker login --username=夜宵也还行 registry.cn-hangzhou.aliyuncs.com&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker tag image registry.cn-hangzhou.aliyuncs.com/username/image:tag
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker push registry.cn-hangzhou.aliyuncs.com/username/image:tag
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="server">Server&lt;/h2>
&lt;h3 id="springboot">SpringBoot&lt;/h3>
&lt;p>application.yml 必须使用环境变量来进行配置。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">spring&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">datasource&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">url&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">jdbc:mysql://${MYSQL_HOST:localhost}:${MYSQL_PORT:3306}/${MYSQL_DATABASE:test}?useUnicode=true&amp;amp;characterEncoding=utf-8&amp;amp;useSSL=false&amp;amp;serverTimezone=Asia/Shanghai&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">username&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">${MYSQL_USER:test}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">password&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">${MYSQL_PASSWORD:123456}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/llm/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%8E%9F%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/llm/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%8E%9F%E7%90%86/</guid><description>&lt;h1 id="大语言模型原理">大语言模型原理&lt;/h1>
&lt;h2 id="语言模型的基础技术">语言模型的基础技术&lt;/h2>
&lt;h3 id="transformer">transformer&lt;/h3>
&lt;h2 id="大语言模型">大语言模型&lt;/h2>
&lt;h3 id="gpt">GPT&lt;/h3>
&lt;h3 id="bert">BERT&lt;/h3>
&lt;p>&lt;a href="https://www.zhihu.com/tardis/zm/art/607605399?source_id=1003" target="_blank" rel="noopener">BERT vs GPT&lt;/a>&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E5%91%BD%E4%BB%A4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E5%91%BD%E4%BB%A4/</guid><description>&lt;h1 id="linux命令">Linux命令&lt;/h1>
&lt;h2 id="常用命令">常用命令&lt;/h2>
&lt;p>ls
mkdir
cp
mv&lt;/p>
&lt;p>nohup&lt;/p>
&lt;p>df&lt;/p>
&lt;h2 id="qa">QA&lt;/h2>
&lt;p>文件过滤用什么, 用法
grep&lt;/p>
&lt;p>grep命令一般怎么使用？
grep [option] pattern file&lt;/p>
&lt;p>Linux统计一个文件有多少行的命令？
wc -l filename&lt;/p>
&lt;h2 id="资源相关">资源相关&lt;/h2>
&lt;h3 id="内存相关">内存相关&lt;/h3>
&lt;p>内存查看
free -m&lt;/p>
&lt;p>内存使用情况&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl"> total used free shared buff/cache available
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Mem: &lt;span class="m">1888&lt;/span> &lt;span class="m">155&lt;/span> &lt;span class="m">1406&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">326&lt;/span> &lt;span class="m">1616&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Swap: &lt;span class="m">2047&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">2047&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>total: 总内存&lt;/li>
&lt;li>used: 已使用内存&lt;/li>
&lt;li>free: 空闲内存&lt;/li>
&lt;li>shared: 共享内存&lt;/li>
&lt;li>buff/cache: 缓存内存&lt;/li>
&lt;li>available: 可用内存&lt;/li>
&lt;/ul>
&lt;h3 id="磁盘相关">磁盘相关&lt;/h3>
&lt;p>磁盘查看
df -h&lt;/p>
&lt;p>磁盘使用情况&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">Filesystem Size Used Avail Use% Mounted on
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">udev 935M &lt;span class="m">0&lt;/span> 935M 0% /dev
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">tmpfs 192M 1.4M 191M 1% /run
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>Size: 总磁盘大小&lt;/li>
&lt;li>Used: 已使用磁盘大小&lt;/li>
&lt;li>Avail: 可用磁盘大小&lt;/li>
&lt;li>Use%: 使用百分比&lt;/li>
&lt;li>Mounted on: 挂载点&lt;/li>
&lt;/ul>
&lt;h3 id="cpu相关">CPU相关&lt;/h3>
&lt;p>CPU查看
top&lt;/p>
&lt;p>CPU使用情况&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">top - 10:00:01 up 1:00, &lt;span class="m">1&lt;/span> user, load average: 0.00, 0.00, 0.00
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Tasks: &lt;span class="m">88&lt;/span> total, &lt;span class="m">1&lt;/span> running, &lt;span class="m">87&lt;/span> sleeping, &lt;span class="m">0&lt;/span> stopped, &lt;span class="m">0&lt;/span> zombie
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">%Cpu&lt;span class="o">(&lt;/span>s&lt;span class="o">)&lt;/span>: 0.0 us, 0.0 sy, 0.0 ni,100.0 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">KiB Mem : &lt;span class="m">1936&lt;/span> total, &lt;span class="m">1456&lt;/span> free, &lt;span class="m">116&lt;/span> used, &lt;span class="m">364&lt;/span> buff/cache
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>load average: 1分钟、5分钟、15分钟的平均负载&lt;/li>
&lt;li>Tasks: 进程信息&lt;/li>
&lt;li>%Cpu(s): CPU使用情况&lt;/li>
&lt;li>KiB Mem: 内存使用情况&lt;/li>
&lt;/ul>
&lt;h2 id="进程相关">进程相关&lt;/h2>
&lt;h3 id="进程查看">进程查看&lt;/h3>
&lt;p>ps
含义: 显示当前用户的进程信息
不加aux的话, 只会显示当前终端的进程&lt;/p>
&lt;p>ps aux
含义: a表示显示所有进程，u表示显示用户信息，x表示显示没有控制终端的进程&lt;/p>
&lt;p>ps -ef&lt;/p>
&lt;ul>
&lt;li>e: 显示所有进程&lt;/li>
&lt;li>f: 显示全格式&lt;/li>
&lt;/ul>
&lt;p>ps -ef | grep java&lt;/p>
&lt;p>输出:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">root &lt;span class="m">1023&lt;/span> &lt;span class="m">1&lt;/span> &lt;span class="m">0&lt;/span> 10:00 ? 00:00:00 /usr/bin/java
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>找内存占用最高的进程
ps aux &amp;ndash;sort=-%mem | head&lt;/p>
&lt;h2 id="应用相关">应用相关&lt;/h2>
&lt;p>查看linux系统中的service
service &amp;ndash;status-all&lt;/p>
&lt;h3 id="nginx相关">nginx相关&lt;/h3>
&lt;p>查看nginx进程
ps -ef | grep nginx&lt;/p>
&lt;p>查看nginx配置文件
nginx -t&lt;/p>
&lt;h2 id="网络相关">网络相关&lt;/h2>
&lt;h3 id="网络配置查看">网络配置查看&lt;/h3>
&lt;p>ifconfig
包含的信息:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">eth0 Link encap:Ethernet HWaddr 00:0C:29:3D:5D:7A
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> inet addr:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Bcast:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Mask:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> inet6 addr:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> RX packets:0 errors:0 dropped:0 overruns:0 frame:0
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> collisions:0 txqueuelen:1000
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>网口的连接状态标志: UP表示网口已经启用，DOWN表示网口未启用, RUNNING表示网口正在运行，而STOPPED表示网口已经停止&lt;/p>
&lt;p>MTU大小: 默认值是 1500 字节，其作用主要是限制网络包的大小，如果 IP 层有一个数据报要传，而且网络包的长度比链路层的 MTU 还大，那么 IP 层就需要进行分片&lt;/p>
&lt;p>网口的 IP 地址、子网掩码、MAC 地址、网关地址&lt;/p>
&lt;p>网络包收发的统计信息&lt;/p>
&lt;ul>
&lt;li>RX packets: 接收的数据包的数量&lt;/li>
&lt;li>TX packets: 发送的数据包的数量&lt;/li>
&lt;/ul>
&lt;p>errors: 出错的数据包的数量
dropped: 丢弃的数据包的数量
overruns: 数据包在接收时超出了缓冲区的大小
frame: 数据包在接收时出现了 CRC 错误&lt;/p>
&lt;h3 id="防火墙">防火墙&lt;/h3>
&lt;p>查看防火墙状态
firewall-cmd &amp;ndash;state&lt;/p>
&lt;p>查看防火墙规则
firewall-cmd &amp;ndash;list-all&lt;/p>
&lt;p>查看端口是否开放
firewall-cmd &amp;ndash;query-port=80/tcp&lt;/p>
&lt;p>开放端口
firewall-cmd &amp;ndash;zone=public &amp;ndash;add-port=80/tcp &amp;ndash;permanent&lt;/p>
&lt;h3 id="socket信息查看">socket信息查看&lt;/h3>
&lt;p>netstat
含义: 显示网络状态信息&lt;/p>
&lt;p>netstat -an
含义: 显示所有的网络连接，不进行域名解析
输出&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">Proto Recv-Q Send-Q Local Address Foreign Address State
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">tcp 0 0
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">tcp6 0 0
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">udp 0 0
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">udp6 0 0
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>netstat -an | grep 8080
含义: 查看端口是否被占用&lt;/p>
&lt;p>ss
含义: 显示套接字信息&lt;/p>
&lt;p>ss -ltnp&lt;/p>
&lt;ul>
&lt;li>l: 显示LISTIEN监听状态的套接字&lt;/li>
&lt;li>t: 显示 TCP 协议的套接字&lt;/li>
&lt;li>n: 不显示名字,而是以数字的方式显示ip和端口&lt;/li>
&lt;li>p: 显示进程信息&lt;/li>
&lt;/ul>
&lt;p>输出&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">State Recv-Q Send-Q Local Address:Port Peer Address:Port
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">LISTEN 0 128
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>都包含了:&lt;/p>
&lt;p>socket 的状态（State）
接收队列（Recv-Q）
发送队列（Send-Q）
本地地址（Local Address）
远端地址（Foreign Address）
进程 PID
进程名称（PID/Program name）&lt;/p>
&lt;p>接收队列（Recv-Q）和发送队列（Send-Q）比较特殊，在不同的 socket 状态。它们表示的含义是不同的。&lt;/p>
&lt;p>当 socket 状态处于 Established时：&lt;/p>
&lt;p>Recv-Q 表示 socket 缓冲区中还没有被应用程序读取的字节数；
Send-Q 表示 socket 缓冲区中还没有被远端主机确认的字节数；&lt;/p>
&lt;p>而当 socket 状态处于 Listen 时：&lt;/p>
&lt;p>Recv-Q 表示全连接队列的长度；
Send-Q 表示全连接队列的最大长度；&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Linux%e5%91%bd%e4%bb%a4/TCP%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>全连接队列指的是服务器与客户端完了 TCP 三次握手后，还没有被 accept() 系统调用取走连接的队列。&lt;/p>
&lt;h3 id="网络吞吐量查看">网络吞吐量查看&lt;/h3>
&lt;p>sar
含义: 查看系统的网络吞吐量&lt;/p>
&lt;p>用法是给 sar 增加 -n 参数就可以查看网络的统计信息，比如&lt;/p>
&lt;p>sar -n DEV，显示网口的统计数据；
sar -n EDEV，显示关于网络错误的统计数据；
sar -n TCP，显示 TCP 的统计数据&lt;/p>
&lt;p>输出&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">10:00:01 IFACE rxpck/s txpck/s rxkB/s txkB/s rxcmp/s txcmp/s rxmcst/s
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">10:10:01 eth0
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">10:20:01 eth0
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>它们的含义：&lt;/p>
&lt;p>rxpck/s 和 txpck/s 分别是接收和发送的 PPS，单位为包 / 秒。
rxkB/s 和 txkB/s 分别是接收和发送的吞吐率，单位是 KB/ 秒。
rxcmp/s 和 txcmp/s 分别是接收和发送的压缩数据包数，单位是包 / 秒。&lt;/p>
&lt;p>对于带宽，我们可以使用 ethtool 命令来查询，它的单位通常是 Gb/s 或者 Mb/s，不过注意这里小写字母 b ，表示比特而不是字节。我们通常提到的千兆网卡、万兆网卡等，单位也都是比特（bit）。如下你可以看到， eth0 网卡就是一个千兆网卡：&lt;/p>
&lt;h3 id="连通性和延时">连通性和延时&lt;/h3>
&lt;p>ping
含义: 测试网络连通性&lt;/p>
&lt;p>ping -c 4 &lt;a href="https://www.baidu.com" target="_blank" rel="noopener">www.baidu.com&lt;/a>&lt;/p>
&lt;ul>
&lt;li>c: 指定发送的数据包数量&lt;/li>
&lt;li>i: 指定发送数据包的时间间隔&lt;/li>
&lt;li>s: 指定发送数据包的大小&lt;/li>
&lt;/ul>
&lt;p>输出&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">PING baidu.com (39.156.66.10) 56(84) bytes of data.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">64 bytes from 39.156.66.10 (39.156.66.10): icmp_seq=1 ttl=50 time=24.2 ms
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">64 bytes from 39.156.66.10 (39.156.66.10): icmp_seq=2 ttl=50 time=23.1 ms
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">64 bytes from 39.156.66.10 (39.156.66.10): icmp_seq=3 ttl=50 time=25.8 ms
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">^C
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">--- baidu.com ping statistics ---
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">3 packets transmitted, 3 received, 0% packet loss, time 2053ms
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">rtt min/avg/max/mdev = 23.114/24.375/25.778/1.092 ms
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>icmp_seq: ICMP 数据包的序列号&lt;/li>
&lt;li>ttl: 生存时间&lt;/li>
&lt;li>time: 延迟时间&lt;/li>
&lt;/ul>
&lt;p>ping 不通服务器并不代表 HTTP 请求也不通，因为有的服务器的防火墙是会禁用 ICMP 协议的&lt;/p>
&lt;p>traceroute
含义: 显示数据包到达目的地的路径&lt;/p>
&lt;p>traceroute &lt;a href="https://www.baidu.com" target="_blank" rel="noopener">www.baidu.com&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">traceroute to www.baidu.com (180.101.50.242), 30 hops max, 60 byte packets
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 1 LAPTOP-7CCB4DQK.mshome.net (172.19.208.1) 0.254 ms 0.233 ms 0.224 ms
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 2 172.21.24.1 (172.21.24.1) 9.785 ms 9.779 ms 9.772 ms
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 3 172.28.255.52 (172.28.255.52) 9.766 ms 7.236 ms 9.754 ms
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 4 * * *
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 5 58.213.8.1 (58.213.8.1) 12.624 ms 12.618 ms 12.613 ms
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 6 58.217.231.201 (58.217.231.201) 9.715 ms 58.217.231.217 (58.217.231.217) 8.304 ms 61.155.254.37 (61.155.254.37) 8.291 ms
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 7 * * *
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 8 58.213.95.54 (58.213.95.54) 6.556 ms 58.213.94.222 (58.213.94.222) 7.334 ms 58.213.95.222 (58.213.95.222) 6.338 ms
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 9 * * *
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>1: 第几跳&lt;/li>
&lt;li>2: 路由器的 IP 地址&lt;/li>
&lt;li>3: 三次 ICMP 数据包的延迟时间&lt;/li>
&lt;li>*: 丢包&lt;/li>
&lt;/ul>
&lt;p>测试ip+端口&lt;/p>
&lt;p>telnet &lt;a href="https://www.baidu.com" target="_blank" rel="noopener">www.baidu.com&lt;/a> 80&lt;/p>
&lt;h2 id="日志分析">日志分析&lt;/h2>
&lt;p>如何从日志分析 PV、UV？&lt;/p>
&lt;p>很多时候，我们观察程序是否如期运行，或者是否有错误，最直接的方式就是看运行日志，当然要想从日志快速查到我们想要的信息，前提是程序打印的日志要精炼、精准。&lt;/p>
&lt;p>但日志涵盖的信息远不止于此，比如对于 nginx 的 access.log 日志，我们可以根据日志信息分析用户行为。&lt;/p>
&lt;p>什么用户行为呢？比如分析出哪个页面访问次数（PV）最多，访问人数（UV）最多，以及哪天访问量最多，哪个请求访问最多等等。&lt;/p>
&lt;h3 id="查看日志大小">查看日志大小&lt;/h3>
&lt;p>&lt;code>ls -lh&lt;/code>&lt;/p>
&lt;ul>
&lt;li>l: 列表显示&lt;/li>
&lt;li>h: 显示文件大小&lt;/li>
&lt;li>a: 显示所有文件, 包括隐藏文件&lt;/li>
&lt;/ul>
&lt;p>通过这个查看日志大小后&lt;/p>
&lt;p>如果日志文件数据量太大, 使用cat会导致终端卡死&lt;/p>
&lt;p>可以使用scp传到其他服务器上查看&lt;/p>
&lt;h3 id="用less而不是cat">用less,而不是cat&lt;/h3>
&lt;p>less不会一次性读取整个文件, 而是按需读取, 所以对于大文件来说, less更加高效&lt;/p>
&lt;p>如果想要查看文件的最后几行, 可以使用tail&lt;/p>
&lt;p>如果想要实时查看文件, 可以使用tail -f&lt;/p>
&lt;h3 id="日志分析-pv分析-page-view">日志分析 PV分析 Page View&lt;/h3>
&lt;p>用户访问一个页面就是一次 PV&lt;/p>
&lt;p>对于日志文件来说, 行数可以代表 PV&lt;/p>
&lt;p>Linux统计一个文件有多少行
wc -l filename&lt;/p>
&lt;h3 id="pv分组">PV分组&lt;/h3>
&lt;p>nginx的access.log日志文件中, 有访问时间的西欧模型/&lt;/p>
&lt;p>如果要按时间分组, 可以先把时间提取出来, 然后再统计&lt;/p>
&lt;p>时间在第四列, 可以使用awk提取&lt;/p>
&lt;p>awk &amp;lsquo;{print $4}&amp;rsquo; access.log
输出&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">[10/Dec/2021:10:00:01
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">[10/Dec/2021:10:00:02
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">[10/Dec/2021:10:00:03
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>也可以继续使用awk的substr 函数提取时间&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">awk &amp;#39;{print substr($4, 2, 11)}&amp;#39; access.log
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>输出&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">10/Dec/2021
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">10/Dec/2021
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">10/Dec/2021
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以使用sort排序, 然后使用uniq统计&lt;/p>
&lt;p>uniq -c是统计重复行的次数&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">awk &amp;#39;{print substr($4, 2, 11)}&amp;#39; access.log | sort | uniq -c
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>输出&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl"> 3 10/Dec/2021
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用 uniq -c 命令前，先要进行 sort 排序&lt;/p>
&lt;p>uniq 的去重是基于相邻行的.&lt;/p>
&lt;h3 id="uv分析-unique-visitor">UV分析 Unique Visitor&lt;/h3>
&lt;p>UV是指独立访客数，即一天内访问网站的不同IP地址的人数&lt;/p>
&lt;p>如果要统计UV, 可以使用awk提取IP地址&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">awk &amp;#39;{print $1}&amp;#39; access.log
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="终端分析">终端分析&lt;/h3>
&lt;p>如果要统计不同终端的访问量, 可以使用awk提取终端信息&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">awk &amp;#39;{print $12}&amp;#39; access.log
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="top3请求">TOP3请求&lt;/h3>
&lt;p>如果要统计访问量最多的请求, 可以使用awk提取请求信息
然后使用sort排序, 然后使用uniq统计
最后使用head -n 3查看前三个&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">awk &amp;#39;{print $7}&amp;#39; access.log | sort | uniq -c | sort -nr | head -n 3
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E7%BC%96%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E7%BC%96%E7%A8%8B/</guid><description>&lt;h1 id="linux">Linux&lt;/h1>
&lt;h4 id="五种io模型">五种IO模型&lt;/h4>
&lt;ol>
&lt;li>阻塞式I/O模型：当应用程序调用I/O操作时，如果数据没有准备好，应用程序会一直等待，直到数据准备好为止。&lt;/li>
&lt;li>非阻塞式I/O模型：当应用程序调用I/O操作时，如果数据没有准备好，应用程序会立即返回，不会等待数据准备好。&lt;/li>
&lt;li>I/O复用模型：应用程序使用select、poll或epoll等系统调用来监控多个文件描述符，当有数据准备好时，应用程序会被通知。
&lt;ol>
&lt;li>I/O 多路复用内部需要使用非阻塞 I/O&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>信号驱动式I/O模型：应用程序使用sigaction系统调用来注册一个信号处理函数，当数据准备好时，内核会向应用程序发送一个信号，应用程序在信号处理函数中处理数据。&lt;/li>
&lt;li>异步I/O模型：应用程序调用aio_read或aio_write等异步I/O函数来发起I/O操作，内核会在I/O操作完成后通知应用程序。&lt;/li>
&lt;/ol>
&lt;h4 id="解释同步阻塞">解释同步，阻塞&lt;/h4>
&lt;p>同步是指应用程序在执行某个操作时，必须等待该操作完成后才能继续执行下一步操作。&lt;/p>
&lt;p>阻塞是指应用程序在执行某个操作时，如果该操作不能立即完成，应用程序会被挂起，直到该操作完成为止。&lt;/p>
&lt;p>在阻塞式I/O模型中，应用程序调用I/O操作时，如果数据没有准备好，应用程序会一直等待，直到数据准备好为止，这就是阻塞。而在非阻塞式I/O模型中，应用程序调用I/O操作时，如果数据没有准备好，应用程序会立即返回，这就是非阻塞。&lt;/p>
&lt;h4 id="nio和bio区别">NIO和BIO区别&lt;/h4>
&lt;p>BIO（Blocking I/O）是阻塞式I/O模型，应用程序调用I/O操作时，如果数据没有准备好，应用程序会一直等待，直到数据准备好为止。NIO（Non-blocking I/O）是非阻塞式I/O模型，应用程序调用I/O操作时，如果数据没有准备好，应用程序会立即返回，不会等待数据准备好。&lt;/p>
&lt;h4 id="nio的底层">NIO的底层&lt;/h4>
&lt;p>NIO的底层实现主要包括以下几个部分：&lt;/p>
&lt;ol>
&lt;li>缓冲区：NIO使用缓冲区来存储数据，包括读缓冲区和写缓冲区。&lt;/li>
&lt;li>通道：NIO使用通道来进行数据的读写操作，通道类似于流，但是可以双向传输数据。&lt;/li>
&lt;li>选择器：NIO使用选择器来监控多个通道的状态，当有数据准备好时，选择器会通知应用程序。&lt;/li>
&lt;/ol>
&lt;h3 id="io-多路复用">I/O 多路复用&lt;/h3>
&lt;p>阻塞 I/O，是指进程发起调用后，会被挂起（阻塞），直到收到数据再返回。如果调用一直不返回，进程就会一直被挂起。因此，当使用阻塞 I/O 时，需要使用&lt;strong>多线程来处理多个文件描述符&lt;/strong>。&lt;/p>
&lt;p>多线程切换有一定的开销，因此引入非阻塞 I/O。非阻塞 I/O 不会将进程挂起，调用时会立即返回成功或错误，因此可以在&lt;strong>一个线程里轮询多个文件描述符是否就绪&lt;/strong>。&lt;/p>
&lt;p>但是非阻塞 I/O 的缺点是：&lt;strong>每次发起系统调用，只能检查一个文件描述符&lt;/strong>是否就绪。当文件描述符很多时，系统调用的成本很高。&lt;/p>
&lt;p>因此引入了 I/O 多路复用，可以通过一次系统调用，检查多个文件描述符的状态。这是 I/O 多路复用的主要优点，相比于非阻塞 I/O，在文件描述符较多的场景下，避免了频繁的用户态和内核态的切换，减少了系统调用的开销。&lt;/p>
&lt;p>I/O 多路复用相当于将「遍历所有文件描述符、通过非阻塞 I/O 查看其是否就绪」的过程从用户线程移到了内核中，由内核来负责轮询。&lt;/p>
&lt;p>进程可以通过 select、poll、epoll 发起 I/O 多路复用的系统调用，这些系统调用都是同步阻塞的：如果传入的多个文件描述符中，有描述符就绪，则返回就绪的描述符；否则如果所有文件描述符都未就绪，就阻塞调用进程，直到某个描述符就绪，或者阻塞时长超过设置的 timeout 后，再返回。I/O 多路复用内部使用非阻塞 I/O 检查每个描述符的就绪状态。&lt;/p>
&lt;p>如果 timeout 参数设为 NULL，会无限阻塞直到某个描述符就绪；如果 timeout 参数设为 0，会立即返回，不阻塞。&lt;/p>
&lt;p>I/O 多路复用引入了一些额外的操作和开销，性能更差。&lt;/p>
&lt;p>但是好处是用户可以在一个线程内同时处理多个 I/O 请求。如果不采用 I/O 多路复用，则必须通过多线程的方式，每个线程处理一个 I/O 请求。后者线程切换也是有一定的开销的。&lt;/p>
&lt;h4 id="文件描述符-fd">文件描述符 fd&lt;/h4>
&lt;p>文件描述符（file descriptor）是一个非负整数，从 0 开始。进程使用文件描述符来标识一个打开的文件。&lt;/p>
&lt;p>系统为每一个进程维护了一个文件描述符表，表示该进程打开文件的记录表，而文件描述符实际上就是这张表的索引。当进程打开（open）或者新建（create）文件时，内核会在该进程的文件列表中新增一个表项，同时返回一个文件描述符 —— 也就是新增表项的下标。&lt;/p>
&lt;p>一般来说，每个进程最多可以打开 64 个文件，fd ∈ 0~63。在不同系统上，最多允许打开的文件个数不同，Linux 2.4.22 强制规定最多不能超过 1,048,576。&lt;/p>
&lt;p>每个进程默认都有 3 个文件描述符：0 (stdin)、1 (stdout)、2 (stderr)。&lt;/p>
&lt;h4 id="socket与fd的关系">socket与fd的关系&lt;/h4>
&lt;p>socket 是 Unix 中的术语。socket 可以用于同一台主机的不同进程间的通信，也可以用于不同主机间的通信。一个 socket 包含地址、类型和通信协议等信息，通过 socket() 函数创建：&lt;/p>
&lt;p>int socket(int domain, int type, int protocol)
&lt;strong>返回的就是这个 socket 对应的文件描述符 fd&lt;/strong>。操作系统将 socket 映射到进程的一个文件描述符上，进程就可以通过读写这个文件描述符来和远程主机通信。&lt;/p>
&lt;p>可以这样理解：socket 是进程间通信规则的高层抽象，而 fd 提供的是底层的具体实现。&lt;/p>
&lt;p>&lt;strong>socket 与 fd 是一一对应的&lt;/strong>。&lt;/p>
&lt;p>通过 socket 通信，实际上就是通过文件描述符 fd 读写文件。&lt;/p>
&lt;p>这也符合 Unix“一切皆文件”的哲学。&lt;/p>
&lt;p>在下面的场景下，socket 和 fd 可以视为同义词&lt;/p>
&lt;p>I/O 多路复用内部会遍历集合中的每个文件描述符，判断其是否就绪：&lt;/p>
&lt;p>for fd in read_set
if（ readable(fd) ) // 判断 fd 是否就绪
count++
FDSET(fd, &amp;amp;res_rset) // 将 fd 添加到就绪集合中
break
&amp;hellip;
return count
这里的 readable(fd) 就是一个非阻塞 I/O 调用。试想，如果这里使用阻塞 I/O，那么 fd 未就绪时，select 会阻塞在这个文件描述符上，无法检查下个文件描述符。&lt;/p>
&lt;p>注意：这里说的是 I/O 多路复用的内部实现，而不是说，使用 I/O 多路复用就必须使用非阻塞 I/O，&lt;/p>
&lt;h4 id="select-poll-epoll">select poll epoll&lt;/h4>
&lt;p>select、poll和epoll都是Linux下的I/O多路复用机制，用于监控多个文件描述符，当有数据准备好时，通知应用程序。select和poll是最早的I/O多路复用机制，epoll是Linux内核提供的一种高效的I/O多路复用机制。&lt;/p>
&lt;p>select：select是最早的I/O多路复用机制，它使用一个fd_set结构体来存储所有需要监控的文件描述符，当有数据准备好时，select会返回，应用程序可以通过遍历fd_set结构体来找到数据准备好的文件描述符。&lt;/p>
&lt;p>poll：poll是select的改进版，它使用一个pollfd结构体来存储所有需要监控的文件描述符，当有数据准备好时，poll会返回，应用程序可以通过遍历pollfd结构体来找到数据准备好的文件描述符。&lt;/p>
&lt;p>与select相比，poll的主要优点是可以监控的文件描述符数量更多，但是poll的效率并没有提高。&lt;/p>
&lt;p>epoll：epoll是Linux内核提供的一种高效的I/O多路复用机制，它使用一个内核事件表来存储所有的I/O事件，包括读、写和异常事件等。当有I/O事件发生时，内核会调用注册的回调函数来处理该事件，回调函数可以是用户自定义的函数，也可以是系统提供的函数。与select和poll相比，epoll的主要优点是效率更高，可以监控的文件描述符数量更多。&lt;/p>
&lt;p>简而言之，epoll 有以下几个特点：&lt;/p>
&lt;p>使用红黑树存储文件描述符集合
使用队列存储就绪的文件描述符
每个文件描述符只需在添加时传入一次；通过事件更改文件描述符状态
select、poll 模型都只使用一个函数，而 epoll 模型使用三个函数：epoll_create、epoll_ctl 和 epoll_wait。&lt;/p>
&lt;h4 id="select">select&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">select&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">nfds&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">fd_set&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="k">restrict&lt;/span> &lt;span class="n">readfds&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">fd_set&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="k">restrict&lt;/span> &lt;span class="n">writefds&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">fd_set&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="k">restrict&lt;/span> &lt;span class="n">errorfds&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">struct&lt;/span> &lt;span class="nc">timeval&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="k">restrict&lt;/span> &lt;span class="n">timeout&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>readfds、writefds、errorfds 是三个文件描述符集合。select 会遍历每个集合的前 nfds 个描述符，分别找到可以读取、可以写入、发生错误的描述符，统称为“就绪”的描述符。然后用找到的子集替换参数中的对应集合，返回所有就绪描述符的总数。&lt;/p>
&lt;p>timeout 参数表示调用 select 时的阻塞时长。如果所有文件描述符都未就绪，就阻塞调用进程，直到某个描述符就绪，或者阻塞超过设置的 timeout 后，返回。如果 timeout 参数设为 NULL，会无限阻塞直到某个描述符就绪；如果 timeout 参数设为 0，会立即返回，不阻塞&lt;/p>
&lt;p>fd_set 文件描述符集合&lt;/p>
&lt;p>由于文件描述符 fd 是一个从 0 开始的无符号整数，所以可以使用 fd_set 的二进制每一位来表示一个文件描述符。某一位为 1，表示对应的文件描述符已就绪。&lt;/p>
&lt;p>&lt;strong>比如设 fd_set 长度为 1 字节&lt;/strong>，则一个 fd_set 变量最大可以表示 8 个文件描述符。当 select 返回 fd_set = 00010011 时，表示文件描述符 1、2、5 已经就绪。&lt;/p>
&lt;p>select 的缺点是：&lt;/p>
&lt;ul>
&lt;li>性能开销大
&lt;ul>
&lt;li>每次调用 select 都需要将 fd_set 集合从用户态拷贝到内核.&lt;/li>
&lt;li>select 会遍历所有文件描述符，即使只有少数文件描述符就绪，也会遍历所有文件描述符。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>文件描述符数量有限
&lt;ul>
&lt;li>select 的 fd_set 集合是一个位图，&lt;strong>位图的大小是固定的&lt;/strong>，因此 select 能够监控的文件描述符数量有限。&lt;/li>
&lt;li>一般来说，select 最多只能监控 1024 个文件描述符。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="poll">poll&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">poll&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="nc">pollfd&lt;/span> &lt;span class="n">fds&lt;/span>&lt;span class="p">[],&lt;/span> &lt;span class="n">nfds_t&lt;/span> &lt;span class="n">nfds&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">timeout&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>poll 在用户态通过数组方式传递文件描述符，在内核会转为链表方式存储，没有最大数量的限制.&lt;/p>
&lt;p>性能开销上和 select 类似，都需要将文件描述符集合从用户态拷贝到内核态。但是 poll 的效率并没有提高，因为 poll 仍然需要遍历所有文件描述符。&lt;/p>
&lt;h4 id="epoll">epoll&lt;/h4>
&lt;p>epoll需要使用三个函数：epoll_create、epoll_ctl 和 epoll_wait。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">epoll_create&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">size&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">epoll_ctl&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">epfd&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">op&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">fd&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="nc">epoll_event&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">event&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">epoll_wait&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">epfd&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="nc">epoll_event&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">events&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">maxevents&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">timeout&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>epoll_create 创建一个 epoll 实例，返回一个文件描述符，用于操作 epoll 实例。&lt;/p>
&lt;p>epoll_ctl 用于向 epoll 实例中添加、修改或删除文件描述符。&lt;/p>
&lt;p>epoll_wait 用于等待文件描述符就绪,是主要函数,功能相当于 select 和 poll 的功能。&lt;/p>
&lt;p>epoll 的特点：&lt;/p>
&lt;ul>
&lt;li>epoll 使用红黑树存储文件描述符集合
&lt;ul>
&lt;li>可以快速查找文件描述符。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>epoll 使用队列存储&lt;strong>就绪的文件描述符&lt;/strong>，可以快速找到就绪的文件描述符。&lt;/li>
&lt;li>epoll 只需在添加文件描述符时传入一次，通过事件更改文件描述符状态。&lt;/li>
&lt;/ul>
&lt;p>对于“性能开销大”&lt;/p>
&lt;ul>
&lt;li>epoll_ctl 中为&lt;strong>每个文件描述符指定了回调函数&lt;/strong>，并在就绪时将其加入到就绪列表
&lt;ul>
&lt;li>因此 epoll 不需要像 select 那样遍历检测每个文件描述符，只需要判断就绪列表是否为空即可。这样，在没有描述符就绪时，epoll 能更早地让出系统资源。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="epoll底层实现">epoll底层实现&lt;/h4>
&lt;p>epoll是Linux内核提供的一种高效的I/O多路复用机制，其底层实现主要包括以下几个部分：&lt;/p>
&lt;ol>
&lt;li>内核事件表：epoll使用一个内核事件表来存储所有的I/O事件，包括读、写和异常事件等。&lt;/li>
&lt;li>文件描述符表：epoll使用一个文件描述符表来存储所有需要监控的文件描述符，每个文件描述符都对应一个epoll_event结构体，用于存储该文件描述符上的事件信息。&lt;/li>
&lt;li>回调函数：当有I/O事件发生时，内核会调用注册的回调函数来处理该事件，回调函数可以是用户自定义的函数，也可以是系统提供的函数。&lt;/li>
&lt;/ol>
&lt;h2 id="线程">线程&lt;/h2>
&lt;h3 id="协程">协程&lt;/h3>
&lt;p>协程完全由程序所控制（在用户态执行），带来的好处是性能大幅度的提升。&lt;/p>
&lt;p>协程的使用&lt;/p>
&lt;ul>
&lt;li>计算型的操作，利.用协程来回切换执行，没有任何意义，来回切换并保存状态 反倒会降低性能。&lt;/li>
&lt;li>IO型的操作，利用协程在IO等待时间就去切换执行其他任务，当IO操作结束后再自动回调，那么就会大大节省资源并提供性能，从而实现异步编程（不等待任务结束就可以去执行其他代码）。&lt;/li>
&lt;/ul></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AE%9E%E6%88%98%E6%A2%B3%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AE%9E%E6%88%98%E6%A2%B3%E7%90%86/</guid><description>&lt;h1 id="实战梳理">实战梳理&lt;/h1>
&lt;h2 id="cpu">CPU&lt;/h2>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%ae%9e%e6%88%98%e6%a2%b3%e7%90%86/CPU%e4%b8%89%e7%ba%a7%e7%bc%93%e5%ad%98.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>64位系统中：
寄存器：一次能处理8字节数据
L1缓存：一次能处理64字节数据
L2缓存：一次能处理512字节数据
L3缓存：一次能处理4096字节数据&lt;/p>
&lt;p>分为：&lt;/p>
&lt;ul>
&lt;li>数据缓存&lt;/li>
&lt;li>指令缓存&lt;/li>
&lt;/ul>
&lt;p>提升缓存的命中率 -&amp;gt; 提升程序的性能&lt;/p>
&lt;p>提升数据缓存的命中率&lt;/p>
&lt;ul>
&lt;li>空间局部性: 一旦访问了某个存储单元，很可能在不久之后再次访问附近的存储单元, Cache Line会将附近的存储单元一并加载到缓存中,&lt;/li>
&lt;/ul>
&lt;p>提升指令缓存的命中率&lt;/p>
&lt;ul>
&lt;li>CPU的分支预测机制: 分支预测可以预测到接下来要执行 if 里的指令，还是 else 指令的话，就可以「提前」把这些指令放在指令缓存中，这样 CPU 可以直接从 Cache 读取到指令，于是执行速度就会很快。&lt;/li>
&lt;/ul>
&lt;p>比如&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// arr是随机的
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 操作1
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">100&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 操作
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 操作2 排序
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">sort&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">arr&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">100&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果先进行操作2，再进行操作1. 那么可以进行分支预测，将&lt;code>if (arr[i] &amp;lt; 10)&lt;/code>的指令放入指令缓存中，这样就可以提高指令缓存的命中率。&lt;/p>
&lt;p>提升多核CPU的命中率&lt;/p>
&lt;p>因为L3缓存是共享的，而L1,L2缓存不是共享的.
因此如果因为进程每次被分配到不同的核心上，那么L1,L2缓存的命中率就会降低，因为每次都要重新加载数据到L1,L2缓存中。&lt;/p>
&lt;p>为了防止因为切换到不同的核心，而导致缓存命中率下降的问题，我们可以把线程绑定在某一个 CPU 核心上，这样性能可以得到非常可观的提升&lt;/p>
&lt;p>如: &lt;code>sched_setaffinity&lt;/code> 函数可以将线程绑定到某一个CPU核心上。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;sched.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">sched_setaffinity&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">pid_t&lt;/span> &lt;span class="n">pid&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">size_t&lt;/span> &lt;span class="n">cpusetsize&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="n">cpu_set_t&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">mask&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="cpu缓存一致性">CPU缓存一致性&lt;/h3>
&lt;p>现在 CPU 都是多核的，由于 L1/L2 Cache 是多个核心各自独有的，那么会带来多核心的缓存一致性（Cache Coherence） 的问题，如果不能保证缓存一致性的问题，就可能造成结果错误。&lt;/p>
&lt;p>解决机制:&lt;/p>
&lt;ul>
&lt;li>写传播: 某个 CPU 核心里的 Cache 数据更新时，必须要传播到其他核心的 Cache&lt;/li>
&lt;li>事务的串行化: 某个 CPU 核心里对数据的操作顺序，必须在其他核心看起来顺序是一样的&lt;/li>
&lt;/ul>
&lt;p>基于总线嗅探机制的 MESI 协议，就满足上面了这两点&lt;/p>
&lt;p>总线嗅探方法很简单， CPU 需要每时每刻监听总线上的一切活动，但是不管别的核心的 Cache 是否缓存相同的数据，都需要发出一个广播事件&lt;/p>
&lt;p>整个 MESI 的状态可以用一个有限状态机来表示它的状态流转&lt;/p>
&lt;p>当 Cache Line 状态是「已修改」或者「独占」状态时，修改更新其数据不需要发送广播给其他 CPU 核心，这在一定程度上减少了总线带宽压力&lt;/p>
&lt;ul>
&lt;li>M(Modified): 表示数据已经被修改，且只存在于当前 CPU 的 Cache 中&lt;/li>
&lt;li>E(Exclusive): 表示数据只存在于当前 CPU 的 Cache 中，但是没有被修改&lt;/li>
&lt;li>S(Shared): 表示数据存在于多个 CPU 的 Cache 中，且没有被修改&lt;/li>
&lt;li>I(Invalid): 表示数据无效，需要从内存中重新读取&lt;/li>
&lt;/ul>
&lt;h3 id="伪共享问题">伪共享问题&lt;/h3>
&lt;p>MESI解决了多核CPU的缓存一致性问题，但是还有伪共享问题.&lt;/p>
&lt;p>如果 1 号和 2 号 CPU 核心这样持续交替的分别修改变量 A 和 B，Cache 并没有起到缓存的效果，虽然变量 A 和 B 之间其实并没有任何的关系，但是因为同时归属于一个 Cache Line&lt;/p>
&lt;p>多个线程同时读写同一个 Cache Line 的不同变量时，而导致 CPU Cache 失效的现象称为伪共享&lt;/p>
&lt;p>Linux内核有 __cache_aligned_in_smp 宏，可以解决伪共享问题&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#ifdef __cache_aligned_in_smp
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#define __cacheline_aligned_in_smp __cache_aligned
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#else
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#define __cacheline_aligned_in_smp
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#endif
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>多核系统里, __cache_aligned 是 64 字节，也就是一个 Cache Line 的大小&lt;/p>
&lt;p>防止伪共享现象的发生，可以采用上面的宏定义使得变量在 Cache Line 里是&lt;strong>对齐&lt;/strong>的&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="k">struct&lt;/span> &lt;span class="nc">mystruct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">b&lt;/span> &lt;span class="n">__cacheline_aligned_in_smp&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样就可以保证变量 a 和 b 不会在同一个 Cache Line 里，从而避免伪共享问题&lt;/p>
&lt;h3 id="中断">中断&lt;/h3>
&lt;p>通过查看 /proc/softirqs 的 内容来知晓「软中断」的运行情况，以及 /proc/interrupts 的 内容来知晓「硬中断」的运行情况。&lt;/p>
&lt;p>中断处理程序的上部分和下半部可以理解为：&lt;/p>
&lt;p>上半部直接处理硬件请求，也就是硬中断，主要是负责耗时短的工作，特点是快速执行；
下半部是由内核触发，也就说软中断，主要是负责上半部未完成的工作，通常都是&lt;strong>耗时比较长的事情&lt;/strong>，特点是延迟执行；&lt;/p>
&lt;p>定位软中断 CPU 使用率过高的问题？&lt;/p>
&lt;ul>
&lt;li>通过 &lt;code>top&lt;/code> 命令查看软中断的 CPU 使用率&lt;/li>
&lt;li>通过&lt;code>watch -n 1 cat /proc/softirqs&lt;/code>查看软中断的运行情况&lt;/li>
&lt;/ul>
&lt;h2 id="内存管理">内存管理&lt;/h2>
&lt;h2 id="网络系统">网络系统&lt;/h2>
&lt;h3 id="零拷贝">零拷贝&lt;/h3>
&lt;p>零拷贝（Zero-copy）技术，因为我们没有在内存层面去拷贝数据，也就是说全程没有通过 CPU 来搬运数据，所有的数据都是通过 DMA 来进行传输的&lt;/p>
&lt;p>DMA: 在进行 I/O 设备和内存的数据传输的时候，数据搬运的工作全部交给 DMA 控制器，而 CPU 不再参与任何与数据搬运相关的事情，这样 CPU 就可以去处理别的事务。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%ae%9e%e6%88%98%e6%a2%b3%e7%90%86/%e4%bc%a0%e7%bb%9f%e6%96%87%e4%bb%b6%e4%bc%a0%e8%be%93%e8%bf%87%e7%a8%8b.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>传统的文件传输：&lt;/p>
&lt;ul>
&lt;li>共发生了 4 次用户态与内核态的上下文切换
&lt;ul>
&lt;li>因为发生了两次系统调用，一次是 read() ，一次是 write()&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>发送了 4 次数据拷贝
&lt;ul>
&lt;li>第一次拷贝，把磁盘上的数据拷贝到操作系统内核的缓冲区里，这个拷贝的过程是通过 DMA 搬运的。&lt;/li>
&lt;li>第二次拷贝，把内核缓冲区的数据拷贝到用户的缓冲区里，于是我们应用程序就可以使用这部分数据了，这个拷贝到过程是由 CPU 完成的&lt;/li>
&lt;li>第三次拷贝，把刚才拷贝到用户的缓冲区里的数据，再拷贝到内核的 socket 的缓冲区里，这个过程依然还是由 CPU 搬运的。&lt;/li>
&lt;li>第四次拷贝，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程又是由 DMA 搬运的。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>减少切换次数就要减少系统调用次数&lt;/p>
&lt;p>减少数据拷贝可以通过利用缓存区&lt;/p>
&lt;p>传统的文件传输方式会历经 4 次数据拷贝，而且这里面，「从内核的读缓冲区拷贝到用户的缓冲区里，再从用户的缓冲区里拷贝到 socket 的缓冲区里」，这个过程是没有必要的。&lt;/p>
&lt;p>实现零拷贝的方式：&lt;/p>
&lt;ul>
&lt;li>mmap + write&lt;/li>
&lt;li>sendfile&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%ae%9e%e6%88%98%e6%a2%b3%e7%90%86/mmap%e7%9a%84%e6%96%87%e4%bb%b6%e4%bc%a0%e8%be%93%e8%bf%87%e7%a8%8b.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>mmap() 系统调用函数会直接把内核缓冲区里的数据「映射」到用户空间&lt;/p>
&lt;p>但仍然需要 4 次上下文切换，因为系统调用还是 2 次。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%ae%9e%e6%88%98%e6%a2%b3%e7%90%86/sendfile%e4%bc%a0%e8%be%93%e8%bf%87%e7%a8%8b.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>但上面的仍有CPU参与拷贝.&lt;/p>
&lt;p>SG-DMA (The Scatter-Gather Direct Memory Access)：是一种 DMA 的方式，可以让 DMA 控制器在一个传输过程中，不需要 CPU 的干预，就可以完成多个不连续的数据块的传输。 需要网卡支持.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%ae%9e%e6%88%98%e6%a2%b3%e7%90%86/%e4%bd%bf%e7%94%a8SG-DMA%e7%9c%9f%e6%ad%a3%e7%9a%84%e9%9b%b6%e6%8b%b7%e8%b4%9d.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>只需要 2 次上下文切换和数据拷贝次数，就可以完成文件的传输，而且 2 次的数据拷贝过程，都不需要通过 CPU，2 次都是由 DMA 来搬运。&lt;/p>
&lt;p>零拷贝技术可以把文件传输的性能提高至少一倍以上&lt;/p>
&lt;p>零拷贝的应用:&lt;/p>
&lt;ul>
&lt;li>Kafka&lt;/li>
&lt;/ul>
&lt;h4 id="pagecache-内核缓存区作用">PageCache 内核缓存区作用&lt;/h4>
&lt;p>PageCache 的优点主要是两个：&lt;/p>
&lt;ul>
&lt;li>缓存最近被访问的数据；&lt;/li>
&lt;li>预读功能: 假设 read 方法每次只会读 32 KB 的字节，虽然 read 刚开始只会读 0 ～ 32 KB 的字节，但内核会把其后面的 32～64 KB 也读取到 PageCache(空间局部性)&lt;/li>
&lt;/ul>
&lt;p>但大文件传输的情况下, PageCache 会不起作用，那就白白浪费 DMA 多做的一次数据拷贝，造成性能的降低，即使使用了 PageCache 的零拷贝也会损失性能&lt;/p>
&lt;h4 id="大文件传输">大文件传输&lt;/h4>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%ae%9e%e6%88%98%e6%a2%b3%e7%90%86/%e6%b2%a1%e6%9c%89%e7%bb%95%e8%bf%87PageCache.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>会阻塞read&lt;/p>
&lt;p>在高并发的场景下，针对大文件的传输的方式，应该使用「异步 I/O + 直接 I/O」来替代零拷贝技术&lt;/p>
&lt;p>使用异步I/O来绕开 PageCache 的限制 , 又称 直接 I/O&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%ae%9e%e6%88%98%e6%a2%b3%e7%90%86/%e5%bc%82%e6%ad%a5I/O%e4%bc%a0%e8%be%93%e5%a4%a7%e6%96%87%e4%bb%b6.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>传输文件的时候，我们要根据文件的大小来使用不同的方式：&lt;/p>
&lt;ul>
&lt;li>传输大文件的时候，使用「异步 I/O + 直接 I/O」；&lt;/li>
&lt;li>传输小文件的时候，则使用「零拷贝技术」；&lt;/li>
&lt;/ul>
&lt;p>在 nginx 中，我们可以用如下配置，来根据文件的大小来使用不同的方式：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">location /video/ {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> sendfile on;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> aio on;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> directio 1024m;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当文件大小大于 directio 值后，使用「异步 I/O + 直接 I/O」，否则使用「零拷贝技术」。&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%A0%94/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%A0%94/</guid><description>&lt;h1 id="操作系统基础">操作系统基础&lt;/h1>
&lt;h2 id="第章-计算机系统概述">第⼀章 计算机系统概述&lt;/h2>
&lt;h3 id="01-操作系统的概念定义">01 操作系统的概念（定义）&lt;/h3>
&lt;p>概念（定义）&lt;/p>
&lt;ul>
&lt;li>负责管理协调硬件、软件等计算机资源的⼯作&lt;/li>
&lt;li>为上层⽤户、应⽤程序提供简单易⽤的服务&lt;/li>
&lt;li>是⼀种系统软件&lt;/li>
&lt;/ul>
&lt;p>资源的管理者&lt;/p>
&lt;ul>
&lt;li>处理机管理&lt;/li>
&lt;li>存储管理&lt;/li>
&lt;li>⽂件管理&lt;/li>
&lt;li>设备管理&lt;/li>
&lt;/ul>
&lt;p>命令接⼝&lt;/p>
&lt;ul>
&lt;li>联机命令接⼝：直接在命令⾏输⼊&lt;/li>
&lt;li>脱机命令接⼝：写命令脚本&lt;/li>
&lt;/ul>
&lt;h3 id="02-操作系统的四个特征">02 操作系统的四个特征&lt;/h3>
&lt;p>操作系统的特征
并发（Concurrence）——最基本的特征
概念：指两个或多个事件在同⼀时间间隔内发⽣。这些时间宏观上是同时发⽣
的，微观上是交替发⽣的。
并⾏：指两个或多个事件在同⼀时刻同时发⽣。
单核与多核
单核CPU同⼀时刻只能运⾏⼀个程序，并发执⾏程序
多核CPU同⼀时刻可以执⾏多个程序，并⾏执⾏程序
共享（Sharing）——最基本的特征，⼆者互为存在条件
概念：即资源共享，是指系统中的资源可供内存中多个并发执⾏的进程共同使
⽤。
两种资源共享⽅式
互斥共享⽅式
⼀个时间段内只允许⼀个进程访问该资源啊
例⼦：摄像头，QQ和微信不能同时使⽤
同时访问⽅式
允许⼀个时间段内由多个进程“同时”对他们进⾏访问（宏观同时）
例⼦：发送⽂件、扬声器（真同时）
如果失去并发性，系统中只有⼀个程序正在运⾏，共享性失去意义。
如果失去共享性，QQ和微信不能同时访问硬盘资源，⽆法实现同时发送⽂
件，也就⽆法并发。
虚拟（Virtual）
概念：把⼀个物理上的实体变为若⼲个逻辑上的对应物。物理实体（前者）是实
际存在的，⽽逻辑上对应物（后者）是⽤户感受到的。
虚拟存储器技术，内存划分给多个程序使⽤：虚拟技术中的“空分复⽤技术”
虚拟处理器，处理器被多个程序使⽤：虚拟技术中的“时分复⽤”技术，微观上交
替执⾏。
没有并发性，也就谈不上虚拟性
异步（Asynchronism）
概念：在多道程序环境下，允许多个程序并发执⾏，但由于资源有限，进程的执
⾏不是⼀贯到底的，⽽是⾛⾛停停，以不可预知的速度向前推进。
如果失去并发性，系统只能串⾏执⾏各个程序，当程序执⾏完毕后才会归还。只
有系统拥有并发性，才有可能导致异步性。&lt;/p>
&lt;h3 id="03-os的发展与分类">03 OS的发展与分类&lt;/h3>
&lt;p>⼿⼯操作阶段
纸带
输⼊输出速度较慢，处理速度快，⽤户独占全机，⼈机速度⽭盾，导致资源利⽤率极
低
批处理阶段
单道批处理系统
主要特征
⾃动性，磁带上的作业能⾃动逐个运⾏
顺序性，作业的完成顺序与进⼊内存的顺序应完全相同
单道性，内存中仅有⼀道程序运⾏，即监督程序每次从磁带上只调⼊⼀道程
序进⼊内存运⾏，当该程序完成或发⽣异常时，才换⼊其后继程序进⼊内存运⾏。
外围机
引⼊脱机输⼊/输出技术（⽤外围机+磁带），并由监督程序负责控制作业的输
⼊、输出
监督程序——操作系统的雏形
优点
缓解⼈及速度⽭盾，提升资源利⽤率
缺点
内存中只能有⼀道程序运⾏
CPU有⼤量时间是在空闲等待I/O完成，利⽤率依然较低
多道批处理系统（操作系统开始出现）
优点
多道程序并发执⾏，共享计算机资源。资源利⽤率⼤幅提升，CPU和其他资
源更能保持“忙碌”状态，系统吞吐量增⼤。
缺点
没有⼈机交互功能，提交作业后只能等待计算机处理，⽆法对中间过程进⾏
⼲预，⽐如调试，输⼊参数
⼯作示意图
分时操作系统
概念：计算机以时间⽚为单位轮流为每个⽤户/作业服务，各个⽤户可通过终端与计
算机进⾏交互。
优点
⽤户的请求可以被即时相应，解决了⼈机交互问题。
允许多个⽤户同时使⽤⼀台计算机，并且⽤户对计算机的操作相互独⽴，感受不
到别⼈的存在。
⽤户感觉独占全机
缺点
不能优先处理紧急任务。
操作系统对每个⽤户/作业都是完全公平的，循环地为每个⽤户/作业服务⼀个时
间⽚，不区分任务点⽽紧急⾏。
实时操作系统
计算机系统接收到外部信号后及时进⾏处理，并且要在严格的时限内处理完事件。实
时操作系统的主要特点是及时性和可靠性。
优点
能够响应⼀些紧急任务，某些紧急任务不需时间⽚排队。
硬实时系统
必须在绝对严格的规定时间内完成处理。
（导弹控制系统、⾃动驾驶系统
软实时系统
能接受偶尔违反事件规定
⽹络操作系统
把⽹络中的各个计算机有机地结合起来，实现数据传输等功能。
实现⽹络中各种资源的共享（如⽂件共享）和个台计算机之间的通信。
Windows NT就是⼀种典型的⽹络操作系统，⽹站服务器就可以使⽤。
分布式操作系统
主要特点是：分布性和并⾏性。
系统中各台计算机地位相同，任何⼯作都可以⽤分布在这些计算机上，由它们并⾏、
协同完成这个任务。
个⼈计算机操作系统
Windows XP、MacOS&lt;/p>
&lt;h3 id="04-操作系统的运机制">⭐04 操作系统的运⾏机制&lt;/h3>
&lt;p>程序是如何运⾏的
C语⾔代码➡编译➡机器指令（⼆进制）
CPU执⾏机器指令
两种程序
内核程序
执⾏⼀些特权指令
应⽤程序
只能执⾏⾮特权指令
两种指令
特权指令
如：内存清零指令，这些指令影响重⼤，只允许管理者（操作系统内核）使⽤。
⾮特权指令
如：加法指令、减法指令。
两种处理器状态
⽤于区分此时正在运⾏的是内核程序 or 应⽤程序
内核态（核⼼态、管态）
运⾏的是内核程序
可以执⾏特权指令
⽤户态（⽬态）
运⾏的是应⽤程序
只能执⾏⾮特权指令
如何区分这两种状态？
CPU中的PSW寄存器（程序状态字寄存器），其中有个⼆进制位，1表示“内核
态”，0表示“⽤户态”
⭐两种状态的切换
内核态➡⽤户态
执⾏⼀条特权指令——修改PSW的标志位为⽤户态，操作系统主动让出CPU控
制权
⽤户态➡内核态
由“中断”引发，CPU 硬件⾃动完成变态过程，触发中断信号意味着操作系统
将强⾏夺回CPU的使⽤权&lt;/p>
&lt;h3 id="05-中断和异常">05 中断和异常&lt;/h3>
&lt;p>中断的作⽤
中断会使CPU由⽤户态变为内核态，使操作系统重新夺回对CPU的控制权
如果没⽤中断机制，就⽆法进⾏并发
中断是操作系统内核夺回CPU使⽤权的唯⼀途径
中断的类型
内中断（也称 异常、例外）
与当前执⾏的指令有关，中断信号来源于CPU内部
由某个指令引发的中断
陷阱、陷⼊（trap）
由陷⼊指令引发的，是应⽤程序故意引发的
如：系统调⽤
故障（fault）
由错误条件引起，可能被内核程序修复。
如：缺⻚故障
终⽌（abort）
由致命错误引起，内核程序⽆法修复该错误。
如：整数除0、⾮法使⽤特权指令
外中断（也称 中断）
与当前执⾏的指令⽆关，中断信号来源于CPU外部
时钟中断
由时钟部件发来的中断信号
时钟部件每隔⼀个时间⽚，归给CPU发送⼀个时钟中断信号
I/O中断
由输⼊输出设备发来的中断信号
中断机制的基本原理
不同的中断信号，需要⽤不同的中断处理程序来处理
内中断：CPU在执⾏指令时会检查是否有异常发⽣
外中断：每个指令周期末尾，CPU都会检查是否有外中断信号需要处理。
中断向量表
CPU检测到中断后，根据中断信号的类型去查询中断向量表，找到相应的中断处
理程序（运⾏在 内核态）在内存中的存放位置&lt;/p>
&lt;h3 id="06-系统调">06 系统调⽤&lt;/h3>
&lt;p>什么是系统调⽤？
概念：操作系统提供给应⽤程序（程序员/编程⼈员）使⽤的接⼝，可以理解为⼀种
可供应⽤系统调⽤的特殊函数，应⽤系统可以通过系统调⽤来请求获得操作系统内核
的服务。
程序接⼝由系统调⽤组成。
系统调⽤与库函数的区别
普通应⽤程序
直接进⾏系统调⽤
使⽤库函数（有的库函数会涉及系统调⽤）
编程语⾔
向上提供库函数
或把系统调⽤封装为库函数
操作系统
向上提供系统调⽤
⼩例⼦：为什么系统调⽤是必须的？
⽤户通过系统调⽤请求资源，由操作系统内核进⾏统⼀管理分配，避免混乱。
什么功能要⽤系统调⽤实现？
系统调⽤（按功能分类）
设备管理
完成设备的 请求/释放/启动 等功能
⽂件管理
完成⽂件的 读/写/创建/删除 等功能
进程控制
完成进程的 创建/撤销/阻塞/唤醒 等功能
进程通信
完成进程之间的 消息传递/信号传递 等功能
内存管理
完成内存的 分配/回收 等功能
系统调⽤的过程
传递系统调⽤参数
执⾏陷⼊/trap/访管指令（⽤户态）
内核程序处理系统调⽤（核⼼态）
返回应⽤程序&lt;/p>
&lt;h3 id="07-操作系统的体系结构">07 操作系统的体系结构&lt;/h3>
&lt;p>内核
对系统资源进⾏管理的功能
进程管理
存储器管理
设备管理
时钟管理
利⽤时钟中断实现计时功能
中断处理
原语（设备驱动、CPU切换等）
⼀种特殊的程序，具有原⼦性。这段程序的运⾏不能被中断。
变态的过程是有成本的，消耗时间，频繁地变态会降低系统性能
⾮内核功能
如：GUI
Ubuntu、CentOS主要⼯作是实现⾮内核功能，内核都是使⽤Linux内核
⼤内核
将操作系统的主要功能模块都作为系统内核，运⾏在核⼼态
优点：⾼性能
缺点：内核代码庞⼤，结构混乱，难以维护。
典型的 ⼤内核/宏内核/单内核 操作系统
Linux、Unix
微内核
只把最基本的功能保留在内核
优点：内核功能说好，结构清晰，⽅便维护
缺点：需要频繁地在核⼼态和⽤户态之间切换，性能低
典型的 微内核 操作系统
Windows NT&lt;/p>
&lt;h2 id="第章-进程管理">第⼆章 进程管理&lt;/h2>
&lt;h3 id="01-进程的-概念组成特征">01 进程的 概念、组成、特征&lt;/h3>
&lt;p>概念
进程 和 程序 的区别
程序：是静态的，就是个存放在磁盘⾥的可执⾏⽂件，就是⼀系列的指令集合。
进程（Process）：是动态的，是程序的⼀次执⾏过程。
操作系统如何区分进程
当进程被创建时，操作系统会为该进程分配⼀个唯⼀的、不重复的PID（Process
ID，进程ID）
组成
⼀个进程实体（进程映像）由PCB、程序段、数据段组成
进程是动态的，进程实体是静态的
进程是进程实体的运⾏过程，是系统进⾏资源分配和调度的⼀个独⽴单位。
PCB是进程存在的唯⼀标志！
进程控制块（PCB）
进程描述信息
进程标识符PID
⽤户标识符UID
进程控制和管理信息
CPU、磁盘、⽹络流量使⽤情况统计
进程当前状态：就绪态/阻塞态/运⾏态&amp;hellip;
资源分配清单
正在使⽤哪些⽂件
正在使⽤哪些内存区域
正在使⽤哪些I/O设备
处理机相关信息
PSW、PC等等各种寄存器的值（⽤于实现进程切换）
程序段
三个QQ进程的程序段相同，数据段、PCB不同
数据段
特征
动态性（进程最基本的特征）
进程是程序的⼀次执⾏过程，是动态地产⽣、变化和消亡的。
并发性
内存中有多个进程实体，各进程可并发执⾏
独⽴性
进程是能独⽴运⾏、独⽴获得资源、独⽴接受调度的基本单位
异步性
各进程按各⾃独⽴的、不可预知的速度向前推进，操作系统要提供“进程同步机
制”来解决异步问题。
结构性
每个进程都会配置⼀个PCB。结构上看，进程由程序段、数据段、PCB组成。
02 进程的状态与转换
状态
运⾏状态（Runing）
占有CPU，并在CPU上运⾏
单核CPU同⼀时刻只会有⼀个进程处于运⾏态，多核CPU可能有多个进程处于运
⾏态
就绪状态（Ready）
具备运⾏条件，但由于没有空闲CPU，⽽暂时不能运⾏
阻塞状态（Waiting/Blocked，⼜称：等待态）（三种基本状态）
因等待某⼀事件⽽暂时不能运⾏
创建状态（New，⼜称新建态）
进程正在被创建，操作系统为进程分配资源、初始化PCB
终⽌状态（Terminated，⼜称：结束态）
进程正在从系统中撤销，操作系统会回收进程拥有的资源、撤销PCB
state变量，1表示创建态，2表示就绪态，3表示运⾏态
状态间的转换
就绪态➡运⾏态
进程被调度
运⾏态➡就绪态
时间⽚到
处理机被抢占
运⾏态➡阻塞态
等待系统资源分配
或等待某时间发⽣（进程主动⾏为）
阻塞态➡就绪态
资源分配到位，等待的事件发⽣（被动⾏为），操作系统发起
进程的组织⽅式
链接⽅式
按照进程状态将PCB分为多个队列
操作系统持有指向各个队列的指针
过程
索引⽅式
根据进程状态的不同，建⽴⼏张索引表
操作系统持有指向各个索引表的指针
过程
03 进程控制
基本概念
概念：进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进
程、撤销已有进程、实现进程状态转换等功能。
实质：实现进程状态转换
过程图
如何实现进程控制：⽤“原语”实现
如何实现原语的“原⼦性”
⽤关中断指令和开中断指令这两个特权指令实现原⼦性
进程控制相关的原语
进程的创建
创建原语
申请空⽩PCB
为新进程分配所需资源
初始化PCB
将PCB插⼊就绪队列（创建态➡就绪态）
引起进程创建的事件
⽤户登录
分时系统中，⽤户登录成功，系统会为其建⽴⼀个新的进程
作业调度
多道批处理系统中，有新的作业放⼊内存时，会为其建⽴⼀个新的进程
提供服务
⽤户向操作系统提出某些请求时，会新建⼀个进程处理该请求
应⽤请求
由⽤户进程主动请求创建⼀个⼦进程
进程的终⽌
就绪态/阻塞态/运⾏态➡终⽌态➡⽆
撤销原语
从PCB集合中找到终⽌进程的PCB
若进程正在运⾏，⽴即剥夺CPU，将CPU分配给其他进程
终⽌其所有⼦进程
进程间的关系是树形结构
将该进程拥有的所有资源归还给⽗进程或操作系统
删除PCB
引起进程终⽌的事件
正常结束
进程⾃⼰请求终⽌（exit系统调⽤）
异常结束
整数除0、⾮法使⽤特权指令，然后被操作系统强⾏杀掉
外界⼲预
Ctrl + Alt + delete，⽤户选择杀掉进程
进程的阻塞
阻塞原语（运⾏态➡阻塞态）
找到要阻塞的进程对应的PCB
保护进程运⾏现场，将PCB状态信息设置为“阻塞态”，暂时停⽌进程运⾏
将PCB插⼊响应时间的等待队列
引起进程阻塞的事件
需要等待系统分配某种资源
需要等待相互合作的其他进程完成⼯作
进程的唤醒（成对出现）
唤醒原语（阻塞态➡就绪态）
在事件等待队列中找到PCB
将PCB从等待队列移除，设置进程为就绪态
将PCB插⼊就绪队列，等待被调度
引起进程唤醒的时间
等待事件发⽣（因何事阻塞，就应由何事唤醒）
进程的切换
切换原语（运⾏态➡就绪态、就绪态➡运⾏态）
将运⾏环境信息存⼊PCB
PCB移⼊相应队列
选择另⼀个进程执⾏，并更新其PCB
根据PCB恢复新进程所需的运⾏环境
引起进程切换的事件
当前进程时间⽚到
有更⾼优先的进程到达
当前进程主动阻塞
当前进程终⽌
04 进程通信
进程之间的信息交换
共享存储器系统
设置⼀个共享空间
要互斥地访问共享空间
两种⽅式
基于数据结构的共享（低级）
基于存储区的共享（⾼级）
消息传递系统
进程间的数据交换以格式化的消息（Message）为单位。
进程通过操作系统提供的“发送消息/接收消息”两个原语进⾏数据交换
消息头，消息体
直接通信⽅式
消息直接挂到接收进程的消息缓冲队列上
间接通信⽅式
消息要先发送到中间实体（信箱）中，因此也称（信箱通信⽅式）。
例⼦：电⼦邮件系统
管道通信系统
只能采⽤半双⼯通信，某⼀时间段内只能实现单向的传输
各进程要互斥地访问管道
数据以字节流写⼊管道，当管道写满时，写进程的write()系统调⽤将被阻塞，等待读
进程将数据取⾛。当数据被全部取⾛，管道变空，读进程的read()系统调⽤将被阻
塞。
如果没写满，就不允许读。如果没读空，就不允许写。
数据⼀旦被读出，就被抛弃，因此，读进程最多只能有⼀个
05 线程
什么是线程，为什么要引⼊线程？
线程是⼀个基本的CPU执⾏单元，也是程序执⾏流的最⼩单元。
引⼊线程后，进程之间可以并发，进程内的各线程之间也可以并发
引⼊线程后，进程只作为除CPU之外的系统资源的分配单位
打印机、内存地址空间都是分配给进程的
引⼊线程机制后，有什么变化
资源分配、调度
传统进程机制中，进程是资源分配、调度的基本单位
引⼊线程后，进程是资源分配的基本单位，线程是调度的基本单位
并发性
传统进程机制中，只能进程间并发
引⼊线程后，各线程间也能并发，提⾼了并发度
系统开销
传统的进程间并发，需要切换进程的运⾏环境，系统开销很⼤
线程间并发，如果是统⼀进程内的线程切换，不需要切换进程环境，开销⼩
引⼊线程后，并发所带来的系统开销减⼩
线程有哪些重要的属性
线程是处理机调度的单位
多CPU计算机中，各个线程可占⽤不同的CPU
每个线程都有⼀个线程id，线程控制块（TCB）
线程也有就绪、阻塞、运⾏三种基本状态
线程⼏乎不⽤系统资源
同⼀进程的不同线程间共享进程的资源
由于共享内存地址空间，同⼀进程中的线程间通信甚⾄⽆需系统⼲预
同⼀进程中的线程切换，不会引起进程切换
不同进程中的线程切换，会引起进程切换
切换同进程内的线程，系统开销很⼩
切换进程，系统开销较⼤
06 线程的实现⽅式——多线程模型
线程实现的⽅式
⽤户级线程（User-Level-thread，ULT）
线程库
优点
开销⼩，效率⾼
缺点
如果单个线程被阻塞，整个进程都会被阻塞，并发度不⾼。
多个线程⽆法在多核处理机上并⾏运⾏。
内核级线程
操作系统会为每个内核级线程建⽴相应的TCB (Thread Control Block，线程控制
块)，通过TCB对线程进⾏管理。“内核级线程”就是“从操作系统内核视⻆看能看到
的线程”
优点
当⼀个线程被阻塞后，别的线程还可以继续执⾏，并发能⼒强。
多线程可在多核处理机上并⾏执⾏。
缺点
⼀个⽤户进程会占⽤多个内核级线程，线程切换由操作系统内核完成，需要
切换到核⼼态，因此线程管理的成本⾼，开销⼤。
多线程模型
⼀对⼀模型
⼀个⽤户级线程映射到⼀个内核级线程。每个⽤户进程有与⽤户级线程同数量的
内核级线程。
优点
当⼀个线程被阻塞后，别的线程还可以继续执⾏，并发能⼒强。
多线程可在多核处理机上并⾏执⾏。
缺点
⼀个⽤户进程会占⽤多个内核级线程，线程切换由操作系统内核完成，需要
切换到核⼼态，因此线程管理的成本⾼，开销⼤。
多对⼀模型
多个⽤户级线程映射到⼀个内核级线程。且⼀个进程只被分配⼀个内核级线程。
优点
⽤户级线程的切换在⽤户空间即可完成，不需要切换到核⼼态，线程管理的
系统开销⼩，效率⾼
缺点
当⼀个⽤户级线程被阻塞后，整个进程都会被阻塞，并发度低。多个线程不
可在多核处理机上并⾏运⾏
操作系统只“看得⻅”内核级线程，因此只有内核级线程才是处理机分配的单位。
多对多模型
n⽤户及线程映射到m个内核级线程(n&amp;gt;=m)。每个⽤户进程对应m个内核级线程。
克服了多对⼀模型并发度不⾼的缺点(⼀个阻塞全体阻塞)，⼜克服了⼀对⼀模型
中⼀个⽤户进程占⽤太多内核级线程，开销太⼤的缺点。
⽤户级线程是“代码逻辑”的载体
内核级线程是“运⾏机会”的载体
07 处理机调度概念、层次
处理机调度
基本概念
当有⼀堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定
某种规则来决定处理这些任务的顺序，这就是“调度”研究的问题。
三个层次
⾼级调度（作业调度）
按⼀定的原则从外存的作业后备队列中挑选⼀个作业调⼊内存，并创建进
程，每个作业只调⼊⼀次，调出⼀次。作业调⼊时会建⽴PCB， 调出时才撒
销PCB。
中级调度（内存调度）
按照某种策略决定将哪个处于挂起状态的进程重新调⼊内存。
内存不够时，可将某些进程的数据调出外存。等内存空闲或者进程需要运⾏
时再重新调⼊内存。
暂时调到外存等待的进程状态为挂起状态（挂起态，suspend）。被挂起的进
程PCB会被组织成挂起队列
⾼频
低级调度（进程调度/处理机调度）
按照某种策略从就绪队列中选取⼀⼀个进程，将处理机分配给它。
进程调度是操作系统中最基本的⼀种调度，在⼀般的操作系统中都必须配置
进程调度。
三层调度的联系、对⽐
补充知识
进程的“挂起态”
就绪挂起
阻塞挂起
七状态模型
08 进程调度的时机、切换与过程调度⽅式
时机
什么时候需要进程调度?
主动放弃
进程正常终⽌
运⾏过程中发⽣异常⽽终⽌
进程主动请求阻塞（如等待I/O）
被动放弃
分给进程的时间⽚⽤完
有更紧急的事需要处理（如I/O中断）
有更⾼优先级的进程进⼊就绪队列
什么时候不能进⾏进程调度?
在处理中断的过程中。中断处理过程复杂，与硬件密切相关，很难做到在中断处
理过程中进⾏进程切换。
进程在操作系统内核程序临界区中。
在原⼦操作过程中（原语）。原⼦操作不可中断，要⼀⽓呵成（如之前讲过的修
改PCB中进程状态标志，并把PCB放到相应队列）
2012年联考真题
进程在操作系统内核程序临界区中不能进⾏调度与切换✅
进程处于临界区时不能进⾏处理机调度❌
普通临界区/内核临界区
临界资源
⼀个时间段内只允许⼀个进程使⽤的资源。各进程需要互斥地访问临界资
源。
临界区
访问临界资源的那段代码。
内核程序临界区
⼀般是⽤来访问某种内核数据结构的
如：进程的就绪队列(由各就绪进程的PCB组成)
切换与过程
&amp;ldquo;狭义的调度&amp;quot;与&amp;quot;切换”的区别
狭义的进程调度
指的是从就绪队列中选中⼀个要运⾏的进程。(这 个进程可以是刚刚被暂停执
⾏的进程，也可能是另⼀个进程，后⼀种情况就需要进程切换)
进程切换
指⼀个进程让出处理机，由另⼀个进程占⽤处理机的过程。
⼴义的进程调度包含了选择⼀个进程和进程切换两个步骤。
进程切换的过程需要做什么?
过程
对原来运⾏进程各种数据的保存
对新的进程各种数据的恢复(如:程序计数器、程序状态字、各种数据寄存器等
处理机现场信息，这些信息⼀般保存在进程控制块)
有代价的，如果过于频繁进⾏进程调度、切换，系统的效率会降低。
⽅式
⾮剥夺调度⽅式(⾮抢占式)
⾮剥夺调度⽅式，⼜称⾮抢占⽅式。即，只允许进程主动放弃处理机。在运⾏过
程中即便有更紧迫的任务到达，当前进程依然会继续使⽤处理机，直到该进程终
⽌或主动要求进⼊阻塞态。
实现简单，系统开销⼩但是⽆法及时处理紧急任务，适合于早期的批处理系统
剥夺调度⽅式(抢占式)
剥夺调度⽅式，⼜称抢占⽅式。当⼀个进程正在处理机上执⾏时，如果有⼀个更
重要或更紧迫的进程需要使⽤处理机，则⽴即暂停正在执⾏的进程，将处理机分
配给更重要紧迫的那个进程。
可以优先处理更紧急的进程，也可实现让各进程按时间⽚轮流执⾏的功能( 通过
时钟中断)。适合于分时操作系统、实时操作系统
09 调度算法的评价指标（计算）
CPU利⽤率
指CPU“忙碌”的时间占总时间的⽐例。
利⽤率 = 忙碌的时间/总时间（道/秒）
⽢特图
系统吞吐量
单位时间内完成作业的数量
系统吞吐量 = 总共完成了多少道作业 / 总共花了多少时间
周转时间
周转时间
指从作业被提交给系统开始，到作业完成为⽌的这段时间间隔。
（作业）周转时间 = 作业完成时间 - 作业提交时间
四部分
作业在外存后备队列上等待作业调度(⾼级调度)的时间
进程在就绪队列上等待进程调度( 低级调度)的时间
进程在CPU上执⾏的时间
进程等待I/O操作完成的时间
后三项在⼀个作业的整个处理过程中，可能发⽣多次。
平均周转时间
平均周转时间 = 各作业周转时间之和 / 作业数
带权周转时间
带权周转时间 = 作业周转时间 / 作业实际运⾏的时间
平均带权周转时间
平均带权周转时间 = 各作业带权周转时间之和 / 作业数
等待时间
指进程/作业处于等待处理机状态时间之和。
对于进程来说，等待时间就是指进程建⽴后等待被服务的时间之和，在等待I/O完成
的期间其实进程也是在被服务的，所以不计⼊等待时间。
对于作业来说，不仅要考虑建⽴进程后的等待时间，还要加上作业在外存后备队列中
等待的时间。
调度算法只会影响作业/进程的等待时间。
平均等待时间即各个 进程/作业 等待时间的平均值
响应时间
指从⽤户提交请求到⾸次产⽣响应所⽤的时间。
10 调度算法 先来先服务、最短作业优先、最⾼响应⽐优先
先来先服务（FCFS，First Come First Serve）
算法规则
按照作业/进程到达的先后顺序进⾏服务
⽤于作业/进程调度
⽤于作业调度时，考虑的是哪个作业先到达后备队列
⽤于进程调度时，考虑的是哪个进程先到达就绪队列
⾮抢占式
优点
公平、算法实现简单
缺点
排在⻓作业(进程)后⾯的短作业需要等待很⻓时间，带权周转时间很⼤，对短作
业来说⽤户体验不好。即，FCFS算法对⻓作业有利，对短作业不利
例如：排队买奶茶
最短作业优先（SJF）
思想
追求最少的平均等待时间，最少的平均周转时间、最少的平均平均带权周转时间
算法规则
最短的作业/进程优先得到服务(所谓“最短”，是指要求服务时间最短)
每次调度时选择当前已到达且运⾏时间最短的作业/进程
⽤于作业/进程调度
即可⽤于作业调度，也可⽤于进程调度。
⽤于进程调度时称为“短进程优先(SPF, Shortest Process First)算法
⾮抢占式
SJF和SPF是⾮抢占式的算法。但是也有抢占式的版本——最短剩余时间优先算法(
SRTN, Shortest Remaining Time Next )
最短剩余时间优先算法：每当有进程加⼊就绪队列改变时就需要调度，如果
新到达的进程剩余时间⽐当前运⾏的进程剩余时间更短，则由新进程抢占处
理机，当前运⾏进程重新回到就绪队列。另外，当⼀个进程完成时也需要调
度。
细节
如果未特别说明，短作业/进程优先算法默认是⾮抢占式的
在所有进程都⼏乎同时到达时，采⽤SJF调度算法的平均等待时间、平均周转
时间最少
抢占式的短作业/进程优先调度算法(最短剩余时间优先, SRNT算法)的平均等
待时间、平均周转时间最少”
缺点
对短作业有利，⻓作业不利。
可能产⽣饥饿现象。
最⾼响应⽐优先（HRRN，Highest Reponse Ratio Next）
思想
要综合考虑作业/进程的等待时间和要求服务的时间
算法规则
在每次调度时先计算各个作业/进程的响应⽐，选择响应⽐最⾼的作业/进程为其
服务
响应⽐ = （等待时间 + 要求服务时间）/ 要求服务时间
⽤于作业/进程调度
既可⽤于作业调度，也可⽤于进程调度
是否可抢占
⾮抢占式的算法。因此只有当前运⾏的作业/进程主动放弃处理机时，才需要调
度，才需要计算响应⽐
优缺点
综合考虑了等待时间和运⾏时间(要求服务时间)等待时间相同时，要求服务时间
短的优先(SJF 的优点)要求服务时间相同时，等待时间⻓的优先(FCFS 的优点)对于
⻓作业来说，随着等待时间越来越久，其响应⽐也会越来越⼤，从⽽避免了⻓作
业饥饿的问题
是否饥饿
不会导致饥饿
三种算法的⽐较
适⽤性
适⽤于早起的批处理系统，FCFS算法也常结合其他的算法使⽤
11 调度算法——时间⽚轮转、优先级调度、多级反馈队列
时间⽚轮转调度算法（RR，Round-Robin）
算法规则
按照各进程到达就绪队列的顺序，轮流让各个进程执⾏⼀个时间⽚(如100ms)。若
进程未在⼀个时间⽚内执⾏完，则剥夺处理机，将进程重新放到就绪队列队尾重
新排队。
⽤于作业/进程调度
是否可抢占
若进程未能在时间⽚内运⾏完，将被强⾏剥夺处理机使⽤权，因此时间⽚轮转调
度算法属于抢占式的算法。
由时钟装置发出时钟中断来通知CPU时间⽚已到。
优缺点
不会饥饿
时间⽚过⼤的影响
优先级调度算法
算法思想
随着计算机的发展，特别是实时操作系统的出现，越来越多的应⽤场景需要根据
任务的紧急程度来决定处理顺序。
调度规则
调度时选择优先级最⾼的作业/进程
⽤于作业调度/进程调度
既可⽤于作业调度，也可⽤于进程调度。甚⾄，还会⽤于在之后会学习的I/O调度
中
是否可抢占
抢占式、⾮抢占式都有。做题时的区别在于：⾮抢占式只需在进程主动放弃处理
机时进⾏调度即可，⽽抢占式还需在就绪队列变化时，检查是否会发⽣抢占。
优缺点
优点
⽤优先级区分紧急程度、重要程度，适⽤于实时操作系统。可灵活地调整对
各种作业/进程的偏好程度。
缺点
若源源不断地有⾼优先级进程到来，则可能导致饥
会导致饥饿
多级反馈队列调度算法
算法思想
对其他调度算法的折中权衡
算法规则
设置多级就绪队列，各级队列优先级从⾼到低，时间⽚从⼩到⼤
新进程到达时先进⼊第1级队列，按FCFS原则排队等待被分配时间⽚。若⽤完时
间⽚进程还未结束，则进程进⼊下⼀级队列队尾。如果此时已经在最下级的队
列，则重新放回最下级队列队尾
只有第k级队列为空时，才会为k+1级队头的进程分配时间⽚
抢占式
在k级队列的进程运⾏过程中，若更上级的队列(1~k-1级)中进⼊了⼀个新进程，则
由于新进程处于优先级更⾼的队列中，因此新进程会抢占处理机，原来运⾏的进
程放回k级队列队尾。
优点
对各类型进程相对公平(FCFS的优点) ；
每个新到达的进程都可以很快就得到响应(RR的优点)；
短进程只⽤较少的时间就可完成(SPF的优点) ；
不必实现估计进程的运⾏时间(避免⽤户作假) ;
可灵活地调整对各类进程的偏好程度，⽐如CPU密集型进程、I/0密集型进程(拓
展:可以将因I/O⽽阻塞的进程重新放回原队列，这样I/O型进程就可以保持较⾼优
先级)
会饥饿
综合⽐较
适合于交互式系统，⽐如：Unix
12 进程同步、进程互斥
进程同步
并发性带来了异步性，有时需要通过进程同步解决这种异步问题。
有的进程之间需要相互配合地完成⼯作，各进程的⼯作推进需要遵循- -定的先后顺
序。
进程互斥
对临界资源的访问，需要互斥的进⾏。即同⼀时间段内只能允许⼀个进程访问该资源
四个部分
进⼊区
检查是否可进⼊临界区，若可进⼊，需要“上锁”
临界区
访问临界资源的那段代码
退出区
负责&amp;quot;解锁&amp;rdquo;
剩余区
其余代码部分
需要遵循的原则
空闲让进
临界区空闲时，应允许⼀个进程访问
忙则等待
如临界区正在被访问时， 其他试图访问的进程需要等待
有限等待
要在有限时间内进⼊临界区，保证不会饥饿
让权等待
如进不了 临界区的进程，要释放处理机，防⽌忙等
13 进程互斥的软件实现⽅法
单标志法
算法思想
两个进程在访问完临界区后会把使⽤临界区的权限转交给另⼀个进程。也就是说
每个进程进⼊临界区的权限只能被另⼀个进程赋予。
int turn = 0; //turn表示当前允许进⼊临界区的进程号
同⼀时刻最多只允许⼀个进程访问临界区
双标志先检查
算法思想
设置⼀个布尔型数组flag[]， 数组中各个元素⽤来标记各进程想进⼊临界区的意
愿，⽐如“flag[0] = ture” 意味着0号进程PO现在想要进⼊临界区。每个进程在进⼊
临界区之前先检查当前有没有别的进程想进⼊临界区，如果没有，则把⾃身对应
的标志flag[]设为true,之后开始访问临界区。
双标志后检查
算法思想
双标志先检查法的改版。前⼀个算法的问题是先“检查”后“上锁”，但是这两个操
作⼜⽆法⼀⽓呵成，因此导致了两个进程同时进⼊临界区的问题。因此，⼈们⼜
想到先“上锁”后“检查”的⽅法，来避免上述问题。
优劣
解决了“忙则等待”的问题，违背了“空闲让进”和“有限等待”原则，会产⽣饥饿。
Peterson算法
算法思想
结合双标志法、单标志法的思想。如果双⽅都争着想进⼊临界区，那可以让进程
尝试“孔融让梨”(谦让)。做⼀个有礼貌的进程。
bool flag[2]; // 表示进⼊临界区意愿的数组，初始值都是false
int turn = 0; // turn表示优先让哪个进程进⼊临界区
图解
优劣
⽤软件⽅法解决了进程互斥问题，遵循了空闲让进、忙则等待、有限等待三个原
则，但是依然未遵循让权等待的原则。
14 进程互斥的硬件实现⽅法
中断屏蔽⽅法
使⽤“开关中断”指令实现
优点
简单⾼效
缺点
只适⽤于单处理机
只适⽤于操作系统内核进程
TestAndSet（TS指令/TSL指令）
过程：
old记录是否被上锁
再将lock设为true
检查临界区是否已被上锁（若已上锁，则循环重复前⼏步）
优点
实现简单
适⽤于多处理机环境
缺点
不满⾜“让权等待”
Swap指令（XCHG指令）
同TSL
15 信号量机制
⽤户进程可以通过使⽤操作系统提供的⼀对原语来对信号量进⾏操作，从⽽很⽅便的实
现了进程互斥、进程同步。
信号量其实就是⼀个变量(可以是⼀个整数，也可以是更复杂的记录型变量)，可以⽤
⼀个信号量来表示系统中某种资源的数量，⽐如：系统中只有⼀台打印机，就可以设
置⼀个初值为1的信号量。
原语是⼀种特殊的程序段，其执⾏只能⼀⽓呵成，不可被中断。原语是由关中断/开
中断指令实现的。软件解决⽅案的主要问题是由“进⼊区的各种操作⽆法⼀⽓呵成”，
因此如果能把进⼊区、退出区的操作都⽤“原语”实现，使这些操作能“⼀⽓呵成”就能
避免问题。
⼀对原语：wait(S)原语和signal(S)原语，可以把原语理解为我们⾃⼰写的函数，函数
名分别为wait和signal，括号⾥的信号量S其实就是函数调⽤时传⼊的⼀个参数。
wait、signal 原语常简称为P、V操作(来⾃荷兰语proberen和verhogen)。因此，做题的
时候常把wait(S)、signal(S)两个操作分别写为P(S)、V(S)
整型信号量
⽤⼀个整数型的变量作为信号量，⽤来表示系统中某种资源的数量。
整型信号量与普通整型变量的区别:对信号量只能执⾏初始化、P、V三种操作
存在的问题
不满⾜“让权等待”原则，会发⽣“忙等”
记录型信号量（⾼频考点）
即⽤记录型数据结构表示的信号量。
S.value表示某种资源数, S.L 指向等待该资源的队列
P 操作中，⼀定是先S.value&amp;ndash;，之后可能需要执⾏block原语
V 操作中，⼀定是先S.value++,之后可能需要执⾏wakeup原语
注意
要能够⾃⼰推断在什么条件下需要执⾏block或wakeup
功能
可以⽤记录型信号量实现系统资源的&amp;quot;申请&amp;quot;和&amp;quot;释放&amp;quot;
可以⽤记录型信号量实现进程互斥、进程同步
过程
16 ⽤信号量机制实现进程互斥、同步、前驱关系
⼀个信号量对应⼀种资源
实现进程互斥
过程
分析并发进程的关键活动，划定临界区（如：对临界资源打印机的访问就应该放
在临界区）
设置互斥信号量mutex，初值为1（semaphore mutex = 1; // 初始化信号量，默认
是记录型信号量）
在进⼊区P(mutex)——申请资源
在退出区V(mutex)——释放资源
注意：
对不同的临界资源需要设置不同的互斥信号量。
P、V操作必须成对出现。
实现进程同步
过程
1.分析什么地⽅需要实现“同步关系”，即必须保证“⼀前⼀后”执⾏的两个操作(或
两句代码)
2.设置同步信号量S，初始为0&lt;/p>
&lt;ol>
&lt;li>在“前操作”之后执⾏V(S)
4.在“后操作”之前执⾏P(S)
前V后P
演示
实现进程的前驱关系
过程
要为每⼀对前驱关系各设置⼀个同步信号量
在“前操作”之后对相应的同步信号量执⾏V操作
在“后操作”之前对相应的同步信号量执⾏P操作
实现进程的前驱关系
17 ⽣产者消费者问题
如何实现
⽣产者、消费者共享⼀个初始为空、⼤⼩为n的缓冲区。
只有缓冲区没满时，⽣产者才能把产品放⼊缓冲区，否则必须等待。
只有缓冲区不空时，消费者才能从中取出产品，否则必须等待。
缓冲区是临界资源，各进程必须互斥地访问。
实现图解
思考：能否改变相邻P、V操作的顺序？
会发⽣死锁
实现互斥的P操作⼀定要在实现同步的P操作之后
V操作不会导致进程阻塞，因此，两个V操作顺序可以交换
易错点
实现互斥和实现同步的两个P操作的先后顺序（死锁问题）
两对同步关系
18 多⽣产者-多消费者
加上互斥信号量。互斥的P操作⼀定要在实现同步的P操作之后，否则可能引起“死锁”
解题思路
1.关系分析。找出题⽬中描述的各个进程，分析它们之间的同步、互斥关系。&lt;/li>
&lt;li>整理思路。根据各进程的操作流程确定P、V操作的⼤致顺序。&lt;/li>
&lt;li>设置信号量。设置需要的信号量，并根据题⽬条件确定信号量初值。 (互斥信号量
初值⼀般为1，同步信号量的初始值要看对应资源的初始值是多少)
解决“多⽣产者-多消费者问题”的关键在于理清复杂的同步关系。
在分析同步问题(⼀前⼀后问题)的时候不能从单个进程⾏为的⻆度来分析，要把“⼀前
⼀后”发⽣的事看做是两种“事件”的前后关系。
过程关系
19 吸烟者问题
代码分析
20 读者-写者问题
实现
两种问题的区别与使⽤
21 哲学家进餐问题
每个进程需要同时持有多个临界资源
防⽌死锁的发⽣
⽅案①、②
⽅案③
22 管程
为什么要引⼊管程
信号量机制存在的问题
编写程序困难、易出错
⾼级同步机制
封装的思想
定义
管程是⼀种特殊的软件模块
组成部分&lt;/li>
&lt;li>局部于管程的共享数据结构说明；&lt;/li>
&lt;li>对该数据结构进⾏操作的⼀组过程；&lt;/li>
&lt;li>对局部于管程的共享数据设置初始值的语句；&lt;/li>
&lt;li>管程有⼀个名字。
基本特征&lt;/li>
&lt;li>局部于管程的数据只能被局部于管程的过程所访问;&lt;/li>
&lt;li>⼀个进程只有通过调⽤管程内的过程才能进⼊管程访问共享数据;&lt;/li>
&lt;li>每次仅允许⼀个进程在管程内执⾏某个内部过程。
拓展1：⽤管程解决⽣产者消费者问题
各进程必须互斥访问管程的特性是由编译器实现的
实现⽅法
具体过程&lt;/li>
&lt;li>需要在管程中定义共享数据(如⽣产者消费者问题的缓冲区)&lt;/li>
&lt;li>需要在管程中定义⽤于访问这些共享数据的“⼊⼝”——其实就是⼀-些函数(如⽣
产者消费者问题中，可以定义⼀个函数⽤于将产品放⼊缓冲区，再定义⼀个函数
⽤于从缓冲区取出产品)&lt;/li>
&lt;li>只有通过这些特定的“⼊⼝”才能访问共享数据&lt;/li>
&lt;li>管程中有很多“⼊⼝”，但是每次只能开放其中⼀个“⼊⼝”，并且只能让⼀个进
程或线程进⼊(如⽣产者消费者问题中，各进程需要互斥地访问共享缓冲区。管程
的这种特性即可保证⼀个时间段内最多只会有⼀个进程在访问缓冲区。注意:这种
互斥特性是由编译器负责实现的，程序员不⽤关⼼) 。&lt;/li>
&lt;li>可在管程中设置条件变量及等待/唤醒操作以解决同步问题。可以让⼀个进程或
线程在条件变量上等待(此时，该进程应先释放管程的使⽤权，也就是让出“⼊
⼝”) ；可以通过唤醒操作将等待在条件变量上的进程或线程唤醒。
程序员可以⽤某种特殊的语法来定义⼀个管程monitor，之后其他程序员可以使⽤这
个管程提供的⼊⼝，⽅便实现进程同步/互斥
拓展2：Java中类似于管程的机制
Java中的synchronized
23 死锁的概念
什么是死锁
在并发环境下，各进程因竞争资源⽽造成的⼀种互相等待对⽅⼿⾥的资源，导致各进
程都阻塞，都⽆法向前推进的现象，就是“死锁”。
发⽣死锁后若⽆外⼒⼲涉，这些进程都将⽆法向前推进。
进程死锁、饥饿、死循环的区别
死锁
各进程互相等待对⽅⼿⾥的资源，导致各进程都阻塞，⽆法向前推进的现象。
饥饿
由于⻓期得不到想要的资源，某进程⽆法向前推进的现象。⽐如：在短进程优先
(SPF) 算法中，若有源源不断的短进程到来，则⻓进程将⼀直得不到处理机， 从
⽽发⽣⻓进程“饥饿”。
死循环
某进程执⾏过程中⼀直跳不出某个循环的现象。有时是因为程序逻辑bug导致
的，有时是程序员故意设计的。
三者的区别
死锁产⽣的必要条件
互斥条件
只有对必须互斥使⽤的资源的争抢才会导致死锁(如哲学家的筷⼦、打印机设
备)。像内存、扬声器这样可以同时让多个进程使⽤的资源是不会导致死锁的(因
为进程不⽤阻塞等待这种资源)。
不剥夺条件
进程所获得的资源在未使⽤完之前，不能由其他进程强⾏夺⾛，只能主动释放。
请求和保持条件
进程已经保持了⾄少⼀个资源，但⼜提出了新的资源请求，⽽该资源⼜被其他进
程占有，此时请求进程被阻塞，但⼜对⾃⼰已有的资源保持不放。
循环等待条件
存在⼀种进程资源的循环等待链，链中的每⼀个进程已获得的资源同时被下⼀个
进程所请求。
发⽣死锁时⼀定有循环等待，但是发⽣循环等待时未必死锁
什么时候会发⽣死锁
对不可剥夺资源的不合理分配，可能导致死锁&lt;/li>
&lt;li>对系统资源的竞争。各进程对不可剥夺的资源( 如打印机)的竞争可能引起死锁，对
可剥夺的资源(CPU)的竞争是不会引起死锁的。&lt;/li>
&lt;li>进程推进顺序⾮法。请求和释放资源的顺序不当，也同样会导致死锁。例如，并发
执⾏的进程P1、P2分别申请并占有了资源R1、R2，之后进程P1⼜紧接着申请资源
R2，⽽进程P2⼜申请资源R1,两者会因为申请的资源被对⽅占有⽽阻塞，从⽽发⽣死
锁。
3.信号量的使⽤不当也会造成死锁。如⽣产者-消费者问题中，如果实现互斥的P操作
在实现同步的P操作之前，就有可能导致死锁。( 可以把互斥信号量、同步信号量也看
做是⼀&amp;ldquo;种抽象的系统资源)
死锁的处理逻辑
预防死锁
破坏死锁产⽣的四个必要条件
避免死锁
避免系统进⼊不安全状态（银⾏家算法）
死锁的检测和解除
允许死锁发⽣，系统负责检测出死锁并解除
24 死锁的处理策略——预防死锁（静态策略）
破坏互斥条件
只有对必须互斥使⽤的资源的争抢才会导致死锁。
SPOOLing技术把独占设备在逻辑上改造成共享设备
破坏不剥夺条件
不剥夺条件：
进程所获得的资源在未使⽤完之前，不能由其他进程强⾏夺⾛，只能主动释放。
⽅案⼀
某些资源上位使⽤完，也要主动释放，从⽽破坏不可剥夺条件。
⽅案⼆
当某个进程需要的资源被其他进程所占有的时候，由操作系统协助，将想要的资
源强⾏剥夺。
缺点
实现复杂
可能会造成前⼀阶段⼯作的失效。只适⽤于易保存和恢复状态的资源，如CPU
增加系统开销，降低系统吞吐量
可能导致某个进程饥饿
破坏请求和保持条件
请求和保持条件：
进程已经保持了⾄少⼀个资源，但⼜提出了新的资源请求，⽽该资源⼜被其他进
程占有，此时请求进程被阻塞，但⼜对⾃⼰已有的资源保持不放。
采⽤静态分配⽅法，即进程在运⾏前⼀次申请完它所需要的全部资源，在它的资源未
满⾜前，不让它投⼊运⾏。⼀旦投⼊运⾏后，这些资源就⼀直归它所有， 该进程就
不会再请求别的任何资源了。
缺点
资源利⽤率低。导致某些进程饥饿。
破坏循环等待条件
循环等待条件
存在⼀种进程资源的循环等待链，链中的每⼀- 个进程已获得的资源同时被下⼀
⼀个进程所请求。
可采⽤顺序资源分配法。
⾸先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类
资源(即编号相同的资源)⼀次申请完。
原理分析
⼀个进程只有已占有⼩编号的资源时，才有资格申请更⼤编号的资源。按此规
则，已持有⼤编号资源的进程不可能逆向地回来申请⼩编号的资源，从⽽就不会
产⽣循环等待的现象。
缺点
不⽅便增加新设备
会导致资源浪费
⽤户变成麻烦
25 死锁的处理策略——避免死锁（动态策略）
什么是安全序列
如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要找出⼀个安全序
列，系统就是安全状态，安全序列可能有多个。
什么是系统的不安全状态，与死锁有何联系
如果分配了资源之后，系统中找不出任何⼀个安全序列，系统就进⼊了不安全状态。
可能会导致所有进程都⽆法顺利的执⾏下去，也有可能冲洗你回到安全状态。
如果处于安全状态，就⼀定不会发⽣死锁。如果进⼊不安全状态，可能会导致死锁。
如何避免系统进⼊不安全状态——银⾏家算法
数据结构
⻓度为m的⼀-维数组Available 表示还有多少可⽤资源
n&lt;em>m矩阵Max表示各进程对资源的最⼤需求数
n&lt;/em>m矩阵Allocation表示已经给各进程分配了多少资源
Max-Allocation=Need矩阵表示各进程最多还需要多少资源
⽤⻓度为m的⼀-位数组Request表示进程此次申请的各种资源数
银⾏家算法步骤
①检查此次申请是否超过了之前声明的最⼤需求数
②检查此时系统剩余的可⽤资源是否还能满⾜这次请求
③试探着分配，更改各数据结构
④⽤安全性算法检查此次分配是否会导致系统进⼊不安全状态
安全性算法步骤
检查当前的剩余可⽤资源是否能满⾜某个进程的最⼤需求，如果可以，就把该进
程加⼊安全序列,并把该进程持有的资源全部回收。
不断重复上述过程，看最终是否能让所有进程都加⼊安全序列。
系统处于不安全状态未必死锁，但死锁时⼀定处于不安全状态。系统处于安全状态⼀定
不 会死锁。
26 死锁的处理策略——检测和解除（允许死锁的发⽣）
死锁的检测
数据结构资源分配图
两种结点
进程结点
对应⼀个进程
资源结点
对应⼀类资源，⼀类资源可能有多个
两种边
进程结点——&amp;gt;资源结点
表示进程想申请⼏个资源（每条边代表⼀个）
资源结点——&amp;gt;进程结点
表示已经为进程分配了⼏个资源（每条边代表⼀个）
是否可以消除所有边
检测死锁的算法
1)在资源分配图中，找出既不阻塞⼜不是孤点的进程Pi (即找出⼀条有向边与它相
连，且该有向边对应资源的申请数量⼩于等于系统中已有空闲资源数量。如下图
中，R1没有空闲资源，R2有⼀个空闲资源。若所有的连接该进程的边均满⾜上述
条件，则这个进程能继续运⾏直⾄完成，然后释放它所占有的所有资源)。消去它
所有的请求边和分配边，使之称为孤⽴的结点。在下图中，P1是满⾜这⼀条件的
进程结点，于是将P1的所有边消去。
2)进程Pi所释放的资源，可以唤醒某些因等待这些资源⽽阻塞的进程，原来的阻
塞进程可能变为⾮阻塞进程。在下图中，P2就满⾜这样的条件。根据1)中的⽅法
进⾏⼀系列简化后，若能消去途中所有的边，则称该图是可完全简化的。
死锁定理
如果某时刻系统的资源分配图是不可完全简化的，那么此时系统死锁。
死锁的解除
⼀旦检测出死锁的发⽣，就应该⽴即解除死锁
并不是系统中所有的进程都是死锁状态。⽤死锁检测算法化简资源分配图后，还连着
边的那些进程就是死锁进程
解除死锁的主要⽅法有&lt;/li>
&lt;li>资源剥夺法。挂起( 暂时放到外存上)某些死锁进程，并抢占它的资源，将这些
资源分配给其他的死锁进程。但是应防⽌被挂起的进程⻓时间得不到资源⽽饥
饿。&lt;/li>
&lt;li>撤销进程法(或称终⽌进程法)。强制撤销部分、甚⾄全部死锁进程，并剥夺这
些进程的资源。这种⽅式的优点是实现简单，但所付出的代价可能会很⼤。因为
有些进程可能已经运⾏了很⻓时间，已经接近结束了，⼀旦被终⽌可谓功亏⼀
篑，以后还得从头再来。&lt;/li>
&lt;li>进程回退法。让⼀个或多个死锁进程回退到⾜以避免死锁的地步。这就要求系
统要记录进程的历史信息，设置还原点。
如何决定“对谁动⼿”
1.进程优先级
2.已执⾏多⻓时间
3.还要多久能完成
4.进程已经使⽤了多少资源
5.进程是交互式的还是批处理式的
第三章 内存管理
01 内存的基础知识
什么是内存，有何作⽤
内存可存放数据。
程序执⾏前需要先放到内存中才能被CPU处理——缓冲CPU与硬盘之间的速度⽭盾
按字节编址
每个存储单元⼤⼩为1字节
按字编址
如果字⻓为16位，按字编址，每个存储单元⼤⼩为1个字；16个⼆进制位
进程运⾏的基本原理
指令的⼯作原理
操作码+参数
MOV, A, B
逻辑地址VS物理地址
相对地址
绝对地址
如何实现地址转换
装⼊的三种⽅式
绝对装⼊
编译时产⽣绝对地址
可重定位装⼊（静态重定位）
⼀次分配完所需要的内存空间
动态运⾏时装⼊（动态重定位）
动态重定位
重定位寄存器
从写程序到程序运⾏的过程
编译
由编译程序将⽤户源代码编译成若千个⽬标模块(编译就是把⾼级语⾔翻译为
机器语⾔)
链接
由链接程序将编译后形成的⼀-组⽬标模块，以及所需库函数链接在⼀起，形
成-⼀个完整的装⼊模块
装⼊(装载)
由装⼊程序将装⼊模块装⼊内存运⾏
链接的三种⽅式
静态链接
在程序运⾏之前，先将各⽬标模块及它们所需的库函数连接成⼀个完整的可
执⾏⽂件(装⼊模块) ，之后不再拆开。
装⼊时动态链接
将各⽬标模块装⼊内存时，边装⼊边链接的链接⽅式。
运⾏时动态链接
在程序执⾏中需要该⽬标模块时，才对它进⾏链接。其优点是便于修改和更
新，便于实现对⽬标模块的共享。
02 内存管理的概念
内存空间的分配与回收
内存空间的扩充
地址转换
逻辑地址与物理地址的转换
三种装⼊⽅式
绝对装⼊（单道程序阶段，⽆操作系统）
编译时产⽣绝对地址
可重定位装⼊（早期多道批处理阶段）
装⼊时将逻辑地址转换为物理地址
动态运⾏时装⼊（现代操作系统）
运⾏时将逻辑地址转换为物理地址，需设置重定位寄存器
存储保护
保证各进程在⾃⼰的内存空间内运⾏，不会越界访问
两种⽅式
设置上下限寄存器
利⽤重定位寄存器、界地址寄存器进⾏判断
03 覆盖与交换（内存空间的扩充）
覆盖技术
解决 程序⼤⼩超过物理内存总和
必须由程序员声明覆盖结构，操作系统完成⾃动覆盖。
缺点
对⽤户不透明，增加了⽤户编程负担
交换（对换）技术
内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运⾏条
件的进程换⼊内存(进程在内存与磁盘间动态调度)
中级调度（内存调度）
决定将哪个处于挂起状态的进程重新调⼊内存
在外存的什么位置保存被换出的进程
具有对换功能的操作系统中，通常把磁盘空间分为⽂件区和对换区两部分。
⽂件区
主要⽤于存放⽂件，主要追求存储空间的利⽤率，因此对⽂件区空间的管理
采⽤离散分配⽅式。
对换区
对换区空间只占磁盘空间的⼩部分，被换出的进程数据就存放在对换区。由
于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求
换⼊换出速度，因此通常对换区采⽤连续分配⽅式( 学过⽂件管理章节后即可
理解)。总之，对换区的I/O速度⽐⽂件区的更快。
什么时候交换
内存吃紧时进⾏，系统负荷降低就暂停
例如
在发现许多进程运⾏时经常发⽣缺⻚，就说明内存紧张，此时可以换出⼀些
进程:
如果缺⻚率明显下降，就可以暂停换出。
应该换出哪些进程
优先换出阻塞进程
可换出优先级低的进程
防⽌优先级低的进程在被调⼊内存后很快被换出，还需考虑进程在内存的驻留时
间
PCB会常驻内存
虚拟存储技术
04 连续分配管理⽅式
单⼀连续分配
内存被分为系统区、⽤户区
内存中只能有⼀道⽤户程序，⽤户程序独占整个⽤户区
优点
实现简单
⽆外部碎⽚
可以采⽤覆盖技术扩充内存
不⼀定需要采取内存保护
缺点
只能⽤于单⽤户、单任务操作系统
有内部碎⽚（有些内部空间没有被利⽤到）
存储利⽤率极低
固定分区分配
分区⼤⼩相等
缺乏灵活性，适⽤于⼀台计算机控制多个相同对象的场合
将程序分段
固定区
调⼊后就不再调出，直⾄运⾏结束
覆盖区
覆盖区中的程序段在运⾏过程中会根据需要调⼊调出
分区⼤⼩不等
增加了灵活性，满⾜不同⼤⼩的进程需求，操作系统根据作业⼤⼩情况进⾏划分
⽆外部碎⽚，有内部碎⽚
动态分区分配
根据进程⼤⼩动态地建⽴分区
分区的⼤⼩和数⽬是可变的
采⽤什么数据结构记录内存的使⽤情况
空闲分区表
空闲分区链
动态分区分配算法
动态分区分配没有内部碎⽚，但是有外部碎⽚
内部碎⽚，分配给某进程的内存区域中，有些部分没有⽤上
外部碎⽚，内存中的某些空闲分区由于太⼩⽽难以利⽤
外部碎⽚可⽤“紧凑”技术来解决
回收内存的四种情况
回收区之后有相邻的空闲分区
回收区之前有相邻的空闲分区
回收区前、后都有相邻的空闲分区
回收区前、后都没有相邻的空闲分区
05 动态分区分配算法
⾸次适应算法（FF，First Fit）
算法思想
每次都从低地址开始查找，找到第⼀个能满⾜⼤⼩的空闲分区。
如何实现
空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链(或空闲分
区表)，找到⼤⼩能满⾜要求的第⼀个空闲分区。
最佳适应算法（BF，Best Fit）
算法思想
由于动态分区分配是⼀种连续分配⽅式，为各进程分配的空间必须是连续的⼀整
⽚区域。因此为了保证当“⼤进程”到来时能有连续的⼤⽚空间，可以尽可能多地
留下⼤⽚的空闲区即，优先使⽤更⼩的空闲区。
如何实现
空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链( 或空闲分
区表)，找到⼤⼩能满⾜要求的第⼀个空闲分区。
缺点
每次都选最⼩的分区进⾏分配，会留下越来越多的、很⼩的、难以利⽤的内存
块。因此这种⽅法会产⽣很多的外部碎⽚。
最坏适应算法（WF，Worst Fit）
⼜称最⼤适应算法（Largest Fit）
算法思想
为了解决最佳适应算法的问题⼀&amp;mdash;即留下太多难以利⽤的⼩碎⽚，可以在每次分
配时优先使⽤最⼤的连续空闲区，这样分配后剩余的空闲区就不会太⼩，更⽅便
使⽤。
如何实现
空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区
表)，找到⼤⼩能满⾜要求的第⼀个空闲分区。
邻近适应算法（NF，Next Fit）
算法思想
如何实现
优点
⾸次适应算法效果最好
⽐较
06 基本分⻚存储管理的基本概念
内存空间的分配与回收
连续分配管理⽅式
连续分配：为⽤户进程分配的必须是⼀⼀个连续的内存空间。
⾮连续分配管理⽅式
⾮连续分配：为⽤户进程分配的可以是-⼀些分散的内存空间。
基本分⻚存储管理
什么是分⻚存储
内存空间分为⼀个个⼤⼩相等的分区，每个分区就是⼀个“⻚框”（⻚框=
⻚帧=内存块=物理块=物理⻚⾯）。每个⻚框有⼀个编号，即“⻚框
号”（⻚框号=⻚帧号=内存块号=物理块号=物理⻚号），⻚框号从0开
始。
将进程的逻辑地址空间也分为与⻚框⼤⼩相等的⼀个个部分，每个部分
称为⼀个“⻚”或“⻚⾯”。每个⻚⾯也有⼀个编号，即“⻚号”，⻚号也是从
0开始
进程的⻚⾯与内存的⻚框有⼀⼀对应的关系。
各个⻚⾯不必连续存放，可以放到不相邻的各个⻚框中。
易混淆
⻚、⻚⾯ vs ⻚框、⻚帧、物理⻚；
⻚号、⻚⾯号 vs ⻚框号、⻚帧号、物理⻚号
⻚表
⻚表通常存在PCB中
⼀个进程对应⼀张⻚表
进程的每个⻚⾯对应⼀个⻚表项
每个⻚表项由“⻚号”和“块号”组成
⻚表记录进程⻚⾯和实际存放的内存块之间的映射关系
具体关系图
已知内存⼤⼩，⻚⾯⼤⼩，计算每个⻚表项需要多⼤
内存⼤⼩/⻚⾯⼤⼩，换算为⽐特位，再转换为字节
计算⽅法
如何实现地址转换&lt;/li>
&lt;li>计算出逻辑地址对应的【⻚号，业内偏移量】&lt;/li>
&lt;li>找到对应⻚⾯在内存中的存放位置（查⻚表）&lt;/li>
&lt;li>物理地址 = ⻚⾯始址 + ⻚内偏移量
逻辑地质结构——可拆分为【⻚号P，⻚内偏移量W】
⻚号 = 逻辑地址 / ⻚⾯⼤⼩；
⻚内偏移量 = 逻辑地址 % ⻚⾯⼤⼩
如果⻚⾯⼤⼩刚好是2的整数次幂呢
结论:如果每个⻚⾯⼤⼩为2^K B，⽤⼆进制数表示逻辑地址，则末尾
K位即为⻚内偏移量，其余部分就是⻚号
基本地址变换机构【⻅P7】
基本分段存储管理
段⻚式存储管理
内存空间的扩充
地址转换
存储保护
07 基本地址变换机构
⻚表寄存器的作⽤
存放⻚表起始地址
存放⻚表⻓度
⚡地址变换过程&lt;/li>
&lt;li>根据逻辑地址算出⻚号、⻚内偏移量&lt;/li>
&lt;li>⻚号的合法性检查(与⻚表⻓度对⽐)&lt;/li>
&lt;li>若⻚号合法，再根据⻚表起始地址、⻚号找到对应⻚表项&lt;/li>
&lt;li>根据⻚表项中记录的内存块号、⻚内偏移量得到最终的物理地址&lt;/li>
&lt;li>访问物理内存对应的内存单元
其他⼩细节
⻚内偏移量位数与⻚⾯⼤⼩之间的关系(要能⽤其中⼀个条件推出另⼀个条件)
⻚式管理中地址是⼀维的
实际应⽤中，通常使-个⻚框恰好能放⼊整数个⻚表项
为了⽅便找到⻚表项，⻚表- -般是放在连续的内存块中的
08 具有快表的地址变换机构
什么是快表（TLB）
快表，⼜称联想寄存器(TLB， translation lookaside buffer)，是⼀种访问速度⽐内存快
很多的⾼速缓存(TLB不是内存! )，⽤来存放最近访问的⻚表项的副本，可以加速地址
变换的速度。与此对应，内存中的⻚表常称为慢表。
引⼊快表后，地址的变换过程
①CPU给出逻辑地址，由某个硬件算得⻚号、⻚内偏移量，将⻚号与快表中的所有⻚
号进⾏⽐较。
②如果找到匹配的⻚号，说明要访问的⻚表项在快表中有副本，则直接从中取出该⻚
对应的内存块号，再将内存块号与⻚内偏移量拼接形成物理地址，最后，访问该物理
地址对应的内存单元。因此，若快表命中，则访问某个逻辑地址仅需⼀次访存即可。
③如果没有找到匹配的⻚号，则需要访问内存中的⻚表，找到对应⻚表项，得到⻚⾯
存放的内存块号，再将内存块号与⻚内偏移量拼接形成物理地址，最后，访问该物理
地址对应的内存单元。因此，若快表未命中，则访问某个逻辑地址需要两次访存(注
意:在找到⻚表项后，应同时将其存⼊快表，以便后⾯可能的再次访问。但若快表已
满，则必须按照⼀-定 的算法对旧的⻚表项进⾏替换)
局部性原理
时间局部性
如果执⾏了程序中的某条指令，那么不久后这条指令很有可能再次执⾏;如果某个
数据被访问过，不久之后该数据很可能再次被访问。( 因为程序中存在⼤量的循
环)
空间局部性
⼀旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访
问。(因为很 多数据在内存中都是连续存放的)
对⽐图
09 两级⻚表
单级⻚表存在什么问题?如何解决?
所有⻚表项必须连续存放，⻚表过⼤时需要很⼤的连续空间
在⼀段时间内并⾮所有⻚⾯都⽤得到，因此没必要让整个⻚表常驻内存
两级⻚表
将⻓⻓的⻚表再分⻚
逻辑地址结构: 【⼀级⻚号，⼆级⻚号，⻚内偏移量】
注意⼏个术语:⻚⽬录表/外层⻚表/顶级⻚表
如何实现地址变换?
①按照地址结构将逻辑地址拆分成三部分
②从PCB中读出⻚⽬录表始址，根据⼀级⻚号查⻚⽬录表，找到下⼀级⻚表在内存中
的存放位置
③根据⼆级⻚号查表，找到最终想访问的内存块号
④结合⻚内偏移量得到物理地址
两级⻚表问题需要注意的⼏个细节
多级⻚表中，各级⻚表的⼤⼩不能超过⼀个⻚⾯。若两级⻚表不够，可以分更多级
多级⻚表的访存次数(假设没有快表机构) ——N 级⻚表访问⼀个逻辑地址需要N+ 1次访
存
10 基本分段存储管理⽅式
什么是分段(类似于分⻚管理中的&amp;quot;分⻚&amp;rdquo;)
将地址空间按照程序⾃身的逻辑关系划分为若⼲个段，每段从0开始编址
每个段在内存中占据连续空间，但各段之间可以不相邻
逻辑地址结构：【段号， 段内地址】
什么是段表(类似于分⻚管理中的&amp;quot;⻚表&amp;quot;)
记录逻辑段到实际存储地址的映射关系
每个段对应-个段表项。各段表项⻓度相同，由段号(隐含)段⻓、基址组成
如何实现地址变换&lt;/li>
&lt;li>由逻辑地址得到段号、段内地址&lt;/li>
&lt;li>段号与段表寄存器中的段⻓度⽐较，检查是否越界&lt;/li>
&lt;li>由段表始址、段号找到对应段表项&lt;/li>
&lt;li>根据段表中记录的段⻓，检查段内地址是否越界&lt;/li>
&lt;li>由段表中的“基址+段内地址”得到最终的物理地址&lt;/li>
&lt;li>访问⽬标单元
分段、分⻚管理的对⽐
分⻚对⽤户不可⻅，分段对⽤户可⻅
分⻚的地址空间是⼀维的，分段的地址空间是⼆维的
分段更容易实现信息的共享和保护(纯代码可重⼊代码可以共享)
分⻚(单级⻚表)、 分段访问⼀个逻辑地址都需要两次访存，分段存储中也可以引⼊快
表机构
11 段⻚式管理⽅式
分⻚、分段管理⽅式中最⼤的优缺点
将地址空间按照程序⾃身的逻辑关系划分为若⼲个段，在将各段分为⼤⼩相等的⻚⾯
将内存空间分为与⻚⾯⼤⼩相等的⼀个个内存块，系统以块为单位为进程分配内存
逻辑地址结构:【段号，⻚号，⻚内偏移量】
分段 + 分⻚的结合——段⻚式管理⽅式
每个段对应⼀个段表项。各段表项⻓度相同，由段号(隐含)、⻚表⻓度、⻚表存放地
址组成
每个⻚对应⼀个⻚表项。各⻚表项⻓度相同，由⻚号(隐含)、⻚⾯存放的内存块号组
成
段表、⻚表&lt;/li>
&lt;li>由逻辑地址得到段号、⻚号、⻚内偏移量&lt;/li>
&lt;li>段号与段表寄存器中的段⻓度⽐较，检查是否越界&lt;/li>
&lt;li>由段表始址、段号找到对应段表项&lt;/li>
&lt;li>根据段表中记录的⻚表⻓度，检查⻚号是否越界&lt;/li>
&lt;li>由段表中的⻚表地址、⻚号得到查询⻚表，找到相应⻚表项&lt;/li>
&lt;li>由⻚⾯存放的内存块号、⻚内偏移量得到最终的物理地址&lt;/li>
&lt;li>访问⽬标单元
如何实现地址变换
第⼀次——查段表、第⼆次——查⻚表、第三次——访问⽬标单元
可引⼊快表机构，以段号和⻚号为关键字查询快表，即可直接找到
最终的⽬标⻚⾯存放位置。引⼊快表后仅需-次访存
12 虚拟内存的基本概念
传统存储管理⽅式的特征、缺点
⼀次性
作业必须⼀次性全部装⼊内存后才能开始运⾏。这会造成两个问题：
①作业很⼤时，不能全部装⼊内存，导致⼤作业⽆法运⾏；
②当⼤量作业要求运⾏时，由于内存⽆法容纳所有作业，因此只有少量作业能运
⾏，导致多道程序并发度下降。
驻留性
⼀旦作业被装⼊内存，就会⼀直驻留在内存中，直⾄作业运⾏结束。事实上，在
⼀个时间段内，只需要访问作业的⼀⼩部分数据即可正常运⾏，这就导致了内存
中会驻留⼤量的、暂时⽤不到的数据，浪费了宝贵的内存资源。
局部性原理
时间局部性
现在访问的指令、数据在不久后很可能会被再次访问
空间局部性
现在访问的内存单元周围的内存空间，很可能在不久后会被访问
⾼速缓存技术
使⽤频繁的数据放到更⾼速的存储器中
虚拟内存的定义和特征
定义
程序不需全部装⼊即可运⾏，运⾏时根据需要动态调⼊数据，若内存不够，还需
换出⼀些数据。
多次性：⽆需在作业运⾏时⼀次性全部装⼊内存，⽽是允许被分成多次调⼊内存。
对换性：在作业运⾏时⽆需⼀直常驻内存，⽽是允许在作业运⾏过程中，将作业换
⼊、换出。
虚拟性：从逻辑上扩充了内存的容量，使⽤户看到的内存容量，远⼤于实际的容量。
如何实现虚拟内存技术
借助离散分配的内存管理⽅式（基本分⻚存储管理、基本分段、基本段⻚式）
访问的信息不在内存时，由操作系统负责将所需信息从外存调⼊内存(请求调⻚功能)
内存空间不够时，将内存中暂时⽤不到的信息换出到外存(⻚⾯置换功能)
虚拟内存的实现
请求分⻚存储管理
请求调⻚
⻚⾯置换
请求分段存储管理
请求调段
段置换
请求段⻚式存储管理
13 请求分⻚管理⽅式
⻚表机制
在基本分⻚的基础上增加了⼏个表项
状态位：表示⻚⾯是否已在内存中
访问字段：记录最近被访问过⼏次，或记录上次访问的时间，供置换算法选择换出⻚
⾯时参考
修改位：表示⻚⾯调⼊内存后是否被修改过，只有修改过的⻚⾯才需在置换时写回外
存
外存地址：⻚⾯在外存中存放的位置
缺⻚中断机构
找到⻚表项后检查⻚⾯是否已在内存，若没在内存,产⽣缺⻚中断
缺⻚中断处理中，需要将⽬标⻚⾯调⼊内存，有必要时还要换出⻚⾯
缺⻚中断属于内中断，属于内中断中的“故障&amp;quot;，即可能被系统修复的异常
⼀条指令在执⾏过程中可能产⽣多次缺⻚中断
地址变换机构
找到⻚表项是需要检查⻚⾯是否在内存中
若⻚⾯不再内存中，需要请求调⻚
若内存空间不够，还需换出⻚⾯
⻚⾯调⼊内存后，需要修改相应⻚表项
14 ⻚⾯置换算法
最佳置换算法(OPT)
最佳置换算法(OPT, Optimal) :每次选择淘汰的⻚⾯将是以后永不使⽤，或者在最⻓时
间内不再被访问的⻚⾯，这样可以保证最低的缺⻚率。
最佳置换算法可以保证最低的缺⻚率，但实际上，只有在进程执⾏的过程中才能知道
接下来会访问到的是哪个⻚⾯。操作系统⽆法提前预判⻚⾯访问序列。因此，最佳置
换算法是⽆法实现的。
先进先出置换算法(FIFO)
先进先出置换算法(FIFO) ：每次选择淘汰的⻚⾯是最早进⼊内存的⻚⾯
实现⽅法:把调⼊内存的⻚⾯根据调⼊的先后顺序排成⼀⼀个队列， 需要换出⻚⾯时
选择队头⻚⾯即可。队列的最⼤⻓度取决于系统为进程分配了多少个内存块。
Belady异常——当为进 程分配的物理块数增⼤时，缺⻚次数不减反增的异常现象。
只有FIFO算法会产⽣Belady异常。另外，FIFO算法 虽然实现简单，但是该算法与进程
实际运⾏时的规律不适应，因为先进⼊的⻚⾯也有可能最经常被访问。因此，算法性
能差
最近最久未使⽤置换算法(LRU)
最近最久未使⽤置换算法(LRU， least recently used)：每次淘汰的⻚⾯是最近最久未
使⽤的⻚⾯
实现⽅法:赋予每个⻚⾯对应的⻚表项中，⽤访问字段记录该⻚⾯⾃上次被访问以来
所经历的时间t。
当需要淘汰：⼀个⻚⾯时，选择现有⻚⾯中t值最⼤的，即最近最久未使⽤的⻚⾯。
时钟置换算法(CLOCK)
时钟置换算法是⼀种性能和开销较均衡的算法，⼜称CLOCK算法，或最近未⽤算法
(NRU，Not Recently Used)
简单的CLOCK算法实现⽅法：为每个⻚⾯设置⼀个访问位，再将内存中的⻚⾯都通过
链接指针链接成⼀个循环队列。
当某⻚被访问时，其访问位置为1。
当需要淘汰⼀个⻚⾯时，只需检查⻚的访问位。
如果是0，就选择该⻚换出；
如果是1，则将它置为0，暂不换出，继续检查下⼀个⻚⾯，若第⼀轮扫描中
所有⻚⾯都是1，则将这些⻚⾯的访问位依次置为0后，再进⾏第⼆轮扫描(第
⼆轮扫描中⼀定会有访问位为0的⻚⾯，因此简单的CLOCK算法选择⼀个淘汰
⻚⾯最多会经过两轮扫描)
改进型的时钟置换算法
简单的时钟置换算法仅考虑到⼀个⻚⾯最近是否被访问过。事实上，如果被淘汰的⻚
⾯没有被修改过，就不需要执⾏I/0操作写回外存。只有被淘汰的⻚⾯被修改过时，才
需要写回外存。
因此，除了考虑⼀个⻚⾯最近有没有被访问过之外，操作系统还应考虑⻚⾯有没有被
修改过。在其他条件都相同时，应优先淘汰没有修改过的⻚⾯，避免I/O操作。这就
是改进型的时钟置换算法的思想。修改位=0，表示⻚⾯没有被修改过;修改位=1， 表
示⻚⾯被修改过。
为⽅便讨论，⽤(访问位，修改位)的形式表示各⻚⾯状态。如(1，1)表示⼀个⻚⾯近
期被访问过,且被修改过。
算法规则
⼏种置换算法的⽐较
15 ⻚⾯分配策略
驻留集
驻留集
指请求分⻚存储管理中给进程分配的物理块的集合。
在采⽤了虚拟存储技术的系统中，驻留集⼤⼩⼀般⼩于进程的总⼤⼩。
若驻留集太⼩，会导致缺⻚频繁，系统要花⼤量的时间来处理缺⻚，实际⽤于进
程推进的时间很少；
驻留集太⼤，⼜会导致多道程序并发度下降，资源利⽤率降低。所以应该选择⼀
个合适的驻留集⼤⼩。
固定分配：操作系统为每个进程分配- -组固定数⽬的物理块，在进程运⾏期间不再改
变。即，驻留集⼤⼩不变
可变分配：先为每个进程分配&amp;ndash;定数⽬的物理块，在进程运⾏期间，可根据情况做适
当的增加或减少。即，驻留集⼤⼩可变
局部置换：发⽣缺⻚时只能选进程⾃⼰的物理块进⾏置换。
全局置换：可以将操作系统保留的空闲物理块分配给缺⻚进程，也可以将别的进程持
有的物理块置换到外存，再分配给缺⻚进程。
⻚⾯分配、置换策略
固定分配局部置换
固定分配局部置换:系统为每个进程分配-⼀ 定数量的物理英,”在整个运⾏期向都不改
变。若进程在运外⾏中发⽣缺⻚，则只能从该进程在内存中的⻚⾯中选出⼀- ⻚换
出，然后再调⼊需要的⻚⾯。这种策略的缺点是:很难在刚开始就确定应为每个进程
分配多少个物理块才算合理。(采⽤这种策略的 系统可以根据进程⼤⼩、优先级、或
是根据程序员给出的参数来确定为- - 个进程分配的内存块数)
可变分配全局置换
刚开始会为每个进程分配⼀定数量的物理块。操作系统会保持- - 个空闲物理块队
列。当某进程发⽣缺⻚时，从空闲物理块中取出⼀块分配给该进程;若已⽆空闲物
理块，则可选择⼀个未锁定的⻚⾯换出外存，再将该物理块分配给缺⻚的进程。
采⽤这种策略时，只要某进程发⽣缺⻚，.都将获得新的物理块，仅当空闲物理块
⽤完时，系统才选择⼀个未锁定的⻚⾯调出。被选择调出的⻚可能是系统中任何
⼀个进程中的⻚，因此这个被选中的进程拥有的物理块会减少，缺⻚率会增加。
可变分配局部置换
刚开始会为每个进程分配⼀定数量的物理块。当某进程发⽣缺⻚时，只允许从该
进程⾃⼰的物理块中选出⼀个进⾏换出外存。如果进程在运⾏中频繁地缺⻚，系
统会为该进程多分配⼏个物理块，直⾄该进程缺⻚率趋势适当程度；反之，如果
进程在运⾏中缺⻚率特别低，则可适当减少分配给该进程的物理块。
区别
可变分配全局置换：只要缺⻚就给分配新物理块
可变分配局部置换：要根据发⽣缺⻚的频率来动态地增加或减少进程的物理块
调⼊⻚⾯的时机
预调⻚策略：⼀般⽤于进程运⾏前
请求调⻚策略：进程运⾏时，发现缺⻚再调⻚
从何处调⻚
对换区——采⽤连续存储⽅式，速度更快；⽂件区——采⽤离散存储⽅式，速度更
慢。
对换区⾜够⼤：运⾏将数据从⽂件区复制到对换区，之后所有的⻚⾯调⼊、调出都是
在内存与对换区之间进⾏
对换区不够⼤：不会修改的数据每次都从⽂件区调⼊；会修改的数据调出到对换区，
需要时再从对换区调⼊
抖动(颠簸)现象
⻚⾯频繁换⼊换出的现象。主要原因是分配给进程的物理块不够
⼯作集
在某段时间间隔⾥，进程实际访问⻚⾯的集合。驻留集⼤⼩⼀般不能⼩于⼯作集⼤
⼩。
第四章 ⽂件管理
01 初识⽂件管理
⽂件定义：⼀组有意义的信息的集合
⽂件的属性
⽂件名：由创建⽂件的⽤户决定⽂件名，主要是为了⽅便⽤户找到⽂件，同⼀⽬录下
不允许有重名⽂件。
标识符：⼀个系统内的各⽂件标识符唯-⼀，对⽤户来说毫⽆可读性,因此标识符只是
操作系统⽤于区分各个⽂件的⼀种内部名称。
类型：指明⽂件的类型.
位置：⽂件存放的路径(让⽤户使⽤)、在外存中的地址(操作系统使⽤，对⽤户不可
⻅)
⼤⼩：指明⽂件⼤⼩
创建时间、上次修改时间、⽂件所有者信息
保护信息：对⽂件进⾏保护的访问控制信息
操作系统向上提供哪些功能
创建⽂件(create系统调⽤)
删除⽂件(delete 系统调⽤)
读⽂件(read系统调⽤)
写⽂件(write系统调⽤)
打开⽂件(open系统调⽤)
关闭⽂件(close 系统调⽤)
⽂件内部应该如何被组织起来(⽂件的逻辑结构)
⽂件之间应该如何被组织起来(⽬录结构)
⽂件应如何存放在外存中(⽂件的物理结构)
操作系统如何管理外存中的空闲块(存储空间的管理)
操作系统需要提供的其他⽂件管理功能
⽂件共享
⽂件保护
02 ⽂件的逻辑结构
⽆结构⽂件
有结构⽂件
顺序⽂件
串结构：记录顺序与关键字⽆关
顺序结构：记录按关键字顺序排列
可变⻓记录的顺序⽂件⽆法实现随机存取，定⻓记录可以
定⻓记录、顺序结构的顺序⽂件可以快速检索(根据关键字快速找到记录)
最⼤缺点：不⽅便增加/删除记录
索引⽂件
建⽴⼀张索引表，每个记录对应-个表项。各记录不⽤保持顺序,⽅便增加删除记
录
索引表本身就是定⻓记录的顺序⽂件，⼀个索引表项就是⼀条定⻓记录， 因此索
引⽂件可⽀持随机存取
若索引表按关键字顺序排列，则可⽀持快速检索
解决了顺序⽂件不⽅便增/删记录的问题，同时让不定⻓记录的⽂件实现了随机存
取。但索引表可能占⽤很多空间
索引顺序⽂件
将记录分组，每组对应-⼀个索引表项
检索记录时先顺序查索引表，找到分组，再顺序查找分组
当记录过多时，可建⽴多级索引表
03 ⽂件⽬录
⽂件控制块(实现⽂件⽬录的关键数据结构)
⼀个⽂件对应⼀个FCB，个FCB就是⼀个⽬录项，多个FCB组成⽂件⽬录
对⽬录的操作:搜索、创建⽂件、删除⽂件、显示⽂件、修改⽂件
⽬录结构
单级⽬录结构
⼀个系统只有⼀张⽬录表，不允许⽂件重名
两级⽬录结构
不同⽤户的⽂件可以重名，但不能对⽂件进⾏分类
多级⽬录结构(树形⽬录结构)
不同⽬录下的⽂件可以重名，可以对⽂件进⾏分类，不⽅便⽂件共享
系统根据“⽂件路径&amp;quot;找到⽬标⽂件
从根⽬录出发的路径是“绝对路径&amp;quot; (&amp;quot;/照⽚/2015-08/⾃ 拍jipg&amp;quot;)
从&amp;quot;当前⽬录”出发的路径是&amp;quot;相对路径”(&amp;quot;/照⽚/201 5-08/⾃拍jpg&amp;quot;)
⽆环图⽬录结构
在树形⽬录结构的基础上，增加⼀些指向同⼀节点的有向边，使整个⽬录成为⼀
个有向⽆环图
为共享结点设置⼀个共享计数器，计数器为0时才真正删除该结点
索引结点(对⽂件控制块的优化)
除了⽂件名之外的所有信息都放到索引结点中，每个⽂件对应⼀个索引结点
⽬录项中只包含⽂件名、索引结点指针，因此每个⽬录项的⻓度⼤幅减⼩
由于⽬录项⻓度减⼩，因此每个磁盘块可以存放更多个⽬录项，因此检索⽂件时磁盘
I/0的次数就少了很多
04 ⽂件的物理结构（⽂件分配⽅式）
对⾮空闲磁盘块的管理（存放了⽂件数据的磁盘块）
连续分配
链接分配
链接分配采取离散分配的⽅式，可以为⽂件分配离散的磁盘块。分为隐式链接和
显式链接两种。
隐式链接
隐式链接——除⽂件的最后⼀个盘块之外，每个盘块中都存有指向下⼀个盘块
的指针。⽂件⽬录包括⽂件第⼀块的指针和最后⼀块的指针。
优点：很⽅便⽂件拓展，不会有碎⽚问题，外存利⽤率⾼。
缺点：只⽀持顺序访问，不⽀持随机访问，查找效率低，指向下⼀个盘块的
指针也需要耗费少量的存储空间。
题⽬中没有要求，默认是隐式链接的链接分配
显式链接
把⽤于链接⽂件各物理块的指针显式地存放在⼀张表中，即⽂件分配表
(FAT， File Allocation Table)。⼀个磁盘只会建⽴⼀张⽂件分配表。开机时⽂
件分配表放⼊内存，并常驻内存。
优点：很⽅便⽂件拓展，不会有碎⽚问题，外存利⽤率⾼，并且⽀持随机访
问。相⽐于隐式链接来说，地址转换时不需要访问磁盘，因此⽂件的访问效
率更⾼。
缺点：⽂件分配表的需要占⽤⼀定的存储空间。
索引分配
①链接⽅案：如果索引表太⼤，⼀个索引块装不下，那么可以将多个索引块链接
起来存放。缺点:若⽂件很⼤，索引表很⻓，就需要将很多个索引块链接起来。想
要找到i号索引块，必须先依次读⼊0~i-1号索引块，这就导致磁盘I/O次数过多，
查找效率低下。
②多层索引：建⽴多层索引(原理类似于多级⻚表)。使第⼀层索引块指向第⼆层
的索引块。还可根据⽂件⼤⼩的要求再建⽴第三层、第四层索引块。采⽤K层索
引结构，且顶级索引表未调⼊内存，则访问⼀个数据块只需要K+ 1次读磁盘操
作。
缺点：即使是⼩⽂件，访问⼀个数据块依然需要K+1次读磁盘。
③混合索引：多种索引分配⽅式的结合。例如，⼀个⽂件的顶级索引表中，既包
含直接地址索引(直接指向数据块)，⼜包含⼀级间接索引(指向单层索引表)、还包
含两级间接索引(指向两层索引表)。
优点：对于⼩⽂件来说，访问⼀个数据块所需的读磁盘次数更少。
超级超级超级重要考点:
①要会根据多层索引、混合索引的结构计算出⽂件的最⼤⻓度(Key：各级索
引表最⼤不能超过⼀个块) ；
②要能⾃⼰分析访问某个数据块所需要的读磁盘次数(Key：FCB中 会存有。
指向顶级索 引块的指针，因此可以根据FCB读⼊顶级索引块。每次读⼊下⼀
级的索引块都需要⼀次读磁盘操作。另外，要注意题⽬条件——顶级索引块是
否已调⼊内存)
各种⽂件分配⽅式的区别
对空闲磁盘块的管理
06 逻辑结构vs物理结构
逻辑结构
⽤户(⽂件创建者)的视⻆看到的亚⼦
在⽤户看来，整个⽂件占⽤连续的逻辑地址空间
⽂件内部的信息组织完全由⽤户⾃⼰决定，操作系统并不关⼼
物理结构
由操作系统决定⽂件采⽤什么物理结构存储
操作系统负责将逻辑地址转变为(逻辑块号， 块内偏移量)的形式，并负责实现逻辑块
号到物理块号的映射
07 ⽂件存储空间管理
存储空间的划分与初始化
⽂件卷(逻辑卷)的概念
为磁盘分区（C/D/E盘），分为逻辑磁盘
⽬录区与⽂件区
⽬录区，主要存放⽂件⽬录信息（FCB）、⽤与磁盘存储空间管理的信息
⽂件区，⽤于存放⽂件数据
多个物理磁盘也可以组成⼀个⽂件卷
初始化
将各个⽂件卷划分为⽬录区、⽂件去
⼏种管理⽅法
注意：
⽤什么⽅式记录、组织空闲块？
如何分配磁盘块
如何回收磁盘块
空闲表法
绿⾊为空闲块、橙⾊为⾮空闲块，适⽤于“连续分配⽅式”
如何分配磁盘块：与内存管理中的动态分区分配很类似，为⼀个⽂件分配连续的
存储空间。同样可采⽤⾸次适应、最佳适应、最坏适应等算法来决定要为⽂件分
配哪个区间。
如何回收磁盘块:与内存管理中的动态分区分配很类似，当回收某个存储区时需要
有四种情况
①回收区的前后都没有相邻空闲区;
②回收区的前后都是空闲区;
③回收区前⾯是空闲区;
④回收区后⾯是空闲区。
总之，回收时需要注意表项的合并问题。
空闲链表法
空闲盘块链
以盘块为单位组成⼀条空闲链
图示
空闲盘区链
以盘区为单位组成⼀条空闲链
图示
如何分配：如何分配:若某⽂件申请K个盘块，则可以采⽤⾸次适应、最佳适
应等算法，从链头开始检索，按照算法规则找到⼀个⼤⼩符合要求的空闲盘
区，分配给⽂件。若没有合适的连续空闲块，也可以将不同盘区的盘块同时
分配给⼀个⽂件，注意分配后可能要修改相应的链指针、盘区⼤⼩等数据。
如何回收：若回收区和某个空闲盘区相邻，则需要将回收区合并到空闲盘区
中。若回收区没有和任何空闲区相邻，将回收区作为单独的⼀个空闲盘区挂
到链尾。
离散分配、连续分配都适⽤。为⼀个⽂件分配多个盘块时效率更⾼。
两种分配⽅式的图示
位示图法
位示图：每个⼆进制位对应⼀⼀个盘块。在本例中，“0” 代表盘块空闲，“1”代表
盘块已分配。位示图⼀般⽤连续的“字”来表示，如本例中⼀个字的字⻓是16位，
字中的每- -位对应⼀⼀个盘块。因此可以⽤(字号，位号)对应⼀个盘块号。当然
有的题⽬中也描述为(⾏号，列号)
计算：
通过（字号，位号）=（i， j）定位得到盘块号b
b号盘块对应的字号i = b/n，位号j = b%n
区分从0开始还是从1开始
如何分配：若⽂件需要K个块，
①顺序扫描位示图，找到K个相邻或不相邻的“0”;
②根据字号、位号算出对应的盘块号，将相应盘块分配给⽂件;
③将相应位设置为“1”
如何回收：
①根据回收的盘块号计算出对应的字号、位号;
②将相应⼆进制位设为“0”
适⽤：连续分配和离散分配都适⽤
成组链接法
Unix系统中采⽤了成组链接法对磁盘空闲块进⾏管理
⽂件卷的⽬录区中专⻔⽤⼀个磁盘块作为“超级块”，当系统启动时需要将超级块
读⼊内存，并且要保证内存与外存的“超级块”数据⼀致
超级块
还有点&amp;hellip;笔者理解起来有点困难，先不写了&amp;hellip;
08 ⽂件的基本操作
向上提供的⼏个最基本的功能
创建⽂件 create系统调⽤
点击“新建”后，图形化交互进程在背后调⽤“create系统调⽤”
提供的参数
所需的外存空间⼤⼩：1KB
⽂件存放路径&amp;quot;D:/Demo&amp;quot;
⽂件名 test.txt
操作系统需要做的：
在外存找到⽂件所需的空间（⽤空闲链表法、位示图、成组链接法等管
理策略，找到空闲空间）
根据⽂件存放路径的信息找到该⽬录对应的⽬录⽂件(此处就是D:/Demo
⽬录)，在⽬录中创建该⽂件对应的⽬录项。⽬录项中包含了⽂件名、⽂
件在外存中的存放位置等信息。
删除⽂件 delete系统调⽤
读⽂件 read系统调⽤
写⽂件 write系统调⽤
打开⽂件open系统调⽤
关闭⽂件 close系统调⽤
0x&amp;hellip;
第五章 输⼊/输出(I/O)管理
后续会更新&amp;hellip;
稍安勿躁。&lt;/li>
&lt;/ol></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</guid><description>&lt;h1 id="操作系统基础">操作系统基础&lt;/h1>
&lt;h2 id="计算机系统概述">⼀、计算机系统概述&lt;/h2>
&lt;h3 id="11-基本概念">1.1 基本概念&lt;/h3>
&lt;p>OS指控制和管理整个计算机系统的硬件与软件资源，合理组织、调度计算机的⼯作与资源分配，进⽽为⽤户和其他软件提供⽅便接⼝与环境的程序集合；&lt;/p>
&lt;p>基本特征：&lt;/p>
&lt;ul>
&lt;li>并发: 两个或多个事件在同⼀时间间隔内发⽣；&lt;/li>
&lt;li>共享: 系统中的资源可供多个并发进程共同使⽤；&lt;/li>
&lt;li>虚拟: 通过某种技术将⼀个物理实体变为多个逻辑实体；&lt;/li>
&lt;li>异步: 事件以不可知的速度推进；&lt;/li>
&lt;/ul>
&lt;p>功能根据目标的划分:&lt;/p>
&lt;ul>
&lt;li>对硬件资源抽象（OS作为 扩充机器 ）
&lt;ul>
&lt;li>将裸机改造为功能更强、使⽤更⽅便的机器，因此把覆盖了软件的机器叫做 虚拟机 和 扩充机器；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>资源管理
&lt;ul>
&lt;li>处理机管理&lt;/li>
&lt;li>存储器管理&lt;/li>
&lt;li>⽂件管理&lt;/li>
&lt;li>设备管理&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>提供用户与硬件之间的接⼝
&lt;ul>
&lt;li>命令接⼝
&lt;ul>
&lt;li>联机命令接⼝（交互式命令接⼝）&lt;/li>
&lt;li>脱机命令接⼝（批处理命令接⼝）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>程序接⼝
&lt;ul>
&lt;li>由⼀组 作业控制命令 组成；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>功能从应用角度划分:&lt;/p>
&lt;ul>
&lt;li>进程管理&lt;/li>
&lt;li>存储管理(内/外存管理)&lt;/li>
&lt;li>⽂件管理&lt;/li>
&lt;li>设备管理(IO管理)&lt;/li>
&lt;/ul>
&lt;h3 id="12-发展与分类">1.2 发展与分类*&lt;/h3>
&lt;ul>
&lt;li>⼿⼯操作阶段：没有操作系统出现，每个操作都由⼈来控制；&lt;/li>
&lt;li>批处理阶段
&lt;ul>
&lt;li>将多个操作打包成作业使计算机进程批处理；&lt;/li>
&lt;li>单道批处理：操作是成批进⾏的（⼀份作业包含很多操作），内存只有⼀道作业；&lt;/li>
&lt;li>多道批处理：内存包含多道作业（等待事件发⽣时可以⾃动切换作业）；宏观并⾏，微观串⾏（ 并发执行 ）；&lt;/li>
&lt;li>ENIAC、GM-NAA I／O&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>分时操作系统：多⽤户通过终端同时共享⼀台主机（⼀般采⽤分时技术），提⾼ 交
互性 ；
&lt;ul>
&lt;li>Multics、UNIX、Linux&lt;/li>
&lt;li>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e5%9f%ba%e7%a1%80/2024-03-07-10-06-07.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>实时操作系统：提⾼ 及时性 和 可靠性 ；&lt;/li>
&lt;li>⽹络操作系统和分布式计算机系统&lt;/li>
&lt;li>个⼈计算机操作系统
&lt;ul>
&lt;li>macOS、Windows&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="13-硬件结构">1.3 硬件结构*&lt;/h3>
&lt;p>冯诺依曼结构&lt;/p>
&lt;ul>
&lt;li>中央处理器（CPU）：根据程序指令对数据进⾏处理；主要负责运算和逻辑控制；&lt;/li>
&lt;li>存储器：存放程序和数据。&lt;/li>
&lt;li>输入输出设备&lt;/li>
&lt;/ul>
&lt;p>CPU的指令集架构（Instruction Set Architecture，ISA）包含了CPU的指令集、特叹级、寄存器、执行模式｀安全扩展。&lt;/p>
&lt;p>指令集：&lt;/p>
&lt;ul>
&lt;li>精简指令集（RISC）
&lt;ul>
&lt;li>AArch64体系结构（ARMv8）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>复杂指令集（CISC）
&lt;ul>
&lt;li>x86体系结构&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>CPU运⾏状态&lt;/strong>
不同架构下CPU的特权级划分不一致&lt;/p>
&lt;p>如AArch64按如下划分：&lt;/p>
&lt;ul>
&lt;li>EL0: 最低的特权级，应用程序通常运行在该特权级，也称为&lt;strong>用户态&lt;/strong>。&lt;/li>
&lt;li>EL1:操作系统通常运行在该特权级，也称为&lt;strong>内核态&lt;/strong>。&lt;/li>
&lt;li>EL2:在虚拟化场景下需要，虚拟机监控器(VirtualMachine Monitor，VMM，也称为 Hypervisor)通常运行在该特权级。&lt;/li>
&lt;li>EL3:和安全特性 TrustZone相关，负责普通世界(normal world)和安全世界secure world)之间的切换。&lt;/li>
&lt;/ul>
&lt;p>x86按如下划分：&lt;/p>
&lt;ul>
&lt;li>Ring 0: 内核态&lt;/li>
&lt;li>Ring 1-3: 用户态&lt;/li>
&lt;li>Ring 0是最高特权级，Ring 3是最低特权级。&lt;/li>
&lt;/ul>
&lt;p>通常只需要区分内核态和用户态即可&lt;/p>
&lt;ul>
&lt;li>内核态（ 管态 ）
&lt;ul>
&lt;li>可以使⽤ &lt;strong>特权指令&lt;/strong> ；&lt;/li>
&lt;li>OS的 内核程序 运⾏在管态；&lt;/li>
&lt;li>内核态特权指令对应的实体为 内核 ；
&lt;blockquote>
&lt;p>系统调⽤相关位于⾼层，硬件相关位于底层；
内核是计算机上配置的 底层软件 ，是计算机功能的延伸；&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>系统调⽤相关；
&lt;blockquote>
&lt;p>引发⼴义中断⾥⾯的系统异常（⽤户执⾏陷⼊指令⽽触发的操作系统的系统调⽤引起的中断）；&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>进程管理&lt;/li>
&lt;li>存储器管理&lt;/li>
&lt;li>设备管理&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>硬件模块相关；
&lt;ul>
&lt;li>时钟管理&lt;/li>
&lt;li>中断机制
&lt;ul>
&lt;li>只有⼀⼩部分在内核（保护和恢复中断现场的信息，转移控制权到相关的处理程序）；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>原语&lt;/li>
&lt;li>设备驱动&lt;/li>
&lt;li>CPU切换&lt;/li>
&lt;li>进程通信&lt;/li>
&lt;li>…&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>⽤户态（ 目态 ）
&lt;ul>
&lt;li>&lt;strong>不可以使⽤特权指令&lt;/strong>；&lt;/li>
&lt;li>⽤户的⾃编程序（ 应用程序 ）运⾏在⽬态；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>用户态切换到内核态的三种方式&lt;/p>
&lt;ul>
&lt;li>系统调用(Trap)&lt;/li>
&lt;li>中断(Interrupt)&lt;/li>
&lt;li>异常(Exception)&lt;/li>
&lt;/ul>
&lt;p>中断和异常
异常（硬件故障：访管指令）&amp;gt; 中断（外部中断，程序性中断）&amp;gt;系统异常（重启）&lt;/p>
&lt;ul>
&lt;li>异常（不可屏蔽,缺⻚中断为内中断）
&lt;ul>
&lt;li>⾃愿中断（系统异常）
&lt;ul>
&lt;li>时钟中断&lt;/li>
&lt;li>特权指令&lt;/li>
&lt;li>切换核⼼态&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>强迫中断（狭义异常）
&lt;ul>
&lt;li>&lt;strong>CPU内部&lt;/strong> 硬件故障&lt;/li>
&lt;li>软中断&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>中断（分为可屏蔽中断和不可屏蔽中断）
&lt;ul>
&lt;li>硬中断（外设导致的中断）&lt;/li>
&lt;li>与程序运⾏⽆关的中断（⼈的⼲预）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>系统调⽤: ⽤户在程序中调⽤操作系统所提供的⼀些⼦功能；&lt;/p>
&lt;ol>
&lt;li>需先执⾏ &lt;strong>陷入指令Trap&lt;/strong> （⾮特权指令）切换为内核态。此时发生了&lt;/li>
&lt;li>再处理OS的系统调⽤，&lt;/li>
&lt;li>处理完成后,执⾏ 返回指令 （特权指令，⼀般为中断返回指令），切换为⽤户态；&lt;/li>
&lt;/ol>
&lt;h3 id="14-体系结构">1.4 体系结构&lt;/h3>
&lt;p>⼤内核（单内核）：将OS的主要功能模块作为⼀个紧密整体运⾏在核⼼态；&lt;/p>
&lt;p>微内核&lt;/p>
&lt;ul>
&lt;li>保留基本功能，其它服务移动到⽤户态；&lt;/li>
&lt;li>有效分离了内核与服务、服务与服务；&lt;/li>
&lt;/ul>
&lt;h2 id="进程管理">⼆、进程管理&lt;/h2>
&lt;h3 id="21-进程与线程">2.1 进程与线程*&lt;/h3>
&lt;h4 id="211-进程的概念和特征">2.1.1 进程的概念和特征&lt;/h4>
&lt;p>1）概念&lt;/p>
&lt;ul>
&lt;li>进程实体：程序段、数据段、进程控制块 PCB 组成 ；
&lt;ul>
&lt;li>PCB是进程存在的唯⼀标志；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>进程&lt;/strong>是&lt;strong>进程实体&lt;/strong>的运⾏过程，是系统进⾏ &lt;strong>资源分配&lt;/strong> 的独⽴单位；&lt;/li>
&lt;li>进程是 动态 的，进程实体是 静态 的；&lt;/li>
&lt;li>引⼊进程是为了&lt;strong>描述程序的动态执⾏过程&lt;/strong>，更好的⽀持和管理多道程序的并发执⾏（进程的异步性与进程同步机制）；&lt;/li>
&lt;/ul>
&lt;p>PCB包含：&lt;/p>
&lt;ul>
&lt;li>进程描述信息（PID，UID）&lt;/li>
&lt;li>进程控制和管理信息&lt;/li>
&lt;li>资源分配清单&lt;/li>
&lt;li>处理机相关信息&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e5%9f%ba%e7%a1%80/2024-03-07-16-41-37.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;blockquote>
&lt;p>c语⾔程序对内存分为正⽂段（代码和常量）、数据堆段（动态分配到存储区）、数据栈段（临时变量）；&lt;/p>
&lt;/blockquote>
&lt;p>对于有线程系统：&lt;/p>
&lt;ul>
&lt;li>进程是&lt;strong>资源分配&lt;/strong>的独立单位&lt;/li>
&lt;li>线程是&lt;strong>资源调度&lt;/strong>的独立单位
对于无线程系统：&lt;/li>
&lt;li>进程是资源调度、分配的独立单位&lt;/li>
&lt;/ul>
&lt;p>2）特点
动态性：具有⽣命周期，是动态变化的（进程最基本的特征）；
并发性: 多个进程并发执⾏.
独⽴性: 进程是系统资源分配的基本单位，是独⽴的实体；
异步性：进程以不可知速度推进，需要配置相应的 进程同步 机制；
结构性: 每个进程都配置一个PCB进行描述。&lt;/p>
&lt;h4 id="212-进程的状态和转换">2.1.2 进程的状态和转换&lt;/h4>
&lt;p>五种状态&lt;/p>
&lt;ul>
&lt;li>创建态：正在被创建，尚未到就绪状态。&lt;/li>
&lt;li>运⾏态：进程正在处理器上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)。&lt;/li>
&lt;li>就绪态：即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。&lt;/li>
&lt;li>阻塞态（等待态）：正在等待某一事件而暂停运行如&lt;strong>等待某资源为可用或等待 IO 操作&lt;/strong>完成。（即使处理器空闲，该进程也不能运行）&lt;/li>
&lt;li>结束态：进程正常结束或其他原因中断退出运行。&lt;/li>
&lt;/ul>
&lt;p>状态转换&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e5%9f%ba%e7%a1%80/%e8%bd%ac%e6%8d%a2%e5%9b%be.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;ul>
&lt;li>⼀个进程从运⾏态变成阻塞态是 主动 的⾏为&lt;/li>
&lt;li>从阻塞态变成就绪态是 被动 的⾏为，需要其他相关进程的协助。&lt;/li>
&lt;/ul>
&lt;h4 id="213-进程控制-">2.1.3 进程控制-&lt;/h4>
&lt;p>进程控制通过 原语 操作，在核⼼态运⾏；&lt;/p>
&lt;p>进程创建（ 创建原语 ）&lt;/p>
&lt;ol>
&lt;li>申请空⽩的PCB，申请失败（PCB有限）则创建失败；&lt;/li>
&lt;li>为进程分配资源，申请失败进⼊等待态；&lt;/li>
&lt;li>初始化PCB；&lt;/li>
&lt;li>等待被调度；&lt;/li>
&lt;/ol>
&lt;p>进程终⽌（ 撤销原语 ）&lt;/p>
&lt;ul>
&lt;li>由 正常结束 、 异常结束 、 外界干预 三种终⽌事件；&lt;/li>
&lt;li>根据被终⽌进程的 标识符 ，检索PCB，读取进程状态；&lt;/li>
&lt;li>处于执⾏状态则终⽌，归还 处理机资源 给其他进程；&lt;/li>
&lt;li>若该进程有⼦进程，则终⽌⼦进程；&lt;/li>
&lt;li>由进程创建的进程为该⽗进程的⼦进程；&lt;/li>
&lt;li>归还 其它资源 给⽗进程或OS；&lt;/li>
&lt;/ul>
&lt;p>进程阻塞&lt;/p>
&lt;ul>
&lt;li>系统⾃动执⾏ 阻塞原语 （主动）；&lt;/li>
&lt;li>找到被阻塞进程标识号对应的PCB；&lt;/li>
&lt;li>若为运⾏态，则保护现场，将其状态转为等待态；&lt;/li>
&lt;li>将该PCB插⼊ 等待队列 ，将处理机调度给其它就绪进程；&lt;/li>
&lt;/ul>
&lt;p>进程唤醒&lt;/p>
&lt;ul>
&lt;li>由有关进程调⽤ 唤醒原语 （被动）；&lt;/li>
&lt;li>与阻塞原语成对出现；&lt;/li>
&lt;li>在该事件的等待队列找到相应的PCB；&lt;/li>
&lt;li>从等待队列移除，置其状态转为就绪态；&lt;/li>
&lt;li>PCB插⼊ 就绪队列 ，等待调度；&lt;/li>
&lt;/ul>
&lt;p>进程切换&lt;/p>
&lt;blockquote>
&lt;p>进程切换和处理机模式切换不同，模式切换时，处理机逻辑上还在执⾏同⼀进程，所以进程环境不变，只需要 恢复CPU现场 ；但进程切换时，进程改变， 进程环境改变 （处理机上下⽂改变）；
调度和切换：调度决定资源分配的进程，是⼀种决策⾏为；切换是实际分配⾏为，是⼀种执⾏⾏为； 先有调度再有切换 ；&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>保存处理机上下⽂（PC和其它寄存器）；&lt;/li>
&lt;li>更新PCB信息；&lt;/li>
&lt;li>将PCB移⼊相应队列；&lt;/li>
&lt;li>选择另⼀进程执⾏，并更新其PCB；&lt;/li>
&lt;li>更新内存管理的数据结构；&lt;/li>
&lt;li>恢复处理机上下⽂；&lt;/li>
&lt;/ul>
&lt;h4 id="214-进程的组织-">2.1.4 进程的组织-&lt;/h4>
&lt;p>进程控制块&lt;/p>
&lt;blockquote>
&lt;p>通常采⽤ 链接方式 和 索引方式 来组织不同状态的PCB；&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>PCB结构&lt;/li>
&lt;li>程序段
&lt;ul>
&lt;li>程序段就是能被进程调度程序调度到CPU执⾏的程序代码段。注意，程序可被多个进程共享，即,多个进程可以运⾏同⼀个程序；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>数据段
&lt;ul>
&lt;li>⼀个进程的数据段，可以是进程对应的程序加⼯处理的原始数据，也可以是程序执⾏时产⽣的中间或最终结果。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="215-进程的通信">2.1.5 进程的通信&lt;/h4>
&lt;p>进程通信就是进程之间的数据交换。&lt;/p>
&lt;p>PV操作时低级通信方式，高级通信方式是指以较高的效率传输大量数据的通信方式。高级通信方法可分为共享存储、消息传递和管道通信三大类。&lt;/p>
&lt;p>&lt;a href="https://www.jianshu.com/p/c1015f5ffa74" target="_blank" rel="noopener">详细&lt;/a>&lt;/p>
&lt;p>管道（PIPE）&lt;/p>
&lt;ul>
&lt;li>无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统&lt;/li>
&lt;li>有名管道：一种半双工的通信方式，它允许无亲缘关系进程间的通信
&lt;ul>
&lt;li>优点：可以实现任意关系的进程间的通信&lt;/li>
&lt;li>缺点：
&lt;ul>
&lt;li>&lt;strong>名字以文件的形式&lt;/strong>长期存于系统中，使用不当容易出错&lt;/li>
&lt;li>缓冲区有限&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>无名管道：一种半双工的通信方式，只能在具有亲缘关系的进程间使用（父子进程/兄弟进程）
&lt;ul>
&lt;li>优点：简单方便&lt;/li>
&lt;li>缺点：
&lt;ul>
&lt;li>局限于&lt;strong>单向通信&lt;/strong>&lt;/li>
&lt;li>只能创建在它的进程以及其有亲缘关系的进程之间&lt;/li>
&lt;li>缓冲区有限&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>信号量（Semaphore）：一个计数器，可以用来控制多个线程对共享资源的访问，信号量的意图在于进程间同步。&lt;/p>
&lt;ul>
&lt;li>优点：可以同步进程&lt;/li>
&lt;li>缺点：信号量有限&lt;/li>
&lt;/ul>
&lt;p>信号（Signal）：一种比较复杂的通信方式，用于通知接收进程某个事件已经发生 . 如SIGKILL：用户终止进程执行信号。shell下执行kill -9发送该信号。&lt;/p>
&lt;p>消息队列（Message Queue）：是消息的链表，存放在内核中并由消息队列标识符标识。&lt;/p>
&lt;ul>
&lt;li>与管道不同
&lt;ul>
&lt;li>消息队列&lt;strong>存放在内核中&lt;/strong>，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。&lt;/li>
&lt;li>消息队列在某个进程往一个队列写入消息之前，并不需要另外某个进程在该队列上等待消息的到达。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>优点：可以实现任意进程间的通信，并通过系统调用函数来实现消息发送和接收之间的同步，无需考虑同步问题，方便&lt;/li>
&lt;li>缺点：信息的复制需要额外消耗 CPU 的时间，不适宜于信息量大或操作频繁的场合&lt;/li>
&lt;/ul>
&lt;p>共享内存（Shared Memory）：映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问&lt;/p>
&lt;ul>
&lt;li>优点：无须复制，快捷，信息量大&lt;/li>
&lt;li>缺点：
&lt;ul>
&lt;li>通信是通过将共享空间缓冲区直接附加到进程的虚拟地址空间中来实现的，因此进程间的读写操作的同步问题&lt;/li>
&lt;li>利用内存缓冲区直接交换信息，内存的实体存在于计算机中，只能同一个计算机系统中的诸多进程共享，不方便网络通信&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>套接字（Socket）：可用于&lt;strong>不同计算机间&lt;/strong>的进程通信&lt;/p>
&lt;ul>
&lt;li>优点：
&lt;ul>
&lt;li>传输数据为字节级，传输数据可自定义，数据量小效率高传输数据时间短，性能高&lt;/li>
&lt;li>适合于客户端和服务器端之间信息实时交互&lt;/li>
&lt;li>可以加密,数据安全性强&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>缺点：需对传输的数据进行解析，转化成应用级的数据。&lt;/li>
&lt;/ul>
&lt;h4 id="216-线程的概念和多线程模型">2.1.6 线程的概念和多线程模型&lt;/h4>
&lt;p>1）线程和进程⽐较&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e5%9f%ba%e7%a1%80/2024-03-07-15-52-01.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>一个进程中可以有多个线程，多个线程共享进程的堆和方法区 (JDK1.8 之后的元空间)资源，但是每个线程有自己的程序计数器、虚拟机栈 和 本地方法栈。&lt;/p>
&lt;p>调度：线程是 处理机独立调度 的基本单位，进程是 资源分配 （除CPU外）的基本单位；&lt;/p>
&lt;p>资源：线程不拥有系统资源（有⼀点），但可以访问所属进程的资源；&lt;/p>
&lt;p>并发：线程也可以并发执⾏；&lt;/p>
&lt;p>通信：线程可以直接读写进程数据段（全局变量）来通信，进程需要使⽤同步互斥⼿段；&lt;/p>
&lt;p>系统开销：线程不拥有资源，因此切换的开销⼩；&lt;/p>
&lt;p>&lt;strong>线程的通信&lt;/strong>
线程间的通信目的&lt;strong>主要是用于线程同步&lt;/strong>，所以线程没有像进程通信中的用于数据交换的通信机制&lt;/p>
&lt;ul>
&lt;li>锁机制：包括互斥锁/量（mutex）、读写锁（reader-writer lock）、自旋锁（spin lock）、条件变量（condition）
&lt;ul>
&lt;li>互斥锁/量（mutex）：提供了以排他方式防止数据结构被并发修改的方法。&lt;/li>
&lt;li>读写锁（reader-writer lock）：允许多个线程同时读共享数据，而对写操作是互斥的。&lt;/li>
&lt;li>自旋锁（spin lock）与互斥锁类似，都是为了保护共享资源。互斥锁是当资源被占用，申请者进入睡眠状态；而自旋锁则循环检测保持者是否已经释放锁。&lt;/li>
&lt;li>条件变量（condition）：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>信号量机制(Semaphore)
&lt;ul>
&lt;li>无名线程信号量&lt;/li>
&lt;li>命名线程信号量&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>信号机制(Signal)：类似进程间的信号处理&lt;/li>
&lt;li>屏障（barrier）：屏障允许每个线程等待，直到所有的合作线程都达到某一点，然后从该点继续执行。&lt;/li>
&lt;/ul>
&lt;p>2）线程的实现
用户级线程和内核级线程&lt;/p>
&lt;p>⽤户级线程 ULT ；&lt;/p>
&lt;ul>
&lt;li>管理由应⽤程序通过 线程库 （最简单可以由的if语句构建）来完成，操作系统意识不到线程，在 用户态 下就可以完成；&lt;/li>
&lt;li>内核调度的还是进程，因此并发度低（⽆法利⽤多核处理机）；&lt;/li>
&lt;li>⼀个线程阻塞，进程就⽆法继续执⾏；&lt;/li>
&lt;/ul>
&lt;p>内核级线程 KLT ；&lt;/p>
&lt;ul>
&lt;li>管理由OS完成，需要切换为 内核态 （切换CPU态需要开销）；&lt;/li>
&lt;li>内核调度的是线程，并发度⾼（可以利⽤多核处理机）；
即使某⼀线程阻塞，其它线程也可以执⾏（内核线程都阻塞时才阻塞）；&lt;/li>
&lt;/ul>
&lt;p>多线程模型 （组合⽅式）；
多对⼀：等价于ULT；
⼀对⼀：等价于KLT；
多对多（ 内核级线程数少于用户级线程 ）：相⽐ULT提⾼了并发度；相⽐KLT节省了管理开销；&lt;/p>
&lt;h3 id="22-处理机调度">2.2 处理机调度*&lt;/h3>
&lt;p>为合理的处理计算机软硬件资源⽽进⾏调度；&lt;/p>
&lt;h4 id="221-三级调度">2.2.1 三级调度&lt;/h4>
&lt;p>⾼级调度（作业调度）&lt;/p>
&lt;ul>
&lt;li>内存与辅存之间的调度。创建态的调度；&lt;/li>
&lt;li>每个作业只调⼊⼀次；
中级调度（内存调度）&lt;/li>
&lt;li>将暂时不能运⾏的进程&lt;strong>调⾄外存&lt;/strong>等待， 挂起态的调度；&lt;/li>
&lt;li>为提⾼内存利⽤率和系统吞吐量；
低级调度（进程调度）&lt;/li>
&lt;li>就绪队列到 运行态的调度；&lt;/li>
&lt;/ul>
&lt;h4 id="222-调度和切换的时机-">2.2.2 调度和切换的时机-&lt;/h4>
&lt;p>进程切换在进程调度之后⽴刻发⽣；&lt;/p>
&lt;p>不调度的情况&lt;/p>
&lt;ul>
&lt;li>处理 中断 的过程中；&lt;/li>
&lt;li>进程在OS内核程序 临界区 中；&lt;/li>
&lt;li>原⼦操作（ 原语 ）过程中；&lt;/li>
&lt;/ul>
&lt;p>调度的情况&lt;/p>
&lt;ul>
&lt;li>非剥夺调度 （⾮抢占⽅式）：调度条件发送后，等进程运⾏结束或⽆法继续运⾏时，才进⾏调度与切换；&lt;/li>
&lt;li>剥夺调度 （抢占⽅式）：调度条件发送后，除遇到不能调度情况需等待结束后再调度外，其它情况⽴刻调度；&lt;/li>
&lt;/ul>
&lt;h4 id="223-调度的评价标准-">2.2.3 调度的评价标准-&lt;/h4>
&lt;ul>
&lt;li>CPU利⽤率&lt;/li>
&lt;li>系统吞吐量：单位时间完成作业的数量；&lt;/li>
&lt;li>周转时间：⽤户提交作业到作业完成经历的时间；包含所有调度的时间；&lt;/li>
&lt;li>响应时间：⽤户提交作业到⾸次响应的时间；包含作业调度和⼀部分中低级调度；&lt;/li>
&lt;li>等待时间：进程等待分配处理机的等待时间和进⼊内存却未被分配处理机的时间；&lt;/li>
&lt;/ul>
&lt;h4 id="224-调度算法">2.2.4 调度算法&lt;/h4>
&lt;p>优先级调度适⽤于 实时系统 ；&lt;/p>
&lt;p>⾼响应⽐调度、时间⽚轮转调度、多级反馈队列调度适⽤于 分时系统 ；&lt;/p>
&lt;p>1）先来先服务 FCFS 调度算法；
适⽤于进程调度和作业调度；
优缺点: 简单、公平,不会产生饥饿现象，因为⼀个长作业会拖累后⾯的短作业；&lt;/p>
&lt;p>2）优先级调度算法；
适⽤于进程调度和作业调度；
优缺点： 可能会产生饥饿现象,即低优先级进程长期得不到服务。静态优先级不够灵活,动态优先级可以更好地反映进程当前状态。剥夺式优先级可能会导致进程频繁切换,影响性能&lt;/p>
&lt;p>优先级：&lt;/p>
&lt;ul>
&lt;li>系统进程 &amp;gt; ⽤户进程&lt;/li>
&lt;li>交互型进程 &amp;gt; ⾮交互型进⾏&lt;/li>
&lt;li>I/O型进程 &amp;gt; 计算型进程
分类：&lt;/li>
&lt;li>静态优先级、动态优先级；&lt;/li>
&lt;li>剥夺式优先级、⾮剥夺式优先级；&lt;/li>
&lt;/ul>
&lt;p>3）短作业优先 SJF 调度算法；
适⽤于进程调度和作业调度；
SJF调度 的平均等待时间、平均周转时间最少；
优缺点: 提高系统的整体吞吐量，导致⻓作业饥饿；&lt;/p>
&lt;p>4）⾼响应比调度算法；
主要⽤于作业调度；
响应⽐⾼的先调度（取决于 已等待时间 与 需要服务时间 ）；
已等待时间越⻓响应⽐越⾼；
需要服务时间越⼩响应⽐越⾼；
优缺点：需要估计作业的服务时间,实现复杂度较高&lt;/p>
&lt;p>5）时间⽚轮转调度算法；
⽤于进程调度；
优先级：需要设置合理的时间片长度,过长会降低响应时间,过短会增加进程切换开销&lt;/p>
&lt;p>6）多级反馈队列调度算法；
⽤于进程调度；
设置多个不同优先级的队列，优先级越⾼的队列对应的可执⾏时间⽚越⼩；
初始进程放⼊第⼀级队列队尾，按FCFS排队，在第⼀级未执⾏完后放⼊第⼆级；
知道前⼀级队列为空时，才执⾏下⼀级队列；&lt;/p>
&lt;p>Linux中的CFS Completely Fair Scheduler 完全公平调度器
为每个任务安排一个虚拟运行时间 vruntime，如果一个任务在运行，其运行的越久，该任务的 vruntime 自然就会越大，而没有被运行的任务，vruntime 是不会变化的。&lt;/p>
&lt;p>那么，在 CFS 算法调度的时候，会优先选择 vruntime 少的任务，以保证每个任务的公平性。&lt;/p>
&lt;p>CFS使用红黑树来存储所有的进程，红黑树是一种自平衡的二叉查找树，可以保证在 O(logN) 的时间复杂度内完成查找、插入、删除等操作。&lt;/p>
&lt;p>优点：公平、高效、低延迟
缺点：复杂度高、难以调试、&lt;/p>
&lt;h4 id="225-僵尸进程和孤儿进程">2.2.5 僵尸进程和孤儿进程&lt;/h4>
&lt;p>当一个进程调用 exit()系统调用结束自己的生命时，内核会释放该进程的所有资源，包括打开的文件、占用的内存等，但是该进程对应的 &lt;strong>PCB 依然存在于系统中&lt;/strong>。这些信息只有在父进程调用 wait()或 waitpid()系统调用时才会被释放，&lt;strong>以便让父进程得到子进程的状态信息&lt;/strong>&lt;/p>
&lt;p>僵尸进程：&lt;/p>
&lt;ul>
&lt;li>子进程已经终止，但是其父进程仍在运行，且父进程没有调用 wait()或 waitpid()等系统调用来获取子进程的状态信息，释放子进程占用的资源，导致子进程的 PCB 依然存在于系统中，但无法被进一步使用。&lt;/li>
&lt;li>这种情况下，子进程被称为“僵尸进程”。避免僵尸进程的产生，父进程需要及时调用 wait()或 waitpid()系统调用来回收子进程。&lt;/li>
&lt;/ul>
&lt;p>Linux 下可以使用 Top 命令查找，zombie 值表示僵尸进程的数量，为 0 则代表没有僵尸进程。
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e5%9f%ba%e7%a1%80/2024-03-08-08-43-12.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>定位僵尸进程以及该僵尸进程的父进程:
&lt;code>ps -A -ostat,ppid,pid,cmd |grep -e '^[Zz]'&lt;/code>&lt;/p>
&lt;p>孤儿进程：&lt;/p>
&lt;ul>
&lt;li>一个进程的父进程已经终止或者不存在，但是该进程仍在运行。这种情况下，该进程就是孤儿进程。&lt;/li>
&lt;li>孤儿进程通常是由于父进程意外终止或未及时调用 wait()或 waitpid()等系统调用来回收子进程导致的。&lt;/li>
&lt;li>为了避免孤儿进程占用系统资源，操作系统会&lt;strong>将孤儿进程的父进程设置为 init 进程（进程号为 1）&lt;/strong>，由 init 进程来回收孤儿进程的资源。&lt;/li>
&lt;/ul>
&lt;h3 id="23-进程同步">2.3 进程同步*&lt;/h3>
&lt;p>为了协调进程之间的相互制约关系；&lt;/p>
&lt;h4 id="231-基本概念-">2.3.1 基本概念-&lt;/h4>
&lt;p>临界资源: ⼀次仅允许⼀个进程使⽤；
临界区 （临界段）: 进程中访问临界资源的代码&lt;/p>
&lt;p>同步 （直接制约关系）：为完成某个任务，针对多个进程的⼯作次序⽽产⽣的制约；&lt;/p>
&lt;p>互斥 （间接制约关系）：当⼀个进程访问临界资源时，另⼀个进程必须等待；&lt;/p>
&lt;ul>
&lt;li>空闲让进：临界区空闲，则可以使⼀个进程进⼊；&lt;/li>
&lt;li>忙则等待：已有进程进⼊临界区则等待；&lt;/li>
&lt;li>有限等待：等待时间为有限时间；&lt;/li>
&lt;li>让权等待：等待时让出处理器（防⽌ 忙等待 ）；&lt;/li>
&lt;/ul>
&lt;h4 id="232-互斥实现法-">2.3.2 互斥实现⽅法-&lt;/h4>
&lt;p>1）软件⽅法&lt;/p>
&lt;ul>
&lt;li>单标志法&lt;/li>
&lt;li>双标志法先检查&lt;/li>
&lt;li>双标志法后检查&lt;/li>
&lt;li>Peterson&amp;rsquo;s Algorithm&lt;/li>
&lt;li>创建管程&lt;/li>
&lt;/ul>
&lt;p>2）硬件⽅法&lt;/p>
&lt;ul>
&lt;li>中断屏蔽⽅法&lt;/li>
&lt;li>硬件指令⽅法&lt;/li>
&lt;li>指令由硬件逻辑直接实现；&lt;/li>
&lt;li>指令均为原⼦操作；&lt;/li>
&lt;li>TestAndSet指令&lt;/li>
&lt;li>Swap指令&lt;/li>
&lt;li>PV指令&lt;/li>
&lt;/ul>
&lt;h4 id="233-同步实现法">2.3.3 同步实现⽅法&lt;/h4>
&lt;p>1）信号量&lt;/p>
&lt;ul>
&lt;li>整型信号量
&lt;ul>
&lt;li>P操作不遵从 让权等待 ，进程⼀直占⽤处理器查询是否可以进⼊临界区；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>记录型信号量
&lt;ul>
&lt;li>P操作：信号量减⼀，信号量 小于 0时，⾃动阻塞进程；&lt;/li>
&lt;li>V操作：信号量加⼀，信号量 小于等于 0时，唤醒⼀个等待进程；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>信号量实现互斥
&lt;ul>
&lt;li>信号 初值为1 ，在临界区前加上P操作，后加上V操作；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>信号量实现同步
&lt;ul>
&lt;li>信号量 初值为0 ，在前⼀进程后加上V操作，后⼀进程前加上P操作；&lt;/li>
&lt;li>每有⼀个前后关系设置⼀个信号量；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>2）管程&lt;/p>
&lt;ul>
&lt;li>管程把对共享资源的操作封装起来；&lt;/li>
&lt;li>只能通过管程的操作访问共享资源；&lt;/li>
&lt;li>每次只允许⼀个进程进⼊管程；&lt;/li>
&lt;li>管程的 条件变量 为没有值的信号量，仅实现 等待排队 功能；&lt;/li>
&lt;/ul>
&lt;h4 id="234-经典同步问题">2.3.4 经典同步问题&lt;/h4>
&lt;p>同步问题:&lt;/p>
&lt;ul>
&lt;li>⽣产者-消费者问题&lt;/li>
&lt;li>吸烟者问题：相当于⽣产者⽣成多种产品的⽣产者-消费者问题；&lt;/li>
&lt;/ul>
&lt;p>互斥问题:&lt;/p>
&lt;ul>
&lt;li>读者-写者问题：设置计数器；&lt;/li>
&lt;li>哲学家进餐问题：使⽤信号量数组；&lt;/li>
&lt;/ul>
&lt;h3 id="24-死锁">2.4 死锁*&lt;/h3>
&lt;h4 id="241-死锁的必要条件">2.4.1 死锁的必要条件&lt;/h4>
&lt;p>互斥条件 ：某资源⼀段时间内只允许⼀个进程进⾏访问；
不可剥夺条件 ：进程所获得的资源只能由进程⾃⼰释放；
请求并保持 ：已占有资源，并继续请求其他资源；
循环等待条件 ：存在⼀种进程资源的循环等待链；&lt;/p>
&lt;p>产生原因:&lt;/p>
&lt;ul>
&lt;li>系统资源不⾜；&lt;/li>
&lt;li>资源分配不当；&lt;/li>
&lt;li>进程推进顺序不当；&lt;/li>
&lt;/ul>
&lt;h4 id="242-死锁的处理策略">2.4.2 死锁的处理策略&lt;/h4>
&lt;p>1） 死锁预防；&lt;/p>
&lt;p>破坏死锁的必要条件；&lt;/p>
&lt;ul>
&lt;li>破环互斥条件：某些场合（打印机）应保持互斥性；&lt;/li>
&lt;li>破坏⾮剥夺条件：请求新资源得不到满⾜时， 释放已申请 的所有资源重新申请；(仅适用于 主存资源 和 处理器资源 的分配),会导致资源利用率下降&lt;/li>
&lt;li>破环请求并保持条件：使⽤ &lt;strong>静态分配 （运⾏前⼀次申请完毕）&lt;/strong>；&lt;/li>
&lt;li>破坏循环等待条件：采⽤ &lt;strong>顺序资源分配 （按资源编号申请资源）&lt;/strong>；&lt;/li>
&lt;/ul>
&lt;p>2） 死锁避免 ；&lt;/p>
&lt;p>资源动态分配过程中，防⽌系统进⼊不安全状态；&lt;/p>
&lt;p>每次分配都预先验证是否会使系统保持 安全状态 ；
并⾮所有不安全状态都是死锁状态；&lt;/p>
&lt;p>银⾏家算法：&lt;/p>
&lt;ul>
&lt;li>进程后续申请资源数和已占⽤资源数之和 与 最⼤需求量⽐较，超过则拒绝分配；&lt;/li>
&lt;li>系统将现存资源数量 与 进程请求量进⾏⽐较，如果超过则拒绝分配；&lt;/li>
&lt;li>执⾏安全性算法，检测此次分配后是否满⾜安全状态，满⾜则正式分配；&lt;/li>
&lt;/ul>
&lt;p>3） 死锁的检测和解除 ；&lt;/p>
&lt;p>系统采取措施检测死锁并解除；&lt;/p>
&lt;p>死锁检测： 死锁条件 是 &lt;strong>资源分配图 不可完全简化&lt;/strong>；&lt;/p>
&lt;ul>
&lt;li>既 不独立也不阻塞 （有有向边连接且申请资源数⼩于系统资源数）的进程点即可释放所有资源；
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e5%9f%ba%e7%a1%80/2024-03-08-08-50-34.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/li>
&lt;/ul>
&lt;p>死锁解除：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>撤销进程法：撤销进程；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>进程回退法：回退进程；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>立即结束所有进程的执行，重新启动操作系统：这种方法简单，但以前所在的工作全部作废，损失很大。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>撤销涉及死锁的所有进程，解除死锁后继续运行：这种方法能彻底打破死锁的循环等待条件，但将付出很大代价，例如有些进程可能已经计算了很长时间，由于被撤销而使产生的部分结果也被消除了，再重新执行时还要再次进行计算。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>逐个撤销涉及死锁的进程，回收其资源直至死锁解除。抢占资源：从涉及死锁的一个或几个进程中&lt;/p>
&lt;/li>
&lt;li>
&lt;p>抢占资源，把夺得的资源再分配给涉及死锁的进程直至死锁解除。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="25-作业程序进程的关系-">2.5 作业、程序、进程的关系-&lt;/h3>
&lt;p>⼀份作业包含多段程序；&lt;/p>
&lt;p>进程是程序的动态运⾏过程；&lt;/p>
&lt;blockquote>
&lt;p>⼀个程序可以形成⼏个进程，⼀个进程也可以执⾏多个程序（程序有⼤有⼩）；&lt;/p>
&lt;/blockquote>
&lt;p>每个作业动态转换为⼀个进程族；&lt;/p>
&lt;ul>
&lt;li>批处理系统 ，每个作业有⼀个 根进程 ，该进程执⾏作业控制命令解释程序，解释改作业说明书，根进程在运⾏过程中可以动态的创建多个⼦进程；&lt;/li>
&lt;li>分时系统 的作业为⽤户的⼀次 上机交互过程 ，根进程为 终端进程 ，执⾏命令解释程序；&lt;/li>
&lt;li>交互提交批作业 的操作系统中，可以交互式的提交批作业，动态转化为⼀个进程族；&lt;/li>
&lt;/ul>
&lt;h2 id="三内存管理">三、内存管理&lt;/h2>
&lt;h3 id="31-内存管理概念">3.1 内存管理概念&lt;/h3>
&lt;h4 id="311-内存管理功能">3.1.1 内存管理功能*&lt;/h4>
&lt;ul>
&lt;li>内存空间的分配和回收: 对进程所需的内存进行分配和释放，malloc 函数：申请内存，free 函数：释放内存。&lt;/li>
&lt;li>地址转换: 将程序中的虚拟地址转换成内存中的物理地址。&lt;/li>
&lt;li>空间扩充: 当系统没有足够的内存时，利用&lt;strong>虚拟内存技术或自动覆盖技术&lt;/strong>，从逻辑上扩充内存。&lt;/li>
&lt;li>内存保护: 保证进程之间使用内存互不干扰，避免一些恶意程序通过修改内存来破坏系统的安全性。&lt;/li>
&lt;/ul>
&lt;h4 id="312-程序执步骤">3.1.2 程序执⾏步骤&lt;/h4>
&lt;p>1）编译：由编译程序将源代码编译成各**⽬标模块的机器语⾔代码**；
2）链接：由链接程序按 各模块代码 与 库函数 的相对地址链接成从0开始编制的 &lt;strong>统一逻辑地址空间&lt;/strong> ，形成 装入模块 ；&lt;/p>
&lt;ul>
&lt;li>静态链接：装⼊之前就链接；&lt;/li>
&lt;li>装⼊时动态链接：装⼊时链接；&lt;/li>
&lt;li>运⾏时动态链接：程序执⾏时需要⽤到⽬标模块再链接；
3）装⼊：由装⼊程序将装⼊模块 分配地址 装⼊内存；&lt;/li>
&lt;li>绝对装⼊：由 程序员 直接赋予或由 编译程序 给出 绝对/物理地址 ；&lt;/li>
&lt;li>静态重定位： 装入前 为从0开始的 逻辑地址 ，装⼊后重定位为 绝对/物理地址 ；&lt;/li>
&lt;li>动态重定位： 运行时 将逻辑地址转为绝对/物理地址（需 重定位寄存器/基址寄存器 ）；&lt;/li>
&lt;/ul>
&lt;h4 id="313-逻辑地址和物理地址">3.1.3 逻辑地址和物理地址&lt;/h4>
&lt;p>每个⽬标模块都&lt;strong>从0开始编制，为其相对地址（逻辑地址）&lt;/strong>，
链接程序将 各模块和库函数 链接为同⼀的从0编制的逻辑地址空间，对程序员不透明；&lt;/p>
&lt;p>物理地址为内存的实际地址，对程序员时 透明 的；&lt;/p>
&lt;h3 id="32-地址分配和回收">3.2 地址分配和回收*&lt;/h3>
&lt;p>内部内存碎片(Internal Memory Fragmentation，简称为内存碎片)：已经&lt;strong>分配给进程使用但未被使用的内存&lt;/strong>。&lt;/p>
&lt;p>外部内存碎片(External Memory Fragmentation，简称为外部碎片)：由于未分配的连续内存区域太小，以至于&lt;strong>不能满足任意进程所需要的内存分配请求&lt;/strong>，这些小片段且不连续的内存空间被称为外部碎片。&lt;/p>
&lt;h4 id="321-连续分配-管理式">3.2.1 连续分配 管理⽅式&lt;/h4>
&lt;p>1）单⼀连续分配
仅分为低位的 系统区 和⾼位的 用户区 ；
内存只有⼀道程序， 无需系统保护 ；&lt;/p>
&lt;p>2）固定分区分配
每个分区装⼊⼀道作业；&lt;/p>
&lt;ul>
&lt;li>分为 分区⼤⼩相等、分区⼤⼩不等 两种划分⽅式；&lt;/li>
&lt;li>使⽤ 覆盖技术 扩⼤分区可容纳的程序⼤⼩；&lt;/li>
&lt;li>⽆外部碎⽚，易产⽣ 内部碎片 ；&lt;/li>
&lt;/ul>
&lt;p>3）动态分区分配（可变分区分配）&lt;/p>
&lt;ul>
&lt;li>根据装⼊进程的⼤⼩ 动态的 建⽴分区；&lt;/li>
&lt;li>易产⽣ 外部碎片 ，可采⽤ 紧凑技术 解决，需要动态重定位寄存器（ 基址寄存器 ）的⽀持；&lt;/li>
&lt;li>分区 分配策略 ：
&lt;ul>
&lt;li>⾸次适应算法
&lt;ul>
&lt;li>⽐其它三种都好；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>最佳适应算法
&lt;ul>
&lt;li>⽐最⼤适应好；&lt;/li>
&lt;li>最容易产⽣内部碎⽚；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>最坏/⼤适应算法&lt;/li>
&lt;li>临近适应算法（循环⾸次适应算法）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>块式管理 是早期计算机操作系统的一种连续内存管理方式，存在严重的内存碎片问题。&lt;/p>
&lt;p>在 Linux 系统中，连续内存管理采用了 伙伴系统（Buddy System）算法.一种经典的连续内存分配算法，可以有效解决外部内存碎片的问题。伙伴系统的主要思想是将内存按 2 的幂次划分（每一块内存大小都是 2 的幂次比如 2^6=64 KB），并将相邻的内存块组合成一对伙伴（注意：必须是相邻的才是伙伴）。&lt;/p>
&lt;ul>
&lt;li>当进行内存分配时，伙伴系统会尝试找到大小最合适的内存块。如果找到的内存块过大，就将其一分为二，分成两个大小相等的伙伴块。如果还是大的话，就继续切分，直到到达合适的大小为止。&lt;/li>
&lt;li>假设两块相邻的内存块都被释放，系统会将这两个内存块合并，进而形成一个更大的内存块，以便后续的内存分配。这样就可以减少内存碎片的问题，提高内存利用率。&lt;/li>
&lt;/ul>
&lt;p>对于内部内碎片问题, Linux采用SLAB解决.&lt;/p>
&lt;h4 id="322-非连续分配-管理式">3.2.2 非连续分配 管理⽅式&lt;/h4>
&lt;h5 id="1-基本-页式-存储管理">1 基本 页式 存储管理&lt;/h5>
&lt;p>分⻚是 &lt;strong>系统行为&lt;/strong> ，对程序员是 透明的 ；&lt;/p>
&lt;p>A）基本概念&lt;/p>
&lt;p>⻚⾯&lt;/p>
&lt;ul>
&lt;li>将进程的块称为 页/页面 ，内存中块称为 页框/页架 ，两者 一一对应 ；&lt;/li>
&lt;li>⻚⾯⼤⼩是2的整数次幂；&lt;/li>
&lt;li>每个进程有多个逻辑模块，⻚式存储每个⻚表对应进程的⼀个逻辑模块，因此 &lt;strong>页表内所有页为统一的逻辑地址空间&lt;/strong> ；&lt;/li>
&lt;/ul>
&lt;p>⻚表和⻚表项&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e5%9f%ba%e7%a1%80/%e2%bb%9a%e8%a1%a8%e5%9b%be.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;ul>
&lt;li>⻚表记录了对应进程每个⻚⾯在内存中所对应的 物理页号 ；&lt;/li>
&lt;li>⻚表由⻚表项构成；&lt;/li>
&lt;li>⻚表项分为 页号 （ 隐含 ，&lt;strong>因为定⻓且顺序存储&lt;/strong>）和 块号 ；&lt;/li>
&lt;/ul>
&lt;p>⻚式逻辑地址
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e5%9f%ba%e7%a1%80/%e2%bb%9a%e5%bc%8f%e9%80%bb%e8%be%91%e5%9c%b0%e5%9d%80%e5%9b%be.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;ul>
&lt;li>⾼位为 页号 ，低位为 页内偏移量 ；&lt;/li>
&lt;li>⻚内偏移量的位数决定了 页面大小 ；&lt;/li>
&lt;li>⻚式管理中地址空间是 &lt;strong>一维&lt;/strong> 的（只要知道逻辑地址,根据页面大小可以确定页号和偏移量）；&lt;/li>
&lt;/ul>
&lt;p>B）⻚式地址转换&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e5%9f%ba%e7%a1%80/%e2%bb%9a%e5%bc%8f%e8%bd%ac%e6%8d%a2%e6%b5%81%e7%a8%8b%e5%9b%be.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;ul>
&lt;li>根据进程号找到 页表基址寄存器PTR 内的⻚表基址；&lt;/li>
&lt;li>计算 页号和偏移量 ：⽤逻辑地址⼤⼩除以⻚⾯⼤⼩，整数部分为⻚号，余数部分为⻚内偏移量；&lt;/li>
&lt;li>当⻚号⼤于⻚表⻓度（表项个数）时，产⽣ 越界中断 ；&lt;/li>
&lt;li>取出⻚表内对应的物理⻚号，与偏移量组成物理地址；&lt;/li>
&lt;/ul>
&lt;p>C）快表（ &lt;strong>相联存储器TLB&lt;/strong> ）
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e5%9f%ba%e7%a1%80/%e5%bf%ab%e8%a1%a8%e5%9c%b0%e5%9d%80%e8%bd%ac%e6%8d%a2%e6%b5%81%e7%a8%8b%e5%9b%be.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;ul>
&lt;li>将常⽤的⻚表项存储到⾼速存储器；&lt;/li>
&lt;li>CPU给出逻辑地址后同时查找快表和内存⻚表（或先查快表再查⻚表）；&lt;/li>
&lt;li>快表的有效性取决于 &lt;strong>局部性原理&lt;/strong> （空间局部性、时间局部性）
&lt;ul>
&lt;li>空间局部性：活跃部分集中在临近空间；&lt;/li>
&lt;li>时间局部性：某部分在单位时间内多次使⽤；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>D）两级⻚表
地址转换过程和段⻚式存储相似；
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e5%9f%ba%e7%a1%80/%e4%b8%a4%e7%ba%a7%e2%bb%9a%e8%a1%a8%e5%9b%be.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;ul>
&lt;li>
&lt;p>由于进程⻚表过⼤占⽤多个⻚⾯，且不需要所有保存⻚表项的⻚⾯都调⼊内存，因此采⽤⼆级⻚表；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>⼀级⻚表（⻚⽬录表/顶级⻚表）负责 ⼆级⻚表逻辑地址和物理地址的映射关系；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>最底层⻚表负责 进程逻辑地址到物理地址的映射关系；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h5 id="2-基本-段式-存储管理">2 基本 段式 存储管理&lt;/h5>
&lt;p>分段是 &lt;strong>按用户进程&lt;/strong> 的⾃然段划分的逻辑空间；&lt;/p>
&lt;p>A）基本概念&lt;/p>
&lt;p>分段是 按用户进程 的⾃然段划分的逻辑空间；
分段的⻓度 不固定 ；
每个进程对应⼀个段表，每个逻辑模块对应⼀个段表项，因此 &lt;strong>段内逻辑地址连续，段间不连续&lt;/strong>；&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e5%9f%ba%e7%a1%80/%e6%ae%b5%e8%a1%a8.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>段式逻辑地址：段式逻辑地址空间是 二维 的，&lt;strong>因为段⻓不固定&lt;/strong>，因此需要段号和偏移量才能知道物理地址；&lt;/p>
&lt;p>B）段式地址转换
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e5%9f%ba%e7%a1%80/%e6%ae%b5%e5%bc%8f%e5%9c%b0%e5%9d%80%e8%bd%ac%e6%8d%a2%e6%b5%81%e7%a8%8b%e5%9b%be.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;ul>
&lt;li>根据进程号找到 段表基址寄存器 的基址；&lt;/li>
&lt;li>段号⼤于段表⻓则产⽣ 越界中断 ；&lt;/li>
&lt;li>根据段号找到段表项，如果取出的段⻓⼩于段内偏移量产⽣ 越界中断 ；&lt;/li>
&lt;li>最后取出物理段号，和偏移量组合成物理地址；&lt;/li>
&lt;/ul>
&lt;p>C）段的共享和保护&lt;/p>
&lt;ul>
&lt;li>段共享通过将两个作业的段表中相应表项指向同⼀个物理地址来实现；&lt;/li>
&lt;li>段保护为 存取控制保护 和 地址越界保护;
&lt;ul>
&lt;li>存取控制保护设置共享段的存取权限，地址越界保护和⻚保护相似（多了⼀个偏移量越界中断）；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>只有 纯代码/可重入代码 （不能修改的代码，因此 不属于临界资源 ）才可以共享；&lt;/li>
&lt;/ul>
&lt;h5 id="3-基本-段页式-管理式">3 基本 段页式 管理⽅式&lt;/h5>
&lt;p>A）基本概念
段⻚式逻辑地址结构
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e5%9f%ba%e7%a1%80/%e6%ae%b5%e8%a1%a8%e5%92%8c%e2%bb%9a%e8%a1%a8.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>段表和⻚表，⻚表和⻚式存储相同，段表与段式存储相⽐段始址换位 页表基址 ；&lt;/p>
&lt;p>每个进程有**⼀个段表，多个⻚表**；&lt;/p>
&lt;p>B）段⻚式地址转换
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e5%9f%ba%e7%a1%80/%e8%bd%ac%e6%8d%a2%e6%b5%81%e7%a8%8b%e5%9b%be.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
分别检测 段表越界 和 页表越界 （相当于段式存储中断偏移量越界）；&lt;/p>
&lt;h3 id="33-地址转换和内存保护">3.3 地址转换和内存保护&lt;/h3>
&lt;h4 id="331-地址转换-装入-">3.3.1 地址转换（ 装入 ）&lt;/h4>
&lt;p>连续分配管理&lt;/p>
&lt;ul>
&lt;li>单⼀连续分配：绝对装⼊、静态重定位、动态重定位；&lt;/li>
&lt;li>固定分区分配：绝对装⼊、静态重定位、动态重定位；&lt;/li>
&lt;li>可变分区分配：绝对装⼊、静态重定位、动态重定位；&lt;/li>
&lt;/ul>
&lt;p>⾮连续分配管理：动态重定位；&lt;/p>
&lt;h4 id="332-地址保护">3.3.2 地址保护&lt;/h4>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e5%9f%ba%e7%a1%80/2024-03-08-09-36-18.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="34-内存空间扩充">3.4 内存空间扩充*&lt;/h3>
&lt;h4 id="341-覆盖-和-交换">3.4.1 覆盖 和 交换&lt;/h4>
&lt;p>覆盖⽤于同⼀进程，⽽交换⽤于多个不同进程；&lt;/p>
&lt;p>1）覆盖&lt;/p>
&lt;ul>
&lt;li>不需要装⼊进程的全部信息；⽤于单⼀分配和固定分区；&lt;/li>
&lt;li>把⽤户空间分为⼀个&lt;strong>固定区和若⼲覆盖区&lt;/strong>；&lt;/li>
&lt;li>固定区存放进程中活跃的部分；&lt;/li>
&lt;li>覆盖区存放即将要访问的段(将不活跃的部分划分为永&lt;strong>远不会同时运⾏的段&lt;/strong>)；&lt;/li>
&lt;/ul>
&lt;p>2）交换&lt;/p>
&lt;ul>
&lt;li>就是 进程挂起 ；&lt;/li>
&lt;li>进程完全空闲时，将进程交换到辅存内独⽴于⽂件系统的 对换区 （采⽤连续分配⽅式因此读写速度更快）；&lt;/li>
&lt;/ul>
&lt;h4 id="342-虚拟内存-技术以-请求页式存储管理-为例">3.4.2 虚拟内存 技术（以 请求页式存储管理 为例）&lt;/h4>
&lt;p>虚拟内存(Virtual Memory) 是计算机系统内存管理非常重要的一个技术，本质上来说它&lt;strong>只是逻辑存在的，是一个假想出来的内存空间，主要作用是作为进程访问主存（物理内存）的桥梁并简化内存管理&lt;/strong>。&lt;/p>
&lt;p>虚拟内存的作用:&lt;/p>
&lt;ul>
&lt;li>隔离进程：物理内存通过虚拟地址空间访问，虚拟地址空间与进程一一对应。进程之间彼此隔离，一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。&lt;/li>
&lt;li>提升物理内存利用率：有了虚拟地址空间后，操作系统只需要将进程当前正在使用的部分数据或指令加载入物理内存。&lt;/li>
&lt;li>简化内存管理：进程都有一个一致且私有的虚拟地址空间，程序员不用和真正的物理内存打交道，而是借助虚拟地址空间访问物理内存，从而简化了内存管理。&lt;/li>
&lt;li>多个进程共享物理内存：进程在运行过程中，会加载许多操作系统的动态库。这些库对于每个进程而言都是公用的，它们在内存中实际只会加载一份，这部分称为共享内存。&lt;/li>
&lt;li>提高内存使用安全性：控制进程对物理内存的访问，隔离不同进程的访问权限，提高系统的安全性。&lt;/li>
&lt;li>提供更大的可使用内存空间：可以让程序拥有超过系统物理内存大小的可用内存空间。这是因为当物理内存不够用时，可以利用磁盘充当，将物理内存页（通常大小为 4 KB）保存到磁盘文件（会影响读写速度），数据或代码页会根据需要在物理内存与磁盘之间移动。&lt;/li>
&lt;/ul>
&lt;p>没有虚拟内存有什么问题？&lt;/p>
&lt;ul>
&lt;li>系统不安全: 用户程序可以访问任意物理内存，可能会不小心操作到系统运行必需的内存，进而造成操作系统崩溃，严重影响系统的安全。&lt;/li>
&lt;li>进程不稳定: 同时运行多个程序容易崩溃。比如你想同时运行一个微信和一个 QQ 音乐，微信在运行的时候给内存地址 1xxx 赋值后，QQ 音乐也同样给内存地址 1xxx 赋值，那么 QQ 音乐对内存的赋值就会覆盖微信之前所赋的值，这就可能会造成微信这个程序会崩溃。&lt;/li>
&lt;li>浪费内存: 程序运行过程中使用的所有数据或指令都要载入物理内存，根据局部性原理，其中很大一部分可能都不会用到，白白占用了宝贵的物理内存资源。&lt;/li>
&lt;/ul>
&lt;p>1）请求⻚式存储管理
2）请求段式存储管理
3）请求段⻚式存储管理&lt;/p>
&lt;p>A）⻚表项&lt;/p>
&lt;ul>
&lt;li>状态位/有效位：是否调⼊内存；&lt;/li>
&lt;li>访问字段/置换位：⼀段时间内被访问次数，配合⻚⾯置换算法使&lt;/li>
&lt;li>修改位/脏位：是否被修改&lt;/li>
&lt;li>外存地址：该⻚在外存的地址；&lt;/li>
&lt;/ul>
&lt;p>B）缺⻚中断&lt;/p>
&lt;ul>
&lt;li>缺⻚中断为 内中断 ；&lt;/li>
&lt;/ul>
&lt;p>C）⻚⾯置换策略/算法&lt;/p>
&lt;ul>
&lt;li>最佳置换 OPT 算法
&lt;ul>
&lt;li>无法实现, 用于评价其他算法&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>先进先出 FIFO 置换算法
&lt;ul>
&lt;li>会产⽣belady异常, 分配的页面数增多，但缺页率反而提高&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>最近不经常使⽤ LRU 算法&lt;/li>
&lt;li>时钟置换 CLOCK 算法（最近未使⽤ NRU 算法）
&lt;ul>
&lt;li>因LRU实现困难，开销⼤⽽设计；增加访问位和修改位；&lt;/li>
&lt;li>最近未被访问，也未被修改(u=0, m= 0)；&lt;/li>
&lt;li>最近未被访问，但被修改(u=0,m=1)；&lt;/li>
&lt;li>最近被访问，但未被修改(u= 1,m=0)；&lt;/li>
&lt;li>最近被访问，被修改(u=1,m= 1)；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>D）⻚⾯分配
反复的调⼊调出叫 抖动/颠簸 ；
驻留集: 是内存为进程分配的空间⼤⼩；
工作集: 为某段时间间隔内（⼯作集窗⼝），进程访问的⻚⾯集合（ 驻留集需要大于工作集 ）；&lt;/p>
&lt;p>分配策略/算法&lt;/p>
&lt;ul>
&lt;li>固定分配
&lt;ul>
&lt;li>驻留集⼤⼩不变；&lt;/li>
&lt;li>固定分配局部置换：驻留集⼤⼩不变，且只在分配的驻留集内进程⻚⾯置换；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>可变分配
&lt;ul>
&lt;li>驻留集⼤⼩可变；&lt;/li>
&lt;li>可变分配全局置换：驻留集⼤⼩可变，且将欲调⼊的⻚置换到OS的空闲块队列；&lt;/li>
&lt;li>可变分配局部置换：驻留集⼤⼩可变，将欲调⼊的⻚置换到驻留集，根据缺⻚率动态调整驻留集⼤⼩；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>⻚⾯调⼊时机&lt;/p>
&lt;ul>
&lt;li>预调页 策略/算法：运⾏前预测需要调⼊的⻚⾯，⼀次调⼊内存；&lt;/li>
&lt;li>请求调页 策略/算法：运⾏时根据请求来逐⻚的调⼊内存；
调⼊调出的位置&lt;/li>
&lt;li>当系统拥有⾜够对换区空间时，调⼊调出都使⽤对换区；&lt;/li>
&lt;li>当系统没有⾜够对换区空间时，从⽂件区调⼊，从对换区调出修改过的内容（未修改的不⽤调出，直接下次再从⽂件区调⼊）；&lt;/li>
&lt;li>UNIX方式 ：从⽂件区调⼊，从对换区调出（只要是从内存调出都放⼊对换区）；&lt;/li>
&lt;/ul>
&lt;h2 id="四件管理">四、⽂件管理&lt;/h2>
&lt;h3 id="41-件系统基础">4.1 ⽂件系统基础*&lt;/h3>
&lt;p>Windows：FCB 表 + FAT + 位图
Unix：inode + 混合索引 + 成组链接&lt;/p>
&lt;p>文件系统主要负责管理和组织计算机存储设备上的文件和目录，其功能包括以下几个方面：&lt;/p>
&lt;ul>
&lt;li>存储管理：将文件数据存储到物理存储介质中，并且管理空间分配，以确保每个文件都有足够的空间存储，并避免文件之间发生冲突。&lt;/li>
&lt;li>文件管理：文件的创建、删除、移动、重命名、压缩、加密、共享等等。&lt;/li>
&lt;li>目录管理：目录的创建、删除、移动、重命名等等。&lt;/li>
&lt;li>文件访问控制：管理不同用户或进程对文件的访问权限，以确保用户只能访问其被授权访问的文件，以保证文件的安全性和保密性&lt;/li>
&lt;/ul>
&lt;h4 id="411-录结构">4.1.1 ⽬录结构&lt;/h4>
&lt;p>1）⽂件控制块和索引结点&lt;/p>
&lt;p>A）⽂件控制块 FCB&lt;/p>
&lt;ul>
&lt;li>为实现 按名存取 ⽽设计，FCB的有序集合位⽬录，⼀个FCB为⼀个⽂件⽬录项；&lt;/li>
&lt;li>基本信息 （⽂件名、物理位置、逻辑结构、物理结构等）、 存取控制信息（存取权限等）、 使用信息 （建⽴时间、修改时间等）；&lt;/li>
&lt;/ul>
&lt;p>B） 索引结点&lt;/p>
&lt;ul>
&lt;li>将FCB的⽂件名和⽂件描述信息分离（使得磁盘块可以存储更多的FCB）；&lt;/li>
&lt;li>索引结点为 文件描述信息 ，FCB只包含⽂件名和索引结点指针；&lt;/li>
&lt;/ul>
&lt;p>2）⽬录结构&lt;/p>
&lt;ul>
&lt;li>单级⽬录结构：整个系统就⼀个⽬录；&lt;/li>
&lt;li>两级⽬录结构：每个⽤户有⼀个⽬录；&lt;/li>
&lt;li>多级⽬录结构（树形⽬录结构）：有多级⽬录，出现 绝对路径 和 相对路径 ；&lt;/li>
&lt;li>⽆环图⽬录结构：多个⽗结点指向同⼀个结点（实现 文件共享 ）；
&lt;ul>
&lt;li>某个⽗结点删除共享结点后不⼀定删除，需要所有指向共享结点的结点都断开才删除；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="412-件共享与保护">4.1.2 ⽂件共享与保护*&lt;/h4>
&lt;p>1）⽂件共享&lt;/p>
&lt;ul>
&lt;li>基于索引结点共享（ 硬链接 ）：直接使**⽬录项指向该⽂件的索引结点**；
&lt;ul>
&lt;li>只有删除了源文件和所有对应的硬链接文件，该文件才会被真正删除&lt;/li>
&lt;li>&lt;code>ln&lt;/code> 命令用于创建硬链接。&lt;/li>
&lt;li>限制
&lt;ul>
&lt;li>不能对目录以及不存在的文件创建硬链接&lt;/li>
&lt;li>硬链接不能跨越文件系统。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>基于符号链共享（ 软链接 ）：建⽴ &lt;strong>LINK文件&lt;/strong> 保存共享⽂件的绝对路径；
&lt;ul>
&lt;li>使⽤时根据绝对路径⼀级⼀级查找；&lt;/li>
&lt;li>&lt;code>ln -s&lt;/code> 命令用于创建软链接&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>2）⽂件保护&lt;/p>
&lt;p>A）访问控制：每个⽂件增加⼀个 访问控制列表ACL ，规定不同⽤户/⽤户组的访问权限；&lt;/p>
&lt;p>B）其它
⼝令：输⼊FCB上的⼝令来访问⽂件；
密码：保存的⽂件是加密过的不能正常读写，需要输⼊密码修改为正常⽂件&lt;/p>
&lt;h4 id="413-件的逻辑结构">4.1.3 ⽂件的逻辑结构&lt;/h4>
&lt;p>1）⽆结构⽂件（流式⽂件）
2）有结构⽂件（记录式⽂件）&lt;/p>
&lt;ul>
&lt;li>为实现 顺序查找 、 索引查找 、 索引顺序查找 、 哈希查找 ⽽设计；&lt;/li>
&lt;/ul>
&lt;p>A）顺序⽂件: 顺序存储&lt;/p>
&lt;ul>
&lt;li>定⻓顺序存储：可实现 随机存取 ；
&lt;ul>
&lt;li>定⻓串结构
&lt;ul>
&lt;li>记录⻓度相等，记录之间顺序与关键字⽆关（由时间决定）；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>定⻓顺序结构：可实现 随机存取 与 快速检索 ；
&lt;ul>
&lt;li>记录⻓度相等，记录之间按关键字排列；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>变⻓顺序存储
&lt;ul>
&lt;li>变⻓串结构&lt;/li>
&lt;li>变⻓顺序结构&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>B）索引⽂件：建⽴的索引表可以实现 随机存取 ；&lt;/p>
&lt;p>C）索引顺序⽂件：顺序⽂件分组，建⽴索引表，索引表每个表项指向其中⼀组；&lt;/p>
&lt;p>D）直接⽂件（散列⽂件）：根据散列函数存取；&lt;/p>
&lt;h3 id="42-件系统实现">4.2 ⽂件系统实现&lt;/h3>
&lt;p>⽂件区和⽬录区是分开的；&lt;/p>
&lt;h4 id="421-录实现">4.2.1 ⽬录实现&lt;/h4>
&lt;p>线性表: 顺序和链式均可；
哈希表&lt;/p>
&lt;h4 id="422-件的物理结构">4.2.2 ⽂件的物理结构&lt;/h4>
&lt;p>1）⽂件分配⽅式（⾮空闲磁盘块的管理）&lt;/p>
&lt;ul>
&lt;li>A）连续分配&lt;/li>
&lt;li>B）链接分配
&lt;ul>
&lt;li>显式链接：建⽴⽂件分配表 FAT ，使每个物理块号有指定的下⼀块指针；⽂件分配表FAT可以 随机访问 ；&lt;/li>
&lt;li>隐式链接：直接在块上⾯存放指针；
C）索引分配：每个⽂件建⽴ 索引表 ，使得⽂件的每个逻辑块号都有对应的物理块号；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>和⻚表相似；&lt;/li>
&lt;li>链接⽅案：为解决索引表⼤于磁盘块的问题，使⽤指针将多个索引块链接；&lt;/li>
&lt;li>多层索引：类⽐内存管理的多级⻚表；&lt;/li>
&lt;li>混合索引：建⽴包含直接地址、间接索引表地址的 &lt;strong>顶级索引表&lt;/strong> ；&lt;/li>
&lt;/ul>
&lt;p>2）⽂件存储空间管理（空闲磁盘块的管理）&lt;/p>
&lt;p>A）空闲表法&lt;/p>
&lt;p>B）空闲链表法&lt;/p>
&lt;ul>
&lt;li>空闲 盘块 链&lt;/li>
&lt;li>空闲 盘区 链：有下⼀盘区的指针与本盘区的⼤⼩；
C）位示图法
D）成组链表 法&lt;/li>
&lt;li>适⽤于⼤型⽂件系统；&lt;/li>
&lt;li>把空闲块依次填⼊其余空闲块的地址，从第⼀个块开始读取地址分配空间；&lt;/li>
&lt;li>第⼀个填⼊地址的空闲块叫做 超级块 ，需要预先读⼊主存；&lt;/li>
&lt;/ul>
&lt;h4 id="423-件系统的层次结构">4.2.3 ⽂件系统的层次结构&lt;/h4>
&lt;p>1）⽤户调⽤接⼝
2）⽂件⽬录系统: 管理⽂件⽬录；
3）存取控制验证模块: 通过⽂件⽬录的FCB实现 文件保护 ；
4）逻辑⽂件系统与⽂件信息缓冲区: 根据⽂件的逻辑结构将⽤户的要读写的逻辑记录转换成⽂件逻辑结构内的相应块号；
5）物理⽂件系统: 将逻辑记录所在的相应块号转换为实际的物理地址；
6）辅助分配模块: 管理辅存空间；
7）设备管理程序模块: 硬件相关 ；&lt;/p>
&lt;h4 id="424-提高文件系统性能的方式有哪些">4.2.4 提高文件系统性能的方式有哪些？*&lt;/h4>
&lt;ul>
&lt;li>优化硬件：使用高速硬件设备（如 SSD、NVMe）替代传统的机械硬盘，使用 RAID（Redundant Array of Inexpensive Disks）等技术提高磁盘性能。&lt;/li>
&lt;li>选择合适的文件系统选型：不同的文件系统具有不同的特性，对于不同的应用场景选择合适的文件系统可以提高系统性能。&lt;/li>
&lt;li>运用缓存：访问磁盘的效率比较低，可以运用缓存来减少磁盘的访问次数。不过，需要注意缓存命中率，缓存命中率过低的话，效果太差。&lt;/li>
&lt;li>避免磁盘过度使用：注意磁盘的使用率，避免将磁盘用满，尽量留一些剩余空间，以免对文件系统的性能产生负面影响。&lt;/li>
&lt;li>对磁盘进行合理的分区：合理的磁盘分区方案，能够使文件系统在不同的区域存储文件，从而减少文件碎片，提高文件读写性能。&lt;/li>
&lt;/ul>
&lt;h3 id="43-磁盘组织与管理">4.3 磁盘组织与管理&lt;/h3>
&lt;h4 id="431-磁盘的结构">4.3.1 磁盘的结构&lt;/h4>
&lt;p>组成:&lt;/p>
&lt;ul>
&lt;li>柱⾯&lt;/li>
&lt;li>磁头&lt;/li>
&lt;li>扇区&lt;/li>
&lt;/ul>
&lt;p>分类&lt;/p>
&lt;ul>
&lt;li>活动头磁盘、固定头磁盘&lt;/li>
&lt;li>固定盘磁盘、可换盘磁盘&lt;/li>
&lt;/ul>
&lt;h4 id="432-磁盘调度算法">4.3.2 磁盘调度算法*&lt;/h4>
&lt;p>标准：寻找时间（找磁道时间）、延迟时间（找扇区时间）、传输时间；&lt;/p>
&lt;ul>
&lt;li>先来先服务 FCFS 算法
&lt;ul>
&lt;li>按照请求到达磁盘调度器的顺序进行处理，先到达的请求的先被服务。FCFS 算法实现起来比较简单，不存在算法开销。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>最短寻找时间 SSTF 算法
&lt;ul>
&lt;li>也被称为最佳服务优先（Shortest Service Time First，SSTF）算法，优先选择距离当前磁头位置最近的请求进行服务。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>扫描 SCAN 算法：双向扫描；
&lt;ul>
&lt;li>可默认为LOOK算法，双向扫描到此⽅向最后⼀个柱⾯就转向；⼜称电梯调度算法；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>循环扫描 C-CSAN 算法：单向扫描；
&lt;ul>
&lt;li>可默认为C-LOOK算法，单向扫描到最后⼀个柱⾯就返回；&lt;/li>
&lt;li>只在磁盘的一侧进行扫描，并且只按照一个方向扫描，直到到达磁盘边界，然后回到磁盘起点，重新开始循环。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="433-磁盘的管理">4.3.3 磁盘的管理&lt;/h4>
&lt;p>1）磁盘初始化&lt;/p>
&lt;p>低级格式化 （物理分区）&lt;/p>
&lt;ul>
&lt;li>每个扇区分为头、尾和数据部分（头尾包含磁盘控制所⽤的信息）
逻辑格式化 （创建⽂件系统）&lt;/li>
&lt;/ul>
&lt;p>2）引导块&lt;/p>
&lt;p>磁盘上的引导块装⼊ 自举程序 （计算机启动时运⾏的初始化程序），在ROM硬件上只保留很⼩的 自居装入程序 （为了⽅便更改）；&lt;/p>
&lt;p>3）坏块&lt;/p>
&lt;p>简单磁盘会将坏扇区在FAT表中表明；&lt;/p>
&lt;p>复杂磁盘会使⽤控制器维护⼀个磁盘坏块链表，使⽤低级格式化时保留的备⽤块进⾏替换，这种⽅式对OS 透明 ；（ 扇区备用 ）&lt;/p>
&lt;h2 id="五输输出管理">五、输⼊/输出管理&lt;/h2>
&lt;h3 id="51-io管理概述">5.1 I/O管理概述&lt;/h3>
&lt;h4 id="511-io控制式">5.1.1 I/O控制⽅式&lt;/h4>
&lt;p>程序查询⽅式&lt;/p>
&lt;ul>
&lt;li>全程需要CPU参与；&lt;/li>
&lt;li>按字读写；&lt;/li>
&lt;/ul>
&lt;p>中断⽅式&lt;/p>
&lt;ul>
&lt;li>设备运⾏完成，准备就绪后发⽣中断使CPU参与；&lt;/li>
&lt;li>按字读写；&lt;/li>
&lt;/ul>
&lt;p>DMA⽅式&lt;/p>
&lt;ul>
&lt;li>DMA控制器为⼀种 块设备 的I/O控制器，且每个DMA仅对应⼀台设备；块设备可寻址；&lt;/li>
&lt;li>DMA控制器：命令/状态寄存器CR、数据寄存器DR、主存地址寄存器MAR、数据计数器DC；&lt;/li>
&lt;li>数据交换过程不需要经过CPU寄存器，CPU需最后读取DMA状态（还包括DMA启动时的预处理）；&lt;/li>
&lt;li>DMA⽅式下每条I/O指令，只能读写连续的数据块；&lt;/li>
&lt;li>按块读写；&lt;/li>
&lt;/ul>
&lt;p>通道控制⽅式&lt;/p>
&lt;ul>
&lt;li>CPU发送的I/O指令负责启动通道程序，最后CPU读取状态；&lt;/li>
&lt;li>通道执⾏内存中的通道程序（不必只操作连续数据块）；对⼀组块进程操作；&lt;/li>
&lt;/ul>
&lt;h4 id="512-io系统的层次结构">5.1.2 I/O⼦系统的层次结构&lt;/h4>
&lt;p>1）⽤户层I/O软件：实现与⽤户交互的接⼝；&lt;/p>
&lt;p>2）设备独⽴性软件&lt;/p>
&lt;p>A）执⾏所有设备的公有操作；&lt;/p>
&lt;ul>
&lt;li>I/O调度&lt;/li>
&lt;li>缓冲管理&lt;/li>
&lt;li>设备分配与回收&lt;/li>
&lt;li>设备保护&lt;/li>
&lt;li>SPOOLing技术
B）⾯向⽤户层提供接⼝；&lt;/li>
&lt;/ul>
&lt;p>3）设备驱动程序：与硬件相关；
4）中断处理程序：与硬件相关；
5）硬件设备&lt;/p>
&lt;h3 id="52-io核系统">5.2 I/O核⼼⼦系统&lt;/h3>
&lt;h4 id="521-io调度如磁盘调度">5.2.1 I/O调度：如磁盘调度；&lt;/h4>
&lt;h4 id="522-缓冲区">5.2.2 缓冲区&lt;/h4>
&lt;blockquote>
&lt;p>磁盘高速缓存 的缓冲区⼀般为内存，逻辑上属于磁盘，实际为内存；&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>单缓冲：
&lt;ul>
&lt;li>两次相同状态间的时间为：【CPU处理时间】与【I/O输⼊到缓存区的时间】取最⼤值，加上【缓存区传输到CPU的时间】；&lt;/li>
&lt;li>因为单缓冲区时，CPU和I/O设备都不能和缓存区冲突，因此最后【缓存区传输到CPU的时间】与其它相加；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>双缓冲：
&lt;ul>
&lt;li>【CPU处理时间】加上【缓存区传输到CPU的时间】，与【I/O输⼊到缓存区的时间】取最⼤值；&lt;/li>
&lt;li>因为双缓存时，缓存交替使⽤，所以I/O设备的传输可以和其它操作并⾏，所以【I/O输⼊到缓存区的时间】与其它操作时间取最⼤值；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>循环缓存&lt;/li>
&lt;li>缓冲池&lt;/li>
&lt;/ul>
&lt;h4 id="523-设备分配与回收">5.2.3 设备分配与回收&lt;/h4>
&lt;p>1）设备类型
独占式设备
分时共享设备
共享设备（SPOOLing技术）&lt;/p>
&lt;p>2）设备分配的数据结构&lt;/p>
&lt;p>从物理设备名依次按照SDT → DCT → COCT → CHCT的顺序查找并分配设备，所有部件都分配成功则设备分配完成；
⽤逻辑设备名查找时第⼀次使⽤SDT查找，并在LUT建⽴表项，以后基础使⽤LUT进程查找；&lt;/p>
&lt;p>通道控制表 CHCT ：描述通道状态，有 指向控制器 的指针；
控制器控制表 COCT ：描述控制器状态，有 指向通道 的指针；
设备控制表 DCT ：描述设备状态，有 指向控制器 的指针；
系统设备表 SDT ：⼀个系统只有⼀个，每个表项都有⼀个 DCT ；
逻辑设备表 LUT ：负责保存逻辑设备名（设备类型）到物理设备名的映射关系；
将常⽤设备名映射关系从⼤表SDT转移到⼩表LUT；&lt;/p>
&lt;p>3）分配策略
分配⽅式&lt;/p>
&lt;ul>
&lt;li>静态分配：⼀次性分配所有要求的设备；&lt;/li>
&lt;li>动态分配&lt;/li>
&lt;/ul>
&lt;p>分配算法：FCFS、优先级等
类似进程调度算法；&lt;/p>
&lt;p>4）分配安全性（设备保护？）&lt;/p>
&lt;ul>
&lt;li>安全分配⽅式：发出I/O请求后就阻塞进程，直到I/O操作完成；&lt;/li>
&lt;li>不安全分配⽅式：发出I/O请求后也不阻塞，可以继续申请；&lt;/li>
&lt;/ul>
&lt;h4 id="524-spooling技术-假脱机技术">5.2.4 SPOOLing技术 （假脱机技术）&lt;/h4>
&lt;p>1）组成&lt;/p>
&lt;ul>
&lt;li>输⼊井和输出井&lt;/li>
&lt;li>输⼊缓冲区和输⼊缓冲区&lt;/li>
&lt;li>输⼊进程和输出进程&lt;/li>
&lt;/ul>
&lt;p>2）特点（空间换时间）&lt;/p>
&lt;ul>
&lt;li>提⾼I/O速度；&lt;/li>
&lt;li>将独占设备改为共享设备；&lt;/li>
&lt;li>实现了虚拟设备功能；&lt;/li>
&lt;/ul></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/</guid><description>&lt;h1 id="mysql">MySQL&lt;/h1>
&lt;p>39.Mysql的存储引擎有什么
40.Innodb的特性
41.Mysql有几种锁
42.怎么避免锁全表
43.Insert into和replace into有什么区别
44.Union和union all的区别
45.常用的几种连接
46.Join和leftjoin什么区别&lt;/p>
&lt;p>MySQL&lt;/p>
&lt;h2 id="引擎">引擎&lt;/h2>
&lt;h3 id="innodb和myisam的区别">&lt;strong>InnoDB和MyISAM的区别&lt;/strong>&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>事务支持&lt;/strong>：InnoDB支持事务，MyISAM不支持事务&lt;/li>
&lt;li>&lt;strong>外键支持&lt;/strong>：InnoDB支持外键，MyISAM不支持外键&lt;/li>
&lt;li>&lt;strong>锁级别&lt;/strong>：InnoDB支持行级锁，MyISAM支持表级锁&lt;/li>
&lt;li>&lt;strong>MVCC&lt;/strong>：InnoDB支持MVCC，MyISAM不支持MVCC&lt;/li>
&lt;li>&lt;strong>表的具体行数&lt;/strong>：InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。MyISAM保存表的具体行数，执行上述语句时直接读取保存的行数。&lt;/li>
&lt;li>&lt;strong>异常奔溃后的恢复&lt;/strong>：InnoDB是崩溃后完全恢复（依赖redo log），MyISAM是损坏后无法恢复&lt;/li>
&lt;li>索引实现不一样：InnoDB是聚集索引，MyISAM是非聚集索引
&lt;ul>
&lt;li>如果没有指定主键，InnoDB会选择一个唯一的非空索引作为主键,如果没有这样的索引，InnoDB会自动创建一个隐藏的主键, 隐藏的主键是一个6字节的字段，是一个递增的整数，这个隐藏的主键是不可见的，但是可以通过show create table来查看。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="日志">日志&lt;/h2>
&lt;p>MySQL 日志 主要包括错误日志、查询日志、慢查询日志、事务日志、二进制日志几大类。其中，比较重要的还要属二进制日志 binlog（归档日志）和事务日志 redo log（重做日志）和 undo log（回滚日志）。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/MySQL/MySQL%e6%97%a5%e5%bf%97.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="重做日志redo-log">重做日志（redo log）&lt;/h3>
&lt;p>InnoDB存储引擎特有的日志&lt;/p>
&lt;p>InnoDB存储引擎以页为单位进行数据的读写，为了减少IO开销，InnoDB会将数据先写入到内存中的缓冲池，然后再以一定的频率刷入到磁盘中。但是，如果在数据写入到磁盘之前，数据库发生了异常重启，那么内存中的数据就会丢失，这时就需要重做日志来恢复数据。&lt;/p>
&lt;p>作用：保证事务的持久性，在数据库异常重启时，通过重做日志可以将数据恢复到异常重启之前的状态&lt;/p>
&lt;p>内容：记录数据页的物理修改，而不是逻辑修改&lt;/p>
&lt;p>redo log 主要做的事情就是记录页的修改，比如某个页面某个偏移量处修改了几个字节的值以及具体被修改的内容是什么。redo log 中的每一条记录包含了表空间号、数据页号、偏移量、具体修改的数据，甚至还可能会记录修改数据的长度（取决于 redo log 类型）。&lt;/p>
&lt;h4 id="刷盘时机">刷盘时机&lt;/h4>
&lt;p>事务开始之后就产生redo log，redo log的落盘并不是随着事务的提交才写入的，而是在事务的执行过程中，便开始写入redo log文件中。
理想情况，事务一提交就会进行刷盘操作，但实际上，刷盘的时机是根据策略来进行的。&lt;/p>
&lt;p>什么时候释放&lt;/p>
&lt;p>当对应事务的脏页写入到磁盘之后，redo log的使命也就完成了，重做日志占用的空间就可以重用（被覆盖）。&lt;/p>
&lt;h3 id="回滚日志undo-log">回滚日志（undo log）&lt;/h3>
&lt;p>undo log 属于逻辑日志，记录的是 SQL 语句，比如说事务执行一条 DELETE 语句，那 undo log 就会记录一条相对应的 INSERT 语句。同时，undo log 的信息也会被记录到 redo log 中，因为 undo log 也要实现持久性保护。并且，undo-log 本身是会被删除清理的，例如 INSERT 操作，在事务提交之后就可以清除掉了；UPDATE/DELETE 操作在事务提交不会立即删除，会加入 history list，由后台线程 purge 进行清理。&lt;/p>
&lt;p>作用：保证事务的原子性&lt;/p>
&lt;p>内容：记录数据页的逻辑修改&lt;/p>
&lt;p>在执行undo操作时，会将undo log中的数据写入到数据页中&lt;/p>
&lt;p>事务开始之前就产生undo log&lt;/p>
&lt;p>当事务提交之后，undo log并不能立马被删除，&lt;/p>
&lt;p>而是放入待清理的链表，由purge线程判断是否由其他事务在使用undo段中表的上一个事务之前的版本信息，决定是否可以清理undo log的日志空间。&lt;/p>
&lt;h3 id="二进制日志binlog">二进制日志（binlog）&lt;/h3>
&lt;p>主要记录了对 MySQL 数据库执行了更改的所有操作(数据库执行的所有 DDL 和 DML 语句)，包括表结构变更（CREATE、ALTER、DROP TABLE…）、表数据修改（INSERT、UPDATE、DELETE&amp;hellip;）&lt;/p>
&lt;p>内容：包括执行了的sql语句和反向的sql语句&lt;/p>
&lt;p>二进制记录格式：&lt;/p>
&lt;ul>
&lt;li>Statement 模式 ：每一条会修改数据的sql都会被记录在binlog中，如inserts, updates, deletes。&lt;/li>
&lt;li>Row 模式 （推荐）: 每一行的具体变更事件都会被记录在binlog中。&lt;/li>
&lt;li>Mixed 模式 ：Statement 模式和 Row 模式的混合。默认使用 Statement 模式，少数特殊具体场景自动切换到 Row 模式。&lt;/li>
&lt;/ul>
&lt;h4 id="用于主从复制">用于主从复制&lt;/h4>
&lt;ol>
&lt;li>主库将数据库中数据的变化写入到 binlog&lt;/li>
&lt;li>从库连接主库&lt;/li>
&lt;li>从库会创建一个 I/O 线程向主库请求更新的 binlog&lt;/li>
&lt;li>主库会创建一个 binlog dump 线程来发送 binlog ，从库中的 I/O 线程负责接收&lt;/li>
&lt;li>从库的 I/O 线程将接收的 binlog 写入到 relay log 中。&lt;/li>
&lt;li>从库的 SQL 线程读取 relay log 同步数据本地（也就是再执行一遍 SQL ）。&lt;/li>
&lt;/ol>
&lt;h4 id="刷盘时机-1">刷盘时机&lt;/h4>
&lt;p>会先把日志写入到binlog cache中，只有在事务提交的时候，才会把binlog cache中的日志持久化到磁盘上的binlog文件中。写入内存的速度更快，这样做也是为了效率考虑。&lt;/p>
&lt;p>可以通过binlog_cache_size参数控制单个线程 binlog cache 大小，如果存储内容超过了这个参数，就要暂存到磁盘（Swap）。&lt;/p>
&lt;p>那么 binlog 是什么时候刷到磁盘中的呢？ 可以通过 sync_binlog 参数控制 biglog 的刷盘时机，取值范围是 0-N，默认为 0 ：
0：不去强制要求，由系统自行判断何时写入磁盘；
1：每次提交事务的时候都要将binlog写入磁盘；
N：每 N 个事务，才会将binlog写入磁盘。&lt;/p>
&lt;h4 id="重新生成binlog">重新生成binlog&lt;/h4>
&lt;p>当遇到以下 3 种情况时，MySQL会重新生成一个新的日志文件，文件序号递增：&lt;/p>
&lt;ul>
&lt;li>MySQL服务器停止或重启；&lt;/li>
&lt;li>使用 flush logs 命令后；&lt;/li>
&lt;li>binlog 文件大小超过 max_binlog_size变量的阈值后。&lt;/li>
&lt;/ul>
&lt;h3 id="慢查询日志">慢查询日志&lt;/h3>
&lt;p>慢查询日志记录了执行时间超过 long_query_time（默认是 10s，通常设置为1s）的所有查询语句，在解决 SQL 慢查询（SQL 执行时间过长）问题的时候经常会用到。&lt;/p>
&lt;p>找到慢 SQL 是优化 SQL 语句性能的第一步，然后再用EXPLAIN 命令可以对慢 SQL 进行分析，获取执行计划的相关信息。&lt;/p>
&lt;p>可以通过 show variables like &amp;ldquo;slow_query_log&amp;rdquo;;命令来查看慢查询日志是否开启，默认是关闭的。&lt;/p>
&lt;h3 id="逻辑日志和物理日志">逻辑日志和物理日志&lt;/h3>
&lt;p>逻辑日志：记录的是逻辑操作，如insert、update、delete&lt;/p>
&lt;ul>
&lt;li>binlog&lt;/li>
&lt;li>undo log&lt;/li>
&lt;/ul>
&lt;p>物理日志：记录的是物理操作，如页的修改，如redo log&lt;/p>
&lt;ul>
&lt;li>redo log&lt;/li>
&lt;/ul>
&lt;h2 id="读写分离主从表">读写分离(主从表)&lt;/h2>
&lt;p>读写分离主要是为了将对数据库的读写操作分散到不同的数据库节点上。&lt;/p>
&lt;p>一般情况下，我们都会选择一主多从，也就是一台主数据库负责写，其他的从数据库负责读。主库和从库之间会进行数据同步，以保证从库中数据的准确性。&lt;/p>
&lt;h3 id="如何实现读写分离">如何实现读写分离&lt;/h3>
&lt;ul>
&lt;li>多台数据库, 1台主库, 多台从库&lt;/li>
&lt;li>保证主从库的数据一致性 &amp;ndash; 主从复制&lt;/li>
&lt;li>将写操作发送到主库，读操作发送到从库&lt;/li>
&lt;/ul>
&lt;h4 id="代理方式">代理方式&lt;/h4>
&lt;p>在应用和数据中加一个代理层,代理层来分离读写请求.&lt;/p>
&lt;p>类似的中间件有:&lt;/p>
&lt;ul>
&lt;li>MySQL Pouter(官方)&lt;/li>
&lt;li>Mysql Proxy&lt;/li>
&lt;li>MaxScale&lt;/li>
&lt;li>MyCat&lt;/li>
&lt;/ul>
&lt;h4 id="组件方式">组件方式&lt;/h4>
&lt;p>引入第三方组件来实现读写分离&lt;/p>
&lt;p>如sharding-jdbc&lt;/p>
&lt;h3 id="主从复制的原理">主从复制的原理&lt;/h3>
&lt;p>基于二进制日志的复制 (binlog)&lt;/p>
&lt;p>binlog记录了数据库执行的所有DDL和DML语句&lt;/p>
&lt;p>过程:&lt;/p>
&lt;ul>
&lt;li>主库将数据库变化写入binlog&lt;/li>
&lt;li>从库连接到主库&lt;/li>
&lt;li>创建一个IO线程请求主库的binlog&lt;/li>
&lt;li>主库创建一个binlog dump线程,将binlog的内容发送给从库&lt;/li>
&lt;li>从库的IO线程接收到binlog后,写入relay log&lt;/li>
&lt;li>从库的SQL线程读取relay log,并执行其中的内容&lt;/li>
&lt;/ul>
&lt;p>应用:&lt;/p>
&lt;ul>
&lt;li>阿里开源的 canal&lt;/li>
&lt;li>分布式缓存组件 Redis 也是通过主从复制实现的读写分离。&lt;/li>
&lt;/ul>
&lt;h3 id="如何避免主从延迟">如何避免主从延迟&lt;/h3>
&lt;p>问题: 写完主库之后，主库的数据同步到从库是需要时间的，这个时间差就导致了主库和从库的数据不一致性问题&lt;/p>
&lt;ol>
&lt;li>强制把读请求给主库&lt;/li>
&lt;li>延迟读取, 等待从库同步完成后再读取&lt;/li>
&lt;/ol>
&lt;h2 id="锁">锁&lt;/h2>
&lt;h3 id="锁的类型">锁的类型&lt;/h3>
&lt;ul>
&lt;li>共享锁（S锁）：允许事务读取一行数据&lt;/li>
&lt;li>排他锁（X锁）：允许事务删除或更新一行数据&lt;/li>
&lt;li>读锁（R锁）：允许事务读取一行数据&lt;/li>
&lt;li>写锁（W锁）：允许事务删除或更新一行数据&lt;/li>
&lt;li>乐观锁：不加锁，通过版本号或时间戳来判断数据是否被修改&lt;/li>
&lt;li>悲观锁：加锁，通过锁来保证数据的一致性&lt;/li>
&lt;li>行锁：锁定一行数据&lt;/li>
&lt;li>表锁：锁定整个表&lt;/li>
&lt;li>间隙锁：锁定一个范围，但不包括记录本身&lt;/li>
&lt;li>临键锁：锁定一个范围，包括记录本身&lt;/li>
&lt;li>读写锁：读锁共享，写锁排他&lt;/li>
&lt;li>自旋锁：不断循环检查锁是否释放&lt;/li>
&lt;li>互斥锁：同一时间只允许一个线程访问共享资源&lt;/li>
&lt;/ul>
&lt;h3 id="间隙锁">间隙锁&lt;/h3>
&lt;h3 id="mvcc">MVCC&lt;/h3>
&lt;p>MVCC（Multi-Version Concurrency Control）多版本并发控制&lt;/p>
&lt;p>用于在多个并发事务同时读写数据库时保持数据的一致性和隔离性。它是通过在每个数据行上维护多个版本的数据来实现的。当一个事务要对数据库中的数据进行修改时，MVCC 会为该事务创建一个数据快照，而不是直接修改实际的数据行。&lt;/p>
&lt;p>当一个事务执行读操作时，它会使用快照读取。
当一个事务执行写操作时，它会生成一个新的数据版本，并将修改后的数据写入数据库。&lt;/p>
&lt;p>当一个事务提交时，它所做的修改将成为数据库的最新版本，并且对其他事务可见。
当一个事务回滚时，它所做的修改将被撤销，对其他事务不可见。&lt;/p>
&lt;p>为了防止数据库中的版本无限增长，MVCC 会定期进行版本的回收。回收机制会删除已经不再需要的旧版本数据，从而释放空间。&lt;/p>
&lt;p>InnoDB存储引擎在 RR 级别下通过 MVCC和 Next-key Lock 来解决幻读问题：&lt;/p>
&lt;p>1、执行普通 select，此时会以 MVCC 快照读的方式读取数据&lt;/p>
&lt;p>在快照读的情况下，RR 隔离级别只会在事务开启后的第一次查询生成 Read View ，并使用至事务提交。所以在生成 Read View 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的 “幻读”&lt;/p>
&lt;p>2、执行 select&amp;hellip;for update/lock in share mode、insert、update、delete 等当前读&lt;/p>
&lt;p>在当前读下，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，就会产生幻读！InnoDB 使用 Next-key Lock 来防止这种情况。当执行当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防止其它事务在查询范围内插入数据。只要我不让你插入，就不会发生幻读&lt;/p>
&lt;h3 id="死锁">死锁&lt;/h3>
&lt;h4 id="mysql中死锁的判断">MYSQL中死锁的判断&lt;/h4>
&lt;p>使用SHOW ENGINE INNODB STATUS命令查看&lt;/p>
&lt;p>在新增订单记录之前，先通过 select &amp;hellip; for update 语句查询订单是否存在，如果不存在才插入订单记录。&lt;/p>
&lt;p>而正是因为这样的操作，当业务量很大的时候，就可能会出现死锁。&lt;/p>
&lt;h4 id="如何解除死锁">如何解除死锁&lt;/h4>
&lt;ul>
&lt;li>重试&lt;/li>
&lt;li>kill掉一个事务&lt;/li>
&lt;li>优化SQL&lt;/li>
&lt;/ul>
&lt;h2 id="分布式场景">分布式场景&lt;/h2>
&lt;h3 id="分布式场景中如何保证主键的唯一性">分布式场景中如何保证主键的唯一性&lt;/h3>
&lt;ul>
&lt;li>使用全局唯一ID&lt;/li>
&lt;li>UUID 不依赖中心认证即可自动生成全局唯一ID。&lt;/li>
&lt;/ul>
&lt;p>32个十六进制数组成的字符串，且分隔为五个部分，如：
467e8542-2275-4163-95d6-7adc205580a9
各部分的数字个数为：8-4-4-4-12&lt;/p>
&lt;h4 id="生成方式">生成方式&lt;/h4>
&lt;ul>
&lt;li>基于时间戳&lt;/li>
&lt;li>基于随机数&lt;/li>
&lt;li>基于名字空间&lt;/li>
&lt;/ul>
&lt;h4 id="使用uuid的好处">使用UUID的好处&lt;/h4>
&lt;ul>
&lt;li>生成简单，不依赖数据库&lt;/li>
&lt;li>生成速度快&lt;/li>
&lt;/ul>
&lt;h4 id="使用uuid的坏处">使用UUID的坏处&lt;/h4>
&lt;ul>
&lt;li>无序性，不适合作为主键&lt;/li>
&lt;li>占用空间大，16个字节&lt;/li>
&lt;/ul>
&lt;h2 id="sql语法">SQL语法&lt;/h2>
&lt;h3 id="修改表结构">修改表结构&lt;/h3>
&lt;p>增加一列&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">ALTER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">table_name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ADD&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">column_name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">column_definition&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>修改某一列的类型&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">ALTER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">table_name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">MODIFY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">column_name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">column_type&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="语句执行顺序">语句执行顺序&lt;/h3>
&lt;ol>
&lt;li>from&lt;/li>
&lt;li>where&lt;/li>
&lt;li>group by&lt;/li>
&lt;li>having&lt;/li>
&lt;li>select&lt;/li>
&lt;/ol>
&lt;p>exist 和 in 的区别
exist 是判断子查询是否有结果，in 是判断字段是否在子查询的结果中&lt;/p>
&lt;p>EXISTS 子查询:&lt;/p>
&lt;p>执行顺序为:&lt;/p>
&lt;p>a. 先执行外层查询
b. 对于外层查询的每一行,执行内层 EXISTS 子查询
c. 如果内层子查询有结果,则外层行满足条件,否则不满足&lt;/p>
&lt;p>这种执行顺序使得 EXISTS 子查询更加高效,因为一旦内层子查询有结果,就可以立即确定外层行满足条件,无需执行完整个子查询。&lt;/p>
&lt;p>IN 子查询:&lt;/p>
&lt;p>执行顺序为:&lt;/p>
&lt;p>a. 先执行内层 IN 子查询,获取子查询的结果集
b. 然后对外层查询的每一行,检查是否在子查询的结果集中&lt;/p>
&lt;p>与 EXISTS 不同,IN 子查询需要先完整执行内层子查询,才能判断外层行是否满足条件。&lt;/p>
&lt;h2 id="实战">实战&lt;/h2>
&lt;h3 id="mysql的单表最大记录如何计算">MySQL的单表最大记录如何计算&lt;/h3>
&lt;p>&lt;a href="https://xiaolincoding.com/mysql/index/2000w.html#%E5%AE%9E%E9%AA%8C" target="_blank" rel="noopener">https://xiaolincoding.com/mysql/index/2000w.html#%E5%AE%9E%E9%AA%8C&lt;/a>&lt;/p>
&lt;p>a为索引字段占用的空间
b为非索引字段占用的空间&lt;/p>
&lt;p>非叶子节点内指向其他页的数量为 x
叶子节点内能容纳的数据行数为 y
B+ 数的层数为 z&lt;/p>
&lt;p>x=15*1024/12≈1280 行。&lt;/p>
&lt;p>按一条行数据 1k 来算，那一页就能存下 15 条，Y = 15*1024/1000 ≈15。&lt;/p>
&lt;p>这边我们暂时按一条行数据 1k 来算，那一页就能存下 15 条，Y = 15*1024/1000 ≈15。&lt;/p>
&lt;p>假设 B+ 树是三层，那就是 z = 3， Total = （1280 ^2） *15 = 24576000 （约 2.45kw）&lt;/p>
&lt;p>如果是 4 层，查询的时候磁盘 IO 次数会增加&lt;/p>
&lt;p>Total = 8000^3 / ( (a+4)^2 * (a+b+30) )&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis%E5%9F%BA%E7%A1%80/</guid><description>&lt;h1 id="redis基础">Redis基础&lt;/h1>
&lt;h2 id="redis基础知识">Redis基础知识：&lt;/h2>
&lt;h3 id="redis是什么有什么用">Redis是什么？有什么用？&lt;/h3>
&lt;p>Redis是一个开源的内存数据结构存储系统。&lt;/p>
&lt;ol>
&lt;li>Redis最常用来做缓存，是实现分布式缓存的首先中间件；&lt;/li>
&lt;li>Redis可以作为数据库，实现诸如点赞、关注、排行等对性能要求极高的互联网需求；&lt;/li>
&lt;li>Redis可以作为计算工具，能用很小的代价，统计诸如PV/UV、用户在线天数等数据；&lt;/li>
&lt;li>Redis还有很多其他的使用场景，例如：可以实现分布式锁，可以作为消息队列使用。&lt;/li>
&lt;/ol>
&lt;h3 id="使用redis的好处是什么">使用Redis的好处是什么？&lt;/h3>
&lt;p>使用Redis的好处包括高性能、高可用性、支持多种数据结构、支持事务和Lua脚本等。&lt;/p>
&lt;h3 id="redis与其他key-value存储的不同之处在哪里">Redis与其他key-value存储的不同之处在哪里？&lt;/h3>
&lt;p>Redis与其他key-value存储的不同之处在于，Redis支持多种数据结构，包括字符串、哈希、列表、集合和有序集合等，而其他key-value存储通常只支持字符串类型。&lt;/p>
&lt;h3 id="比较redis与memcache">比较Redis与Memcache&lt;/h3>
&lt;ul>
&lt;li>Redis支持多种数据结构，包括字符串、哈希、列表、集合和有序集合，支持事务和Lua脚本、支持持久化和复制等。&lt;/li>
&lt;li>Memcache只支持字符串类型。&lt;/li>
&lt;/ul>
&lt;h3 id="redis是单进程单线程的吗">Redis是单进程单线程的吗&lt;/h3>
&lt;p>是的，Redis是单进程单线程的，主要是指Redis的网络IO和键值对读写是由一个线程来完成的。&lt;/p>
&lt;p>而Redis的其他功能，如持久化、异步删除、集群数据同步等，则是依赖其他线程来执行的。所以，说Redis是单线程的只是一种习惯的说法，事实上它的底层不是单线程的。&lt;/p>
&lt;ol>
&lt;li>对服务端程序来说，线程切换和锁通常是性能杀手，而单线程避免了线程切换和竞争所产生的消耗；&lt;/li>
&lt;li>Redis的大部分操作是在内存上完成的，这是它实现高性能的一个重要原因；&lt;/li>
&lt;li>Redis采用了IO多路复用机制，使其在网络IO操作中能并发处理大量的客户端请求，实现高吞吐率。&lt;/li>
&lt;/ol>
&lt;h3 id="redis底层原理">Redis底层原理&lt;/h3>
&lt;p>Redis是一个单线程的应用程序，它使用了事件驱动模型来实现高性能的I/O操作。它的主要数据结构都是基于哈希表和链表实现的。对于读取操作，Redis会直接从内存中读取数据，因此具有很高的读取性能；对于写入操作，Redis会先将数据缓存在内存中，然后定期将数据写入磁盘中，因此具有较高的写入性能。此外，Redis还提供了多种持久化方式，包括RDB快照和AOF日志，可以满足不同场景下的需求。&lt;/p>
&lt;h3 id="redis的最大连接数如何配置不配置会怎么样">Redis的最大连接数如何配置，不配置会怎么样&lt;/h3>
&lt;p>在redis.conf的max_clients中设置&lt;/p>
&lt;p>如果不配置,会使用默认值,默认值是10000&lt;/p>
&lt;p>合理的最大连接数 = 最大并发量 / (1000ms / 每次请求耗时ms)&lt;/p>
&lt;h3 id="redis需要把所有数据放到内存中吗">Redis需要把所有数据放到内存中吗？&lt;/h3>
&lt;p>是的，Redis需要把所有数据放到内存中，是因为它采用了基于内存的数据存储方式，可以快速读写数据。&lt;/p>
&lt;h2 id="redis-命令">Redis 命令&lt;/h2>
&lt;h3 id="redis中的watch命令">Redis中的watch命令&lt;/h3>
&lt;p>很多时候，要确保事务中的数据没有被其他客户端修改才执行该事务。&lt;/p>
&lt;p>Redis提供了watch命令来解决这类问题，这是一种乐观锁的机制。&lt;/p>
&lt;p>客户端通过watch命令，要求服务器对一个或多个key进行监视，如果在客户端执行事务之前，这些key发生了变化，则服务器将拒绝执行客户端提交的事务，并向它返回一个空值。&lt;/p>
&lt;p>26、Redis的密码可以通过哪些方式设置和验证？&lt;/p>
&lt;p>Redis的密码可以通过配置文件设置，验证密码可以使用AUTH命令。&lt;/p>
&lt;p>32、Redis集群可以选择不同的数据库吗？&lt;/p>
&lt;p>Redis集群可以选择不同的数据库，通过SELECT命令进行切换。&lt;/p>
&lt;p>33、如何测试Redis的连通性？&lt;/p>
&lt;p>可以使用PING命令测试Redis的连通性。&lt;/p>
&lt;h2 id="redis数据结构">Redis数据结构&lt;/h2>
&lt;p>这里从原理的角度分析Redis的数据结构&lt;/p>
&lt;p>一个Redis节点包含多个database（非cluster模式下默认是16个，cluster模式下只能是1个）&lt;/p>
&lt;p>一个database通过一个dict结构来保存所有的键值对，其中key是一个字符串，value是一个RedisObject对象。&lt;/p>
&lt;p>RedisObject对象是一个union结构，包含多种数据类型，其对应的底层数据结构分别是&lt;/p>
&lt;ul>
&lt;li>string
&lt;ul>
&lt;li>SDS(Simple Dynamic String)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>list
&lt;ul>
&lt;li>ZipList(压缩列表&amp;ndash;特殊编码的双向链表)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>hash
&lt;ul>
&lt;li>dict, HashTable&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>set
&lt;ul>
&lt;li>IntSet 整数集&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>zset
&lt;ul>
&lt;li>ZSkipList(跳跃表)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="redis的其他数据类型">Redis的其他数据类型&lt;/h3>
&lt;ol>
&lt;li>Redis支持5种核心的数据类型，分别是字符串、哈希(是一个键值(key=&amp;gt;value)对集合)、列表、集合(set)、有序集合(zset)；&lt;/li>
&lt;li>Redis还提供了Bitmap、HyperLogLog、Geo类型，但这些类型都是基于上述核心数据类型实现的；&lt;/li>
&lt;li>Redis在5.0新增加了Streams数据类型，它是一个功能强大的、支持多播的、可持久化的消息队列。&lt;/li>
&lt;/ol>
&lt;h3 id="set和zset有什么区别">set和zset有什么区别？&lt;/h3>
&lt;p>set：&lt;/p>
&lt;ul>
&lt;li>集合中的元素是无序、不可重复的，一个集合最多能存储232-1个元素；&lt;/li>
&lt;li>集合除了支持对元素的增删改查之外，还支持对多个集合取交集、并集、差集。&lt;/li>
&lt;/ul>
&lt;p>使用的是哈希表数据结构，可以保证在O(1)的时间复杂度内完成插入、删除、查找等操作。&lt;/p>
&lt;p>zset：&lt;/p>
&lt;ul>
&lt;li>有序集合保留了集合元素不能重复的特点；&lt;/li>
&lt;li>有序集合会给每个元素设置一个分数，并以此作为排序的依据；&lt;/li>
&lt;li>有序集合不能包含相同的元素，但是不同元素的分数可以相同。&lt;/li>
&lt;/ul>
&lt;p>使用的是&lt;strong>跳表数据&lt;/strong>结构，可以保证在O(log(N))的时间复杂度内完成插入、删除、查找等操作。&lt;/p>
&lt;h3 id="一个字符串类型的值能存储的最大容量是多少">一个字符串类型的值能存储的最大容量是多少？&lt;/h3>
&lt;p>一个字符串类型的值能存储的最大容量是512MB。&lt;/p>
&lt;h3 id="sds-简答动态字符串">SDS 简答动态字符串&lt;/h3>
&lt;p>分为三部分:&lt;/p>
&lt;ul>
&lt;li>头部
&lt;ul>
&lt;li>len&lt;/li>
&lt;li>alloc&lt;/li>
&lt;li>flag&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>中间部分
&lt;ul>
&lt;li>buf&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>\0&lt;/li>
&lt;/ul>
&lt;p>源码&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-md" data-lang="md">&lt;span class="line">&lt;span class="cl">&lt;span class="k">-&lt;/span> len 保存了SDS保存字符串的长度
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">-&lt;/span> buf[] 数组用来保存字符串的每个元素
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">-&lt;/span> alloc分别以uint8, uint16, uint32, uint64表示整个SDS, 除过头部与末尾的\0, 剩余的字节数.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">-&lt;/span> flags 始终为一字节, 以低三位标示着头部的类型, 高5位未使用
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>有五种不同头部: 1 byte, sdshdr8, sdshdr16, sdshdr32, sdshdr64.
区别是alloc的大小不同, 以及len的大小不同.&lt;/p>
&lt;p>优点:&lt;/p>
&lt;ul>
&lt;li>获取字符串长度的时间复杂度为O(1)&lt;/li>
&lt;li>杜绝缓冲区溢出&amp;ndash;通过len和alloc来控制&lt;/li>
&lt;li>减少内存重新分配次数,通过以下手段:
&lt;ul>
&lt;li>空间预分配&lt;/li>
&lt;li>惰性空间释放&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>二进制安全 &amp;ndash; 通过len判断释放结束&lt;/li>
&lt;li>可以使用&amp;lt;string.h&amp;gt;中的函数&lt;/li>
&lt;/ul>
&lt;h3 id="redis中list结构的相关操作">Redis中List结构的相关操作&lt;/h3>
&lt;p>列表是线性有序的数据结构，它内部的元素是可以重复的，并且一个列表最多能存储2^32-1个元素。列表包含如下的常用命令：&lt;/p>
&lt;ul>
&lt;li>lpush/rpush：从列表的左侧/右侧添加数据；&lt;/li>
&lt;li>lrange：指定索引范围，并返回这个范围内的数据；&lt;/li>
&lt;li>lindex：返回指定索引处的数据；&lt;/li>
&lt;li>lpop/rpop：从列表的左侧/右侧弹出一个数据；&lt;/li>
&lt;li>blpop/brpop：从列表的左侧/右侧弹出一个数据，若列表为空则进入阻塞状态。&lt;/li>
&lt;/ul>
&lt;h4 id="跳表和红黑树比较">跳表和红黑树比较&lt;/h4>
&lt;p>跳表和红黑树都是有序的数据结构，它们的区别主要体现在以下几个方面：&lt;/p>
&lt;ol>
&lt;li>跳表是一种随机化的数据结构，插入、删除和查找的平均时间复杂度都是O(logN)，而红黑树是一种平衡二叉搜索树，插入、删除和查找的最坏时间复杂度都是O(logN)；&lt;/li>
&lt;li>跳表的实现比较简单，而红黑树的实现比较复杂；&lt;/li>
&lt;/ol>
&lt;p>跳表是通过随机函数来维护前面提到的平衡性。&lt;/p>
&lt;p>为什么Redis的zset使用跳表&lt;/p>
&lt;p>Redis的作者 @antirez 是怎么说的&lt;/p>
&lt;ol>
&lt;li>它们不是非常内存密集型的。基本上由你决定。改变关于节点具有给定级别数的概率的参数将使其比 btree 占用更少的内存。
&lt;ol>
&lt;li>平衡树每个节点包含 2 个指针（分别指向左右子树），而跳表每个节点包含的指针数目平均为 1/(1-p)，具体取决于参数 p 的大小。如果像 Redis里的实现一样，取 p=1/4，那么平均每个节点包含 1.33 个指针，比平衡树更有优势。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Zset 经常需要执行 ZRANGE 或 ZREVRANGE 的命令，即作为链表遍历跳表。通过此操作，跳表的缓存局部性至少与其他类型的平衡树一样好。&lt;/li>
&lt;li>它们更易于实现、调试等。例如，由于跳表的简单性，我收到了一个补丁（已经在Redis master中），其中扩展了跳表，在 O(log(N) 中实现了 ZRANK。它只需要对代码进行少量修改。&lt;/li>
&lt;/ol>
&lt;h2 id="redis持久化">Redis持久化&lt;/h2>
&lt;h3 id="redis的持久化机制有哪些">Redis的持久化机制有哪些？&lt;/h3>
&lt;p>RDB和AOF是Redis的两种持久化机制，它们都可以将Redis的数据保存到磁盘上，以便在Redis重启时恢复数据。但是它们的实现方式和适用场景有所不同。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>RDB是一种快照机制，它可以将Redis的内存数据保存到磁盘上。&lt;/p>
&lt;ul>
&lt;li>RDB的实现方式是在指定的时间间隔内，将Redis的内存数据快照保存到磁盘上。快照文件的格式是二进制的，可以通过配置文件指定保存的文件名和路径。&lt;/li>
&lt;li>RDB的优点是快速、简单、可靠，适合用于备份和恢复数据。缺点是可能会丢失最近一次快照之后的数据，因为快照是定期保存的。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>AOF是一种追加日志机制，它可以将Redis的写操作记录到磁盘上。&lt;/p>
&lt;ul>
&lt;li>AOF的实现方式是将Redis的写操作以追加的方式记录到一个日志文件中，日志文件的格式是文本的。&lt;/li>
&lt;li>AOF有三种同步方式：always、everysec和no。always表示每次写操作都会同步到磁盘上，保证数据的完整性和一致性，但是会影响性能；everysec表示每秒钟同步一次，可以平衡性能和数据安全；no表示不同步，性能最好，但是数据安全性最差。&lt;/li>
&lt;li>AOF的优点是可以保证数据的完整性和一致性，适合用于数据持久化和灾备。缺点是日志文件可能会很大，需要定期进行压缩和重写。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>在实际应用中，可以根据实际情况选择RDB和AOF中的一种或两种持久化机制。如果数据的安全性和一致性比较重要，可以选择AOF；如果数据的恢复速度比较重要，可以选择RDB；如果两者都比较重要，可以同时使用两种持久化机制。&lt;/p>
&lt;h3 id="aof-日志实现">AOF 日志实现&lt;/h3>
&lt;p>先执行命令，再把数据写入日志&lt;/p>
&lt;p>Reids 是先执行写操作命令后，才将该命令记录到 AOF 日志里的，这么做其实有两个好处。&lt;/p>
&lt;ul>
&lt;li>避免额外的检查开销：&lt;/li>
&lt;li>&lt;strong>不阻塞当前写&lt;/strong>操作命令的执行：因为当写操作命令执行成功后，才会将命令记录到 AOF 日志。&lt;/li>
&lt;/ul>
&lt;p>当然，这样做也会带来风险：&lt;/p>
&lt;ul>
&lt;li>数据可能会丢失： 执行写操作命令和记录日志是两个过程，那当 Redis 在还没来得及将命令写入到硬盘时，服务器发生宕机了，这个数据就会有丢失的风险。&lt;/li>
&lt;li>可能阻塞其他操作： 由于写操作命令执行成功后才记录到 AOF 日志，所以不会阻塞当前命令的执行，但因为 AOF 日志也是在主线程中执行，所以当 &lt;strong>Redis 把日志文件写入磁盘时&lt;/strong>，还是会阻塞后续的操作无法执行&lt;/li>
&lt;/ul>
&lt;h4 id="aof-写回策略">AOF 写回策略&lt;/h4>
&lt;ol>
&lt;li>Redis 执行完写操作命令后，会将命令追加到 server.aof_buf 缓冲区；&lt;/li>
&lt;li>通过 write() 系统调用，将 aof_buf 缓冲区的数据写入到 AOF 文件，此时数据并没有写入到硬盘，而是拷贝到了内核缓冲区 page cache，等待内核将数据写入硬盘；&lt;/li>
&lt;li>具体&lt;strong>内核缓冲区的数据什么时候写入到硬盘，由内核决定&lt;/strong>。&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>always：每次写操作都会同步到磁盘上，保证数据的完整性和一致性，但是会影响性能；&lt;/li>
&lt;li>everysec：每秒钟同步一次，可以平衡性能和数据安全；&lt;/li>
&lt;li>no：不同步，由操作系统控制写回，性能最好，但是数据安全性最差。&lt;/li>
&lt;/ul>
&lt;h4 id="aof-重写机制----解决aof-过大问题">AOF 重写机制 &amp;ndash; 解决AOF 过大问题&lt;/h4>
&lt;p>当 AOF 文件的大小超过所设定的阈值后，Redis 就会启用 AOF 重写机制，来压缩 AOF 文件。&lt;/p>
&lt;p>在重写时，&lt;strong>读取当前数据库中的所有键值对&lt;/strong>，然后将每一个键值对用一条命令记录到「新的 AOF 文件」&lt;/p>
&lt;p>重写 AOF 过程是由后台子进程 bgrewriteaof 来完成的&lt;/p>
&lt;ul>
&lt;li>重写期间，主进程可以继续处理命令请求，从而避免阻塞主进程&lt;/li>
&lt;li>子进程带有主进程的数据副本，这里使用子进程而不是线程，因为如果是使用线程，多线程之间会共享内存，那么在修改共享内存数据的时候，需要通过加锁来保证数据的安全，而这样就会降低性能。&lt;/li>
&lt;/ul>
&lt;p>写时复制，发生不一致怎么办
AOF 重写缓冲区，这个缓冲区在创建 bgrewriteaof 子进程之后开始使用。&lt;/p>
&lt;p>在重写 AOF 期间，当 Redis 执行完一个写命令之后，它会&lt;strong>同时将这个写命令写入到 「AOF 缓冲区」和 「AOF 重写缓冲区」&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Redis%e5%9f%ba%e7%a1%80/AOF%e9%87%8d%e5%86%99%e5%ad%90%e8%bf%9b%e7%a8%8b.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>主进程收到该信号后，会调用一个信号处理函数，该函数主要做以下工作：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>将 AOF 重写缓冲区中的所有内容追加到新的 AOF 的文件&lt;/strong>中，使得新旧两个 AOF 文件所保存的数据库状态一致；&lt;/li>
&lt;li>新的 AOF 的文件进行改名，覆盖现有的 AOF 文件。&lt;/li>
&lt;/ul>
&lt;p>信号函数执行完后，主进程就可以继续像往常一样处理命令了。&lt;/p>
&lt;h3 id="rdb快照">RDB快照&lt;/h3>
&lt;p>RDB 快照就是记录某一个瞬间的内存数据，记录的是实际数据
Redis 的快照是全量快照&lt;/p>
&lt;p>Redis 恢复数据时，直接将 RDB 文件读入内存就可以，快速&lt;/p>
&lt;p>RDB 做快照时会阻塞线程吗？&lt;/p>
&lt;p>有两个命令来生成RDB文件，SAVE和BGSAVE&lt;/p>
&lt;ul>
&lt;li>SAVE会阻塞线程，直到RDB文件生成完毕&lt;/li>
&lt;li>BGSAVE不会阻塞线程，会fork一个子进程来生成RDB文件&lt;/li>
&lt;/ul>
&lt;p>Redis可以通过配置文件来实现每隔多久自动执行bgsave&lt;/p>
&lt;p>RDB 在执行快照的时候，数据能修改吗？
可以修改，基于写时复制技术&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Redis%e5%9f%ba%e7%a1%80/fork%e5%ad%90%e8%bf%9b%e7%a8%8b.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>主线程执行写操作，则被修改的数据会复制一份副本，然后 bgsave 子进程会把该副本数据写入 RDB 文件&lt;/p>
&lt;p>也就是写入RDB文件的数据是fork前的数据。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Redis%e5%9f%ba%e7%a1%80/%e5%86%99%e6%97%b6%e5%a4%8d%e5%88%b6.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="混合持久化">混合持久化&lt;/h3>
&lt;p>fork 出来的重写子进程会先将与主线程共享的内存数据以 RDB 方式写入到 AOF 文件&lt;/p>
&lt;p>然后主线程处理的操作命令会被记录在重写缓冲区里，重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件&lt;/p>
&lt;p>写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件。&lt;/p>
&lt;p>混合持久化，AOF 文件的前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据。&lt;/p>
&lt;p>混合持久化优点：&lt;/p>
&lt;ul>
&lt;li>混合持久化结合了 RDB 和 AOF 持久化的优点，开头为 RDB 的格式，使得 Redis 可以更快的启动，同时结合 AOF 的优点，有减低了大量数据丢失的风险。&lt;/li>
&lt;/ul>
&lt;p>混合持久化缺点：&lt;/p>
&lt;ul>
&lt;li>AOF 文件中添加了 RDB 格式的内容，使得 AOF 文件的可读性变得很差；&lt;/li>
&lt;li>兼容性差，如果开启混合持久化，那么此混合持久化 AOF 文件，就不能用在 Redis 4.0 之前版本了&lt;/li>
&lt;/ul>
&lt;h3 id="redis的持久化机制的优缺点有哪些">Redis的持久化机制的优缺点有哪些？&lt;/h3>
&lt;p>Redis的持久化机制包括RDB和AOF两种方式，各自的优缺点包括数据恢复速度、数据安全性、数据一致性等方面。&lt;/p>
&lt;p>RDB方式是将Redis的内存数据快照保存到磁盘上，优点是恢复速度快，缺点是可能会丢失最近一次快照之后的数据。&lt;/p>
&lt;p>AOF方式是将Redis的写操作以追加的方式记录到一个日志文件中，优点是可以保证数据的完整性和一致性，缺点是日志文件可能会很大。&lt;/p>
&lt;h3 id="大key对持久化的影响">大Key对持久化的影响&lt;/h3>
&lt;h2 id="redis-事务">Redis 事务&lt;/h2></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis%E5%BA%94%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis%E5%BA%94%E7%94%A8/</guid><description>&lt;h1 id="redis应用">Redis应用&lt;/h1>
&lt;h2 id="redis分布式应用">Redis分布式应用&lt;/h2>
&lt;h3 id="分布式锁">分布式锁&lt;/h3>
&lt;p>分布式锁实现：&lt;/p>
&lt;p>原始方式：setnx key true（死锁）/set key true ex 30 nx（锁误删）-&amp;gt; 锁重入问题。&lt;/p>
&lt;p>Redis 的 SET 命令有个 NX 参数可以实现「key不存在才插入」，所以可以用它来实现分布式锁：&lt;/p>
&lt;ul>
&lt;li>如果 key 不存在，则显示插入成功，可以用来表示加锁成功；&lt;/li>
&lt;li>如果 key 存在，则会显示插入失败，可以用来表示加锁失败。&lt;/li>
&lt;/ul>
&lt;p>三个条件:&lt;/p>
&lt;ul>
&lt;li>枷锁包括了读取锁变量、检查锁变量值和设置锁变量值三个操作，但需要以原子操作的方式, 需要使用SET + NX&lt;/li>
&lt;li>锁变量需要设置过期时间，以免客户端拿到锁后发生异常，导致锁一直无法释放, 加上 EX/PX
&lt;ul>
&lt;li>EX: 秒&lt;/li>
&lt;li>PX: 毫秒&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>需要能区分来自不同客户端的加锁操作，以免在释放锁时，出现误释放操作, 使用uuid等分布式唯一ID&lt;/li>
&lt;/ul>
&lt;p>命令格式&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">set lock_key unique_id NX PX 30000
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>lock_key: 锁的key&lt;/li>
&lt;li>unique_id: 客户端唯一ID&lt;/li>
&lt;li>NX: key不存在时才设置成功&lt;/li>
&lt;li>PX 30000: 设置过期时间为30秒&lt;/li>
&lt;/ul>
&lt;p>解锁一般要使用 Lua 脚本来保证原子性，因为 Redis 的删除操作不是原子的，可能会导致误删。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-lua" data-lang="lua">&lt;span class="line">&lt;span class="cl">&lt;span class="o">//&lt;/span> &lt;span class="err">先比较是否是自己的锁，再删除&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">if&lt;/span> &lt;span class="n">redis.call&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;get&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">KEYS&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">])&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">ARGV&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="kr">then&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">return&lt;/span> &lt;span class="n">redis.call&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;del&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">KEYS&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">])&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">else&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">return&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Redis分布式锁的优点:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>性能高&lt;/strong>：Redis 是单线程的，所以性能非常高，可以支持高并发的请求。&lt;/li>
&lt;li>实现简单：使用 Redis 的 setnx 命令就可以实现分布式锁，非常简单。&lt;/li>
&lt;li>避免单点故障: Redis 支持主从复制和集群，可以避免单点故障。&lt;/li>
&lt;/ul>
&lt;p>缺点:&lt;/p>
&lt;ul>
&lt;li>超时时间设置: 过长影响性能.
&lt;ul>
&lt;li>合理超时时间设置: 基于续约机制，每隔一段时间对锁进行续约，保证锁不会过期。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>锁的不可靠性: 旧主节点宕机，新主节点上的锁丢失。
&lt;ul>
&lt;li>可以使用 Redlock 算法解决这个问题，Redlock 算法是 Redis 官方提供的一种分布式锁算法，可以保证在大部分节点正常运行的情况下，分布式锁可以正常工作。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>TODO: Redis 如何解决集群情况下分布式锁的可靠性？&lt;/p>
&lt;h3 id="分布式session登录">分布式session登录&lt;/h3>
&lt;p>Redisson 框架实现方式：Redis + Lua 实现。&lt;/p>
&lt;h2 id="redis过期删除-和-内存淘汰策略">Redis过期删除 和 内存淘汰策略&lt;/h2>
&lt;h3 id="redis过期键的删除策略">Redis过期键的删除策略&lt;/h3>
&lt;p>Redis过期键的删除策略包括定期删除和惰性删除。&lt;/p>
&lt;p>惰性删除：客户端访问一个key的时候，Redis会先检查它的过期时间，如果发现过期就立刻删除这个key。
缺点: 浪费内存&lt;/p>
&lt;p>定期删除：Redis会将设置了过期时间的key放到一个独立的字典中，并对该字典进行每秒10次的过期扫描，&lt;/p>
&lt;p>过期扫描不会遍历字典中所有的key，而是采用了一种简单的贪心策略。该策略的删除逻辑如下：&lt;/p>
&lt;ol>
&lt;li>从过期字典中随机选择20个key；&lt;/li>
&lt;li>删除这20个key中&lt;strong>已过期的key&lt;/strong>；&lt;/li>
&lt;li>如果已过期key的比例超过25%(大于5个)，则&lt;strong>重复步骤1&lt;/strong>。&lt;/li>
&lt;/ol>
&lt;p>为了保证定期删除不会出现&lt;strong>循环过度&lt;/strong>，导致线程卡死现象，为此增加了定期删除循环流程的时间上限，默认不会超过 25ms&lt;/p>
&lt;p>缺点: 不好控制频率, 过快可能导致CPU占用过高&lt;/p>
&lt;p>Redis1实际使用的是定期删除和惰性删除相结合的方式来删除过期键。&lt;/p>
&lt;h4 id="redis持久化时对过期键的处理">Redis持久化时对过期键的处理&lt;/h4>
&lt;p>&lt;strong>RDB 中对过期键的处理&lt;/strong>&lt;/p>
&lt;p>RDB 生成阶段: 会检查 key 是否过期，如果过期则不会将其写入 RDB 文件。&lt;/p>
&lt;p>RDB 加载阶段: 根据服务器是主还是从&lt;/p>
&lt;ul>
&lt;li>主服务器: 会在加载 RDB 文件时，跳过过期的 key&lt;/li>
&lt;li>从服务器: 全部加载进去, 因为在进行主从复制时会清空,所以没什么影响.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>AOF 中对过期键的处理&lt;/strong>&lt;/p>
&lt;p>AOF 文件写入阶段: 不会主动删除过期键, 当key被删除时, 在AOF文件中追加一条DEL命令&lt;/p>
&lt;p>AOF 文件重写阶段: 会对Redis中的过期键进行检查, 不会将过期键写入到新的AOF文件中&lt;/p>
&lt;h3 id="redis内存淘汰策略">Redis内存淘汰策略&lt;/h3>
&lt;p>运行内存达到了某个阀值，就会触发内存淘汰机制，这个阀值就是我们设置的最大运行内存，此值在 Redis 的配置文件中可以找到，配置项为 maxmemory&lt;/p>
&lt;p>分为两类:&lt;/p>
&lt;p>不进行数据淘汰&lt;/p>
&lt;ul>
&lt;li>neo-eviction&lt;/li>
&lt;/ul>
&lt;p>进行数据淘汰的策略&lt;/p>
&lt;p>在过期时间内进行淘汰&lt;/p>
&lt;ul>
&lt;li>volatile-lru：从设置了过期时间的 key 中挑选最近最少使用的 key 淘汰&lt;/li>
&lt;li>volatile-ttl：从设置了过期时间的 key 中挑选将要过期的 key 淘汰&lt;/li>
&lt;li>volatile-random：从设置了过期时间的 key 中随机挑选 key 淘汰&lt;/li>
&lt;li>volatile-lfu：从设置了过期时间的 key 中挑选最少使用的 key 淘汰&lt;/li>
&lt;/ul>
&lt;p>在所有数据范围进行淘汰&lt;/p>
&lt;ul>
&lt;li>allkeys-lru：从所有 key 中挑选最近最少使用的 key 淘汰&lt;/li>
&lt;li>allkeys-random：从所有 key 中随机挑选 key 淘汰&lt;/li>
&lt;li>allkeys-lfu：从所有 key 中挑选最少使用的 key 淘汰&lt;/li>
&lt;/ul>
&lt;p>lfu是Redis4.0之后新增的&lt;/p>
&lt;h4 id="lru的实现">LRU的实现&lt;/h4>
&lt;p>实现近似的LRU&lt;/p>
&lt;p>在 Redis 的对象结构体中添加一个额外的字段，用于记录此数据的最后一次访问时间&lt;/p>
&lt;p>会使用随机采样的方式来淘汰数据，它是随机取 5 个值（此值可配置），然后淘汰最久没有使用的那个。&lt;/p>
&lt;p>优点:&lt;/p>
&lt;ul>
&lt;li>不维护大链表，节省内存&lt;/li>
&lt;li>不需要移动链表，提高效率&lt;/li>
&lt;/ul>
&lt;p>缺点:&lt;/p>
&lt;ul>
&lt;li>缓存污染问题: 应用一次读取了大量的数据，而这些数据只会被读取这一次，那么这些数据会留存在 Redis 缓存中很长一段时间&lt;/li>
&lt;/ul>
&lt;h4 id="lfu的引入和实现">LFU的引入和实现&lt;/h4>
&lt;p>Least Frequently Used，最近最不常用&lt;/p>
&lt;p>根据数据访问次数来淘汰数据的，它的核心思想是“如果数据过去被访问多次，那么将来被访问的频率也更高”&lt;/p>
&lt;p>相比于 LRU 算法的实现，多记录了「数据的访问频次」的信息&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c++" data-lang="c++">&lt;span class="line">&lt;span class="cl">&lt;span class="k">typedef&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="nc">redisObject&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 24 bits，用于记录对象的访问信息
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">unsigned&lt;/span> &lt;span class="nl">lru&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="mi">24&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span> &lt;span class="n">robj&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在 LRU 算法中，Redis 对象头的 24 bits 的 lru 字段是用来记录 key 的访问时间戳，因此在 LRU 模式下，Redis可以根据对象头中的 lru 字段记录的值，来比较最后一次 key 的访问时间长，从而淘汰最久未被使用的 key。&lt;/p>
&lt;p>在 LFU 算法中，Redis对象头的 24 bits 的 lru 字段被分成两段来存储，高 16bit 存储 ldt(Last Decrement Time)，用来记录 key 的访问时间戳；低 8bit 存储 logc(Logistic Counter)，用来记录 key 的访问频次。&lt;/p>
&lt;h3 id="如何设计redis-key的过期时间">如何设计Redis Key的过期时间？&lt;/h3>
&lt;ol>
&lt;li>热点数据不设置过期时间，&lt;strong>使其达到“物理”上的永不过期&lt;/strong>，可以避免缓存击穿问题；&lt;/li>
&lt;li>在设置过期时间时，可以&lt;strong>附加一个随机数&lt;/strong>，避免大量的key同时过期，导致缓存雪崩。&lt;/li>
&lt;/ol>
&lt;h2 id="redis-缓存设计">Redis 缓存设计&lt;/h2>
&lt;h3 id="缓存雪崩缓存穿透缓存预热缓存更新和缓存降级是什么">缓存雪崩、缓存穿透、缓存预热、缓存更新和缓存降级是什么？&lt;/h3>
&lt;h4 id="缓存穿透">缓存穿透&lt;/h4>
&lt;p>客户端&lt;strong>查询根本不存在的数据，使得请求直达存储层&lt;/strong>，导致其负载过大，甚至宕机。出现这种情况的原因，可能是业务层误将缓存和库中的数据删除了，也可能是有人&lt;strong>恶意攻击，专门访问库中不存在的数据&lt;/strong>。&lt;/p>
&lt;p>解决方案：&lt;/p>
&lt;ol>
&lt;li>缓存空对象：存储层未命中后，仍然将空值存入缓存层，客户端再次访问数据时，缓存层会直接返回空值。&lt;/li>
&lt;li>布隆过滤器：将数据存入布隆过滤器，访问缓存之前以过滤器拦截，若请求的数据不存在则直接返回空值。&lt;/li>
&lt;li>非法请求的限制：当有大量恶意请求访问不存在的数据的时候，也会发生缓存穿透，因此在 API 入口处我们要判断求请求参数是否合理，请求参数是否含有非法值、请求字段是否存在，如果判断出是恶意请求就直接返回错误，避免进一步访问缓存和数据库。&lt;/li>
&lt;/ol>
&lt;h4 id="缓存击穿">缓存击穿&lt;/h4>
&lt;p>&lt;strong>一份热点数据，它的访问量非常大&lt;/strong>。在其&lt;strong>缓存失效&lt;/strong>的瞬间，大量请求直达存储层，导致服务崩溃。&lt;/p>
&lt;p>解决方案：&lt;/p>
&lt;ol>
&lt;li>永不过期：热点数据不设置过期时间，所以不会出现上述问题，这是“物理”上的永不过期。或者为每个数据设置逻辑过期时间，当发现该数据&lt;strong>逻辑过期时，使用单独的线程重建缓存&lt;/strong>。&lt;/li>
&lt;li>加互斥锁：对数据的访问加互斥锁，当一个线程访问该数据时，其他线程只能等待。这个线程访问过后，缓存中的数据将被重建，届时其他线程就可以直接从缓存中取值。&lt;/li>
&lt;/ol>
&lt;h4 id="缓存雪崩">缓存雪崩&lt;/h4>
&lt;p>在&lt;strong>某一时刻&lt;/strong>，缓存层无法继续提供服务，导致大量请求直达存储层，造成数据库宕机。可能是&lt;strong>缓存中有大量数据同时过期&lt;/strong>，也可能是Redis&lt;strong>节点发生故障，导致大量请求无法得到处理&lt;/strong>。&lt;/p>
&lt;p>解决方案：&lt;/p>
&lt;ol>
&lt;li>避免数据同时过期：设置过期时间时，附加一个随机数，避免大量的key同时过期。&lt;/li>
&lt;li>启用降级和熔断措施：在发生雪崩时，若应用访问的不是核心数据，则直接返回预定义信息/空值/错误信息。或者在发生雪崩时，对于访问缓存接口的请求，客户端并不会把请求发给Redis，而是直接返回。&lt;/li>
&lt;li>构建高可用的Redis服务：采用哨兵或集群模式，部署多个Redis实例，个别节点宕机，依然可以保持服务的整体可用。&lt;/li>
&lt;/ol>
&lt;h3 id="动态缓存热点数据策略设计">动态缓存热点数据策略设计&lt;/h3>
&lt;p>通过数据最新访问时间来做排名，并过滤掉不常访问的数据，只留下经常访问的数据&lt;/p>
&lt;p>只缓存用户经常访问的 Top 1000 的商品。具体细节如下：&lt;/p>
&lt;ul>
&lt;li>先通过缓存系统做一个&lt;strong>排序队列（比如存放 1000 个商品）&lt;/strong>，系统会根据商品的访问时间，更新队列信息，越是&lt;strong>最近访问的商品排名越靠前&lt;/strong>；&lt;/li>
&lt;li>同时系统会&lt;strong>定期过滤掉队列中排名最后的 200 个商品&lt;/strong>，然后再从数据库中&lt;strong>随机读取出 200 个商品加入队列中&lt;/strong>；&lt;/li>
&lt;li>这样当&lt;strong>请求每次到达的时候，会先从队列中获取商品 ID，如果命中，就根据 ID 再从另一个缓存数据结构中读取实际的商品信息&lt;/strong>，并返回。&lt;/li>
&lt;li>在 Redis 中可以用 zadd 方法和 zrange 方法来完成排序队列和获取 200 个商品的操作。&lt;/li>
&lt;/ul>
&lt;h3 id="缓存与数据库的双写一致性缓存更新策略">缓存与数据库的双写一致性(缓存更新策略)&lt;/h3>
&lt;p>常见的缓存更新策略共有3种：&lt;/p>
&lt;ul>
&lt;li>Cache Aside（旁路缓存）策略；
&lt;ul>
&lt;li>先更新数据库，再删除缓存。&lt;/li>
&lt;li>Cache Aside 策略适合&lt;strong>读多写少的场景，不适合写多的场景&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Read/Write Through（读穿 / 写穿）策略；
&lt;ul>
&lt;li>先更新数据库，再更新缓存。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Write Back（写回）策略；&lt;/li>
&lt;/ul>
&lt;p>实际开发中，Redis 和 MySQL 的更新策略用的是 Cache Aside，&lt;/p>
&lt;h4 id="先更新数据库再删除缓存-cache-aside">先更新数据库再删除缓存 (Cache Aside)&lt;/h4>
&lt;p>写策略的步骤：&lt;/p>
&lt;ul>
&lt;li>先更新数据库中的数据，再删除缓存中的数据。&lt;/li>
&lt;/ul>
&lt;p>读策略的步骤：&lt;/p>
&lt;ul>
&lt;li>如果读取的数据命中了缓存，则直接返回数据；&lt;/li>
&lt;li>如果读取的数据没有命中缓存，则从数据库中读取数据，然后将数据写入到缓存，并且返回给用户。&lt;/li>
&lt;/ul>
&lt;p>不能先删除缓存再更新数据库的原因:&lt;/p>
&lt;ul>
&lt;li>「读+写」并发时, 数据不一致.&lt;/li>
&lt;/ul>
&lt;p>即删除了缓存之后, 还没有更新数据库, 这时候另一个线程读取了缓存, 由于缓存被删除, 从数据库中读取了旧数据.&lt;/p>
&lt;h4 id="先更新数据库再更新缓存-readwrite-through读穿--写穿策略">先更新数据库再更新缓存 Read/Write Through（读穿 / 写穿）策略&lt;/h4>
&lt;p>当有数据更新的时候，先查询要写入的数据在缓存中是否已经存在：&lt;/p>
&lt;ul>
&lt;li>如果缓存中数据已经存在，则&lt;strong>更新缓存中的数据&lt;/strong>，并且&lt;strong>由缓存组件同步更新到数据库中&lt;/strong>，然后缓存组件告知应用程序更新完成。&lt;/li>
&lt;li>如果缓存中数据不存在，直接更新数据库，然后返回；&lt;/li>
&lt;/ul>
&lt;p>不常使用的原因:&lt;/p>
&lt;ul>
&lt;li>原因是我们经常使用的分布式缓存组件，无论是 Memcached 还是 Redis 都&lt;strong>不提供写入数据库和自动加载数据库中的数据的功能&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;h4 id="只更新缓存-write-back写回策略">只更新缓存 Write Back（写回）策略&lt;/h4>
&lt;p>Write Back 策略特别适合写多的场景，因为发生写操作的时候， 只需要更新缓存，就立马返回了。&lt;/p>
&lt;p>比如，写文件的时候，实际上是写入到文件系统的缓存就返回了，并不会写磁盘。&lt;/p>
&lt;p>但是带来的问题是，数据不是强一致性的，而且会有数据丢失的风险，&lt;/p>
&lt;h4 id="保证-先更新数据库再删除缓存-操作成功">保证 先更新数据库再删除缓存 操作成功&lt;/h4>
&lt;p>如果 在删除缓存（第二个操作）的时候失败了，导致缓存中的数据是旧值，而数据库是最新值。&lt;/p>
&lt;p>采用异步操作缓存&lt;/p>
&lt;p>&lt;strong>重试机制&lt;/strong>&lt;/p>
&lt;p>引入消息队列，将第二个操作（删除缓存）要操作的数据加入到消息队列，由消费者来操作数据。&lt;/p>
&lt;ul>
&lt;li>如果&lt;strong>应用删除缓存失败，可以从消息队列中重新读取数据&lt;/strong>，然后再次删除缓存，这个就是重试机制。当然，如果重试超过的一定次数，还是没有成功，我们就需要向业务层发送报错信息了。&lt;/li>
&lt;li>如果删除缓存成功，就要把数据从消息队列中移除，避免重复操作，否则就继续重试。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>订阅 MySQL binlog，再操作缓存&lt;/strong>&lt;/p>
&lt;p>阿里的Canal 中间件就是这个策略&lt;/p>
&lt;p>通过订阅 binlog 日志，拿到具体要操作的数据，然后再执行缓存删除&lt;/p>
&lt;p>Canal 模拟 MySQL 主从复制的交互协议，把自己伪装成一个 MySQL 的从节点，向 MySQL 主节点发送 dump 请求，MySQL 收到请求后，就会开始推送 Binlog 给 Canal，Canal 解析 Binlog 字节流之后，转换为便于读取的结构化数据，供下游程序订阅使用。&lt;/p>
&lt;h4 id="延迟双删">延迟双删&lt;/h4>
&lt;p>针对「先删除缓存，再更新数据库」方案在「读 + 写」并发请求而造成缓存不一致的解决办法是「延迟双删」&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">#删除缓存
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">redis.delKey(X)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#更新数据库
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">db.update(X)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#睡眠
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Thread.sleep(N)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#再删除缓存
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">redis.delKey(X)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>睡眠时间是为了确保请求 A 在睡眠的时候，请求 B 能够在这这一段时间完成「从数据库读取数据，再把缺失的缓存写入缓存」的操作，然后请求 A 睡眠完，再删除缓存&lt;/p>
&lt;h4 id="双写一致性策略分析">双写一致性策略分析&lt;/h4>
&lt;p>四种同步策略：&lt;/p>
&lt;p>想要保证缓存与数据库的双写一致，一共有4种方式，即4种同步策略：&lt;/p>
&lt;ol>
&lt;li>先更新缓存，再更新数据库；&lt;/li>
&lt;li>先更新数据库，再更新缓存；&lt;/li>
&lt;li>先删除缓存，再更新数据库；&lt;/li>
&lt;li>先更新数据库，再删除缓存&lt;/li>
&lt;/ol>
&lt;p>从这4种同步策略中，我们需要作出比较的是：&lt;/p>
&lt;ol>
&lt;li>更新缓存与删除缓存哪种方式更合适？&lt;/li>
&lt;li>应该先操作数据库还是先操作缓存？&lt;/li>
&lt;/ol>
&lt;p>更新缓存还是删除缓存：&lt;/p>
&lt;p>下面，我们来分析一下，应该采用更新缓存还是删除缓存的方式。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>更新缓存&lt;/p>
&lt;p>优点：每次数据变化都及时更新缓存，所以查询时不容易出现未命中的情况。&lt;/p>
&lt;p>缺点：更新缓存的消耗比较大。如果数据需要经过复杂的计算再写入缓存，那么频繁的更新缓存，就会影响服务器的性能。如果是写入数据频繁的业务场景，那么可能频繁的更新缓存时，却没有业务读取该数据。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>删除缓存&lt;/p>
&lt;p>优点：操作简单，无论更新操作是否复杂，都是将缓存中的数据直接删除。&lt;/p>
&lt;p>缺点：删除缓存后，下一次查询缓存会出现未命中，这时需要重新读取一次数据库。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>从上面的比较来看，一般情况下，删除缓存是更优的方案。&lt;/p>
&lt;p>先操作数据库还是缓存：&lt;/p>
&lt;p>下面，我们再来分析一下，应该先操作数据库还是先操作缓存。&lt;/p>
&lt;p>首先，我们将先删除缓存与先更新数据库，在出现失败时进行一个对比：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="https://uploadfiles.nowcoder.com/images/20220224/4107856_1645695077865/A8EAB406CDF2717DDC4C9AB91E37092E" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>如上图，是先删除缓存再更新数据库，在出现失败时可能出现的问题：&lt;/p>
&lt;ol>
&lt;li>进程A删除缓存成功；&lt;/li>
&lt;li>进程A更新数据库失败；&lt;/li>
&lt;li>进程B从缓存中读取数据；&lt;/li>
&lt;li>由于缓存被删，进程B无法从缓存中得到数据，进而从数据库读取数据；&lt;/li>
&lt;li>进程B从数据库成功获取数据，然后将数据更新到了缓存。&lt;/li>
&lt;/ol>
&lt;p>最终，缓存和数据库的数据是一致的，但仍然是旧的数据。而我们的期望是二者数据一致，并且是新的数据。&lt;/p>
&lt;p>总结:&lt;/p>
&lt;ul>
&lt;li>「先更新数据库，再删除缓存」的方案虽然保证了数据库与缓存的数据一致性，但是每次更新数据的时候，缓存的数据都会被删除，这样会对缓存的命中率带来影响。&lt;/li>
&lt;li>&lt;strong>对缓存命中率有很高的要求&lt;/strong>，我们可以采用「更新数据库 + 更新缓存」的方案，因为更新缓存并不会出现缓存未命中的情况。
&lt;ul>
&lt;li>带来的问题: 写入顺序的不同造成数据的不一致&lt;/li>
&lt;li>解决方法:
&lt;ul>
&lt;li>更新缓存前加锁, 保证写入顺序的一致性&lt;/li>
&lt;li>在更新完缓存时，给缓存加上较短的过期时间&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="redis集群">Redis集群&lt;/h2>
&lt;p>Redis可以采用一主多从的方式实现集群，也可以采用哨兵模式实现集群。&lt;/p>
&lt;p>Redis集群的原理： 将数据分散到多个节点上存储，通过主从复制和哨兵机制保证数据的可用性和一致性。&lt;/p>
&lt;p>Redis集群最大节点个数是16384。&lt;/p>
&lt;h3 id="主从复制">主从复制&lt;/h3>
&lt;p>主服务器可以进行读写操作，当发生写操作时自动将写操作同步给从服务器&lt;/p>
&lt;p>&lt;strong>从服务器一般是只读&lt;/strong>，并接受主服务器同步过来写操作命令，然后执行这条命令。&lt;/p>
&lt;p>主从服务器之间的命令复制是异步进行的&lt;/p>
&lt;p>使用 replicaof（Redis 5.0 之前使用 slaveof）命令形成主服务器和从服务器的关系&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 服务器 B 执行这条命令&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">replicaof &amp;lt;服务器 A 的 IP 地址&amp;gt; &amp;lt;服务器 A 的 Redis 端口号&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>服务器 B 就会变成服务器 A 的「从服务器」，然后与主服务器进行第一次同步。&lt;/p>
&lt;p>第一次同步的过程可分为三个阶段：&lt;/p>
&lt;ul>
&lt;li>第一阶段是建立链接、协商同步；&lt;/li>
&lt;li>第二阶段是主服务器同步数据给从服务器；&lt;/li>
&lt;li>第三阶段是主服务器发送新写操作命令给从服务器&lt;/li>
&lt;/ul>
&lt;p>命令传播:&lt;/p>
&lt;p>完成第一次同步后，双方之间就会维护一个 基于TCP长连接的命令传播。&lt;/p>
&lt;h4 id="分摊主服务器压力">分摊主服务器压力&lt;/h4>
&lt;p>第一次数据同步的过程中，主服务器会做两件耗时的操作：生成 RDB 文件和传输 RDB 文件. 如果从服务器多,会影响主服务器的性能。&lt;/p>
&lt;p>&lt;strong>从服务器可以有自己的从服务器&lt;/strong>，我们可以把拥有从服务器的从服务器当作经理角色，它不仅可以接收主服务器的同步数据，自己也可以同时作为主服务器的形式将数据同步给从服务器&lt;/p>
&lt;p>主服务器生成 RDB 和传输 RDB 的压力可以分摊到充当经理角色的从服务器&lt;/p>
&lt;p>在「从服务器」上执行下面这条命令，使其作为目标服务器的从服务器&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">replicaof &amp;lt;目标服务器的IP&amp;gt; 6379
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="增量复制">增量复制&lt;/h4>
&lt;p>2.8之前会全部重新同步&lt;/p>
&lt;p>从 Redis 2.8 开始，网络断开又恢复后，从主从服务器会采用增量复制的方式继续同步, 即之后只会把网络断开期间主服务器接收到的写操作命令，同步给从服务器&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Redis%e5%ba%94%e7%94%a8/%e5%a2%9e%e9%87%8f%e5%a4%8d%e8%af%95%e6%b5%81%e7%a8%8b.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>主服务器怎么知道要将哪些增量数据发送给从服务器呢？&lt;/p>
&lt;ul>
&lt;li>repl_backlog_buffer，是一个「环形」缓冲区，用于主从服务器断连后，从中找到差异的数据；&lt;/li>
&lt;li>replication offset，标记上面那个缓冲区的同步进度，主从服务器都有各自的偏移量，主服务器使用 master_repl_offset 来记录自己「写」到的位置，从服务器使用 slave_repl_offset 来记录自己「读」到的位置。&lt;/li>
&lt;/ul>
&lt;p>在主服务器进行命令传播时，不仅会将写命令发送给从服务器，还会将写命令写入到 repl_backlog_buffer 缓冲区里，因此 这个缓冲区里会保存着最近传播的写命令。&lt;/p>
&lt;p>网络断开后，当从服务器重新连上主服务器时，从服务器会通过 psync 命令将自己的复制偏移量 slave_repl_offset 发送给主服务器，主服务器根据自己的 master_repl_offset 和 slave_repl_offset 之间的差距，然后来决定对从服务器执行哪种同步操作：&lt;/p>
&lt;ul>
&lt;li>如果判断出&lt;strong>从服务器要读取的数据&lt;/strong>还在 repl_backlog_buffer 缓冲区里，那么主服务器将采用增量同步的方式；&lt;/li>
&lt;li>相反，如果判断出&lt;strong>从服务器要读取的数据&lt;/strong>已经不存在 repl_backlog_buffer 缓冲区里，那么主服务器将采用全量同步的方式。&lt;/li>
&lt;/ul>
&lt;p>为了避免在网络恢复时，主服务器频繁地使用全量同步的方式，我们应该调整下 repl_backlog_buffer 缓冲区大小，尽可能的大一些&lt;/p>
&lt;p>修改方法, 配置文件中的字段:
&lt;code>repl-backlog-size 1mb&lt;/code>&lt;/p>
&lt;h3 id="哨兵模式">哨兵模式&lt;/h3>
&lt;p>解决的问题: 主从服务器出现故障宕机时，需要手动进行恢复。&lt;/p>
&lt;p>作用:&lt;/p>
&lt;ul>
&lt;li>监控主从服务器的运行状态&lt;/li>
&lt;li>提供主从节点故障转移功能&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Redis%e5%ba%94%e7%94%a8/%e5%93%a8%e5%85%b5%e6%a8%a1%e5%bc%8f.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h4 id="监控">监控&lt;/h4>
&lt;p>每隔 1 秒给所有主从节点发送 PING 命令，当主从节点收到 PING 命令后，会发送一个响应命令给哨兵&lt;/p>
&lt;p>如果主节点或者从节点没有在规定的时间内响应哨兵的 PING 命令，哨兵就会将它们标记为「主观下线」。这个「规定的时间」是配置项 down-after-milliseconds 参数设定的，单位是毫秒。&lt;/p>
&lt;p>为了减少误判的情况，哨兵在部署的时候不会只部署一个节点，而是用多个节点部署成&lt;strong>哨兵集群&lt;/strong>（最少需要三台机器来部署哨兵集群），通过多个哨兵节点一起判断，就可以就可以避免单个哨兵因为自身网络状况不好，而误判主节点下线的情况&lt;/p>
&lt;p>当一个哨兵判断主节点为「主观下线」后，就会向其他哨兵发起命令，其他哨兵收到这个命令后，就会根据自身和主节点的网络状况，做出赞成投票或者拒绝投票的响应。当**超过半数的哨兵节点都认为主节点为「主观下线」**时，就会将主节点标记为「客观下线」。&lt;/p>
&lt;h4 id="选主">选主&lt;/h4>
&lt;p>从哨兵集群中选出一个哨兵节点作为领导者，这个领导者负责进行故障转移的操作&lt;/p>
&lt;p>候选者: 判断主节点为「客观下线」的那个节点&lt;/p>
&lt;p>选举过程:&lt;/p>
&lt;ul>
&lt;li>候选者主动向哨兵集群发起选举请求&lt;/li>
&lt;li>每个哨兵节点都会对候选者进行投票
&lt;ul>
&lt;li>投给自己(只有候选者可以)&lt;/li>
&lt;li>投给其他哨兵&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>任何一个候选者同时满足
&lt;ul>
&lt;li>半数以上赞成票&lt;/li>
&lt;li>票数大于等于配置文件的 &lt;code>quorum&lt;/code> 参数&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h5 id="哨兵节点至少要有三个">哨兵节点至少要有三个&lt;/h5>
&lt;p>如果一个哨兵想要成功成为 Leader，必须获得 2 票，而不是 1 票&lt;/p>
&lt;p>挂掉一个还能进行投票&lt;/p>
&lt;p>挂掉两个就需要人为介入或增加哨兵节点&lt;/p>
&lt;p>quorum 的值建议设置为哨兵个数的二分之一加 1，例如 3 个哨兵就设置 2，5 个哨兵设置为 3，而且哨兵节点的数量应该是奇数。&lt;/p>
&lt;h4 id="主从故障转移">主从故障转移&lt;/h4>
&lt;ol>
&lt;li>在已下线主节点（旧主节点）属下的&lt;strong>所有「从节点」里面，挑选出一个从节点&lt;/strong>，并将其转换为主节点。&lt;/li>
&lt;li>让已下线主节点属下的&lt;strong>所有「从节点」修改复制目标&lt;/strong>，修改为复制「新主节点」；&lt;/li>
&lt;li>将新主节点的 IP 地址和信息，通过「发布者/订阅者机制」&lt;strong>通知给客户端&lt;/strong>；&lt;/li>
&lt;li>继续监视旧主节点，&lt;strong>当这个旧主节点重新上线时，将它设置为新主节点的从节点&lt;/strong>&lt;/li>
&lt;/ol>
&lt;h4 id="哨兵集群的组成">哨兵集群的组成&lt;/h4>
&lt;p>哨兵节点之间是通过 Redis 的发布者/订阅者机制来相互发现的。&lt;/p>
&lt;ul>
&lt;li>互相感知: 在主从集群中，主节点上有一个名为__sentinel__:hello的频道，不同哨兵就是通过它来相互发现，实现互相通信的。&lt;/li>
&lt;li>建立连接: 哨兵会每 10 秒一次的频率向主节点发送 INFO 命令来获取所有「从节点」的信息, 从而可以建立连接&lt;/li>
&lt;/ul>
&lt;h3 id="切片集群模式">切片集群模式&lt;/h3>
&lt;p>当 Redis 缓存数据量大到一台服务器无法缓存, 需要切片集群&lt;/p>
&lt;p>Redis 3.0 之后的版本支持切片集群模式，它将数据分布在不同的服务器上，以此来降低系统对单主节点的依赖，从而提高 Redis 服务的读写性能。&lt;/p>
&lt;p>Redis Cluster 方案采用哈希槽（Hash Slot），来处理数据和节点之间的映射关系。在 Redis Cluster 方案中，一个切片集群共有 16384 个哈希槽&lt;/p>
&lt;ul>
&lt;li>根据键值对的 key，按照 CRC16 算法 (opens new window)计算一个 16 bit 的值。&lt;/li>
&lt;li>再用 16bit 值对 16384 取模，得到 0~16383 范围内的模数，每个模数代表一个相应编号的哈希槽。&lt;/li>
&lt;/ul>
&lt;p>哈希槽映射到Redis节点方式:&lt;/p>
&lt;ul>
&lt;li>平均分配: 将 16384 个哈希槽均匀分配到每个 Redis 节点上&lt;/li>
&lt;li>手动分配: 指定每个 Redis 节点负责的哈希槽范围
&lt;ul>
&lt;li>在手动分配哈希槽时，&lt;strong>需要把 16384 个槽都分配完&lt;/strong>，否则 Redis 集群无法正常工作。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="为什么不使用一致性哈希">为什么不使用一致性哈希&lt;/h4>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s/Q68UN34-BqxyQFtkJL98lg" target="_blank" rel="noopener">得物面试：为啥Redis用哈希槽，不用一致性哈希？&lt;/a>&lt;/p>
&lt;h3 id="集群脑裂问题">集群脑裂问题&lt;/h3>
&lt;p>Redis架构一般是一主多从.&lt;/p>
&lt;ul>
&lt;li>如果主节点与从节点断开&lt;/li>
&lt;li>但不与客户端断开&lt;/li>
&lt;/ul>
&lt;p>从节点中会选举出一个新主节点.&lt;/p>
&lt;p>但此时客户端还在与旧主节点通信, 会集群出现两个主节点&lt;/p>
&lt;p>脑裂问题:&lt;/p>
&lt;ul>
&lt;li>当旧主节点和新主节点之间网络恢复后, 会出现数据不一致问题
leader哨兵会把旧主节点设置为从节点(A), A向新主节点请求同步数据.&lt;/li>
&lt;li>第一次是全量同步, 旧主节点A会清空本地数据. 那么之前&lt;strong>客户端写入A的数据就会丢失&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>解决方案:&lt;/p>
&lt;p>当主节点发现从节点下线或者通信超时的总数量小于阈值时，那么禁止主节点进行写数据，直接把错误返回给客户端。&lt;/p>
&lt;p>对应的参数:&lt;/p>
&lt;ul>
&lt;li>min-slaves-to-write x，主节点必须要有至少 x 个从节点连接，如果小于这个数，主节点会禁止写数据。&lt;/li>
&lt;li>min-slaves-max-lag x，主从数据复制和同步的延迟不能超过 x 秒，如果超过，主节点会禁止写数据。&lt;/li>
&lt;/ul>
&lt;p>这样在选举完后, 不会出现丢失问题, 因为旧主节点不会再接收写请求.&lt;/p>
&lt;h2 id="redis实战">Redis实战&lt;/h2>
&lt;h3 id="redis实现延迟队列">Redis实现延迟队列&lt;/h3>
&lt;p>使用有序集合（ZSet）的方式来实现延迟消息队列的，ZSet 有一个 Score 属性可以用来存储延迟执行的时间&lt;/p>
&lt;p>使用 zadd score1 value1 命令就可以一直往内存中生产消息。再利用 &lt;strong>zrangebysocre 查询符合条件的所有待处理的任务， 通过循环执行队列任务&lt;/strong>即可。&lt;/p>
&lt;h3 id="redis的大key处理">Redis的大Key处理&lt;/h3>
&lt;h3 id="redis是否支持事务">Redis是否支持事务&lt;/h3>
&lt;p>Redis 支持事务，但是 Redis 的事务和数据库的事务是不同的。&lt;/p>
&lt;p>开启事务, 使用 MULTI 命令，然后执行多个命令，最后使用 EXEC 命令来执行事务中的所有命令。&lt;/p>
&lt;p>Redis 提供了 DISCARD 命令，但是这个命令只能用来主动放弃事务执行，把暂存的命令队列清空.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">#读取 count 的值4
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">127.0.0.1:6379&amp;gt; GET count
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&amp;#34;1&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#开启事务
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">127.0.0.1:6379&amp;gt; MULTI
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">OK
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#发送事务的第一个操作，对count减1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">127.0.0.1:6379&amp;gt; DECR count
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">QUEUED
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#执行DISCARD命令，主动放弃事务
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">127.0.0.1:6379&amp;gt; DISCARD
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">OK
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#再次读取a:stock的值，值没有被修改
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">127.0.0.1:6379&amp;gt; GET count
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&amp;#34;1&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>因此 Redis 并&lt;strong>不一定保证原子性&lt;/strong>&lt;/p>
&lt;p>Redis 的事务是通过 MULTI 和 EXEC 命令来实现的，它的事务是一个单独的操作，不会被其他客户端的命令打断。&lt;/p>
&lt;p>Redis的事务是不支持回滚的&lt;/p>
&lt;p>作者不支持事务回滚的原因有以下两个：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Redis 事务的执行时，错误通常都是编程错误造成的&lt;/strong>，这种错误通常只会出现在开发环境中，而很少会在实际的生产环境中出现，所以他认为没有必要为 Redis 开发事务回滚功能；&lt;/li>
&lt;li>不支持事务回滚是因为这种复杂的功能和 Redis 追求的简单高效的设计主旨不符合。&lt;/li>
&lt;/ul>
&lt;p>这里不支持事务回滚，指的是不支持事务运行时错误的事务回滚。&lt;/p>
&lt;h2 id="其他">其他&lt;/h2>
&lt;p>23、Redis集群会导致整个集群不可用的情况有哪些？&lt;/p>
&lt;p>Redis集群会导致整个集群不可用的情况包括节点故障、网络分区等。&lt;/p>
&lt;p>24、Redis支持的Java客户端有哪些？&lt;/p>
&lt;p>Redis支持的Java客户端包括Jedis、Lettuce、Redisson等，官方推荐使用Lettuce。&lt;/p>
&lt;p>25、Jedis与Redisson对比的优缺点有哪些？&lt;/p>
&lt;p>Jedis与Redisson对比的优缺点包括性能、功能、易用性等方面。&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/</guid><description>&lt;h1 id="数据库">数据库&lt;/h1>
&lt;h2 id="索引">索引&lt;/h2>
&lt;h3 id="索引的优缺点">索引的优缺点&lt;/h3>
&lt;p>优点：&lt;/p>
&lt;ul>
&lt;li>使用索引可以大大加快数据的检索速度（大大减少检索的数据量）, 减少 IO 次数，这也是创建索引的最主要的原因。&lt;/li>
&lt;li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。&lt;/li>
&lt;li>可以加速表和表之间的&lt;strong>连接&lt;/strong>，特别是在实现数据的参照完整性方面特别有意义&lt;/li>
&lt;li>在使用分组和排序子句进行数据检索式，同样可以显著减少查询中**分组&lt;/li>
&lt;li>通过使用索引，可以在查询的过程中，使用&lt;strong>优化隐藏器&lt;/strong>，提高系统的性能&lt;/li>
&lt;/ul>
&lt;p>缺点：&lt;/p>
&lt;ul>
&lt;li>创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。&lt;/li>
&lt;li>索引需要使用物理文件存储，也会耗费一定空间。&lt;/li>
&lt;/ul>
&lt;p>但使用索引不一定能提高查询性能吗?&lt;/p>
&lt;p>大多数情况下，索引查询都是比全表扫描要快的。但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升。&lt;/p>
&lt;h3 id="索引有哪些索引分类">&lt;strong>索引有哪些？索引分类&lt;/strong>&lt;/h3>
&lt;h4 id="按照物理存储分类">按照物理存储分类&lt;/h4>
&lt;p>聚簇索引&lt;/p>
&lt;ul>
&lt;li>按照数据存放的&lt;strong>物理位置为顺序&lt;/strong>的索引结构，聚集索引的&lt;strong>叶子节点包含了整个数据行&lt;/strong>。&lt;/li>
&lt;li>InnoDB表要求&lt;strong>必须有聚簇索引，默认在主键字段上建立聚簇索引&lt;/strong>,在.idb文件中就包含了索引和数据.
&lt;ul>
&lt;li>如果没有定义主键，那么会使用第一非空的唯一索引（NOT NULL and UNIQUE INDEX）作为聚簇索引&lt;/li>
&lt;li>如果既没有主键也找不到合适的非空索引，那么InnoDB会自动生成一个不可见的名为ROW_ID的列名为GEN_CLUST_INDEX的聚簇索引，该列是一个6字节的自增数值，随着插入而自增&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>每个表&lt;strong>只能有一个聚集索引&lt;/strong>，它对应的索引键值也是表的&lt;strong>主键或唯一约束条件&lt;/strong>。&lt;/li>
&lt;li>通过聚集索引，我们可以快速地按照主键或唯一约束条件查询和排序表中的数据, &lt;strong>提高多行检索速度&lt;/strong>
优点:&lt;/li>
&lt;li>查询速度快&lt;/li>
&lt;li>对排序查找和范围查找优化：聚簇索引对于主键的排序查找和范围查找速度非常快。&lt;/li>
&lt;/ul>
&lt;p>缺点:&lt;/p>
&lt;ul>
&lt;li>有序, 对于UUID等无序的主键, 会导致插入性能下降.&lt;/li>
&lt;li>更新代价大,叶子节点包含了整个数据行,更新索引会导致数据行的移动, 代价大.&lt;/li>
&lt;/ul>
&lt;p>非聚簇索引&lt;/p>
&lt;ul>
&lt;li>索引顺序与数据&lt;strong>物理列排序无关&lt;/strong>，&lt;strong>叶节点仍然是索引节点(指向主键)&lt;/strong>&lt;/li>
&lt;li>每个表可以有&lt;strong>多个非聚集索引&lt;/strong>，这些索引可以覆盖&lt;strong>多个数据列&lt;/strong>，以满足不同的查询需求。&lt;/li>
&lt;li>通过非聚集索引，快速地&lt;strong>定位表中符合查询条件的记录的主键&lt;/strong>，然后进行(回表查询)。&lt;/li>
&lt;li>MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引
优点:&lt;/li>
&lt;li>更新代价小
缺点:&lt;/li>
&lt;li>引起二次查询(回表), 查到索引对应的指针或主键后, 要根据主键再次查询数据, 会增加查询时间.&lt;/li>
&lt;/ul>
&lt;p>为了使得&lt;strong>表中数据有序&lt;/strong>, 很多数据库使用了&lt;strong>聚簇索引&lt;/strong>.&lt;/p>
&lt;p>聚簇索引就是按照每张表的主键构造一颗B+树，同时叶子节点中存放的就是整张表的行记录数据，这个叶子节点也被称为数据页。每张表只能拥有一个聚簇索引。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>范围查询效率非常高&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>代价: &lt;strong>非范围查询也要进行范围扫描&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>主键更新会导致记录的重新排序，从而导致记录物理位置的变化&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>为了更加安全, 聚簇索引可以和索引组织表一样，根据主键来定义. 因为主键被更新的概率小,或者说不应该被更新.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>聚簇索引&lt;strong>也可以是非主键索引,这是和索引组织表不一样的地方&lt;/strong>.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>聚簇索引和IOT的区别在于索引键的选择和存储方式。&lt;/p>
&lt;ul>
&lt;li>聚簇索引只包括表的主键，并将表的数据按照主键值的顺序存储在硬盘上；&lt;/li>
&lt;li>IOT包括表的主键和数据列，并将数据和索引存储在同一个结构中。&lt;/li>
&lt;/ul>
&lt;h4 id="按应用的字段">按应用的字段&lt;/h4>
&lt;p>主键索引：加速查询 + 列值唯一（不可以有 NULL）+ 表中只有一个。
唯一索引：加速查询 + 列值唯一（可以有 NULL）。
普通索引：仅加速查询。
覆盖索引：一个索引包含（或者说覆盖）所有需要查询的字段的值。&lt;/p>
&lt;ul>
&lt;li>如果&lt;strong>非聚簇符合索引&lt;/strong>已经能够得到&lt;strong>查询的所有信息&lt;/strong>了，就&lt;strong>无需再回表&lt;/strong>，即只按照条件&lt;strong>找主键&lt;/strong>。
联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并。&lt;/li>
&lt;li>联合索引遵循最左前缀原则，即在查询时，&lt;strong>查询条件必须使用到联合索引的最左边的列&lt;/strong>，索引才会生效。
全文索引：对文本的内容进行分词，进行搜索。目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替。&lt;/li>
&lt;/ul>
&lt;h3 id="索引的底层数据结构">索引的底层数据结构&lt;/h3>
&lt;h4 id="b树索引">B+树索引&lt;/h4>
&lt;p>见&lt;a href="###B&amp;#43;%e6%a0%91">B+树&lt;/a>&lt;/p>
&lt;h4 id="哈希索引">哈希索引&lt;/h4>
&lt;ul>
&lt;li>所有的数据类型，通过哈希函数变成一个&lt;strong>等长的哈希值&lt;/strong>。&lt;/li>
&lt;li>将这个&lt;strong>等长的哈希值&lt;/strong>作为&lt;strong>组织成索引的结构 —— 哈希链表&lt;/strong>。&lt;/li>
&lt;li>哈希链表的结点上，&lt;strong>储存哈希值&lt;/strong> 和 &lt;strong>指向记录哈希值的地址 uid（索引行的地址）&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>哈希索引能做什么不能做什么？&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>哈希索引只能用来进行&lt;strong>全键值&lt;/strong>的查询
&lt;ul>
&lt;li>不能前缀查询&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>哈希索引只支持&lt;strong>击中运算符&lt;/strong>
&lt;ul>
&lt;li>击中运算符：= , != , in&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>哈希索引&lt;strong>不支持范围查询&lt;/strong>&lt;/li>
&lt;li>哈希索引&lt;strong>不支持对字段排序&lt;/strong>(因为只支持击中运算符)&lt;/li>
&lt;li>哈希索引&lt;strong>读取效率高于B树索引&lt;/strong>
&lt;ul>
&lt;li>哈希索引结构非常&lt;strong>紧凑&lt;/strong>.&lt;/li>
&lt;li>哈希索引&lt;strong>使用数值的比较&lt;/strong>,远&lt;strong>高于字符串比较&lt;/strong>速度.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="函数索引">函数索引&lt;/h4>
&lt;p>B树索引是对一个字段构建索引,而函数索引是对&lt;strong>这个字段上的一个函数值&lt;/strong>构建索引.&lt;/p>
&lt;p>&lt;strong>结构同样是B+树索引,只是节点的关键字是函数的值而不是字段值.&lt;/strong>&lt;/p>
&lt;p>是最具创造力的索引结构,用得好可用解决并发冲突,优化存储结构.等很多事情.&lt;/p>
&lt;p>&lt;strong>能用在哪&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>不区分大小写&lt;/strong>查询&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>T、F比例巨大差异&lt;/strong>的查询&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>有选择的唯一性&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>项目表有两个状态, active和inactive.
要求active的项目,必须要有唯一名. 而inactive没有这个要求.
解决方法: &lt;strong>函数索引上构建唯一索引&lt;/strong>.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="位图索引">位图索引&lt;/h4>
&lt;p>用一个&lt;strong>索引键条目（01图）存储指向多行&lt;/strong>的指针。&lt;/p>
&lt;p>&lt;strong>位图索引适合&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>相异基数(distinct cardinality)低&lt;/strong>的字段进行快速查询 (复合查询)
&lt;ul>
&lt;li>可以取的值的范围小: 性别、真假,年龄段 等.&lt;/li>
&lt;li>使用B树索引,需要复合索引时 组合数多. 且共同的值多, 可能使得叶子结点远少于索引结点.&lt;/li>
&lt;li>使用哈希索引,碰撞率贼高.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>大量&lt;strong>临时查询的聚合&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>位图索引对于写操作非常不友好&lt;/strong>/位图索引&lt;strong>不能应用在OLTP&lt;/strong>应用中的原因&lt;/p>
&lt;p>&lt;strong>原因&lt;/strong>: 位图索引的&lt;strong>键值指向多行&lt;/strong>, 如果一个session修改了一个索引的数据,则&lt;strong>该索引指向的所有行都会被查找到&lt;/strong>.无法锁定单独一个条目,&lt;strong>可能在修改时要锁住整个目录&lt;/strong>,导致并发性下降严重 几乎变成串行化.&lt;/p>
&lt;p>&lt;strong>位图连结索引&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>允许使用&lt;strong>另外某个表的列&lt;/strong> 对 &lt;strong>一个给定表&lt;/strong> 建立索引。&lt;/li>
&lt;li>实际上，这就是允许&lt;strong>对一个索引结构&lt;/strong>(而不是表本身)中的数据进行&lt;strong>逆规范化&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>位图联结索引的&lt;strong>前提条件&lt;/strong>:&lt;/p>
&lt;p>&lt;strong>必须连接到另一张表的主键/唯一键&lt;/strong>&lt;/p>
&lt;p>&lt;strong>反向键索引或叫避向索引“eseindex)&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>将键值反向插入，以免并发插入时都插入到同一个块。&lt;/li>
&lt;li>此时进程将竞争同一个索引页,插入并发性大幅度下降&lt;/li>
&lt;/ol>
&lt;h3 id="b树">B+树&lt;/h3>
&lt;h4 id="b树与b树的结构">B树与B+树的结构&lt;/h4>
&lt;p>B树是&lt;strong>多关键字平衡树&lt;/strong>,且节点内的关键字是有序的.每个节点都存储其关键字指向的具体数据地址.&lt;/p>
&lt;p>B+树是在B树的基础上, 非叶子节点仅指向其多个子节点的地址 , 只有叶子节点指向具体以堆文件形式存放的数据块地址. 相邻叶子节点也通过指针连接. 方便快速范围查询.&lt;/p>
&lt;p>不同之处:&lt;/p>
&lt;ul>
&lt;li>层数更低: 相比于B树, B+树的非叶子节点全部用于索引,使得B+树的层数更低,&lt;/li>
&lt;li>效率稳定, B+树一定只能在叶子节点找到数据的具体地址, 每次查询的路径长度基本一致.&lt;/li>
&lt;li>范围查询: B+树的叶子节点有next指针, 使得范围查询效率更高.&lt;/li>
&lt;/ul>
&lt;h4 id="为什么不用其他数据结构做索引而用b树或b树">为什么不用其他数据结构做索引，而用B树或B+树&lt;/h4>
&lt;ul>
&lt;li>链表, 链表的查询速度是O（N），每次查询都得从链表头开始查询，例如上面查询“xiaxia”，如果xiaxia在1000的位置，那么需要遍历1000次才能查找到。&lt;/li>
&lt;li>数组:查询速度O（1），但删除插入是O(n), 且数据必须存在于内存, 索引过大时无法存储.&lt;/li>
&lt;li>平衡二叉树
&lt;ul>
&lt;li>二叉查找树查询的时间复杂度是O（logN），查找速度最快和比较次数最少. 但在树形结构下,影响查询效率的因素主要是树的深度, B树的深度远比平衡二叉树小。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="b树索引的适用范围">B+树索引的适用范围&lt;/h4>
&lt;ul>
&lt;li>全键值匹配&lt;/li>
&lt;li>匹配最左前缀
&lt;ul>
&lt;li>匹配列前缀&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>匹配范围值
&lt;ul>
&lt;li>精确匹配某一列并范围匹配另外一列&lt;/li>
&lt;li>只访问索引的查询&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="什么时候使用b树索引--b树的索引可用性">什么时候使用B树索引 / B树的索引可用性&lt;/h4>
&lt;p>1、只需要获取少量的行;(确保使用索引比不使用索引更高效)&lt;/p>
&lt;p>2、即便获取很多行，但是可以只使用索引不使用基本表。(索引中包含整个表)&lt;/p>
&lt;h3 id="正确使用索引">正确使用索引&lt;/h3>
&lt;h4 id="索引带来的问题负面的使用索引会降低查询效率的情况">索引带来的问题（负面的）,使用索引会降低查询效率的情况&lt;/h4>
&lt;ul>
&lt;li>总是&lt;strong>存在索引不被使用&lt;/strong>的情况。
&lt;ul>
&lt;li>存在索引时, 创建索引会带来系统的维护和空间的开销.&lt;/li>
&lt;li>因此索引如果不被使用反而会降低效率.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>当&lt;strong>一次查询的结果集较大&lt;/strong>时，索引会影响效率。
&lt;ul>
&lt;li>因为&lt;strong>索引是针对点查询&lt;/strong>的，而不是针对某个范围查询的。此时有可能不使用索引反而效率更高.&lt;/li>
&lt;li>一般结果集在10%以下可以考虑使用索引。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>对于&lt;strong>修改需求大的表&lt;/strong>中，使用索引会严重影响数据库更新操作的效率。&lt;/li>
&lt;li>太多索引会让&lt;strong>设计不稳定&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h4 id="设计索引时需要考虑的主要因素">设计索引时需要考虑的主要因素&lt;/h4>
&lt;ul>
&lt;li>在&lt;strong>适合加&lt;/strong>索引的列上加索引&lt;/li>
&lt;li>不在&lt;strong>不应该加&lt;/strong>索引的列上加索引&lt;/li>
&lt;li>限制索引数量&lt;/li>
&lt;li>确保建立该索引后&lt;strong>能够被使用&lt;/strong>&lt;/li>
&lt;li>确保索引带来的&lt;strong>好处大于索引带来的问题&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h4 id="哪些字段适合建立索引">哪些字段适合建立索引&lt;/h4>
&lt;ul>
&lt;li>&lt;strong>经常搜索&lt;/strong>的列&lt;/li>
&lt;li>经常&lt;strong>使用where子句&lt;/strong>的列上，加快条件的判断速度&lt;/li>
&lt;li>经常进行&lt;strong>范围搜索&lt;/strong>的列上，因为索引已经排序了，其指定的范围是连续的.&lt;/li>
&lt;li>&lt;strong>唯一性&lt;/strong>的列:在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构&lt;/li>
&lt;li>经常&lt;strong>需要排序&lt;/strong>的列上，因为索引已经排序了，查询可以利用索引的排序，加速排序查询时间.&lt;/li>
&lt;li>&lt;strong>经常用在连接的列&lt;/strong>，这些列&lt;strong>主要是外键&lt;/strong>，可以加快连接速度&lt;/li>
&lt;li>&lt;strong>数据分布较广的列&lt;/strong>:&lt;/li>
&lt;/ul>
&lt;h4 id="哪些字段上不应该加索引">哪些字段上不应该加索引&lt;/h4>
&lt;ul>
&lt;li>&lt;strong>很少使用&lt;/strong>或者参考的列不应该创建索引。&lt;/li>
&lt;li>&lt;strong>很少的数据值&lt;/strong>列不应该创建索引。&lt;/li>
&lt;li>&lt;strong>text,image,bit数据类型&lt;/strong>的列不应该加索引。
&lt;ul>
&lt;li>比较和排序的开销大.&lt;/li>
&lt;li>因为这些列要么数据量很大，要么很小，不利于使用索引&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>修改需求大&lt;/strong>的列.&lt;/li>
&lt;/ul>
&lt;h4 id="对外键建立索引">对外键建立索引&lt;/h4>
&lt;p>系统对外键建立索引很普遍。为什么要对外键建立索引&lt;/p>
&lt;ul>
&lt;li>加快对于父表和子表的&lt;strong>连接查询&lt;/strong>.&lt;/li>
&lt;li>&lt;strong>删除操作&lt;/strong>时，可以快速通过外键的索引找到&lt;strong>主表中&lt;/strong>要删除的行。&lt;/li>
&lt;li>&lt;strong>避免死锁&lt;/strong>, 有外键时会导致两个表都要上锁.
&lt;ul>
&lt;li>添加索引能够让&lt;strong>上锁后操作的时间变短&lt;/strong>, .并发时需要 A表加锁/B表加锁。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>什么情况下不对外键建立索引&lt;/p>
&lt;ul>
&lt;li>&lt;strong>子表不容易&lt;/strong>修改
&lt;ul>
&lt;li>不从子表中删除记录&lt;/li>
&lt;li>是一个字典表,不容易被修改.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>一般&lt;strong>不进行父表和子表的连接查询&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h4 id="为什么一般不会给所有单个属性都建立索引请写出两条原因">为什么一般不会给所有单个属性都建立索引，请写出两条原因&lt;/h4>
&lt;ul>
&lt;li>过多的索引会&lt;strong>加重优化器&lt;/strong>查找最优查询计划的负担&lt;/li>
&lt;li>会增加数据库&lt;strong>维护索引的负担&lt;/strong>.&lt;/li>
&lt;li>一旦聚集索引改变，&lt;strong>所有非聚集索引都会跟着改变&lt;/strong>&lt;/li>
&lt;li>该列是&lt;strong>属于不该建立索引&lt;/strong>的列时.&lt;/li>
&lt;/ul>
&lt;h3 id="索引失效的情况">索引失效的情况&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>使用B+树索引&lt;/strong>，但&lt;strong>没有使用索引的最前列&lt;/strong>&lt;/li>
&lt;li>&lt;strong>不能为NULL建立索引条目&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>COUNT(*)&lt;/strong>， 包括NULL, t会引起&lt;strong>全表扫描&lt;/strong>，&lt;/li>
&lt;li>is not NULL&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>函数查询&lt;/strong>时不使用索引&lt;/li>
&lt;li>&lt;strong>隐形函数查询&lt;/strong>，比如**&amp;lt;&amp;gt;不等于符**，会&lt;strong>引起全表扫描&lt;/strong>&lt;/li>
&lt;li>&lt;strong>隐式类型转换&lt;/strong>，如字符串转成数值来比较&lt;/li>
&lt;li>如果用了我的索引，实际反而会更慢。
&lt;ul>
&lt;li>即查询&lt;strong>优化器发现有比使用你的索引更快的访问方式&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>没有正确的统计信息&lt;/strong>，造成CBO无法做出正确的选择&lt;/li>
&lt;li>两个条件用 &lt;strong>or 连接&lt;/strong>，一个有索引一个没索引&lt;/li>
&lt;/ul>
&lt;p>总结成两条：&lt;/p>
&lt;ul>
&lt;li>“不能使用索引，使用索引会返回不正确的结果”&lt;/li>
&lt;li>“不该使用索引，如果使用了索引就会变得更慢”&lt;/li>
&lt;/ul>
&lt;h3 id="如何查看索引是否被使用">如何查看索引是否被使用&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>explain&lt;/strong>命令
&lt;ul>
&lt;li>&lt;code>explain select * from company_info where cname like '%小%'&lt;/code>&lt;/li>
&lt;li>看possible_keys和key列&lt;/li>
&lt;li>possible_keys 可能用到的所有索引; key 实际用到的索引&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="事务">事务&lt;/h2>
&lt;h3 id="为什么要加锁">&lt;strong>为什么要加锁&lt;/strong>&lt;/h3>
&lt;ul>
&lt;li>多个应用程序&lt;strong>同时对相同数据进行访问&lt;/strong>。&lt;/li>
&lt;li>&lt;strong>保证数据库的完整性和一致性&lt;/strong>，就必须要有一定的机制用于控制数据记录的读取、插入、删除和更新。&lt;/li>
&lt;li>通过对数据库对象加锁，我们可以&lt;strong>避免由于并发更改造成数据的丢失&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h3 id="加锁与提交">&lt;strong>加锁与提交&lt;/strong>&lt;/h3>
&lt;ul>
&lt;li>想要使加锁时间最短，必须&lt;strong>频繁的提交&lt;/strong>&lt;/li>
&lt;li>但如果每个逻辑单元完成后都提交&lt;strong>会增加大量开销&lt;/strong>&lt;/li>
&lt;li>对于批处理程序，并发控制不是问题，&lt;strong>避免频繁提交才是明智的做法&lt;/strong>。&lt;/li>
&lt;li>对于用户交互程序，则需要&lt;strong>高频提交，加快释放锁&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;h3 id="加锁与可伸缩性">&lt;strong>加锁与可伸缩性&lt;/strong>&lt;/h3>
&lt;ul>
&lt;li>与表级锁相比，行级锁能产生更佳的&lt;strong>吞吐量&lt;/strong>&lt;/li>
&lt;li>&lt;strong>行级锁大都性能曲线很快达到极限&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h3 id="加锁处理的原则">&lt;strong>加锁处理的原则&lt;/strong>&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>不要随便使用表级锁&lt;/strong>&lt;/li>
&lt;li>尽量&lt;strong>缩短加锁时间&lt;/strong>&lt;/li>
&lt;li>&lt;strong>索引也需要维护&lt;/strong>&lt;/li>
&lt;li>编程上的原则(语句性能高，未必程序性能高（下面有4点）)
&lt;ul>
&lt;li>避免SQL语句上的&lt;strong>循环处理&lt;/strong>&lt;/li>
&lt;li>减少程序和数据库之间的&lt;strong>交互次数&lt;/strong>&lt;/li>
&lt;li>充分利用DBMS提供的机制，使&lt;strong>跨机器交互的次数&lt;/strong>降至最少&lt;/li>
&lt;li>把所有&lt;strong>不重复不必要的SQL语句放在逻辑工作单元&lt;/strong>之外&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="锁的分类">锁的分类&lt;/h3>
&lt;p>悲观锁：&lt;/p>
&lt;ul>
&lt;li>指在读写数据时，认为&lt;strong>数据很可能会被其他并发操作所修改&lt;/strong>.
&lt;ul>
&lt;li>因此在**进行操作之前，先加锁，**确保数据不会被其他操作修改。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>悲观锁适用于并发写操作多，&lt;strong>读操作少&lt;/strong>的场景
&lt;ul>
&lt;li>例如&lt;strong>银行转账等涉及到账户余额变动&lt;/strong>的场景。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>悲观锁的缺点是在&lt;strong>并发量高时，会导致大量的阻塞和等待&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>乐观锁：&lt;/p>
&lt;ul>
&lt;li>指在读写数据时，认为&lt;strong>数据不会被其他并发操作所修改.&lt;/strong>
&lt;ul>
&lt;li>因此在进行操作之前，不加锁，但在&lt;strong>提交数据时，检查数据是否被其他操作所修改，如果没有修改，则提交成功，否则返回错误信息&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>乐观锁适用于并发读操作多，&lt;strong>写操作少&lt;/strong>的场景.
&lt;ul>
&lt;li>例如商品库存等只需要查询不需要修改的场景。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>乐观锁的优点是可以&lt;strong>大大降低阻塞和等待&lt;/strong>，但是需要在提交数据时进行额外的校验，&lt;strong>增加了程序开发和维护的难度&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>共享锁（Shared Lock）：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>允许多个事务进行读操作，但不允许写操作&lt;/strong>。&lt;/li>
&lt;li>共享锁适用于多个事务&lt;strong>只读同一份数据&lt;/strong>的场景。&lt;/li>
&lt;li>适用于读多写少的场景，例如在线图书馆、新闻网站等需要大量读取数据的应用，可以使用共享锁来&lt;strong>提高并发读取的能力，避免写操作的阻塞&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>排他锁（Exclusive Lock）：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>只允许一个事务进行写操作&lt;/strong>，其他事务&lt;strong>不能进行读写操作&lt;/strong>。&lt;/li>
&lt;li>适用于写多读少的场景，&lt;/li>
&lt;li>例如银行转账、在线购物等需要对数据进行修改的应用，可以使用排他锁来保证操作的原子性，&lt;strong>避免读写冲突和数据不一致性&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>共享锁（S 锁）：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。排他锁（X 锁）：又称写锁/独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条事务加任何类型的锁（锁不兼容）。&lt;/p>
&lt;p>行级锁（Row Lock）：&lt;/p>
&lt;ul>
&lt;li>针对数据表中的某一行数据进行加锁，&lt;strong>只有在访问该行数据时才会加锁&lt;/strong>，这样可以&lt;strong>提高并发性能&lt;/strong>。&lt;/li>
&lt;li>例如社交网络、在线游戏等需要&lt;strong>频繁更新数据,高并发&lt;/strong>的应用，可以使用行级锁来控制并发更新，提高系统的并发能力和性能。&lt;/li>
&lt;/ul>
&lt;p>间隙锁（Gap Lock）：&lt;/p>
&lt;ul>
&lt;li>针对数据表中&lt;strong>不存在的数据进行加锁&lt;/strong>，可以防止其他事务在这个间隙中插入数据。&lt;/li>
&lt;li>适用于对数据表中不存在的数据进行加锁的场景，例如对于需要&lt;strong>进行范围查询或者范围删除的应用&lt;/strong>，可以使用间隙锁来避免其他事务在查询或删除操作中插入数据，保证数据的一致性和正确性。(避免幻读)&lt;/li>
&lt;/ul>
&lt;p>意向锁（Intention Lock）：&lt;/p>
&lt;ul>
&lt;li>在加行级锁和表级锁&lt;strong>之前，先进行意向锁的判断&lt;/strong>，以&lt;strong>提高加锁效率&lt;/strong>。&lt;/li>
&lt;li>例如在多个事务同时请求对同一数据行进行更新时，可以使用意向锁来提前判断需要加的锁类型，&lt;strong>避免不必要的锁竞争和死锁问题&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;h3 id="必须由程序员利用程序语言控制并发更新的情况">&lt;strong>必须由程序员利用程序语言控制并发更新的情况:&lt;/strong>&lt;/h3>
&lt;ul>
&lt;li>业务规则&lt;strong>复杂的更新&lt;/strong>：如果更新操作需要依赖多个表或者多个条件，并且需要保证操作的原子性，就需要使用事务来控制并发更新。&lt;/li>
&lt;li>&lt;strong>分布式系统中的数据更新&lt;/strong>：在分布式系统中，不同节点之间可能会同时更新同一份数据，如果不加控制，就会导致数据的不一致性。因此，在分布式系统中，需要使用分布式锁来控制并发更新。&lt;/li>
&lt;li>&lt;strong>批量数据更新&lt;/strong>：如果需要批量更新数据，而且更新的数据量很大，可能会导致数据库锁表或者死锁等问题。因此，需要&lt;strong>将批量更新操作分批进行&lt;/strong>，或者&lt;strong>使用分布式锁&lt;/strong>来控制并发更新。&lt;/li>
&lt;li>&lt;strong>大量并发更新&lt;/strong>：如果并发更新的请求数量非常大，可能会导致数据库性能下降或者崩溃。因此，&lt;strong>需要使用连接池、缓存等技术来优化数据库性能，或者使用分布式锁来分散并发更新的压力。&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h3 id="资源竞争解决方案有哪些">&lt;strong>资源竞争解决方案有哪些&lt;/strong>&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>DBA解决方案：针对事务空间、可用列表&lt;/p>
&lt;ul>
&lt;li>增加分配给储物条目的空间缓解冲突&lt;/li>
&lt;li>让&lt;strong>insert分配到不同的物理块&lt;/strong>.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>架构解决方案：分区、逆序索引、索引组织表&lt;/p>
&lt;/li>
&lt;li>
&lt;p>开发解决方案：&lt;/p>
&lt;ul>
&lt;li>调节&lt;strong>并发数&lt;/strong>
&lt;ul>
&lt;li>限制session个数为最高性能的session个数，使周转更快&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>不使用系统产生值&lt;/strong>
&lt;ul>
&lt;li>连续值只在范围查询中使用，在连续值本身毫无现实意义的情况下，范围查询的场景也不多见;&lt;/li>
&lt;li>可以只使用随机数来做主键，遇到随机数碰撞，就再生成一个随机数.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>总结：&lt;strong>与加锁不同，数据库竞争是可以改善的&lt;/strong>。架构师、开发者和DBA都可以从各自的角度改善竞争&lt;/p>
&lt;h3 id="并发操作主要解决哪三个问题">&lt;strong>并发操作主要解决哪三个问题&lt;/strong>&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>丢失修改&lt;/strong>：T1和T2读入同一数据并修改，T2提交的结果破坏了T1的提交，导致T1修改被丢失&lt;/li>
&lt;li>&lt;strong>读脏数据&lt;/strong>：T1修改某一数据并将其写回磁盘，T2读取同一数据后，T1由于某种原因被撤销，数据也做了恢复，此时T2读的数据和数据库里的数据不一致，T2读到脏数据，即不正确数据&lt;/li>
&lt;li>&lt;strong>不可重复读&lt;/strong>：T1读数据后，T2对其修改，T1无法再现前一次读取结果&lt;/li>
&lt;/ul>
&lt;h3 id="事务的隔离级别">事务的隔离级别&lt;/h3>
&lt;p>未提交读（Read Uncommitted）：事务可以读取未提交的数据，也称作脏读（Dirty Read）。一般很少使用。&lt;/p>
&lt;p>提交读（Read Committed）：是大都是 DBMS （如：Oracle, SQLServer）默认事务隔离。执行两次同意的查询却有不同的结果，也叫不可重复读。&lt;/p>
&lt;p>可重复读（Repeable Read）：是 MySQL 默认事务隔离级别。能确保同一事务多次读取同一数据的结果是一致的。可以解决脏读的问题，但理论上无法解决幻读（Phantom Read）的问题。&lt;/p>
&lt;p>串行化（Serializable）：是最高的隔离级别。强制事务串行执行，会在读取的每一行数据上加锁，这样虽然能避免幻读的问题，但也可能导致大量的超时和锁争用的问题。很少会应用到这种级别，只有在非常需要确保数据的一致性且可以接受没有并发的应用场景下才会考虑。&lt;/p>
&lt;p>MySql实现的哪种隔离级别&lt;/p>
&lt;ul>
&lt;li>可重复读&lt;/li>
&lt;/ul>
&lt;p>实现方式: MVCC&lt;/p>
&lt;h3 id="mvcc原理">MVCC原理&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>多版本并发控制&lt;/strong>，是一种并发控制方法，用于实现事务隔离级别。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通过保存数据在某个时间点的快照来实现事务的隔离。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当前事务内的更新，可以读到；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>版本未提交，不能读到；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>版本已提交，但是却在快照创建后提交的，不能读到；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>版本已提交，且是在快照创建前提交的，可以读到；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>使用select进行查询，就是快照读，在“快照读&amp;quot;的情况下是可以解决“幻读”的问题的。使用的就是MVCC，&lt;/p>
&lt;p>对于会对数据修改的操作(update、insert、delete)都是采用当前读的模式&lt;/p>
&lt;h3 id="事务隔离级别的实现">事务隔离级别的实现&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>未提交读&lt;/strong>：不加锁&lt;/li>
&lt;li>&lt;strong>提交读&lt;/strong>：加行级共享锁&lt;/li>
&lt;li>&lt;strong>可重复读&lt;/strong>：加行级排他锁
&lt;ul>
&lt;li>MySQL的InnoDB存储引擎通过**多版本并发控制（MVCC）**来实现可重复读。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>可串行化&lt;/strong>：加表级锁&lt;/li>
&lt;/ul>
&lt;h3 id="事务的acid特性">&lt;strong>事务的ACID特性&lt;/strong>&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>原子性（Atomicity）&lt;/strong>：事务是一个不可分割的工作单位，事务中的操作要么都做，要么都不做。&lt;/li>
&lt;li>&lt;strong>一致性（Consistency）&lt;/strong>：事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。&lt;/li>
&lt;li>&lt;strong>隔离性（Isolation）&lt;/strong>：一个事务的执行不能被其他事务干扰。&lt;/li>
&lt;li>&lt;strong>持久性（Durability）&lt;/strong>：事务一旦提交，它对数据库中的数据的改变就是永久性的。&lt;/li>
&lt;/ul>
&lt;h2 id="模型">模型&lt;/h2>
&lt;h3 id="面向对象中可持久化类的父类子类继承关系如何映射到关系数据库中有哪几种情况-每种情况下的表结构设计是怎姓的层次结构">&lt;strong>面向对象中可持久化类的父类子类继承关系，如何映射到关系数据库中，有哪几种情况, 每种情况下的表结构设计是怎姓的。(层次结构)&lt;/strong>&lt;/h3>
&lt;p>例子:&lt;/p>
&lt;p>指挥官和士兵&lt;/p>
&lt;p>每人都有唯一的ID, 名字(name), 描述(description)&lt;/p>
&lt;p>&lt;strong>邻接模型&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>层次中&lt;strong>父记录ID&lt;/strong>作为子记录(childrow) 的一个属性。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>设计直观简单,但会导致&lt;strong>递归的查询&lt;/strong>。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>原理&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>在邻接表中&lt;/strong>，所有的数据均拥有一个Parent字段，用来存储它的父节点。&lt;/li>
&lt;li>当前节点为根节点的话，它的父节点则为NULL。&lt;/li>
&lt;li>在遍历的时候，可以使用递归来实现查询整棵树，从根节点开始，不断寻找子节点（父节点-&amp;gt;子节点-&amp;gt;父节点-&amp;gt;子节点）&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>优点：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>快速获取直接父子节点&lt;/strong>，很容易&lt;strong>插入新节点&lt;/strong>。&lt;/li>
&lt;li>容易实现
&lt;ul>
&lt;li>使用Connect by容易实现&lt;/li>
&lt;li>递归实现，用oracle的with，表示出树的层次&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>三种树状模型中&lt;strong>性能最高&lt;/strong>，每秒返回的查询记录最多；只需要遍历一次，&lt;strong>但不是基于关系的处理&lt;/strong>，性能最好&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>缺点：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>为了避免多次交互,&lt;strong>每次获得整张表&lt;/strong>
&lt;ul>
&lt;li>比如查询后代节点树，需要用到递归，要发送多次的请求，与数据库交互多次。&lt;/li>
&lt;li>一般&lt;strong>为了避免递归给数据库发送sql&lt;/strong>，采用&lt;strong>一次性读取整个表&lt;/strong>的数据，然后在应用端构建树的方法。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>查询子树性能不好&lt;/strong>
&lt;ul>
&lt;li>只需要某一个子树，仍然要把整个树加载出来，性能上并不好；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>删除中间节点&lt;/strong>
&lt;ul>
&lt;li>要删除中间层结点时，需要同时删除该节点下的所有节点，否则会出现孤立节点；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>举例&lt;/strong>:&lt;/p>
&lt;p>表结构定义 : model(&lt;strong>id&lt;/strong>,parent_id,description,commander)&lt;/p>
&lt;p>&lt;strong>自顶向下SQL&lt;/strong>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">select level,* from model
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">connect by parent_id = prior.id
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">start with commander = &amp;#34;Root Commander&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>不用connect by时，需要使用with as来递归&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="o">//&lt;/span>&lt;span class="err">定义起点&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">select&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">level&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">from&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">model&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">where&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">commader&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;Root Commander&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="o">//&lt;/span>&lt;span class="err">定义递归体&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">select&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">parant&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">level&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">child&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">child&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">description&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">child&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">commander&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">from&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">query&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">parent&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">model&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">child&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">where&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">child&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">parent_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">parent&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">with&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">recursive_query&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">level&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">description&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">commander&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">as&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">select&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">as&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">level&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">from&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">model&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">where&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">commader&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;Root Commander&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">union&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">all&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">select&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">parant&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">level&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">child&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">child&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">description&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">child&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">commander&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">from&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">recursive_query&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">parent&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">model&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">child&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">where&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">child&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">parent_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">parent&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="o">//&lt;/span>&lt;span class="err">但这是层次遍历&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">select&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">level&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">from&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">recursive_query&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>自底向上SQL&lt;/strong>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">select&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">level&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">from&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">model&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">connect&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">by&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">prior&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">parent_id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">start&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">with&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">description&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">like&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;%Highland%&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="err">无法看到树&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="err">因为无法存储中间结果集&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>物化路径模型&lt;/strong>&lt;/p>
&lt;p>每一个节点都存储节点的&lt;strong>完整路径&lt;/strong>，一般用字符串存，它允许节点之间有顺序.&lt;/p>
&lt;p>每个节点保存的结构信息里包括&lt;/p>
&lt;ul>
&lt;li>祖先各节点的路径&lt;/li>
&lt;li>后代节点路径的一部分&lt;/li>
&lt;li>兄弟节点路径的长度&lt;/li>
&lt;li>节点所在层次等等。&lt;/li>
&lt;/ul>
&lt;p>1代表第一章;&lt;/p>
&lt;p>1.2代表第一章第二节;
1.2.3代表第一章第二节
第三小节。&lt;/p>
&lt;p>&lt;strong>优点：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>性能良好&lt;/strong>，借助了unix文件目录的思想，主要是&lt;strong>以空间换时间&lt;/strong>；&lt;/li>
&lt;li>&lt;strong>可靠性&lt;/strong>（&lt;strong>容易实现&lt;/strong>，不容易出bug）&lt;/li>
&lt;li>&lt;strong>可维护性&lt;/strong>（简单、不需要依赖大量额外的处理逻辑）&lt;/li>
&lt;li>并且通过&lt;strong>比较路径字符串长度&lt;/strong>也容易知道树的深浅&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>缺点：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>不能实现无限深度的树&lt;/strong>，每个节点的子节点数有上限；&lt;/li>
&lt;li>而且深度越大，路径越长，还要解决操作过程中&lt;strong>节点路径的唯一性&lt;/strong>；&lt;/li>
&lt;li>树的深度要自己&lt;strong>写函数计算&lt;/strong>&lt;/li>
&lt;li>&lt;strong>物化路径不应该是KEY&lt;/strong>，即使他们有唯一性，因为主键最好不更新原则。&lt;/li>
&lt;li>数据库&lt;strong>无法确保路径格式正确&lt;/strong>，只能&lt;strong>由应用程序来验证&lt;/strong>&lt;/li>
&lt;li>查询&lt;strong>复杂度主要在路径字符串的处理&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>与邻接模型的差别&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>邻接模型的&lt;strong>子节点是平等&lt;/strong>的,且可以&lt;strong>无限扩展&lt;/strong>。&lt;/li>
&lt;li>物化路径模型可以指出&lt;strong>兄弟的排名&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>影响物化路径模型的因素&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>计算&lt;strong>深度&lt;/strong>
计算两个&lt;strong>字符串函数的差&lt;/strong>，所带来的代价;&lt;/li>
&lt;li>&lt;strong>缩排&lt;/strong>函数
物化路径模型需&lt;strong>不断地处理字符串&lt;/strong>，在where子句中不断的执行字符串操作，处理速度比邻接模型更慢。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>表结构定义&lt;/strong> : model(&lt;strong>path&lt;/strong>,description,commander)&lt;/p>
&lt;p>&lt;strong>自顶向下查询&lt;/strong>:&lt;/p>
&lt;p>自定义函数&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">create&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">function&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">m_depth&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">varchar&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">returns&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">begin&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">length&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">length&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">replace&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="s1">&amp;#39;.&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="s1">&amp;#39;&amp;#39;&lt;/span>&lt;span class="p">))&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">end&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">select&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">lpad&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">description&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="k">length&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">description&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">mp_depth&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="p">))&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">description&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">commander&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">from&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">model&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">model&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">where&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">like&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">||&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;%&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">and&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">commander&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;Root Commander&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">order&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">by&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>自底向上查询&lt;/strong>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">select&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">lpad&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">description&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="k">length&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">description&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">mp_depth&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">mp_depth&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="p">))&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">description&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">commander&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">from&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">model&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">model&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">where&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">like&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">||&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;%&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">and&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">decription&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">like&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;%Highland%&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">order&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">by&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">desc&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>嵌套集合模型&lt;/p>
&lt;ul>
&lt;li>
&lt;p>每一个节点都有一个左编号(left_num)和右编号(right_num)，包含其所有的子节点的左右数字.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>确定这二个值的方法是对树进行一次深度优先遍历，在逐层深入的过程中依次递增地分配left_num的值，并在返回时依次递增地分配right_num的值&lt;/p>
&lt;/li>
&lt;li>
&lt;p>数据元素之间不再是点和线的关系，而是以&lt;strong>容纳和被容纳&lt;/strong>的方式&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>优点：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>易理解&lt;/strong>&lt;/li>
&lt;li>&lt;strong>查找某一个节点的子节点很容易&lt;/strong>，&lt;/li>
&lt;li>删除一个非叶子节点时，它的&lt;strong>后代会自动替代被删除的节点&lt;/strong>，成为其直接祖先节点的直接后代；&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>缺点：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>但是对&lt;strong>结果集排序不好操作&lt;/strong>，缩排无法处理&lt;/li>
&lt;li>数据&lt;strong>更新、插入、删除&lt;/strong>开销大&lt;/li>
&lt;li>&lt;strong>计算量大，对存储程序要求高&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>影响嵌套集合模型性能的因素&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>找后代方面胜于其他两个模型&lt;/strong>，但为&lt;strong>缩排付出更大代价&lt;/strong>&lt;/li>
&lt;li>&lt;strong>额外的连接&lt;/strong>，以及group by所做的&lt;strong>深度&lt;/strong>有关&lt;/li>
&lt;li>&lt;strong>改善嵌套集合模型性能代价巨大,但引入冗余&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>应用场景：&lt;/strong>&lt;/p>
&lt;p>如果&lt;strong>简单快速的查询是最重要的功能&lt;/strong>，那么可以使用嵌套集合。&lt;/p>
&lt;p>然而，在嵌套集中&lt;strong>插入和移动节点是复杂&lt;/strong>的，因为需要&lt;strong>重新分配左右值&lt;/strong>，因此嵌套集不适合需要频繁插入和删除节点的应用场景&lt;/p>
&lt;p>&lt;strong>表结构定义&lt;/strong>: model(&lt;u>left_num&lt;/u>,&lt;u>right_num&lt;/u>,commander,description)&lt;/p>
&lt;p>&lt;strong>自顶向下查询&lt;/strong>:&lt;/p>
&lt;p>找后代直接,找范围就可以. 排序不可以&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">select&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">from&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">model&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">model&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">where&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">commander&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;Root Commander&amp;#34;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">and&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">left_num&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">between&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">left_num&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">and&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">right_num&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>找level,需要再加一个 a b中间加一个c&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">select&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">lpad&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">description&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="k">length&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">description&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">depth&lt;/span>&lt;span class="p">))&lt;/span>&lt;span class="k">from&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">select&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">count&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">left_num&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">depth&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">description&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">commander&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">left_num&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">from&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">model&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">model&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">model&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">c&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">where&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">commander&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;Root Commander&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">and&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">c&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">left_num&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">between&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">left_num&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">and&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">right_num&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">and&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">left_num&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">between&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">c&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">left_num&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">and&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">c&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">right_num&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">group&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">by&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">description&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">commander&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">left_num&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">order&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">by&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">left_num&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>自底向上查询&lt;/strong>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="n">b是a的父亲&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="err">通过&lt;/span>&lt;span class="n">b找包括自己的所有父亲数量来定义深度&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">select&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">lpad&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">description&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">length&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">description&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">6&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">depth&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">commander&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">from&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">select&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">distinct&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">description&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">commander&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">left_num&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">select&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">count&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">c&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">left_num&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">from&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">model&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">c&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">where&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">left_num&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">between&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">c&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">left_num&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">and&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">c&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">right_num&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">depth&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">from&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">model&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">where&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">description&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">like&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;%Highland%&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">and&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">left_num&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">between&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">left_num&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">and&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">right_num&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">and&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">left_num&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">order&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">by&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">left_num&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">desc&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>动态计算深度依旧是个问题·&lt;/li>
&lt;li>不要显示人造根节点&lt;/li>
&lt;li>硬编码最大深度 (为了缩排显示)&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>嵌套间隔模型(nested interval)&lt;/strong>&lt;/p>
&lt;p>思想是以两个数字为特定节点的&lt;strong>路径编码&lt;/strong>，这两个数字被解释成有理数(就是分数)的&lt;strong>分子和分母&lt;/strong>。 太复杂了不讲.&lt;/p>
&lt;p>多父节点模型?&lt;/p>
&lt;p>**闭包表模型：**闭包表是一个简单、优雅模型，它记录了树中所有节点的关系，将树中任何具有祖先与后代关系的节点对，都存储在 TreePaths 中，同时我们也把指向节点自身的关系也存储在这张表；为了方便查询某个节点直接父节点或直接子节点，我们还增加一个 path_length 字段，自我引用的节点该值为 0，直接子节点为 1&lt;/p>
&lt;p>**优点：**它需要一张额外的表来存储关系，是一种典型的采用空间来换时间的方案，查询、插入、删除都比较简单&lt;/p>
&lt;p>&lt;strong>缺点&lt;/strong>：占用太多空间；&lt;/p>
&lt;p>&lt;strong>三种层次模型的查询效率比较&lt;/strong>&lt;/p>
&lt;p>自顶向下查询：Vandamme查询&lt;/p>
&lt;p>效率：邻接模型&amp;gt;物化模型&amp;gt;嵌套集合模型&lt;/p>
&lt;ul>
&lt;li>邻接模型
&lt;ul>
&lt;li>利用了&lt;strong>递归&lt;/strong>&lt;/li>
&lt;li>内部connect by是用&lt;strong>过程化方法&lt;/strong>实现的，&lt;strong>未利用关系模型实现&lt;/strong>。&lt;/li>
&lt;li>是进行&lt;strong>字符比较&lt;/strong>，并且置于内存中进行计算，比较快速;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>物化路径
&lt;ul>
&lt;li>利用&lt;strong>关系模型进行表联接&lt;/strong>，通过字符串前缀比较确定是否是父子关系。&lt;/li>
&lt;li>效率低下的主要原因是&lt;strong>字符串操作，比如字符串拆分&lt;/strong>（物化路径如果解决了用&lt;strong>字符型代替字符串型表示目录时，效率会大大提高&lt;/strong>）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>嵌套模型
&lt;ul>
&lt;li>&lt;strong>虽然找出子节点很容易&lt;/strong>，&lt;/li>
&lt;li>但确定子节点的&lt;strong>深度&lt;/strong>，对子节点&lt;strong>排序&lt;/strong>以及缩排比较&lt;strong>复杂&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>自底向上访问：Highland查询&lt;/p>
&lt;ul>
&lt;li>邻接表模型&lt;/li>
&lt;li>不管是自底向上的查询还是自顶向下查询，效率都是一样的。&lt;/li>
&lt;li>物化路径
&lt;ul>
&lt;li>因为&lt;strong>自底向上需要遍历很多节点&lt;/strong>，而&lt;strong>自顶向下只需要遍历一个节点&lt;/strong>，自底向上查询远远低于自定上下查询&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>嵌套集合模型
&lt;ul>
&lt;li>自顶向下查询与自底向上查询效率&lt;strong>差不多&lt;/strong>&lt;/li>
&lt;li>但多了排序过程，&lt;strong>排序比较耗时&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>效率：邻接模型&amp;gt;物化模型&amp;gt;嵌套集合模型&lt;/p>
&lt;p>&lt;strong>物化路径模型&lt;/strong>是&lt;strong>最通用的最均衡&lt;/strong>的树状结构设计方案&lt;/p>
&lt;p>&lt;strong>自底向上查询慢于自顶向下查询的原因&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>自顶向下查询只有一个起点;,&lt;strong>自底向上查询可能有多个出发点&lt;/strong>。
·多个记录都包含highland查询。&lt;/li>
&lt;li>&lt;strong>不能使用索引&lt;/strong>,导致完整地表扫描&lt;/li>
&lt;/ul>
&lt;h3 id="反范式与打破范式要考虑的因素">反范式与打破范式要考虑的因素&lt;/h3>
&lt;p>&lt;strong>反范式&lt;/strong>: 引入&lt;strong>受控的冗余&lt;/strong>，通过放松规范化规则来&lt;strong>提高系统的性能,降低数据模型的复杂度&lt;/strong>. 通常包括将多个表合并成一个表，增加冗余数据，以及创建复合索引等技术手段。&lt;/p>
&lt;p>&lt;strong>打破范式需要考虑的三因素&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>规范弱化使得&lt;strong>实现变得更加复杂&lt;/strong>，因为需要&lt;strong>手动保持数据的完整性&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>规范弱化会&lt;strong>降低灵活性&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>规范弱化会加快元组检索的速度，但却会&lt;strong>使更新速度变慢&lt;/strong>。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="判断是否应该使用逆范式的条件什么时候可以不遵守范式">&lt;strong>判断是否应该使用逆范式的条件/什么时候可以不遵守范式&lt;/strong>：&lt;/h3>
&lt;ul>
&lt;li>数据&lt;strong>表非常大&lt;/strong>或&lt;strong>查询非常频繁&lt;/strong>，导致查询性能严重下降；
&lt;ul>
&lt;li>大型电商网站, 订单读取非常频繁,把订单和订单详细信息合并提高效率&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>存在大量连接操作&lt;/strong>，导致查询复杂度极高；
&lt;ul>
&lt;li>社交媒体软件,用户的关系复杂. 经常需要使用用户的关系信息.把关系信息合并到用户信息中.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>需要&lt;strong>快速读取大量数据&lt;/strong>，而&lt;strong>不需要强制保证数据的实时性&lt;/strong>；&lt;/li>
&lt;li>&lt;strong>修改频率非常低&lt;/strong>，数据更新的代价相对较小。
&lt;ul>
&lt;li>博客网站,文章和评论都很多时,只需要最新的数据,且不容易修改.&lt;/li>
&lt;li>可以把新的播客信息和评论合并成一个表.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="打破范式的步骤">&lt;strong>打破范式的步骤&lt;/strong>:&lt;/h3>
&lt;ol>
&lt;li>画好ER模型&lt;/li>
&lt;li>分辨一对一、一对多和多对多关系&lt;/li>
&lt;li>构建三范式表结构设计。&lt;/li>
&lt;li>考虑打破范式&lt;/li>
&lt;/ol>
&lt;h3 id="七大反范式pattern">&lt;strong>七大反范式Pattern&lt;/strong>&lt;/h3>
&lt;p>&lt;strong>Pattern 1&lt;/strong> &lt;strong>合并一对一关系&lt;/strong>&lt;/p>
&lt;p>合并：基于全部参与的实体为主，引入部分参与的表。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>会产生大量空值&lt;/p>
&lt;/li>
&lt;li>
&lt;p>若两边都部分参与则不能合并&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>如，将“员工”和“员工地址”表合并为一个表，其中包含员工和他们的地址信息。&lt;/p>
&lt;p>&lt;strong>Pattern 2&lt;/strong> &lt;strong>一对N的关系复制非键值减少连接&lt;/strong>&lt;/p>
&lt;p>适用条件：两表连接时最主要的事务都与某非键值相关&lt;/p>
&lt;ul>
&lt;li>最需要关注更新，可能需要&lt;strong>使用触发器&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>如：查询学生信息以及学生所在学院&lt;/p>
&lt;p>例如，在“订单”和“订单行项目”表之间的一对多关系中，将订单头信息（如客户名称、订单日期等）复制到订单行项目表中。&lt;/p>
&lt;p>&lt;strong>Pattern 3&lt;/strong> &lt;strong>在一对N关系中复制外键来减少JOIN表数量&lt;/strong>&lt;/p>
&lt;p>为减少或删除常用或关键查询的连接，复制关系中一个或多个外键列来提高
查询的效率。&lt;/p>
&lt;p>例如，在“订单”和“订单行项目”表之间的一对多关系中，将订单表的外键（如客户id）复制到订单行项目表中。&lt;/p>
&lt;p>&lt;strong>Pattern 4&lt;/strong> &lt;strong>多对多关系中复制属性来减少JOIN表数量&lt;/strong>&lt;/p>
&lt;p>把两张表中经常需要的属性都拷贝到同一关系表中&lt;/p>
&lt;p>在“学生”和“课程”之间的多对多关系中，将学生和课程的属性（如姓名、课程名称等）复制到“选课”关联表中&lt;/p>
&lt;p>&lt;strong>Pattern 5&lt;/strong> &lt;strong>引入重复组&lt;/strong>&lt;/p>
&lt;p>通常对于一个多值属性，值不太多（小于等于10），且不会经常变，可以在表中见多个有关属性列&lt;/p>
&lt;p>如一个人有地址一、地址二、地址三&lt;/p>
&lt;p>将学生的多个地址存储在一个单一字段中，并将其标记为重复组。&lt;/p>
&lt;p>&lt;strong>Pattern 6&lt;/strong> &lt;strong>建立提取表&lt;/strong>&lt;/p>
&lt;p>将查询慢的表需要连接成大表并储存下来。&lt;/p>
&lt;p>查询可以访问派生数据并在同一组基表上执行多表联接。&lt;/p>
&lt;p>不能做实时计算，得到数据可能是&lt;strong>相对静态&lt;/strong>
的，也可能不一定是最新的。&lt;/p>
&lt;p>好处大，缺点非常大&lt;/p>
&lt;p>带来非常大的复杂性，导致数据库中存在各种同步的、异步的、有用的没用的提取表。
数据更新耗费后续人员极长时间.&lt;/p>
&lt;p>&lt;strong>Pattern 7&lt;/strong> &lt;strong>分区&lt;/strong>&lt;/p>
&lt;p>将大型表分割为更小的逻辑部分，以便更好地管理和查询数据。&lt;/p>
&lt;p>例如，将“销售记录”表分成按日期、地理区域或销售代表等逻辑分区。&lt;/p>
&lt;h3 id="范式的价值或者作用">&lt;strong>范式的价值或者作用&lt;/strong>&lt;/h3>
&lt;p>1NF 每个属性不可再分， 确保&lt;strong>原子性&lt;/strong>，具有原子性的价值&lt;/p>
&lt;p>2NF 主键可以唯一标识记录. 非主属性完全依赖候选键.检查对键的完全依赖，价值在于&lt;strong>控制数据冗余和查询性能&lt;/strong>&lt;/p>
&lt;p>3NF 消除对主属性的传递依赖,非主键属性之间不能相互依赖，检查&lt;strong>属性的独立性&lt;/strong>&lt;/p>
&lt;p>BCNF: 每一个函数依赖的决定因素都包含候选键&lt;/p>
&lt;p>四范式:消除多值依赖.&lt;/p>
&lt;p>所以范式的价值在于：&lt;/p>
&lt;ul>
&lt;li>降低&lt;strong>冗余&lt;/strong>&lt;/li>
&lt;li>消除&lt;strong>操作异常&lt;/strong>&lt;/li>
&lt;li>合理规范化的模式&lt;strong>可应对需求变更&lt;/strong>；&lt;/li>
&lt;/ul>
&lt;h2 id="数据库类型">数据库类型&lt;/h2>
&lt;h3 id="列数据库是什么">&lt;strong>列数据库是什么&lt;/strong>&lt;/h3>
&lt;p>&lt;strong>列数据库&lt;/strong>是将传统的表格形式拆分为单列存储，&lt;strong>存储方式&lt;/strong>是列数据库与传统数据库的最大差别。这个差别同时&lt;strong>带给了列数据库高效的查询性能&lt;/strong>。&lt;/p>
&lt;p>即每一列的数据的存储在一个连续空间的,且有序,因此只要找到了主键在第几个位置,就可以快速找到其他属性的元素.&lt;/p>
&lt;h3 id="redismemcachemongodb特点和区别">&lt;strong>Redis、memcache、mongoDb特点和区别&lt;/strong>&lt;/h3>
&lt;p>&lt;strong>Redis&lt;/strong>&lt;/p>
&lt;p>内存型KV数据库，适合&lt;strong>读多写少&lt;/strong>的业务场景。很适合做缓存。&lt;/p>
&lt;p>优点：&lt;/p>
&lt;ul>
&lt;li>支持&lt;strong>多种数据类型&lt;/strong> string、list、set、zset、hash&lt;/li>
&lt;li>&lt;strong>读写性能优异&lt;/strong>。&lt;/li>
&lt;li>数据可以&lt;strong>持久化&lt;/strong>保持（AOF、快照），写入硬盘，&lt;/li>
&lt;li>支持&lt;strong>灾难恢复，主从复制&lt;/strong>。主机会自动将数据同步到从机，可以进行读写分离。&lt;/li>
&lt;/ul>
&lt;p>缺点：&lt;/p>
&lt;ul>
&lt;li>redis较&lt;strong>难支持在线扩容&lt;/strong>，当集群数据达到上限在线扩容变得复杂。&lt;/li>
&lt;li>&lt;strong>主从宕机&lt;/strong> 会导致前端读写失败，主从数据复制过程中，数据未完全复制到从机，会出现数据不一致。&lt;/li>
&lt;/ul>
&lt;p>应用场景：&lt;/p>
&lt;ul>
&lt;li>在程序和关系型数据库&lt;strong>中间做高速缓存&lt;/strong>&lt;/li>
&lt;li>缓存&lt;strong>高频数据,降低IO次数&lt;/strong>&lt;/li>
&lt;li>分布式架构中做&lt;strong>session共享&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>例子：&lt;/p>
&lt;ul>
&lt;li>比如微信token每两小时刷新一次，就比较适合用redis存储，读也比较方便；&lt;/li>
&lt;li>在线游戏排行榜；计时达到一定时间后显示相关广告；按照用户投票和时间排序，更新新闻；&lt;/li>
&lt;li>统计在某段特点时间里有多少特定用户访问了某个特定资源，统计哪些特定用户访问了某篇的文章；&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Memcache&lt;/strong>&lt;/p>
&lt;p>高性能的&lt;strong>分布式内存对象缓存&lt;/strong>系统，基于一个&lt;strong>存储键/值对&lt;/strong>的hashmap&lt;/p>
&lt;p>优点, 基于其&lt;strong>分布式特性&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>均衡请求&lt;/strong>&lt;/li>
&lt;li>增加&lt;strong>缓存容量&lt;/strong>&lt;/li>
&lt;li>&lt;strong>部分容灾&lt;/strong>:多台MC服务器使用哈希一致性算法,当有一台挂掉时,能保留部分请求.&lt;/li>
&lt;/ul>
&lt;p>缺点&lt;/p>
&lt;ul>
&lt;li>只支持&lt;strong>简单的key/value数据&lt;/strong>结构，不像Redis可以支持丰富的数据类型。&lt;/li>
&lt;li>&lt;strong>无法进行持久化&lt;/strong>，数据不能备份，只能用于缓存使用，且重启后数据全部丢失。&lt;/li>
&lt;/ul>
&lt;p>应用场景：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>分布式缓存&lt;/strong>&lt;/li>
&lt;li>数据库前段缓存&lt;/li>
&lt;li>服务器间数据共享&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>MongoDB&lt;/strong>&lt;/p>
&lt;p>是&lt;strong>文档型&lt;/strong>的非关系型数据库，使用&lt;strong>json结构&lt;/strong>。&lt;/p>
&lt;p>优点&lt;/p>
&lt;ul>
&lt;li>&lt;strong>查询功能&lt;/strong>强大：json文档结构的存储方式，能够更便捷的获取数据&lt;/li>
&lt;li>能存储&lt;strong>海量数据&lt;/strong>&lt;/li>
&lt;li>&lt;strong>海量数据下性能优越&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>缺点&lt;/p>
&lt;ul>
&lt;li>占用&lt;strong>内存过大&lt;/strong> 。&lt;/li>
&lt;li>&lt;strong>不支持事务&lt;/strong>。&lt;/li>
&lt;li>模式自由,自由灵活的文件存储&lt;strong>格式带来的数据错误&lt;/strong>&lt;/li>
&lt;li>MongoDB没有成熟的&lt;strong>维护工具&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>应用场景:&lt;/p>
&lt;ul>
&lt;li>存放&lt;strong>评论等半结构化数据&lt;/strong>&lt;/li>
&lt;li>适合&lt;strong>存储json&lt;/strong>类型数据&lt;/li>
&lt;li>&lt;strong>不经常变化&lt;/strong>,朋友圈,日志,直播礼物&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>应用场景&lt;/strong>&lt;/p>
&lt;p>redis: 数据量较&lt;strong>小的更性能操作和运算&lt;/strong>上。&lt;/p>
&lt;p>memcache: 用于在&lt;strong>动态系统中减少数据库负载&lt;/strong>，提升性能;做缓存，提高性能（适合读多写少，对于数据量比较大，可以采用sharding）。&lt;/p>
&lt;p>MongoDB:主要解决&lt;strong>海量数据的访问效率&lt;/strong>问题。&lt;/p>
&lt;h3 id="数据仓库">&lt;strong>数据仓库&lt;/strong>&lt;/h3>
&lt;p>主要功能是 将OLTP经年累月所累积的大量数据，通过&lt;strong>数据仓库特有的数据储存架构进行 OLAP&lt;/strong>，最终帮助决策者能快速有效地从大量数据中，分析出有价值的信息，提供决策支持. &lt;strong>仍然是结构化数据&lt;/strong>&lt;/p>
&lt;p>与数据库的区别: 数据库面向的是OLTP.，数据仓库面向OLAP&lt;/p>
&lt;p>数据仓库是一个用以更好地支持企业决策分析处理的、面向主题的、集成的、不可更新的、随时间不断变化的数据集合&lt;/p>
&lt;ul>
&lt;li>&lt;strong>面向主题&lt;/strong>：主题是个抽象的概念，是&lt;strong>在较高层次上将企业信息系统中的数据综合、归类并进行分析利用&lt;/strong>的抽象，比如对于商场而言，主题就包括供应商、商品、顾客等&lt;/li>
&lt;li>&lt;strong>集成&lt;/strong>的：数据仓库的数据是&lt;strong>从原有分散的数据库数据中抽取的&lt;/strong>，因此数据在进入前必然经过加工与集成，同一与综合&lt;/li>
&lt;li>&lt;strong>不可更新&lt;/strong>的：所涉及的数据操作主要是数据查询，一般不会修改操作&lt;/li>
&lt;li>随&lt;strong>时间变化&lt;/strong>：不可更新是指数据仓库的&lt;strong>用户&lt;/strong>进行分析处理是&lt;strong>不进行数据更新操作&lt;/strong>的，但不代表数据仓库的&lt;strong>整个生存周期中数据集合&lt;/strong>是不变的&lt;/li>
&lt;/ul>
&lt;h3 id="数据湖">&lt;strong>数据湖&lt;/strong>:&lt;/h3>
&lt;p>企业希望把**所有数据(结构化与非结构化)**都完整保存下来，进行有效管理与集中治理，挖掘和探索数据价值。&lt;/p>
&lt;p>数据湖是一个集中存储各类&lt;strong>结构化和非结构化&lt;/strong>数据的大型数据仓库，它可以存储来自&lt;strong>多个数据源、多种数据类型&lt;/strong>的&lt;strong>原始数据&lt;/strong>，数据&lt;strong>无需经过结构化处理&lt;/strong>，就可以进行存取、处理、分析和传输。&lt;/p>
&lt;p>对于数据仓库与数据湖的不同之处，可以类比为仓库和湖泊的区别：仓库存储着来自特定来源的货物；而湖泊的水来自河流、溪流和其他来源，&lt;strong>并且是原始数据&lt;/strong>。&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E6%88%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E6%88%98/</guid><description>&lt;h1 id="实践">实践&lt;/h1>
&lt;p>数据库最大表&lt;/p>
&lt;p>深分页&lt;/p>
&lt;h1 id="数据库优化">数据库优化&lt;/h1>
&lt;p>优化思路：&lt;/p>
&lt;ol>
&lt;li>索引&lt;/li>
&lt;li>执行计划(查询优化)&lt;/li>
&lt;li>SQL优化&lt;/li>
&lt;li>分库分表&lt;/li>
&lt;li>数据库设计&lt;/li>
&lt;/ol>
&lt;h2 id="布隆过滤器">布隆过滤器&lt;/h2>
&lt;h2 id="sql优化">SQL优化&lt;/h2>
&lt;h3 id="sql中使用绑定变量的优点与缺点">&lt;strong>Sql中使用绑定变量的优点与缺点&lt;/strong>&lt;/h3>
&lt;p>&lt;strong>绑定变量实质就是变量&lt;/strong>。类似于我们是用过的替代变量（占位符）。就是在sql语句中使用变量，通过改变变量的值来得到不同的结果。&lt;/p>
&lt;p>sql语句是分为动态部分和静态部分的。而动态部分在一般的情况下，对执行计划的影响是微乎其微的。&lt;/p>
&lt;p>&lt;strong>同一个sql语句有不同动态部分生成的执行计划是相同的。&lt;/strong>&lt;/p>
&lt;p>优点：&lt;/p>
&lt;ul>
&lt;li>使用动态绑定，可以&lt;strong>减少sql的解析&lt;/strong>，从而减少了数据库引擎在sql解析上资源的消耗。&lt;/li>
&lt;li>提高了&lt;strong>执行效率和可靠性&lt;/strong>。减少对数据库的访问实际上就是减少了数据库的工作量&lt;/li>
&lt;/ul>
&lt;p>缺点：&lt;/p>
&lt;ul>
&lt;li>可能长时间使用动态sql，由于参数的不同。可能sql的&lt;strong>执行效率不同&lt;/strong>；&lt;/li>
&lt;li>&lt;strong>使用不当会有安全问题 sql注入&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h3 id="实现数据安全性控制的常用方法和技术">&lt;strong>实现数据安全性控制的常用方法和技术&lt;/strong>&lt;/h3>
&lt;p>数据库管理系统提供的安全措施主要包括&lt;/p>
&lt;ul>
&lt;li>用户&lt;strong>身份鉴别&lt;/strong>&lt;/li>
&lt;li>自主存取控制 Discretionary Access Control&lt;/li>
&lt;li>强制存取控制 Mandatory Access Control&lt;/li>
&lt;li>&lt;strong>视图&lt;/strong>机制&lt;/li>
&lt;li>&lt;strong>审计&lt;/strong>&lt;/li>
&lt;li>数据&lt;strong>加密&lt;/strong>存储和加密传输等&lt;/li>
&lt;/ul>
&lt;h3 id="登记日志的原则运行记录优先原则是什么为什么">&lt;strong>登记日志的原则（运行记录优先原则）是什么，为什么&lt;/strong>&lt;/h3>
&lt;p>&lt;strong>运行记录优先原则&lt;/strong>:&lt;/p>
&lt;ol>
&lt;li>&lt;strong>登记的次序严格按并发事务执行的时间次序&lt;/strong>&lt;/li>
&lt;li>必须&lt;strong>先写日志文件，后写数据库&lt;/strong>&lt;/li>
&lt;/ol>
&lt;p>如果先写了数据库修改，而在运行记录中没有登记下这个修改，则以后就&lt;strong>无法恢复这个修改&lt;/strong>了。&lt;/p>
&lt;p>如果先写日志，但没有修改数据库，按日志文件恢复时只不过是多执行一次&lt;strong>不必要的UNDO操作&lt;/strong>，并&lt;strong>不会影响数据库的正确性&lt;/strong>。&lt;/p>
&lt;p>所以为了安全，一定要先写日志文件，即首先把日志记录写到日志文件中，然后写数据库的修改。这就是**“先写日志文件”的原则**&lt;/p>
&lt;h3 id="sql-语句的执行过程并简单对各个步骤的所花费的代价大小进行描述和比较">SQL 语句的执行过程，并简单对各个步骤的所花费的代价大小进行描述和比较。&lt;/h3>
&lt;ol>
&lt;li>语法分析：确保语句的正确性和有效性。代价很小，语法分析器已预先定义了所有合法的 SQL 语法。&lt;/li>
&lt;li>语义分析：需要检查语句中的&lt;strong>对象是否存在&lt;/strong>、&lt;strong>用户是否有访问权限&lt;/strong>等信息。代价比语法分析高一些。&lt;/li>
&lt;li>解析（软解析和硬解析）：将 SQL 语句转换成执行计划，比语义分析高。需要进行语法转换、查询优化等复杂操作。
&lt;ol>
&lt;li>在软解析过程中，DBMS 会查找已经编译好的执行计划缓存，如果找到了对应的执行计划就直接使用.&lt;/li>
&lt;li>否则会进行硬解析，生成新的执行计划，此时代价最大。&lt;/li>
&lt;li>执行计划生成：生成最优的执行计划，以最小化查询的代价。代价最高，需要进行大量的计算和查询优化。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>查询执行：按照执行计划执行查询，并从磁盘中读取数据、对数据进行排序、过滤和聚合等操作，可能还需要进行大量的磁盘和内存交换。代价取决于查询本身的复杂度以及所涉及的数据量。&lt;/li>
&lt;/ol>
&lt;p>综合来看，SQL 语句的执行过程中，查询优化和查询执行往往是代价最大的两个步骤。在实际应用中，可以通过&lt;strong>优化查询语句的结构&lt;/strong>、&lt;strong>创建合适的索引&lt;/strong>、&lt;strong>优化查询计划&lt;/strong>等手段来提高查询性能，从而减少查询优化和查询执行所需的代价。&lt;/p>
&lt;h3 id="sql-优化原理是什么优化的逻辑是怎样的对此经验之谈">&lt;strong>SQL 优化原理是什么？优化的逻辑是怎样的？对此经验之谈&lt;/strong>&lt;/h3>
&lt;p>SQL 优化的原理：&lt;/p>
&lt;ul>
&lt;li>通过&lt;strong>优化查询的执行计划&lt;/strong>&lt;/li>
&lt;li>&lt;strong>减少查询的时间和资源消耗&lt;/strong>&lt;/li>
&lt;li>提高数据库系统的&lt;strong>性能&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>SQL 优化的逻辑一般可以分为以下几个步骤：&lt;/p>
&lt;ol>
&lt;li>优化&lt;strong>查询语句&lt;/strong>：对查询语句进行优化，包括&lt;strong>重写查询语句&lt;/strong>、&lt;strong>使用索引&lt;/strong>、&lt;strong>避免全表扫描&lt;/strong>等。&lt;/li>
&lt;li>优化&lt;strong>数据库结构&lt;/strong>：根据业务需求优化数据库中表的&lt;strong>结构、索引、分区&lt;/strong>等，以提高查询和更新操作的性能。&lt;/li>
&lt;li>优化&lt;strong>硬件环境&lt;/strong>：优化数据库所在的硬件环境，包括 CPU、内存、磁盘、网络等，以提高数据库系统的整体性能。&lt;/li>
&lt;/ol>
&lt;p>对于 SQL 优化的经验之谈，以下是一些常见的建议：&lt;/p>
&lt;ol>
&lt;li>将&lt;strong>过滤条件进行排序&lt;/strong>,好的过滤条件先做&lt;/li>
&lt;li>使用&lt;strong>join来暗示表连接顺序&lt;/strong>，当有多表连接操作时，考虑使用&lt;strong>exists和in操作来优化&lt;/strong>&lt;/li>
&lt;li>&lt;strong>避免过度连接表&lt;/strong>，将多维度的查询进行降维处理，一次连接的表不要超过3张，超过就将非关联子查询变成内嵌视图。
&lt;ul>
&lt;li>聚合子查询转化为JOIN&lt;/li>
&lt;li>非关联子查询变成内嵌视图&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>避免在高层使用distinct&lt;/strong>，用exists和in来处理&lt;/li>
&lt;li>*&lt;em>避免在高层使用select &lt;em>&lt;strong>, 这样会产生&lt;/strong>冗余的结果集，降低性能&lt;/em>&lt;/em>&lt;/li>
&lt;li>&lt;strong>不要滥用子查询&lt;/strong>. 子查询有如下好处,除这些好处外,不要用
&lt;ol>
&lt;li>分辨过滤条件的好坏&lt;/li>
&lt;li>避免顶层的distinct&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>总之，SQL 优化需要根据具体的情况进行分析和优化，需要综合考虑查询的复杂度、数据的规模和类型、硬件环境等因素。&lt;/p>
&lt;h3 id="sql有什么优化策略从硬件系统应用上分析">&lt;strong>SQL有什么优化策略，从硬件、系统、应用上分析&lt;/strong>&lt;/h3>
&lt;p>这个优化法则归纳为5个层次：&lt;/p>
&lt;ul>
&lt;li>减少数据访问（&lt;strong>减少磁盘访问&lt;/strong>）系统上
&lt;ul>
&lt;li>正确使用&lt;strong>索引&lt;/strong>&lt;/li>
&lt;li>&lt;strong>优化执行计划&lt;/strong>&lt;/li>
&lt;li>尽量使用&lt;strong>自带函数&lt;/strong>,慎用自定义函数.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>减少服务器CPU开销（&lt;strong>减少CPU&lt;/strong>及内存开销）
&lt;ul>
&lt;li>使用&lt;strong>绑定变量&lt;/strong>&lt;/li>
&lt;li>合理使用&lt;strong>排序&lt;/strong>&lt;/li>
&lt;li>减少&lt;strong>模糊查找&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>返回&lt;strong>更少数据&lt;/strong>（减少网络传输或磁盘访问）应用上
&lt;ul>
&lt;li>数据&lt;strong>分页&lt;/strong>处理&lt;/li>
&lt;li>返回&lt;strong>只需要的字段&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>减少交互次数（减少网络传输）应用上
&lt;ul>
&lt;li>一次连接批量处理数据&lt;/li>
&lt;li>使用存储过程.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>利用更多资源（硬件上）
&lt;ul>
&lt;li>扩大内存&lt;/li>
&lt;li>增加CPU&lt;/li>
&lt;li>更快的硬盘&lt;/li>
&lt;li>更高速的网络&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="请描述oracle中iot的物理存储结构和读取数据的方式并与堆文件的物理存储结构和读取数据的方式进行比较后解释iot的适用范围">&lt;strong>请描述Oracle中IOT的物理存储结构和读取数据的方式，并与堆文件的物理存储结构和读取数据的方式进行比较后解释IOT的适用范围。&lt;/strong>&lt;/h3>
&lt;p>IOT（&lt;strong>Index-Organized&lt;/strong> Table）索引组织表 是一种基于B+树的索引类型，它的索引键包括表的主键和数据列。IOT的数据访问和索引访问是一体化的。&lt;/p>
&lt;p>IOT通常用于&lt;strong>需要频繁地使用主键查询&lt;/strong>的表，因为IOT将主键值和对应的数据行存储在同一个B+树节点中，可以减少磁盘I/O操作的次数，从而提高查询性能。&lt;/p>
&lt;p>与堆文件的存储结构相比。&lt;/p>
&lt;ul>
&lt;li>堆文件的存储是&lt;strong>随机存储&lt;/strong>的，而IOT使用的B树结构是&lt;strong>根据主键按照一定顺序存储&lt;/strong>的。&lt;/li>
&lt;li>堆文件的读取是需要&lt;strong>遍历整个堆文件数据&lt;/strong>的，而IOT则可以&lt;strong>通过主键的信息&lt;/strong>快速定位到相关节点，读取数据。&lt;/li>
&lt;/ul>
&lt;p>IOT适用范围：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>主键很少更新&lt;/strong>。因为主键更新会导致B树结构的重新调整。&lt;/li>
&lt;li>&lt;strong>多用主键查询&lt;/strong>。因为IOT是以主键为节点构造B树的，以主键信息查询能较快找到对应节点。&lt;/li>
&lt;li>&lt;strong>很少插入新数据&lt;/strong>。插入新数据会导致B树重新调整。&lt;/li>
&lt;li>希望数据已某种特定的&lt;strong>顺序物理存储&lt;/strong>，那也适合用IOT&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>IOT的优点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>记录排序&lt;/strong>，查询效率贼强&lt;/li>
&lt;li>&lt;strong>节约磁盘空间开销&lt;/strong>，主键没有空间开销，索引就是数据&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>IOT缺点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>插入效率也许低于堆文件&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对于&lt;strong>经常更新的表不适合用IOT&lt;/strong>，因为维护的索引代价大，更何况是多字段索引&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="分库分表">分库分表&lt;/h2>
&lt;p>分库 就是将数据库中的数据分散到不同的数据库上，可以垂直分库，也可以水平分库。
分表 就是将数据库中的数据分散到不同的表上，可以垂直分表，也可以水平分表。&lt;/p>
&lt;h3 id="分区的作用与类型">分区的作用与类型&lt;/h3>
&lt;p>&lt;strong>分区的作用&lt;/strong>: 提高&lt;strong>并发性和并行性&lt;/strong>，从而增强系统架构的&lt;strong>可伸缩性&lt;/strong>&lt;/p>
&lt;p>&lt;strong>分区的类型&lt;/strong>（不一定是方式）&lt;/p>
&lt;p>循环分区：&lt;strong>不受数据影响&lt;/strong>的内部机制。分区定义为各个磁盘的存储区域；可以看作是随意散布数据的机制；保持更改带来的磁盘I/O操作的平衡&lt;/p>
&lt;p>数据驱动分区：根据**一个或多个字段中的值(分区键)**来定义分区。是一种手工分区，一般叫分区视图.&lt;/p>
&lt;h3 id="数据驱动分区的实现方式">&lt;strong>数据驱动分区的实现方式&lt;/strong>&lt;/h3>
&lt;p>&lt;strong>哈希分区(Hash-partitioning)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>对&lt;strong>分区键进行哈希运算&lt;/strong>，根据运算结果进行分区.&lt;/li>
&lt;li>能保证&lt;strong>根据分区键可以快速找到记录&lt;/strong>，但对范围搜索没有任何帮助。&lt;/li>
&lt;li>其实更接近与循环分区, 只是它还能&lt;strong>负载均衡提高并发&lt;/strong>的能力.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>范围分区(Range- partitioning)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>滑动窗口，就是范围分区，&lt;strong>根据连续数据的范围&lt;/strong>对数据进行分区。&lt;/li>
&lt;li>&lt;strong>非常适合处理历史数据&lt;/strong>，每一个分区专门用来存储&lt;strong>特定范围内的数据&lt;/strong>。&lt;/li>
&lt;li>一般系统还会设定&lt;strong>else分区&lt;/strong>,来存储所有&lt;strong>可能漏网的数据&lt;/strong>(其他)&lt;/li>
&lt;li>应用: 时间范围, 字母范围&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>列表分区(List-partitioning)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>是一种最具手工风格的分区类型，适合&lt;strong>定制某种特殊的解决方案&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>分区键必须明确指定&lt;/strong>，但&lt;strong>分区键只能有一列&lt;/strong>，不能像范围或者哈希分区那样同时指定多个列做为分区键，但它的&lt;strong>单个分区对应值可以是多个&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>一旦插入的列值不在分区范围内，则插入/更新就会失败.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>因此
通常建议使用列表分区时，要创建一个&lt;strong>default分区&lt;/strong>存储那些&lt;strong>不在指定列表内的记录&lt;/strong>。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>复合分区&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>很多数据库中分区可以嵌套，即分区可以再建立子分区，叫sub partition.子分区是分区内的分区。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>一种二位分区处理的方法，比如在时间的分区中，建立哈希分区,范围-哈希分区、范围-列表分区等&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>OB把它叫做二级分区&lt;/strong>，再举个例子，&lt;strong>类似于用户账单领域，会按照user id做哈希分区，按照账单创建时间做范围分区&lt;/strong>。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>数据驱动的分区是最常使用的分区方式，用数据值本身作为分区的基础，这时候&lt;strong>数据分区最具有开发使用的价值&lt;/strong>。&lt;/p>
&lt;h3 id="分区是如何提高查询效率">&lt;strong>分区是如何提高查询效率&lt;/strong>&lt;/h3>
&lt;p>分区后，逻辑上表仍然是一张完整的表，只是将表中的数据在物理上存放到多个表空间（物理文件上），利于高速检索，&lt;strong>查询数据时，不至于每次都扫描整张表&lt;/strong>.&lt;/p>
&lt;h3 id="分区的优点和缺点">&lt;strong>分区的优点和缺点&lt;/strong>&lt;/h3>
&lt;p>&lt;strong>优点&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>增强&lt;strong>可用性&lt;/strong>：如果表的某个分区出现故障，表在其他分区的数据仍然可用；&lt;/li>
&lt;li>&lt;strong>维护&lt;/strong>方便：如果表的某个分区出现故障，需要修复数据，只修复该分区即可；&lt;/li>
&lt;li>&lt;strong>均衡I/O&lt;/strong>：可以把不同的分区映射到磁盘以平衡I/O，改善整个系统性能；&lt;/li>
&lt;li>改善&lt;strong>查询性能&lt;/strong>：对分区对象的查询可以仅搜索自己关心的分区，提高检索速度。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>缺点&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>除了堆文件之外的任何存储方法，都会&lt;strong>带来复杂性&lt;/strong>&lt;/li>
&lt;li>&lt;strong>选错存储方式&lt;/strong>会带来大幅度的性能降低&lt;/li>
&lt;li>降低了并发个数，但如果&lt;strong>涉及数据量非常庞大&lt;/strong>，&lt;strong>降低并发所带来的缺陷远远小于分区所带来的性能提高&lt;/strong>&lt;/li>
&lt;li>由于&lt;strong>强制的部分数据聚合&lt;/strong>可能会&lt;strong>导致其他数据的分散&lt;/strong>，所以不同的查询请求也可能会形成性能上的矛盾&lt;/li>
&lt;/ul>
&lt;h3 id="数据分区的最佳方法">&lt;strong>数据分区的最佳方法&lt;/strong>&lt;/h3>
&lt;ul>
&lt;li>当&lt;strong>数据分区键均匀分布时&lt;/strong>，分区表查询收益最大&lt;/li>
&lt;li>&lt;strong>避免更新分区键&lt;/strong>, 更新分区键会影响数据移动&lt;/li>
&lt;li>&lt;strong>不在更新数据频繁时使用分区&lt;/strong>.&lt;/li>
&lt;li>&lt;strong>考虑整体&lt;/strong>,当有多个处理执行时，解决方案就不应该过度偏袒其中任何一个&lt;/li>
&lt;/ul></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/sql%E5%AE%9E%E4%BE%8B%E8%A7%A3%E6%9E%90%E4%B8%8E%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/sql%E5%AE%9E%E4%BE%8B%E8%A7%A3%E6%9E%90%E4%B8%8E%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F/</guid><description>&lt;p>示例表：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230309100013301.png" alt="image-20230309100013301" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h2 id="1sql实例处理字符串">1.SQL实例处理：字符串&lt;/h2>
&lt;p>SQL不专门用于处理复杂的字符串，但内置了很多有用的字符串。&lt;/p>
&lt;h3 id="11遍历字符串">1.1遍历字符串&lt;/h3>
&lt;p>SQL没有Loop功能, 需要使用数据透视表&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227163824652.png" alt="image-20230227163824652" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>循环的次数是字符串的长度, 用where来终止.&lt;/p>
&lt;h3 id="12嵌入引号">1.2嵌入引号&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227163859353.png" alt="image-20230227163859353" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="13统计字符出现的次数">1.3统计字符出现的次数&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227163927154.png" alt="image-20230227163927154" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>sql server 是用len&lt;/p>
&lt;h3 id="14删除不想要的字符">1.4删除不想要的字符&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227164016283.png" alt="image-20230227164016283" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>替换多个字符时可以使用: &lt;strong>translate&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227164049652.png" alt="image-20230227164049652" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>先全部一致替换为a,再把a给删除.&lt;/p>
&lt;p>但mysql中没有translate.&lt;/p>
&lt;p>阿里的OceanBase同时支持replace和translate&lt;/p>
&lt;h3 id="15判断是否只含有字母和数字">1.5判断是否只含有字母和数字&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227164123913.png" alt="image-20230227164123913" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>Mysql可以直接使用正则表达式. [] 内表示范围 ^ 表示否定&lt;/p>
&lt;p>OceanBase 的0 1相反&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230309101159648.png" alt="image-20230309101159648" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>思考题&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227164306073.png" alt="image-20230227164306073" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>​&lt;/p>
&lt;h2 id="2sql实例解析-数值处理">2.SQL实例解析 数值处理&lt;/h2>
&lt;p>虽然SQL不容易处理，但硬要在SQL中完成比如字符串，比如日期，比如今天的数值计算。&lt;/p>
&lt;p>数值处理在数据库完成，可以减少数据库和服务器的交互。&lt;/p>
&lt;p>能在数据库中，写个&lt;strong>完整功能的SQL&lt;/strong>，让查询优化器统一优化，一般来说对整个系统的吞吐量会有非常大的提升.&lt;/p>
&lt;h3 id="21计算平均值">2.1计算平均值&lt;/h3>
&lt;p>空值默认是忽略&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227164534143.png" alt="image-20230227164534143" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>coalesce 空值设置为0&lt;/strong>&lt;/p>
&lt;p>当使用聚合函数时通常要考虑空值的处理.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227164603887.png" alt="image-20230227164603887" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>不能把group by 子句中没有的列放到select语句中.&lt;/p>
&lt;h3 id="22查找最大值和最小值">2.2查找最大值和最小值&lt;/h3>
&lt;p>空值没有影响.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227164620369.png" alt="image-20230227164620369" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="23求和">2.3求和&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227164639158.png" alt="image-20230227164639158" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="24计算行数">2.4计算行数&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227164719491.png" alt="image-20230227164719491" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>count(*)计算了空值.&lt;/strong>&lt;/p>
&lt;p>&lt;strong>针对某一列时会跳过空值&lt;/strong>&lt;/p>
&lt;h3 id="25累计求和-running-total">2.5累计求和 Running Total&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227164847493.png" alt="image-20230227164847493" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>Sum( ) over ()&lt;/p>
&lt;p>over 中的 order by 需要具有唯一性.&lt;/p>
&lt;p>否则, WARD 会和 MARTIN一样是5350&lt;/p>
&lt;p>即建立&lt;strong>唯一的排他序列得到正确的累加值&lt;/strong>.&lt;/p>
&lt;p>在以前的mysql不支持窗口函数,所以要使用标量子查询.&lt;/p>
&lt;h3 id="26计算众数">2.6计算众数&lt;/h3>
&lt;p>oracle 使用 max + keep&lt;/p>
&lt;p>如果max相同,则按照keep中的排序规则保留其最大的.&lt;/p>
&lt;p>keep从右向左执行, 先对每一个cnt降序排序,然后执行rank函数,保留rank1的值.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227164934043.png" alt="image-20230227164934043" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>mysql只能用通用做法.group by + having&lt;/p>
&lt;p>思考题:&lt;/p>
&lt;p>累计乘法和累计减法&lt;/p>
&lt;h2 id="3sql实例分析-日期处理">3.SQL实例分析 日期处理&lt;/h2>
&lt;h3 id="31日期加减法">3.1日期加减法&lt;/h3>
&lt;p>Oracle中，对天数来说，对天数来说可以直接加减，如果要加减若干月或者年，需要用一个函数，add months.&lt;/p>
&lt;p>MySQL日期加减法类似，使用&lt;strong>INTERVAL关键字&lt;/strong>指定要加上或者减去时间
的单位，不必使用单引号。
第二种方法: 使用date add函数，一样的作用。&lt;/p>
&lt;p>OceanBase的add和mysql一模一样&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230309103225068.png" alt="image-20230309103225068" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="32计算两个日期之间的天数">3.2计算两个日期之间的天数&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227165217187.png" alt="image-20230227165217187" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>mysql 和 OceanBase datediff(较晚的日期,较早的日期)&lt;/p>
&lt;p>sql server 是datediff(较早的,较晚的)&lt;/p>
&lt;h3 id="33两个日期的工作日天数">3.3两个日期的工作日天数&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227165324649.png" alt="image-20230227165324649" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>这样统计天数就变成了计算行数的问题.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230309103757837.png" alt="image-20230309103757837" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>1.计算出开始日期和结束日期之间相隔多少天。 x视图&lt;/p>
&lt;p>2.排除掉周末，统计有多少个工作日，计算满足条件的记录。&lt;/p>
&lt;p>Oracle 和 mysql的差异是函数使用的不同.&lt;/p>
&lt;h3 id="34判断闰年">3.4判断闰年&lt;/h3>
&lt;p>判断闰年的最简单方式&lt;/p>
&lt;p>检查2月份最后一天，如
果是29号，就是闰年;如
果是28号，就不是闰年;
如果既不是28号，也不是
29号，程序写错。&lt;/p>
&lt;p>orcale 有trunc函数找到&lt;strong>当前年份的第一天&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230309104059402.png" alt="image-20230309104059402" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>先算出当前日期是当前年份的第几天, 找到当前年的第一天.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227165617940.png" alt="image-20230227165617940" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="35识别重叠的日期区间">3.5识别重叠的日期区间&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227165658575.png" alt="image-20230227165658575" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>自连接方法, 复制出另一份表,然后找到重叠的项目&lt;/p>
&lt;p>窗口比自联结快,但需要限定项目的个数.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227165731407.png" alt="image-20230227165731407" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>思考题: 当前月份的第一个和最后一个星期一&lt;/p>
&lt;h2 id="4常见的sql连接模式">4.常见的SQL连接模式&lt;/h2>
&lt;p>查询有时候并不只需要等值连接.&lt;/p>
&lt;p>4.1叠加行集(Union &amp;amp;Union all)&lt;/p>
&lt;p>4.2查找只存在于一张表的数据 (差)&lt;/p>
&lt;p>4.3从一个表检索另一个不相关的行(外连接&lt;/p>
&lt;p>4.4从多个表中返回缺失值 (全外连接)&lt;/p>
&lt;p>4.5连接与聚合函数的使用&lt;/p>
&lt;h3 id="41叠加行集union--union-all">4.1叠加行集(Union &amp;amp; Union all)&lt;/h3>
&lt;p>使用连接的情况，就是想返回保存至多个表中的数据
理论上需要将一个结果集叠加到另一个之上，甚至这些表&lt;strong>可以没有相同的键&lt;/strong>，有一个前提条件是，它们&lt;strong>列的数据类型必须相同&lt;/strong>。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227165935617.png" alt="image-20230227165935617" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>Union all是将多个表中的行并入结果集. 列的数目和类型必须匹配,名字可以不一样. Union all 会包括重复项, union会去除重复项.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227170009502.png" alt="image-20230227170009502" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>union的问题 : &lt;strong>有排序操作&lt;/strong>以删除重复项,慎用.&lt;/p>
&lt;p>排序是非关系操作,大数据量的排序对性能是一个灾难.&lt;/p>
&lt;h3 id="42查找只存在于一张表的数据差">4.2查找只存在于一张表的数据(差)&lt;/h3>
&lt;p>使用差函数, 但不同数据库的差函数关键字不一样.&lt;/p>
&lt;p>minus限制条件, 列必须相同个数和数据类型,且不返回重复值. 空值不问产生任何问题.&lt;/p>
&lt;p>except 对结果进行去重.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227170147073.png" alt="image-20230227170147073" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>使用not in时用空值的问题,一遍要加上exists 或 not exists&lt;/p>
&lt;h3 id="43从一个表检索另一个不相关的行外连接">4.3从一个表检索另一个不相关的行(外连接)&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227170229988.png" alt="image-20230227170229988" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>outer可写可不写&lt;/p>
&lt;h3 id="44从多个表中返回每个表的缺失值全外连接">4.4从多个表中返回每个表的缺失值(全外连接)&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227170250386.png" alt="image-20230227170250386" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="45连接与聚合函数的使用">4.5连接与聚合函数的使用&lt;/h3>
&lt;p>确保表之间的连接查询不会干扰到聚合操作.&lt;/p>
&lt;p>左边是员工奖金表,&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227170339432.png" alt="image-20230227170339432" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>奖金总额正确,但工资总额是错的.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230309105955183.png" alt="image-20230309105955183" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>是因为连接查询导致某行的工资出现两次.&lt;/p>
&lt;p>解决方法, 使用distinct.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227170437389.png" alt="image-20230227170437389" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>如果表中, 部门编号为10的人只有部分人有奖金.此时计算总额会少算.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227170454013.png" alt="image-20230227170454013" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>提示: 需要选择连接方式.用&lt;strong>外连接把员工全包括&lt;/strong>.&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/sql%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/sql%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/</guid><description>&lt;p>4.1关系代数&lt;/p>
&lt;p>4.2查询优化器&lt;/p>
&lt;p>4.3使用SQL需要考虑的因素&lt;/p>
&lt;p>4.4查询的过滤条件&lt;/p>
&lt;p>4.5高效过滤条件举例&lt;/p>
&lt;p>4.6 SQL优化的其它问题-where子的比较运算符&lt;/p>
&lt;p>4.7 SQL优化的其它问题-SQL连接&lt;/p>
&lt;h2 id="1关系代数">1.关系代数&lt;/h2>
&lt;p>代数的作用： 表达式的等价代换&lt;/p>
&lt;p>2、3、4 这些数字对应的就是 关系(表)&lt;/p>
&lt;p>+-x/这些运算符对应的就是 关系操作&lt;/p>
&lt;p>SQL语句的本质是关系表达式&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309153407418.png" alt="image-20230309153407418" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>查询优化器 的作用 ： 就是在数据库中间进行关系表达式等价变化后找到最优路径&lt;/p>
&lt;p>关系代数是&lt;strong>以数学为基础&lt;/strong>的，是一个科学
在写代码时，像一个工匠。
关系数据库不一样，写的SQL只是向数据库提出取什么样数据的要求，具体怎么找到最快速的执行方式，是数据库的查询优化器的事情。&lt;/p>
&lt;p>关系数据库还有一个科学的地方，它&lt;strong>存在简单模式，实现冗余最小的设计&lt;/strong>。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>没有简单通用的规则，实现数据库冗余最小。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>windows的资源管理器的目录结构、XML这种树形结构，这种文件组织方式是最习惯但不科学的&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>no sql 是 not only sql&lt;/p>
&lt;h2 id="2查询优化器">2.查询优化器&lt;/h2>
&lt;p>&lt;strong>sql 关系理论 查询优化器的关系&lt;/strong>：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309153946870.png" alt="image-20230309153946870" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>关系理论适用于理论意义上无限大的集合。&lt;/p>
&lt;p>在不同大小的数据集在不同物理环境中间，如何实现更有效率地读取，&lt;strong>将无限收缩到有限的环境中&lt;/strong>，这就是查询优化器干的事情。&lt;/p>
&lt;p>优化器借助关系理论提供的&lt;strong>语义无误的原始查询进行有效的等价变换&lt;/strong>。&lt;/p>
&lt;p>优化器的工作：&lt;/p>
&lt;ul>
&lt;li>优化是在数据真正要被执行的时候才发生的;&lt;/li>
&lt;li>有相同结果，但写法不同的关系表达式在实际环境下执行的效率相差很大:&lt;/li>
&lt;li>OceanBase的查询优化则是一个&lt;strong>规则优化和代价优化相结合&lt;/strong>的过程，其主体是基于成本进行查询优化，并在查询优化过程中通过规则进行启发和剪枝。
&lt;ul>
&lt;li>以前更多是基于规则的优化器 RBO, 现在大多数用的是基于成本的优化器 CBO&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>sql的执行顺序&lt;/strong>&lt;/p>
&lt;p>&lt;strong>解析是SQL优化是最消耗资源的过程.&lt;/strong>&lt;/p>
&lt;p>从解析中选择执行计划&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309155255554.png" alt="image-20230309155255554" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;ul>
&lt;li>你的&lt;strong>SQL仍然是它优化的起点&lt;/strong>，是它选择优化路径的提示，不同的SQL写法，会对查询优化器最终选择的路径产生影响。&lt;/li>
&lt;li>查询优化器不知道一些&lt;strong>影响实际执行效率的重要的信息&lt;/strong>，而这只有写SOL的程序员知道。&lt;/li>
&lt;/ul>
&lt;h3 id="21查看查询优化器的执行计划">2.1查看查询优化器的执行计划&lt;/h3>
&lt;p>&lt;strong>Oracle的执行计划&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309155531599.png" alt="image-20230309155531599" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>在使用explain plan for语句时，跟在后面的SQL并不真正执行，执行计划表中的数据和操作都是预估的，&lt;/p>
&lt;p>好处是，方便快捷，不影响数据库数据.&lt;/p>
&lt;p>缺点是，没有输出相关统计信息。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309155611613.png" alt="image-20230309155611613" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>MySql的执行计划&lt;/strong>:&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309155731369.png" alt="image-20230309155731369" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>第七列key:实际使用的索引;&lt;/p>
&lt;p>第十列rows:估算的找到所需数据需读取的行数:&lt;/p>
&lt;p>第十一列filtered:返回结果的行数占读取行数的百分比，值越大越好:&lt;/p>
&lt;p>&lt;strong>OceanBase的执行计划&lt;/strong>:&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309155810560.png" alt="image-20230309155810560" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="22查询优化器的有效范围">2.2查询优化器的有效范围&lt;/h3>
&lt;ol>
&lt;li>&lt;strong>1优化器需要借助数据库中找到的信息&lt;/strong>。&lt;/li>
&lt;/ol>
&lt;p>一是&lt;strong>普通统计数据&lt;/strong>，二是数据定义中重要的&lt;strong>声明信息&lt;/strong>&lt;/p>
&lt;p>尽量要把数据约束的语义信息在&lt;strong>数据库的声明中体现&lt;/strong>，这样优化器就可以利用数据取值范围这样的语义信息来做优化决策.&lt;/p>
&lt;ol start="2">
&lt;li>
&lt;p>只有能够进行数学意义上的&lt;strong>等价变换&lt;/strong>，优化效果才最佳。&lt;/p>
&lt;p>对于查询中的非关系部分优化器可借助的理论基础不多，优化结果和原始语句写法所指定的方式相差无几&lt;/p>
&lt;/li>
&lt;li>
&lt;p>一个独立执行的查询，优化效果可能很好，但把它嵌入一个更为复杂的查询内部，可能优化的效果就变差了&lt;/p>
&lt;p>优化器需要考虑&lt;strong>整体响应时间&lt;/strong>&lt;/p>
&lt;p>&lt;strong>预计需要查询越久的,查询优化器会花更多的时间去找优化路径.&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>优化器改善的是&lt;strong>独立查询&lt;/strong>&lt;/p>
&lt;p>优化器无法使独立的查询联系在一起进行统一优化，所以，如果通过过程化的编程提取了数据，再将数据传递到后续查询中，优化器是没有办法进行统一优化的&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="3使用sql需要考虑的因素">3.使用SQL需要考虑的因素&lt;/h2>
&lt;p>需要考虑的五大要素:&lt;/p>
&lt;ul>
&lt;li>获得结果集所需访问的数据量&lt;/li>
&lt;li>定义结果集所需的查询条件&lt;/li>
&lt;li>结果集的大小获得&lt;/li>
&lt;li>结果集所涉及的表的数量&lt;/li>
&lt;li>同时修改这些数据用户的多少&lt;/li>
&lt;/ul>
&lt;h3 id="31数据总量">3.1数据总量&lt;/h3>
&lt;p>SQL考虑&lt;strong>最重要因素:必须访问的数据总量&lt;/strong>&lt;/p>
&lt;p>没有&lt;strong>确定目标数据容量&lt;/strong>之前，很难断定查询执行的效率,这是后续所有工作的基础.&lt;/p>
&lt;h3 id="32定义结果集的查询条件">3.2定义结果集的查询条件&lt;/h3>
&lt;p>一个或几个数据表，经过Join操作，再通过查询条件的选择，会产生一个SQL查询的结果集，完成我们的查询。&lt;/p>
&lt;p>&lt;strong>从数据表到 结果集 发生的变化就是 查询条件&lt;/strong>&lt;/p>
&lt;p>查询条件是SQL优化的关键因素，也是写SQL的重要部分&lt;/p>
&lt;p>过滤条件的效率有高有低，受到其它因素的影响很大&lt;/p>
&lt;p>如果一个查询条件能剔除掉更多的数据，也就是满足这个查询条件的记录数很少，我们就称之为&lt;strong>高效的过滤条件&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>寻找高效的过滤条件是程序员写SQL需要重点考虑的问题&lt;/strong>&lt;/p>
&lt;h3 id="33结果集的大小">3.3结果集的大小&lt;/h3>
&lt;p>查询所返回的数据量，重要而被忽略&lt;/p>
&lt;p>取决于表的大小和&lt;strong>过滤条件的细节&lt;/strong>&lt;/p>
&lt;p>例外是 若干个&lt;strong>独立使用效率不高的条件结合起来效率非常高&lt;/strong>, 如双学位&lt;/p>
&lt;p>从技术角度来看，查询结果集的&lt;strong>大小并不重要&lt;/strong>，&lt;strong>重要的是用户的感觉&lt;/strong>&lt;/p>
&lt;p>熟练的开发者应该努力使&lt;strong>响应时间与返回的记录数成正比&lt;/strong>.&lt;/p>
&lt;h3 id="34表的数量">3.4表的数量&lt;/h3>
&lt;p>from中间连接表的数量对性能有很大影响,尽管现在的DBMS都可以高效地连接多个表.&lt;/p>
&lt;p>表的 join连接&lt;/p>
&lt;ul>
&lt;li>(太)多表连接该质疑设计的正确性了&lt;/li>
&lt;li>对于&lt;strong>优化器&lt;/strong>，随着表数量的增加，复杂度将呈指数增长&lt;/li>
&lt;li>编写 (太)多表的复杂查询时，&lt;strong>多种方式连接的选择失误的几率很高&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>在一个查询中间, 避免连接太多的表&lt;/p>
&lt;h3 id="35并发用户数">3.5并发用户数&lt;/h3>
&lt;p>设计sql时,随时&lt;strong>要关注并发性&lt;/strong>, 并发量大会导致原先并发量小时效率高的设计变得极低.&lt;/p>
&lt;ul>
&lt;li>数据块访问争用(block-accesscontention)&lt;/li>
&lt;li>阻塞(locking)&lt;/li>
&lt;li>闩定(latching)&lt;/li>
&lt;li>保证读取一致性(read consistency)&lt;/li>
&lt;/ul>
&lt;p>警惕多米诺骨牌一样的现象, 如内存不够用导致硬盘资源争夺, 进而导致其他cpu负载过重.&lt;/p>
&lt;p>也会有反例:&lt;/p>
&lt;p>DBA增加物理I/0操作，反而会使任务执行效率更高，因为某些计算密集型操作的并发执行程度很高，一个进程刚刚因等待I/O操作而阻塞，它释放出来的CPU就被另一个进程占用了，这样CPU的资源反而被充分利用了。&lt;/p>
&lt;p>必须要&lt;strong>考虑整体吞吐量,而不是个人响应时间&lt;/strong>.&lt;/p>
&lt;h2 id="4查询的过滤条件">4.查询的过滤条件&lt;/h2>
&lt;h3 id="41过滤条件的分类">4.1过滤条件的分类&lt;/h3>
&lt;p>如何限定结果集是最为关键的因素.&lt;/p>
&lt;p>过滤条件主要是指Where子句中的各种各样的条件 也包括having&lt;/p>
&lt;p>有些过滤条件直接作用于select运算符. 如某字段是否满足条件.&lt;/p>
&lt;p>还有其他用于连接表的. 可以分成如下两种:&lt;/p>
&lt;ul>
&lt;li>Join过滤条件&lt;/li>
&lt;li>Select过滤条件&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309162132327.png" alt="image-20230309162132327" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>不一定哪个效率快, 运行效率和优化器有关系，不同的写法首先是影响了优化器&lt;strong>进行路径选择的起始点&lt;/strong>.&lt;/p>
&lt;p>在没有效率问题的情况下，SQL的写法无关紧要，但是在&lt;strong>有效率问题的情况下，SQL的写法就会导致效率有很大差别。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>其他类型的条件&lt;/strong>:&lt;/p>
&lt;p>检查另一个表内是否存在特定数据的条件&lt;/p>
&lt;p>sql语法上类似,但语义上完全不同.&lt;/p>
&lt;h3 id="42过滤条件的含义">4.2过滤条件的含义&lt;/h3>
&lt;p>过滤条件的计算顺序有时候会影响效率.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309162532396.png" alt="image-20230309162532396" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>此时计算顺序无关紧要,但再加入一个条件:&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309162644909.png" alt="image-20230309162644909" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>在有些数据库中，试图把非数字字符串转化为整数的时候，会造成运行错误的问题.&lt;/p>
&lt;p>一般来说，数据库有一个基本的原则，就是对于where子句的条件如果优化器在优化的过程中没有什么理由和原因的话，一般是&lt;strong>按照顺序执行的&lt;/strong>&lt;/p>
&lt;p>&lt;strong>mysql是从左到右, Oracle 是从右到左.&lt;/strong>&lt;/p>
&lt;p>where&lt;strong>的顺序是很重要的&lt;/strong>&lt;/p>
&lt;h3 id="43基本原则">4.3基本原则&lt;/h3>
&lt;p>好的过滤条件要先做&lt;/p>
&lt;p>能过滤掉更多数据的条件也就是满足这个条件的记录越少，这个条件越好&lt;/p>
&lt;p>因为中间结果集的大小会不一样, 会影响性能.&lt;/p>
&lt;p>在复杂的高并发大数据量的系统中，一个查询的执行计划往往要做很多步骤，&lt;strong>中间结果集的大小&lt;/strong>，会从整体上影响整个系统的吞吐量中间结果集过大，会对缓存、硬盘、CPU都造成压力。&lt;/p>
&lt;p>更重要的是，哪个过滤条件好，哪个过滤条件坏，查询优化器不一定知道，这是只有知道业务需求的程序员才知道的事情。&lt;/p>
&lt;p>写SQL前要对过滤条件排序，去寻找高效的过滤条件&lt;/p>
&lt;p>真正高效的过滤条件是查询的主要驱动力，低效条件只是为了业务要求的正确性对高效的过滤条件起到辅助筛选的作用。&lt;/p>
&lt;p>定义高效过滤条件的准则:是否能够尽快减少必须处理的数据总量&lt;/p>
&lt;p>思考题:你能列举出哪些where字句中用于过滤的关键字呢?&lt;/p>
&lt;h2 id="5高效过滤条件的举例">5.高效过滤条件的举例&lt;/h2>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309163212559.png" alt="image-20230309163212559" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309163223970.png" alt="image-20230309163223970" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>和join on指定的条件相关,也和过滤条件的顺序相关.&lt;/p>
&lt;p>古老的方式:&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309163403832.png" alt="image-20230309163403832" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>没有适用于所有情况的解决方案.&lt;/p>
&lt;p>但上面的用了distinct,会把同名的人给合并.&lt;/p>
&lt;p>避免在最高层distinct应该是一条基本规则; 因为即便遗漏了连接的条件,仍然会正常允许.&lt;/p>
&lt;p>现实中,应该返回具有唯一性的客户ID和客户名，以保证得到BMW买家的完整清单&lt;/p>
&lt;p>&lt;strong>摆脱distinct的方法&lt;/strong>&lt;/p>
&lt;p>&lt;strong>关联子查询&lt;/strong>:&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309163645545.png" alt="image-20230309163645545" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>缺点, 子查询执行很多次. 取决于 第一个过滤条件的好坏.&lt;/p>
&lt;p>&lt;strong>非关联子查询&lt;/strong>:&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309163825049.png" alt="image-20230309163825049" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>找到分辨率最强的条件&lt;/p>
&lt;ul>
&lt;li>解决方案不止一种，查询和数据隐含的假设密切相关&lt;/li>
&lt;li>预先考虑优化器的工作，以确定它能找到所需要的数据&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309163932229.png" alt="image-20230309163932229" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h2 id="6sql优化的其他问题">6.SQL优化的其他问题&lt;/h2>
&lt;h3 id="61sql的连接问题">6.1SQL的连接问题&lt;/h3>
&lt;p>第一个问题是&lt;strong>滥用子查询&lt;/strong>,&lt;/p>
&lt;p>子查询有两个好处:&lt;/p>
&lt;ul>
&lt;li>分辨过滤条件的好坏&lt;/li>
&lt;li>避免顶层的distinct&lt;/li>
&lt;/ul>
&lt;p>但如果没有以上两个好处,不如把选择权交给查询优化器.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309164152188.png" alt="image-20230309164152188" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>但还有一种情况,&lt;strong>杜绝使用子查询&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309164315664.png" alt="image-20230309164315664" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>以上方法性能很差.,因为是要选择没有分配的.&lt;/p>
&lt;p>应该用out join&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309164344992.png" alt="image-20230309164344992" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="把聚合子查询转化为join或内嵌视图">把聚合子查询转化为JOIN或内嵌视图&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309164543277.png" alt="image-20230309164543277" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309164638238.png" alt="image-20230309164638238" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>上面orderstatus被访问了多次&lt;/p>
&lt;p>可以做成非关联嵌套子查询&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309164738725.png" alt="image-20230309164738725" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>但性能还有问题.&lt;/p>
&lt;p>要告诉优化器,先获得子查询的结果集再连接这个表.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309164849679.png" alt="image-20230309164849679" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>最好是使用内嵌的视图.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309164936407.png" alt="image-20230309164936407" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>虽然做了一次大表遍历,但省了连接.&lt;/p>
&lt;p>但如果状态很多,还需要用OLAP或者SQL引擎来进行优化.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309165102184.png" alt="image-20230309165102184" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">select&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">from&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">select&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">max&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">totalitems&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">as&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">mx&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">custid&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">from&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">orders&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">group&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">by&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">custid&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">o1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">join&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">orders&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">o2&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">where&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">o1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">mx&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">o2&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">totalitems&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">and&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">o1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">custid&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">o2&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">custid&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%A4%84%E7%90%86%E5%8F%8A%E5%8F%8D%E8%8C%83%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%A4%84%E7%90%86%E5%8F%8A%E5%8F%8D%E8%8C%83%E5%BC%8F/</guid><description>&lt;p>数据库表结构设计&lt;/p>
&lt;ul>
&lt;li>不同设计对相同的查询会产生什么样不同的效率影响。&lt;/li>
&lt;li>打破范式可以提高效率.&lt;/li>
&lt;/ul>
&lt;h2 id="1处理层次结构">1.处理层次结构&lt;/h2>
&lt;p>以人类最熟悉的数据存储组织的方式最早出现
层次数据库存储数据存在一种逻辑嵌套，不是一种对数据的线性排列. 后续还出现了多重层次连接的网状数据库.&lt;/p>
&lt;p>直到关系理论出现, 使得操控的灵活性，数据的组织，以及数据访问的效率上，找到了一个非常好的平衡&lt;/p>
&lt;p>但层次组织数据的方式还是有很多的使用. 如:XML,LDAP都是基于树状结构的层次组织.&lt;/p>
&lt;p>&lt;strong>层次结构复杂的原因&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>访问数据的方式，本质是一个访问树的方式，需要访问树的全部或者
部分节点。&lt;/li>
&lt;li>通常需要按照访问顺序返回这些数据.&lt;/li>
&lt;li>&lt;strong>过程化的访问方式，是违背关系理论&lt;/strong>的，造成了一种&lt;strong>mismatch&lt;/strong>。&lt;/li>
&lt;li>在关系结构中，构建层次数据的存储和访问都很困难。&lt;/li>
&lt;/ul>
&lt;p>树状结构有三种表结构的设计方式，都是满足三范式三种完全不同的设计方式&lt;/p>
&lt;h3 id="11邻接模型">1.1邻接模型&lt;/h3>
&lt;p>层次中父记录ID作为子记录(childrow) 的一个属性，树中两个相邻的节点&lt;/p>
&lt;p>因而被明确关联在一一起。&lt;/p>
&lt;p>设计直观简单,但会导致&lt;strong>递归的查询&lt;/strong>。&lt;/p>
&lt;h3 id="12物化路径模型">1.2物化路径模型&lt;/h3>
&lt;p>把树中的每个节点、与它
在树中的位置的描述数据相结合。&lt;/p>
&lt;p>1代表第一章;&lt;/p>
&lt;ol>
&lt;li>2代表第一章第二节;
1.2.3代表第一章第二节
第三小节。&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>与邻接模型的差别&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>邻接模型的子节点是平等的&lt;/li>
&lt;li>物化路径模型可以指出&lt;strong>兄弟的排名&lt;/strong>。&lt;/li>
&lt;li>且可以无限扩展,扩展很多层。&lt;/li>
&lt;/ul>
&lt;h3 id="13嵌套集合模型">1.3嵌套集合模型&lt;/h3>
&lt;p>每个节点被赋予了一对数字，其中父节点的两个数字包含其所有的子节点的左右数字，然后一层一层
这样包含下去。&lt;/p>
&lt;h3 id="14嵌套间隔模型nested-interval">1.4嵌套间隔模型(nested interval)&lt;/h3>
&lt;p>思想是以两个数字为特定节点的&lt;strong>路径编码&lt;/strong>，这两个数字被解释成有理数(就是分数)的&lt;strong>分子和分母&lt;/strong>。 太复杂了不讲.&lt;/p>
&lt;h3 id="15树状结构的三种方式访问的比较">1.5树状结构的三种方式访问的比较&lt;/h3>
&lt;p>例子 &lt;strong>军队结构&lt;/strong>.&lt;/p>
&lt;p>&lt;strong>邻接模型&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230309190604145.png" alt="image-20230309190604145" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230227192057736.png" alt="image-20230227192057736" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>物化路径模型&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230309190631784.png" alt="image-20230309190631784" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230227192122633.png" alt="image-20230227192122633" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>嵌套集合模型&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230227192142928.png" alt="image-20230227192142928" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>特征:节点[left_num,right_num]值必定介于其任一个祖先的[left_num,right_num]值之间，这就是“嵌套集合”的由来。(nested set)&lt;/p>
&lt;p>叶子结点即right_num = left_num + 1&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230227192211959.png" alt="image-20230227192211959" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h2 id="2层次结构的自顶向下查询">2.层次结构的自顶向下查询&lt;/h2>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230227192330951.png" alt="image-20230227192330951" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230309190847607.png" alt="image-20230309190847607" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>以下用oracle&lt;/p>
&lt;h3 id="邻接模型">邻接模型&lt;/h3>
&lt;p>oracle专有关键词：ocean base也支持&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230309190953499.png" alt="image-20230309190953499" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>使用了虚拟的level字段。&lt;/p>
&lt;p>不用connect by时，需要使用with as来递归&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230309191109258.png" alt="image-20230309191109258" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230309191120429.png" alt="image-20230309191120429" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230227192536512.png" alt="image-20230227192536512" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>with as 实现。但是层次遍历，不是深度优先遍历。&lt;/p>
&lt;p>需要&lt;strong>定义层次&lt;/strong>来进行重新的排序。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230309191243402.png" alt="image-20230309191243402" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>便捷的方法是用connectted by&lt;/p>
&lt;p>&lt;strong>mysql的问题&lt;/strong>&lt;/p>
&lt;p>MySQL8.0添加了CTE支持with as&lt;/p>
&lt;p>8.0之前版本;两个方法手动union在一个查询中多次连接&lt;/p>
&lt;h3 id="物化路径模型">物化路径模型&lt;/h3>
&lt;ul>
&lt;li>查询编写不困难&lt;/li>
&lt;li>计算由路径导出的&lt;/li>
&lt;li>层次不方便假设&lt;/li>
&lt;li>mp_depth(函数返回当前节点深度) 用字符串处理&amp;quot;.&amp;quot;&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230227192847984.png" alt="image-20230227192847984" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="嵌套集合模型">嵌套集合模型&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230309191511744.png" alt="image-20230309191511744" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>兄弟节点要排序就很复杂。&lt;/p>
&lt;p>计算节点数量无法从leftnum和right_num导出.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230309191542150.png" alt="image-20230309191542150" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="比较性能的方法">比较性能的方法&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230227193009108.png" alt="image-20230227193009108" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>影响物化路径模型的因素&lt;/strong>&lt;/p>
&lt;p>1.计算深度
计算两个字符串函数的差，所带来的代价;&lt;/p>
&lt;p>2.缩排函数
物化路径模型需&lt;strong>不断地处理字符串&lt;/strong>，在where子句中不断的执行字符
串操作，处理速度比邻接模型更慢。&lt;/p>
&lt;p>&lt;strong>嵌套集合模型&lt;/strong>&lt;/p>
&lt;p>找后代方面胜于其他两个模型，但为&lt;strong>缩排&lt;/strong>付出更大代价;&lt;/p>
&lt;p>性能的降低和额外连接，以及group by所做的深度有关&lt;/p>
&lt;p>改善嵌套集合模型性能,其代价巨大&lt;/p>
&lt;h2 id="5自底向上的查询-hightland查询">5.自底向上的查询 Hightland查询&lt;/h2>
&lt;p>&lt;strong>自底向上查询的特点&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>自顶向下查询只有一个起点; 而自底向上查询&lt;strong>可能有多个出发点&lt;/strong>。
·多个记录都包含highland查询。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在description字段中查找“Highland”字符,
必然&lt;strong>导致完整表扫描&lt;/strong>.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>自底向上查询效率慢于自顶向下查询&lt;/strong>&lt;/p>
&lt;h3 id="51邻接模型">5.1邻接模型&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230309192326051.png" alt="image-20230309192326051" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>connect by 不是关系操作, 是基于过程的关键词,&lt;strong>不存储中间结果集&lt;/strong>,&lt;/p>
&lt;h3 id="52物化路径模型">5.2物化路径模型&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230309192441538.png" alt="image-20230309192441538" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>重复项和记录顺序的问题的解决方式&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230309192517555.png" alt="image-20230309192517555" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>另一种方式把节点的物化路径分解成路径列表，即列转行的方式.&lt;/p>
&lt;p>树状结构表增加到千行以上，like比较方法性能风险可能会大大提升&lt;/p>
&lt;h3 id="53嵌套集合查询">5.3嵌套集合查询&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230227193634675.png" alt="image-20230227193634675" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="54比较效率">5.4比较效率&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230227193659877.png" alt="image-20230227193659877" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>结果 connect by 查询效果依旧卓越.&lt;/p>
&lt;p>物化路径和嵌套集合模型都只有邻接模型的一半的效率。&lt;/p>
&lt;ul>
&lt;li>物化路径不该是主键，即使它们有唯一性。字符串不适合做主键且主键最好不要更新.&lt;/li>
&lt;li>所选择的编码方式不需要完全中立
&lt;ul>
&lt;li>F.3.1.1 变成 F030101&lt;/li>
&lt;li>但这种方法不通用.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="4聚合来自树的值">4.聚合来自树的值&lt;/h2>
&lt;p>一.对保存于&lt;strong>叶节点中的值做聚合&lt;/strong>; 简单的树,单一父节点&lt;/p>
&lt;p>二.计算某个值散布在树中各层次的百分比。&lt;/p>
&lt;h3 id="41第一个查询">4.1第一个查询&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230309193055261.png" alt="image-20230309193055261" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>对于邻接模型&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230227194121906.png" alt="image-20230227194121906" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>对于物化路径模型&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230309193243048.png" alt="image-20230309193243048" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>性能差异&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230309193319263.png" alt="image-20230309193319263" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="42第二个问题-多父节点时无法在一张表中解决">4.2第二个问题 多父节点时,无法在一张表中解决&lt;/h3>
&lt;p>邻接模型和物化路径模型设计仍然存在局限性;&lt;/p>
&lt;p>物料单位问题 BOM问题&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230227194421886.png" alt="image-20230227194421886" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>出现的问题&lt;/strong>:&lt;/p>
&lt;p>一、龙蛋壳成分有多个父
节点，5号魔药和9号基础魔药都是它的父亲节点。&lt;/p>
&lt;p>二、计算龙蛋壳在5号魔
药中占比，不仅要计算5号魔药本身的龙蛋壳的百
分比，还要加上9号魔药
中龙蛋壳的含量。&lt;/p>
&lt;p>&lt;strong>解决方案:&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230227194512062.png" alt="image-20230227194512062" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>一个components包含多个composition，一个处方，也包含多个composition。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230309193629175.png" alt="image-20230309193629175" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>用with as 做递归&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230309193641103.png" alt="image-20230309193641103" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="43树状结构问题">4.3树状结构问题&lt;/h3>
&lt;p>关系型数据库非常难处理树状结构&lt;/p>
&lt;p>因为性能非常差，处理层次型数据很困难。
SQL缺乏处理树结构的
强大的、可伸缩的手段。&lt;/p>
&lt;p>不同的表结构设计，在相同的查询下，性能也会差距甚大.&lt;/p>
&lt;p>不建议对关系模型不建议对屡遭诟病的缓慢本性 反规范化，这很容易遮掩程序设计中的问题&lt;/p>
&lt;h2 id="5对冗余的控制反范式">5.对冗余的控制（反范式）&lt;/h2>
&lt;h3 id="51范式的概念">5.1范式的概念&lt;/h3>
&lt;p>1NF:一个字段，只有一
个值。&lt;/p>
&lt;p>2NF:一条记录，可以被唯一的主键所区分，是一个实体有唯一的标识。&lt;/p>
&lt;p>3NF :字段和字段之间不存在函数依赖。&lt;/p>
&lt;p>设置范式的原因： &lt;strong>控制冗余&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>如果一个值，在关系型数据库中存在多个地方，那么他们应该一起被修改，否则数据完整性就没有办法保障了&lt;/li>
&lt;li>但数据访问压力大，需从数据库设计入手，通过打破三范式提高数据库访问的性能。&lt;/li>
&lt;/ul>
&lt;p>打破范式的根本逻辑在于&lt;strong>降低表连接数量&lt;/strong>。
提升了查询效率，降低了SQL优化器的优化难度。&lt;/p>
&lt;h3 id="52第一范式">5.2第一范式&lt;/h3>
&lt;p>含义：一个字段只有一个值;
不仅仅是存储的要求，也同样是&lt;strong>使用的要求&lt;/strong>。&lt;/p>
&lt;p>满足一范式的本质:把这个字段&lt;strong>只当成一个值&lt;/strong>来使用，不能拆散使用。&lt;/p>
&lt;p>如：身份证号码不和 生日 产生依赖。&lt;/p>
&lt;p>&lt;strong>判断三范式&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>一个字段的全部，不能和其它字段产生函数依赖。&lt;/li>
&lt;li>而不是一个字段的一-部分是不是和其它字段产生函数依赖。&lt;/li>
&lt;li>任何拆分字段的使用方式，本质上都是打破了一范式。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>三范式的实践基础&lt;/strong>&lt;/p>
&lt;p>一个字段只当成一个值使用。
生日和年龄是函数依赖关系，身份证号码和生日在实践意义上并不构成函数依赖。&lt;/p>
&lt;h3 id="53打破范式的本质">5.3打破范式的本质&lt;/h3>
&lt;p>引入&lt;strong>受控的冗余&lt;/strong>，确定是否通过放松规范化规则来提高系统的性能。&lt;/p>
&lt;p>规范化的结果是一个结构上拥有&lt;strong>一致且最少冗余&lt;/strong>的逻辑数据库设计。&lt;/p>
&lt;p>有必要放弃完全规范化而得到某些性能上的好处。&lt;/p>
&lt;p>&lt;strong>一旦打破范式需要考虑的三因素&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>规范弱化使得&lt;strong>实现变得更加复杂&lt;/strong>，因为需要&lt;strong>手动保持数据的完整性&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>规范弱化会&lt;strong>降低灵活性&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>规范弱化会加快元组检索的速度，但却会&lt;strong>使更新速度变慢&lt;/strong>。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>通常的经验&lt;/strong>：&lt;/p>
&lt;p>80%的性能问题来自于开发和对数据库的使用不当，&lt;/p>
&lt;p>&lt;strong>但如果系统具有低修改性和高查询率，规范弱化可能是提高数据库&lt;/strong>
&lt;strong>查询效率一种可行的选择。&lt;/strong>&lt;/p>
&lt;p>用复制的方式打破范式，比如将某些属性或者将某些关系连
接起来，以&lt;strong>减少执行查询时所需要的连接操作&lt;/strong>。&lt;/p>
&lt;p>规范弱化取决于系统具体情况。&lt;/p>
&lt;h3 id="规范弱化模式">规范弱化模式&lt;/h3>
&lt;p>了解打破范式的几种手段，按照相应模式需求，构建手动的方式保证数据的完整性&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230227195347207.png" alt="image-20230227195347207" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>打破范式的步骤：&lt;/p>
&lt;p>画好ER模型→分辨一对一、一对多和多对多关系→构建三范式表结构设计。&lt;/p>
&lt;h2 id="6反范式的实现">6.反范式的实现&lt;/h2>
&lt;h3 id="61合并一对一关系">6.1合并一对一关系&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230309194735438.png" alt="image-20230309194735438" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>合并：基于全部参与的实体为主，引入部分参与的表。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230227195601373.png" alt="image-20230227195601373" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>产生空值。&lt;/p>
&lt;h3 id="62复制一对多关系中的非键列来减少连接">6.2复制一对多关系中的非键列来减少连接&lt;/h3>
&lt;p>在子表中复制一个或更多的&lt;strong>父表中非键列来减少或删除链接&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230227195721370.png" alt="image-20230227195721370" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>此时最需要关注更新，可能需要&lt;strong>使用触发器&lt;/strong>。&lt;/p>
&lt;h3 id="3复制一对多关系中的外键列来减少连接">3.复制一对多关系中的外键列来减少连接&lt;/h3>
&lt;p>为减少或删除常用或关键查询的连接，复制关系中一个或多个外键列来提高
查询的效率。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230309194939656.png" alt="image-20230309194939656" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230227195815024.png" alt="image-20230227195815024" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="64复制多对多的列">6.4复制多对多的列&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230227195834238.png" alt="image-20230227195834238" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="65引入重复组">6.5引入重复组&lt;/h3>
&lt;p>重复组：一组地址，一组电话号码，用户有多个。&lt;/p>
&lt;p>满足范式要求:单独建一张地址或者电话的表，做连接查询。&lt;/p>
&lt;p>打破方法：&lt;/p>
&lt;ul>
&lt;li>把重复组全部打包放在主表中，增加n列
&lt;ul>
&lt;li>1)重复组的绝对数量是已知的&lt;/li>
&lt;li>2该数量是静态的，不会改变&lt;/li>
&lt;li>
&lt;ol start="3">
&lt;li>该数量并不是很大，通常不大于10&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>主表中存储缺省的电话和地址，所有地址和电话都单独存在地址表和电
话表中。
&lt;ul>
&lt;li>大部分查询，只需要缺省值。&lt;/li>
&lt;li>优点:通用性和效率都可以达到很好的平衡&lt;/li>
&lt;li>缺点：需要在UI中分开&lt;/li>
&lt;li>缺省值的读取和全部值的读取都在不同页面。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="66创建提取表">6.6创建提取表&lt;/h3>
&lt;p>将查询慢需要的表连接成
大表并储存下来。&lt;/p>
&lt;p>查询可以访问派生数据并
在同一组基表上执行多表联接。&lt;/p>
&lt;p>不能做实时计算，得到数据可能是&lt;strong>相对静态&lt;/strong>
的，也可能不一定是最新的。&lt;/p>
&lt;p>好处大，缺点非常大&lt;/p>
&lt;p>带来非常大的复杂性，导致数据库中存在各种同步的、异步的、有用的没用的提取表。
数据更新耗费后续人员极长时间&lt;/p>
&lt;h3 id="67关于打破范式">6.7关于打破范式&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230227200214330.png" alt="image-20230227200214330" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>受控的冗余引入，冗余不可怕，但需要受控。&lt;/p>
&lt;h3 id="68总结">6.8总结&lt;/h3>
&lt;p>四个角度讨论查询优化的问题：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230309195507718.png" alt="image-20230309195507718" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E9%97%AE%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E9%97%AE%E9%A2%98/</guid><description>&lt;h2 id="1黑盒问题">1.黑盒问题&lt;/h2>
&lt;p>不能当作黑盒。&lt;/p>
&lt;p>因为数据库其实不存在独立性。&lt;/p>
&lt;h3 id="11体系结构的巨大差异">1.1体系结构的巨大差异&lt;/h3>
&lt;p>会导致数据库的连接，数据库并发处理等差异&lt;/p>
&lt;p>数据库迁移会出现很多问题。&lt;/p>
&lt;h3 id="12黑盒与数据库独立性的问题">1.2黑盒与数据库独立性的问题&lt;/h3>
&lt;p>数据库有脱离实现级别的使用方法。&lt;/p>
&lt;ul>
&lt;li>要构建一个完全的数据库独立应用，而且是高度可扩展的应用是极其-
&lt;ul>
&lt;li>困难不依赖于任何一个数据库，既可在Oracle上运行，也可在MySQL上运行实际上几乎不可能&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>要构建一个完全独立的数据库应用:
&lt;ul>
&lt;li>必须真正了解每个数据库具体如何工作&lt;/li>
&lt;li>如果清楚每个数据库工作的具体细节，数据库独立性可能并不满足&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>如&lt;strong>Null值&lt;/strong>造成的&lt;strong>数据库迁移障碍&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>在Sybase中间（is NULL）返回的是true&lt;/li>
&lt;li>在Oracle中间返回的仍然是空&lt;/li>
&lt;/ul>
&lt;h2 id="2不同数据库中的差异--并发控制">2.不同数据库中的差异 —— 并发控制&lt;/h2>
&lt;p>并发控制是用于保护数据库完整性的技术&lt;/p>
&lt;ul>
&lt;li>产生并发问题主要原因: 事务的隔离性没控制好，一致性不能得到保证&lt;/li>
&lt;li>并发机制不正确可能导致脏读、幻读和不可重复读等此类问题&lt;/li>
&lt;/ul>
&lt;h3 id="21不同数据库的并发控制不同">2.1不同数据库的并发控制不同&lt;/h3>
&lt;p>如果不了解数据库如何实现并发控制，就没有办法做&lt;strong>性能优异的并发系统&lt;/strong>，就&lt;strong>一定会有不好的结果&lt;/strong>。&lt;/p>
&lt;p>车辆排队时间随着数量增加，后续会呈现&lt;strong>指数增长&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>一方面要花费更大的额外时间来管理，需要划线，需要维持现场秩序。&lt;/li>
&lt;li>另一方面，收费站问题，最终可能引起整个&lt;strong>高速公路连锁反应&lt;/strong>。&lt;/li>
&lt;li>在数据库中间把它称之为&lt;strong>上下文切换&lt;/strong>。&lt;/li>
&lt;li>现实存在并发，需保持&lt;strong>数据一致性&lt;/strong>，所以要做并发控制。‘&lt;/li>
&lt;/ul>
&lt;h3 id="22当前数据库系统如何使用锁机制">2.2当前数据库系统如何使用锁机制&lt;/h3>
&lt;p>数据库通过锁机制来处理并发问题。&lt;/p>
&lt;p>行级锁：乐观锁、二段锁。&lt;/p>
&lt;p>不同数据库的&lt;strong>锁机制不一致&lt;/strong>、&lt;strong>差异性&lt;/strong>将极大程度地影响数据库的并发控制机制。&lt;/p>
&lt;ul>
&lt;li>有些数据可能有页级锁、另外一些有行级锁，有些实现会把行级锁升级为页级锁，另外一些则不然; 有些使用读锁，另外一些不使用。&lt;/li>
&lt;li>有些通过锁定实现&lt;strong>串行化事务&lt;/strong>，另外一些则通过数据库的**“读一致”视图**来实现(没有锁）。&lt;/li>
&lt;/ul>
&lt;p>不了解锁机制有时将导致致命的bug。&lt;/p>
&lt;h3 id="23orcale数据库的锁机制有时无法读正确数据-特别地">2.3Orcale数据库的锁机制有时无法读正确数据。 特别地&lt;/h3>
&lt;p>Orcale的多版本控制、读一致性模型：&lt;/p>
&lt;ul>
&lt;li>读一致性：对一个时间点的查询结果是一致的。&lt;/li>
&lt;li>非阻塞性读：读不会被写阻塞。//但其他数据库可能会&lt;/li>
&lt;/ul>
&lt;p>Orcale锁机制的好处：&lt;/p>
&lt;ul>
&lt;li>因为没有读锁，读和写可以并发，并发效率提高。&lt;/li>
&lt;li>&lt;strong>其他数据库&lt;/strong>使用了&lt;strong>读共享锁&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%bc%80%e5%8f%91%e4%b8%ad%e7%9a%84%e6%95%b0%e6%8d%ae%e5%ba%93%e9%97%ae%e9%a2%98/image-20230308141957218.png" alt="image-20230308141957218" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>充分了解锁机制、才能发挥数据库管理系统的最大潜能。&lt;/p>
&lt;h2 id="3数据库的并发控制对程序员影响">3.数据库的并发控制——对程序员影响&lt;/h2>
&lt;h3 id="31-orcale的读一致性">3.1 Orcale的读一致性&lt;/h3>
&lt;p>特点：对一个时间点的查询结果是一致的。读和写可以并发，并发效率提高。&lt;/p>
&lt;p>Orcale的无阻塞设计的&lt;strong>副作用&lt;/strong>：&lt;/p>
&lt;p>当要保证一次最多只有一个用户访问一行数据，需要开发人员做工作。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%bc%80%e5%8f%91%e4%b8%ad%e7%9a%84%e6%95%b0%e6%8d%ae%e5%ba%93%e9%97%ae%e9%a2%98/image-20230308142438375.png" alt="image-20230308142438375" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>因为where中查询时，两条数据都是合法的，都能插入，此时会出现业务逻辑错误。&lt;/p>
&lt;p>&lt;strong>修改方式&lt;/strong>：&lt;/p>
&lt;p>使用FOR UPDATE关键字，表示这个读是用来修改的，此时有个共享锁机制。&lt;/p>
&lt;h3 id="32-不能把数据库当成黑盒使用">3.2 不能把数据库当成黑盒使用&lt;/h3>
&lt;p>HIBERNATE
·对可持续化的类直接连接数据库，进行可持续化的存储。&lt;/p>
&lt;ul>
&lt;li>Hibernate并不会为 sqlserver，DB2，oracle生成不同的代码，而每个数据库的特征又是如此的不一样。&lt;/li>
&lt;li>数据库有时跟编译器一样，只能做语法检查&lt;/li>
&lt;li>很难对一个数据库的操作进行对错的判断，&lt;strong>很难debug&lt;/strong>&lt;/li>
&lt;li>因此需要在每个环节尽量&lt;strong>避免引入bug&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>oracle mysql SqlServer数据库上差异，导致了并发处理上的差别&lt;/p>
&lt;h3 id="33程序员通过程序来考虑并发问题的情况">3.3程序员通过程序来考虑并发问题的情况：&lt;/h3>
&lt;p>回答：不知道、看情况。&lt;/p>
&lt;ul>
&lt;li>并发控制
90%的情况下，
并发都是完全透明，无需担心。&lt;/li>
&lt;li>10%的情况下，必须清楚哪些情况下需要自己考虑
并发控制。&lt;/li>
&lt;/ul>
&lt;p>需要做什么：&lt;/p>
&lt;ul>
&lt;li>了解每个feature的
结构和实现，避免犯错。&lt;/li>
&lt;li>测试，而且要&lt;strong>学会在多用户环境下&lt;/strong>对代码进行不断的测试。&lt;/li>
&lt;/ul>
&lt;h2 id="4为性能而设计">4.为性能而设计&lt;/h2>
&lt;h3 id="41-性能调优">4.1 性能调优&lt;/h3>
&lt;p>避免依赖专家调优。因为专家调优不靠谱。&lt;/p>
&lt;h3 id="性能调优的两种方式">性能调优的两种方式：&lt;/h3>
&lt;ul>
&lt;li>根据当前CPU能力、可用内存、I/O子系统等资源情况来设置相应参数。数据库管理员（专家）要做的事情，大概提高20-30%。&lt;/li>
&lt;li>通过索引、物理结构、SQL的优化，具体提高某&amp;ndash;个查询的性能。本身是程序员要做的事情。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>决定性能的根本原因—— 设计（提高性能的基础）&lt;/strong>&lt;/p>
&lt;p>体系结构设计决定了数据库系统的性能上限（&lt;strong>性能级别&lt;/strong>）。&lt;/p>
&lt;p>比如：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>动态页面：对于百万量级访问负担重。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>静态页面：还需要额外的内容管理系统。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>修改对顺序文件是极大的性能障碍，所以这些系统都不提供修改功能。&lt;/p>
&lt;p>&lt;strong>设计决定了性能指标&lt;/strong>，性能拙劣的罪魁祸首都是错误的设计。&lt;/p>
&lt;p>性能指标都是有成本的，性能设计是在安全和优化中寻找平衡&lt;/p>
&lt;h3 id="42性能指标--要考虑整体性">4.2性能指标 —— 要考虑整体性&lt;/h3>
&lt;ul>
&lt;li>以前的，查询事务，多少s能够返回数据&lt;/li>
&lt;li>以&lt;strong>吞吐量&lt;/strong>为核心。每秒&lt;strong>处理多少事务&lt;/strong>。（&lt;strong>整体性&lt;/strong>）&lt;/li>
&lt;li>数据库环境，web服务器的环境，只能支持3000个并发&lt;/li>
&lt;li>比如OceanBase的成绩单上写，它承载了双十一峰值6100万次/秒的数据库访问这就是针对访问吞吐量的指标&lt;/li>
&lt;/ul>
&lt;p>一个&lt;strong>具体的sql的性能提升&lt;/strong>，也许会&lt;strong>导致其它操作性能的下降&lt;/strong>，使整个&lt;strong>系统吞吐量&lt;/strong>下降。‘性能指标要考虑整体性：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>任何一个技术可以解决一个问题，但必然存在另一个问题的风险&lt;/p>
&lt;/li>
&lt;li>
&lt;p>debug能力和使用优化工具的能力，是每个数据库工程师应该有的。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%bc%80%e5%8f%91%e4%b8%ad%e7%9a%84%e6%95%b0%e6%8d%ae%e5%ba%93%e9%97%ae%e9%a2%98/image-20230201115754595.png" alt="image-20230201115754595" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="43-整体层面考虑性能优化">4.3 整体层面考虑性能优化&lt;/h3>
&lt;p>数据的&lt;strong>性能直接指标&lt;/strong>就是&lt;strong>CPU或者是I/O的负载&lt;/strong>的问题.所以要监控CPU，IO负载。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>CPU负载高，I/O负载低&lt;/p>
&lt;ul>
&lt;li>内存不够&lt;/li>
&lt;li>磁盘性能差(磁盘问题、RAID设计不好，
RAID降级)&lt;/li>
&lt;li>&lt;strong>SQL的问题&lt;/strong>&lt;/li>
&lt;li>&lt;strong>并发锁机制的问题&lt;/strong>&lt;/li>
&lt;li>&lt;strong>事务设计问题，大量小数据I/O&lt;/strong>&lt;/li>
&lt;li>&lt;strong>大量的全表扫描&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>I/O负载高，CPU负载低&lt;/p>
&lt;ul>
&lt;li>&lt;strong>大量小的I/O执行写操作&lt;/strong>&lt;/li>
&lt;li>**Autocommit，产生大量小/0 **自动提交&lt;/li>
&lt;li>&lt;strong>大量大的I/O执行写操作&lt;/strong>&lt;/li>
&lt;li>&lt;strong>SQL的问题&lt;/strong>&lt;/li>
&lt;li>IOPS: 磁盘每秒的读写次数&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>都高&lt;/p>
&lt;ul>
&lt;li>硬件不够用&lt;/li>
&lt;li>&lt;strong>SQL存在明显问题&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>性能问题 90%是程序员问题，开发环境到生产环境容易出问题。&lt;/p>
&lt;p>&lt;strong>数据库应用要从自己身上找原因&lt;/strong>&lt;/p>
&lt;p>sql优化的方向：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%bc%80%e5%8f%91%e4%b8%ad%e7%9a%84%e6%95%b0%e6%8d%ae%e5%ba%93%e9%97%ae%e9%a2%98/image-20230201120131053.png" alt="image-20230201120131053" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E5%92%8C%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E5%92%8C%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8F/</guid><description>&lt;p>并发问题: 单独一个session执行的时候，很多问题不会暴露，但多个
session一起访问的时候，就会遇到问题。&lt;/p>
&lt;p>并发用户遇到最多的是更新问题，即&lt;strong>多个用户更新相同资源的时候&lt;/strong>，会
产生数据冲突的问题，以及随后会采用的各种级别的锁的问题。&lt;/p>
&lt;p>并发也会涉及&lt;strong>读取问题&lt;/strong> （各种资源竞争）&lt;/p>
&lt;p>一、并发读取和并发修改的常见问题和解决方案;&lt;/p>
&lt;p>二、数据库事务隔离级别:&lt;/p>
&lt;p>三、大数据量的一些处理手段。&lt;/p>
&lt;h2 id="1处理并发和大数据量">1.处理并发和大数据量&lt;/h2>
&lt;h3 id="11并发读取问题">1.1并发读取问题&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227200500826.png" alt="image-20230227200500826" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>有索引和没索引对数据访问的差距&lt;/strong>：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227200620323.png" alt="image-20230227200620323" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>5000数据量太少，所以单次查询的测试感觉不明显。&lt;/p>
&lt;p>单位时间内，随机间隔执行若干次。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230309200022761.png" alt="image-20230309200022761" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230309200051642.png" alt="image-20230309200051642" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227200824602.png" alt="image-20230227200824602" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="12排队">1.2排队&lt;/h3>
&lt;p>单个查询的时间慢，队会越排越长，性能也越来越差。&lt;/p>
&lt;p>队伍的增长速度与查询的执行频率和查询所需平均时间之间的比例有关,比例拉高，查询越来越快，&lt;strong>队伍就越拉越长&lt;/strong>。&lt;/p>
&lt;p>即&lt;strong>阈值效应&lt;/strong>。数据库是非常典型的具备闯值效应的东西.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230309200313192.png" alt="image-20230309200313192" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h2 id="2并发修改数据-加锁">2.并发修改数据-加锁&lt;/h2>
&lt;p>&lt;strong>并发真正影响的是写&lt;/strong>。&lt;/p>
&lt;p>保证每个sesssion，:每个事务，都有不被别人影响的写的权力，此时要使用锁。&lt;/p>
&lt;p>并发过程中，有多少用户会相互产生影响&lt;strong>取决于锁的粒度&lt;/strong>。&lt;/p>
&lt;h3 id="21看锁的粒度">2.1看锁的粒度&lt;/h3>
&lt;p>不同的DBMS支持不同的锁类型。支持何种粒度的锁，在大型系统和小规模系统之间
存在极大的差异。&lt;/p>
&lt;p>大型系统对于锁的粒度选择非常谨慎，而在小规模系统中往往不是那么计较锁的粒度。&lt;/p>
&lt;p>加锁的数据量小的锁，称之为细粒度锁。&lt;/p>
&lt;p>行锁是粒度很细的锁，只锁一条记录行。
在行锁的环境下，多个并发进程就可能同时修改同一表中的不同行的数据,
而不会造成阻塞。&lt;/p>
&lt;p>&lt;strong>行锁不同进程之间可以有一定的重叠&lt;/strong>，不一定要等到一个进程执行的事务结束才可以执行。&lt;/p>
&lt;p>而&lt;strong>表锁则必须等到上一个对本表执行操作的事务执行结束后才能执行&lt;/strong>，粒度较大;所以一般选择粒度更小的锁。&lt;/p>
&lt;p>更小的锁意味着处理器有更多的工作要做，从而提高硬件资源的利用率。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230309200551574.png" alt="image-20230309200551574" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227201240507.png" alt="image-20230227201240507" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>加锁处理的原则&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>不要随便使用表级锁&lt;/li>
&lt;li>尽量缩短加锁时间&lt;/li>
&lt;li>缩小事务的大小&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>编程上的处理原则&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>尽可能&lt;strong>避免&lt;/strong>SQL语句上的&lt;strong>循环处理&lt;/strong>，在程序体中，不能有一个循环体，循环体中
包含一个SQL语句。
&lt;ul>
&lt;li>SQL本身就是集合读取的过
程，不需要放在循环中。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>尽可能&lt;strong>减少程序和数据库之间的交互次数&lt;/strong>，尽可
能一个SQL就能完成所有的工作，或者一-次查询就读
到尽量多的数据，再本地
处理;&lt;/li>
&lt;li>&lt;strong>跨机器的交互次数越少越好&lt;/strong>。&lt;/li>
&lt;li>未来工作中读取或更新了错误信息，错误处理顺序应该是，&lt;strong>先rolIback，&lt;/strong>
&lt;strong>结束事务，再去查询错误信息表。&lt;/strong>
&lt;ul>
&lt;li>先结束事务，可以先解锁。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="22加锁与提交">2.2加锁与提交&lt;/h3>
&lt;p>这里的频繁提交，是指可以减小事务的大小。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227201458385.png" alt="image-20230227201458385" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>这个和物理组织形式有关。&lt;/p>
&lt;ul>
&lt;li>事务越大，提交越不频繁，资源被锁住的时间越少，&lt;strong>并发出现冲突的概率就越小&lt;/strong>。&lt;/li>
&lt;li>事务越小，提交越频繁，处理事务付出的平均代价就越大&lt;/li>
&lt;/ul>
&lt;p>对于批处理程序，并发控制不是问题，&lt;strong>避免频繁提交才是明智的做法&lt;/strong>。&lt;/p>
&lt;p>对于用户交互程序，则需要&lt;strong>高频提交，加快释放锁&lt;/strong>。&lt;/p>
&lt;h2 id="3资源竞争">3.资源竞争&lt;/h2>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227201626952.png" alt="image-20230227201626952" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230309201216936.png" alt="image-20230309201216936" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230309201243791.png" alt="image-20230309201243791" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>真正的问题是“是否可以更好地利用这些资源。&lt;/p>
&lt;p>进程之间仍然会发生资源竞争，竞争发生在两个地方: 表和索引。&lt;/p>
&lt;p>系统层次也可能发生资源竞争，但通常由数据库层面的竞争引起。&lt;/p>
&lt;p>数据库层面资源竞争消耗CPU，因为处理竞争问题要执行一些代码在等待另一个处理器上执行的进程释放资源时，还可能出现“活动等待”或“闲置循环”&lt;/p>
&lt;p>解决资源竞争的手段，比解决锁的方法多。除了降低锁的粒度外，还可以：&lt;/p>
&lt;p>DBA、架构、开发三方法&lt;/p>
&lt;h3 id="31dba解决方案">3.1DBA解决方案&lt;/h3>
&lt;p>DBA——数据库管理员的解决方案。&lt;/p>
&lt;p>DBA的解决方案，是解决插入的问题，对其它事务的影响比较少&lt;/p>
&lt;p>手段针对对象：事务空间](Transaction space. 可用列表(Freelist)&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227201851918.png" alt="image-20230227201851918" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227201904695.png" alt="image-20230227201904695" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="32架构解决方案">3.2架构解决方案&lt;/h3>
&lt;ul>
&lt;li>分区(Partitioning)&lt;/li>
&lt;li>逆序索引(Reverseindex )&lt;/li>
&lt;li>索引组织表 (Indexorganized table)&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227201930658.png" alt="image-20230227201930658" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="33开发解决方案">3.3开发解决方案&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>调节并发数&lt;/p>
&lt;ul>
&lt;li>限制session个数为最高性能的session个数，使周转更快&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>不使用系统产生值&lt;/p>
&lt;ul>
&lt;li>连续值只在范围查询中使用，在连续值本身毫无现实意义的情况下，范围查询的场景也不多见;&lt;/li>
&lt;li>可以只使用随机数来做主键，遇到随机数碰撞，就再生成一个随机数。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="34比较">3.4比较&lt;/h3>
&lt;p>&lt;strong>session比较多时&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227202036432.png" alt="image-20230227202036432" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230309201842351.png" alt="image-20230309201842351" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>违反主键约束必须到插入主键值之时才可发现，索引保存的是物理地址此时记录已被插入表中，所以需要undo，产生额外的时间成本。&lt;/p>
&lt;p>产生随机数的范围比最糟情况大100倍时，&lt;strong>性能显著改善&lt;/strong>。&lt;/p>
&lt;p>如果要设置随机值作为主键来解决资源竞争的问题，只要range足够大效率就会得到足够的改善。&lt;/p>
&lt;p>&lt;strong>session比较少时&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227202207498.png" alt="image-20230227202207498" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227202235452.png" alt="image-20230227202235452" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h2 id="4事务的隔离级别">4.事务的隔离级别*&lt;/h2>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230309202246087.png" alt="image-20230309202246087" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227202341188.png" alt="image-20230227202341188" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227202437445.png" alt="image-20230227202437445" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>另一个事务是修改但没成果提交，读到错误数据&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227202506641.png" alt="image-20230227202506641" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>另一个事务是修改后并提交，两次读到的数据不同&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227203100328.png" alt="image-20230227203100328" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>另一个事务是插入后并提交，第二次读的时候数据量不一样&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227202536809.png" alt="image-20230227202536809" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>对应MySql四种事务隔离级别&lt;/p>
&lt;p>未提交读(READ UNCOMMITTED)：脏读&lt;/p>
&lt;p>已提交读(READ COMMITTED)：解决脏读产生不可重复读&lt;/p>
&lt;p>可重复读(REPEATABLE READS)：解决不可重复读，产生幻读&lt;/p>
&lt;p>可串行化(Serializable )：解决幻读&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227202730759.png" alt="image-20230227202730759" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>更新时只加了个读锁。其他人不能写但还可以读，会读到自己产生的脏数据。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227202800296.png" alt="image-20230227202800296" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>加了个写锁。自己写完后（即使失败），别人才能读。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227203130428.png" alt="image-20230227203130428" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>提交后锁解开了，仍能有不可重复读。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227203156244.png" alt="image-20230227203156244" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227203250209.png" alt="image-20230227203250209" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>此时情况，既防重复读也防止了幻读。&lt;/p>
&lt;p>&lt;strong>它是怎么做到的&lt;/strong>?&lt;/p>
&lt;p>MVCC(多版本并发控制)&lt;/p>
&lt;p>在InnoDB中，会在每行数据后&lt;strong>添加两个额外的隐藏的值来实现MVCC&lt;/strong>,&lt;/p>
&lt;p>这两个值一
个记录这行数据&lt;strong>何时被创建&lt;/strong>，另外一个记录这行数据&lt;strong>何时过期(或者被删除)。&lt;/strong>&lt;/p>
&lt;p>在实际操作中，存储的不是时间，而是&lt;strong>事务版本号&lt;/strong>，每开启一个新事务，&lt;strong>事务版本号就会递增。&lt;/strong> 用一个乐观锁实现。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230309203313708.png" alt="image-20230309203313708" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>此外，Mysql还有&lt;strong>邻键锁&lt;/strong>。&lt;/p>
&lt;h3 id="42next-key锁">4.2Next-Key锁&lt;/h3>
&lt;p>也属于行锁的一种，且&lt;strong>是INNODB的行锁默认算法&lt;/strong>，临键锁会把查询出
的记录锁住，也会把&lt;strong>该范围查询内的所有间隙空间也会锁住&lt;/strong>，再之它会&lt;strong>把相邻的下一个区间也会锁住&lt;/strong>。&lt;/p>
&lt;p>Next-Key是记录锁 + 间隙锁&lt;/p>
&lt;p>记录锁：记录锁是对索引记录的锁，注意，它是针对索引记录，即它只锁定记录这一行数据。&lt;/p>
&lt;p>间隙锁会所上一个区间&lt;/p>
&lt;p>首先我们来看看 Next-Key Lock 的加锁规则：&lt;/p>
&lt;p>锁的范围是左开右闭。
如果是唯一非空索引的等值查询，Next-Key Lock 会退化成 Record Lock。
普通索引上的等值查询，向后遍历时，最后一个不满足等值条件的时候，Next-Key Lock 会退化成 Gap Lock。&lt;/p>
&lt;p>临键锁避免了在范围查询时出现脏读、重复读、幻读问题。
加了临键锁之后，&lt;strong>在范围区间内数据不允许被修改和插入。&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227203503925.png" alt="image-20230227203503925" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227203452959.png" alt="image-20230227203452959" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h2 id="5数据量增加的不同影响">5.数据量增加的不同影响&lt;/h2>
&lt;p>如何高效搜索庞大的表。&lt;/p>
&lt;p>如何避免数据量稍有增长就可能出现的性能下降。&lt;/p>
&lt;p>5.1应用面临 “要处理的数据量会大幅度增长&amp;quot;的问题。&lt;/p>
&lt;ul>
&lt;li>某一个应用突然火了，数据量暴增，或者业务时间很长，数据库存放了好多年的不经常被用到的数据。&lt;/li>
&lt;li>很多原本能快速处理批处理程序，消耗的时间越来越大，甚至会干扰其它正常操作的查询速度。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>不同的sql操作对于数据量增加的敏感性不同&lt;/strong>&lt;/p>
&lt;h3 id="51影响不大的情况">5.1影响不大的情况&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227203832407.png" alt="image-20230227203832407" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227203924260.png" alt="image-20230227203924260" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230309204022976.png" alt="image-20230309204022976" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="52常见是线性影响">5.2&lt;strong>常见是线性影响&lt;/strong>&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227204139562.png" alt="image-20230227204139562" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="53非线性影响">5.3非线性影响&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227204203453.png" alt="image-20230227204203453" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>现代数据库的处理方式&lt;/strong>：&lt;/p>
&lt;p>比如聚簇索引，比如很多有序的索引，除了为了快速检索，也同样为了简单的排序逻辑依照索引读出数据的顺序就是有序的。&lt;/p>
&lt;p>注意：排序性能降低常间歇发生，时快时慢，较小型排序全部在内存中执行，较大型排序(涉及多个有序子集的合并) 则需将有序子集临时存储到硬盘中&lt;/p>
&lt;p>通过调整&lt;strong>分配排序内存大小&lt;/strong>，
来改善排序密集型操作的性能
是&lt;strong>常见有效的调优技巧。&lt;/strong>&lt;/p>
&lt;h2 id="6大数据量的处理逻辑">6.大数据量的处理逻辑&lt;/h2>
&lt;p>是否需要在需求之外，添加一个格外的查询条件，来限制需要查询的数据规模。这是一个普遍的原则。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227204418997.png" alt="image-20230227204418997" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>排序主要是读写硬盘的影响。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227204526760.png" alt="image-20230227204526760" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227204539957.png" alt="image-20230227204539957" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>SQL优化中： 必须限制SQL查询中&lt;strong>非关系层部分&lt;/strong>，因为非关系层与操作数据数
量、复杂度有关，排序、limit
都是非关系层操作。&lt;/p>
&lt;p>遇到非关系操作，SQL会把一个查询，在关系和非关系操作边界上切一刀，内层是一个sql进行优化，外层是另一个sql进行优化，这样避免查询优化器对语义理解的错误。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227204629339.png" alt="image-20230227204629339" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="消除关联子查询">消除关联子查询&lt;/h3>
&lt;p>exists是关联嵌套子查询&lt;/p>
&lt;p>它和非关联嵌套子查询in的最大的差异:子查询要执行多次。&lt;/p>
&lt;p>它想效率高只有一个方式: 外层查询的条件足够的好，否则有风险。&lt;/p>
&lt;p>关联嵌套子查询在计算每一条返回记录时，&lt;strong>都被调用一次&lt;/strong>。&lt;/p>
&lt;p>死亡sql：但常见&lt;/p>
&lt;p>随数据量增加，减少关联子查询，否则风险很大。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227204741869.png" alt="image-20230227204741869" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/%E7%B4%A2%E5%BC%95%E5%8F%8A%E7%89%A9%E7%90%86%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/%E7%B4%A2%E5%BC%95%E5%8F%8A%E7%89%A9%E7%90%86%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84/</guid><description>&lt;p>索引概述&lt;/p>
&lt;p>&lt;strong>索引与目录&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>目录和索引是两种不同的机制&lt;/li>
&lt;li>索引是一种以原子粒度访问数据的手段，而不是为
了检索大量数据的&lt;/li>
&lt;/ul>
&lt;h2 id="1b树索引的结构和应用">1.B+树索引的结构和应用&lt;/h2>
&lt;h3 id="11b树的结构">1.1B+树的结构&lt;/h3>
&lt;p>必须关注关键数据的读取，并为它们提供&lt;strong>最高效的访问路径&lt;/strong>，而&lt;strong>建立索引可能是你第一个能想到的策略&lt;/strong>。&lt;/p>
&lt;p>几乎所有关系型数据库的缺省索引都是B+树索引，OceanBase也用了。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e7%b4%a2%e5%bc%95%e5%8f%8a%e7%89%a9%e7%90%86%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84/image-20230308150235556.png" alt="image-20230308150235556" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>数据库引擎&lt;strong>读取的方式&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>是从硬盘上&lt;strong>整块整块地读取&lt;/strong>数据到内存里&lt;/p>
&lt;/li>
&lt;li>
&lt;p>接着在内存中把块中的某一条记录提取出来
再进行使用。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>一个块大概4k，存多条记录。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>数据库引擎的某次读取&lt;strong>只是为了读取一条记录&lt;/strong>，但是它&lt;strong>会首先读一个完整的块&lt;/strong>而这个过程就叫&lt;strong>物理IO读取&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>数据库性能最大的消耗，就是在物理IO上。一个查询的物理IO次数越多，这个查询的速度就越慢&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>B+树索引为什么能够降低物理IO次数&lt;/p>
&lt;ul>
&lt;li>索引结构是一个树状结构，一个层次化的结构。&lt;/li>
&lt;li>根节点，会把节点上的数值分成几个区间，每个区间用指针指向下一层节点，在下一层节点上也划分成几个区间，再指向下一层，直到最下层的叶节点。&lt;/li>
&lt;li>叶节点会记录索引字段的值，以及这个值所对应的记录&lt;strong>在基本表上的存放地址&lt;/strong>，我们把这个地址叫作rowid。&lt;/li>
&lt;li>物理IO次数 = 经过的结点数量 + 1次基本表查询。&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e7%b4%a2%e5%bc%95%e5%8f%8a%e7%89%a9%e7%90%86%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84/image-20230308150733243.png" alt="image-20230308150733243" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;ul>
&lt;li>&lt;strong>叶节点到根节点的距离叫深度&lt;/strong>，例子深度是3，一般B树索引的深度都是3，有些是4&lt;/li>
&lt;li>B树索引要提高查询效率&lt;strong>首先要控制的就是树的深度&lt;/strong>&lt;/li>
&lt;li>本质上B树索引通常意味着数据存储是有序的，每个叶子页到根的距离都是一样的&lt;/li>
&lt;li>B树索引的&lt;strong>叶节点&lt;/strong>就构成了一个&lt;strong>顺序存储的数据结构&lt;/strong>它们对于范围查询，也就是&lt;strong>搜索范围数据很有用&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;h3 id="12b树索引的应用-能做什么">1.2B树索引的应用 能做什么&lt;/h3>
&lt;p>1、&lt;strong>全键值查询&lt;/strong>&lt;/p>
&lt;p>比如&lt;strong>字段x上有索引&lt;/strong>，where子 句中的条件是&lt;strong>x=123&lt;/strong>，就可以使用B树索引做高速的查询。&lt;/p>
&lt;p>2、&lt;strong>键值范围查询&lt;/strong>&lt;/p>
&lt;p>比如x在45-123之间，先进行x==45这个等值查询，查询到相关的地址,
是顺序存储，&lt;strong>横向直接顺序读取叶节点&lt;/strong>，直到找到最右侧x=123对应的地址。&lt;/p>
&lt;p>&lt;strong>读完索引之后，再去基本表去读那些地址相关的块&lt;/strong>。&lt;/p>
&lt;p>3、键值的前缀查询 与键值类似&lt;/p>
&lt;h3 id="13索引的另一面">1.3索引的另一面&lt;/h3>
&lt;p>B+树索引是最典型的索引结构。&lt;/p>
&lt;p>索引可以大幅提高查询的速度; 但与此同时，我们也不能忽略&lt;strong>索引带来的沉重的成本&lt;/strong>&lt;/p>
&lt;p>&lt;strong>存储的成本&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>很多业务系统，&lt;strong>索引数据量远大于被索引的实际数据量&lt;/strong>，也就是基本表的数据量。&lt;/li>
&lt;li>索引&lt;strong>通常是镜像的&lt;/strong>，还需要在热备、灾备、甚至是物理备份中存储，&lt;strong>存储成本非常高&lt;/strong>。&lt;/li>
&lt;li>当需要备份恢复的时候，索引还大大地增加了从备份中&lt;strong>恢复的停机时间&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>而最大的问题&lt;strong>不在于存储&lt;/strong>，&lt;strong>在于处理的开销&lt;/strong>&lt;/p>
&lt;p>基本表数据更改时，索引也需要更新。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e7%b4%a2%e5%bc%95%e5%8f%8a%e7%89%a9%e7%90%86%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84/image-20230308151320663.png" alt="image-20230308151320663" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>在并发访问的环境中，更多的索引将意味着&lt;strong>更多的并发冲突&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>更新操作&lt;strong>需要更新数据本身和更新索引数据&lt;/strong>&lt;/li>
&lt;li>索引通常是一种比数据库表&lt;strong>更紧凑&lt;/strong>的结构。&lt;/li>
&lt;li>在更新索引时，在更小的区间中&lt;strong>并发操作产生冲突的概率就会更大&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>索引在&lt;strong>物理存储上&lt;/strong>、在&lt;strong>更新处理开销上&lt;/strong>以及&lt;strong>在并发冲突的概率&lt;/strong>上，都会大幅度地影响系统的效率&lt;/p>
&lt;p>但索引仍然是最重要的组成部分，因为在实际业务中，&lt;strong>查询的次数一般比更新次数要多得多&lt;/strong>。&lt;/p>
&lt;p>索引也&lt;strong>不一定能提高查询效率&lt;/strong>&lt;/p>
&lt;h2 id="2建立索引的基础--让索引发挥作用">2.建立索引的基础 —— 让索引发挥作用&lt;/h2>
&lt;h3 id="21索引发挥作用的指标">2.1索引发挥作用的指标&lt;/h3>
&lt;p>基本表很小的时候，B+树索引还不如全表查询。&lt;/p>
&lt;ul>
&lt;li>索引只是一种特殊的访问数据的方式，它并不是一定会提高查询效率，要看具体的情况&lt;/li>
&lt;li>这种访问数据的手段是一种&lt;strong>原子粒度的，直接读取记录的&lt;/strong>，它&lt;strong>不是为了检索大量数据而存在的技术&lt;/strong>.&lt;/li>
&lt;li>如果数据是沙滩中的沙子，全表遍历是一把铲子，用来大块大块地读取数据，那么索引就像一个小勺子，一勺一勺地取数据&lt;/li>
&lt;/ul>
&lt;p>每建立一个索引，都需要这个索引能发挥所需要的作用，否则就不该建立，这是&lt;strong>建立索引的基本原则&lt;/strong>.&lt;/p>
&lt;p>判断建立一个&lt;strong>索引到底有没有作用的指标&lt;/strong>，最常用的就是&lt;strong>检索比例&lt;/strong>，
也就是查询检索到的数据占总数据的百分比，往往这个百分比被设
置为10%。&lt;/p>
&lt;ul>
&lt;li>也就是说,如果你查询到的结果集占整个源数据集的10%以下，
那么&lt;strong>在这个查询中使用索引是有效的&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>这也称之为索引的选择性，检索出来的&lt;strong>数据占总数据的百分比越低&lt;/strong>、&lt;strong>索引越有选择性&lt;/strong>。&lt;/p>
&lt;p>这里是&lt;strong>从索引的有效性来说&lt;/strong>.&lt;/p>
&lt;h3 id="22胖表和瘦表的问题">2.2胖表和瘦表的问题&lt;/h3>
&lt;p>胖表是一条记录很长的表，长的原因，很可能是字段数量很多，也可能是每个字段的长度很长&lt;/p>
&lt;p>瘦表的特点与胖表相反它的字段很少，每个字段长度很短。&lt;/p>
&lt;ul>
&lt;li>它们决定了基本表中一个块，能存储的记录的数量。&lt;/li>
&lt;li>瘦表中，一个块能存储更多的行，而胖表中，&lt;strong>一个块能存储的行数就少于瘦表&lt;/strong>。&lt;/li>
&lt;li>原则上，瘦表的&lt;strong>检索比例会更低一些&lt;/strong>，比如5%，而胖表相对来说索引的&lt;strong>检索比例会更高&lt;/strong>，对索引的使用更宽容。（低于检索比例，索引才被认为是有效的）&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>检索比例没有明确的分界线&lt;/strong>，判断索引是否可以被使用，只能&lt;strong>进行实际的测试与验证&lt;/strong>。即只访问基本表中的&lt;strong>少量行是适合使用索引&lt;/strong>的。&lt;/p>
&lt;h3 id="23只使用索引不使用表">2.3只使用索引不使用表&lt;/h3>
&lt;p>即使你需要访问基本表中的&lt;strong>很多行也可以使用索引&lt;/strong>，这种情况就是&lt;strong>只使用索引不使用表&lt;/strong>。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>单键值索引：只对一个字段建立索引。如B+树索引就是典型。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>复合键索引，本质上&lt;strong>是按照第一个字段构建的索引&lt;/strong>，区别是&lt;strong>页节点上增加y的顺序存储&lt;/strong>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e7%b4%a2%e5%bc%95%e5%8f%8a%e7%89%a9%e7%90%86%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84/image-20230308153818080.png" alt="image-20230308153818080" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>●虽然要检索很多行，
但是可以只使用索引不使用基本表。&lt;/p>
&lt;p>●即&lt;strong>只查询索引的值&lt;/strong>，此时&lt;strong>不需要读取基本表&lt;/strong>。&lt;/p>
&lt;p>以上可以总结&lt;strong>使用B+树索引的两个条件（索引可用性）&lt;/strong>:&lt;/p>
&lt;p>1、只需要获取少量的行;&lt;/p>
&lt;p>2、即便获取很多行，但是可以只使用索引不使用基本表。&lt;/p>
&lt;p>但索引读取是复杂的事情，记录的位置也会导致索引效率的不同。&lt;/p>
&lt;p>下图是5条记录在同一块，和不在同一块的索引次数对比：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e7%b4%a2%e5%bc%95%e5%8f%8a%e7%89%a9%e7%90%86%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84/image-20230308154251969.png" alt="image-20230308154251969" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>为什么很多查询在开发环境中运行效率都比生产环境高呢?&lt;/strong>&lt;/p>
&lt;p>因为往往生成的记录是按顺序一起插入的，&lt;strong>记录的存储顺序和索引的顺序非常相似&lt;/strong>，所以当读完索引后就能用最小的代价读取所检索到的记录。&lt;/p>
&lt;p>但是&lt;strong>生产环境下&lt;/strong>，由于并发、修改以及各种情况的产生，真实的数据很可能是&lt;strong>混乱地分散在硬盘的不同块中&lt;/strong>的，这时查询效率必然会下降。&lt;/p>
&lt;p>&lt;strong>解决办法：&lt;/strong>&lt;/p>
&lt;p>只有在&lt;strong>开发环境测试并且远超过需求的性能标准&lt;/strong>，这样才能在&lt;strong>生产环境达到需求的性能指标&lt;/strong>&lt;/p>
&lt;p>&lt;strong>总结&lt;/strong>&lt;/p>
&lt;p>索引是一个非常复杂的存在。虽然它的结构很简单，但是使用中会&lt;strong>受到很多复杂因素的影响&lt;/strong>。&lt;/p>
&lt;p>因为索引的成本很大，所以我们要&lt;strong>谨慎地选择构建索引&lt;/strong>，务必让索引变得可用。&lt;/p>
&lt;h2 id="3哈希索引和函数索引">3.哈希索引和函数索引&lt;/h2>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e7%b4%a2%e5%bc%95%e5%8f%8a%e7%89%a9%e7%90%86%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84/image-20230308154630283.png" alt="image-20230308154630283" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>学习索引的方法：&lt;/p>
&lt;ol>
&lt;li>学习结构&lt;/li>
&lt;li>根据结构找出特点和作用&lt;/li>
&lt;/ol>
&lt;h3 id="31哈希索引">3.1哈希索引&lt;/h3>
&lt;p>&lt;strong>哈希索引的结构&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e7%b4%a2%e5%bc%95%e5%8f%8a%e7%89%a9%e7%90%86%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84/image-20230308154825502.png" alt="image-20230308154825502" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>所有的数据类型，通过哈希函数变成一个&lt;strong>等长的哈希值&lt;/strong>。&lt;/p>
&lt;p>将这个&lt;strong>等长的哈希值&lt;/strong>作为&lt;strong>组织成索引的结构 —— 哈希链表&lt;/strong>。&lt;/p>
&lt;p>哈希链表的结点上，储存哈希值 和 指向记录哈希值的地址 uid（索引行的地址）。&lt;/p>
&lt;p>&lt;strong>哈希索引能做什么不能做什么？&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>哈希索引只能用来进行&lt;strong>全键值&lt;/strong>的查询
&lt;ul>
&lt;li>不能前缀查询&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>哈希索引只支持&lt;strong>击中运算符&lt;/strong>
&lt;ul>
&lt;li>击中运算符：= , != , in&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>哈希索引&lt;strong>不支持对字段排序&lt;/strong>&lt;/li>
&lt;li>哈希索引&lt;strong>不支持范围查询&lt;/strong>&lt;/li>
&lt;li>哈希索引&lt;strong>读取效率高于B树索引&lt;/strong>
&lt;ul>
&lt;li>哈希索引结构非常紧凑.&lt;/li>
&lt;li>哈希索引&lt;strong>使用数值的比较&lt;/strong>,远高于字符串比较速度.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>碰撞率的问题&lt;/strong>&lt;/p>
&lt;p>碰撞指不同的字段值，通过计算得到了相同的哈希值，而碰撞发生的频繁程度就是碰撞率。&lt;/p>
&lt;p>当发生碰撞时，存储引擎必须访问链表中相同哈希值的&lt;strong>每一个行&lt;/strong>指针，然后&lt;strong>逐行进行数据比较&lt;/strong>，以确定正确的数据。&lt;/p>
&lt;ul>
&lt;li>如果有很多碰撞，一些索引维护操作就有可能会变慢。如果在一个&lt;strong>选择性很低的列&lt;/strong>(&lt;strong>列的基数占总行数&lt;/strong>的比例低) 上创建哈希索引就会产生很多碰撞.&lt;/li>
&lt;li>这时假如从表中删除一行,那么从索引中&lt;strong>找到这一行的代价会很高&lt;/strong>。存储引擎将&lt;strong>不得不检查哈希键链表中的每一行&lt;/strong>，以找到和移除被删除行的索引。&lt;/li>
&lt;/ul>
&lt;p>数据仓库层面中的&lt;strong>星型结构&lt;/strong>, 在查找很多表的连接时, 哈希索引正是其所需要的.&lt;/p>
&lt;p>&lt;strong>mysql中不同引擎 对哈希索引的支持&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>只有Memory引擎有显式的哈希索引&lt;/li>
&lt;li>NBD cluster存储引擎支持唯一的哈希索引&lt;/li>
&lt;li>InnoDB引擎有&lt;strong>自适应哈希索引&lt;/strong>
&lt;ul>
&lt;li>当存储引擎发现一些索引值被频率很高访问时,将自动在B+树的顶端构建哈希索引.&lt;/li>
&lt;li>这时的B+树索引有哈希索引的特征 &amp;mdash;- 很快的哈希索引.&lt;/li>
&lt;li>但是自动的过程,不能控制也不能配置.&lt;/li>
&lt;li>即&lt;strong>越使用某个查询, 查询越快&lt;/strong>.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="32函数索引">3.2函数索引&lt;/h3>
&lt;p>B树索引是对一个字段构建索引,而函数索引是对&lt;strong>这个字段上的一个函数值&lt;/strong>构建索引.&lt;/p>
&lt;p>&lt;strong>结构同样是B+树索引,只是叶节点的值是函数的值而不是字段值.&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>B+树索引 , B+树上对X构建索引,&lt;/li>
&lt;li>函数索引, B+树上对F(x)的值构建索引&lt;/li>
&lt;li>但他们叶子结点指向的地址,&lt;strong>都是字段对应的地址&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>是最具创造力的索引结构,用得好可用解决并发冲突,优化存储结构.等很多事情.&lt;/p>
&lt;p>&lt;strong>能用在哪&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>不区分大小写&lt;/strong>查询&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>T、F比例巨大差异&lt;/strong>的查询&lt;/p>
&lt;blockquote>
&lt;p>有一个事务处理的表，处理过的事务记录，flag取值为T或者Y,而没有处理的
就是F或者N。时间一久，表中大部分记录都是T,而少部分记录是F。&lt;/p>
&lt;p>怎么才能在
索引中不记录T的记录，只把flag的值 等于F的记录记在索引结构中呢?&lt;/p>
&lt;p>答案:给flag做&amp;ndash;个函数索引。&lt;/p>
&lt;p>解析:编写一个函数，如果是T，就返回NULL;如果是F，就返回一个非NULL的
值。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>有选择的唯一性&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e7%b4%a2%e5%bc%95%e5%8f%8a%e7%89%a9%e7%90%86%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84/image-20230308161603917.png" alt="image-20230308161603917" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>项目表有两个状态, active和inactive.&lt;/p>
&lt;p>要求active的项目,必须要有唯一名. 而inactive没有这个要求.&lt;/p>
&lt;p>解决方法: &lt;strong>函数索引上构建唯一索引&lt;/strong>.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="4位图索引和位图连续索引">4.位图索引和位图连续索引&lt;/h2>
&lt;h3 id="41-位图索引-oracle独有的">4.1 位图索引 oracle独有的&lt;/h3>
&lt;p>结构: 用一个&lt;strong>索引键条目存储指向多行&lt;/strong>的指针。01图&lt;/p>
&lt;ul>
&lt;li>B树索引中，索引键和表中的行存在着对应关系，-一个索引就指向一行;&lt;/li>
&lt;li>位图索引中，可能&lt;strong>只有很少的索引条目&lt;/strong>，但&lt;strong>每个索引指向多行&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e7%b4%a2%e5%bc%95%e5%8f%8a%e7%89%a9%e7%90%86%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84/image-20230227155733844.png" alt="image-20230227155733844" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>统计行数非常快&lt;/strong>.压缩地很紧凑&lt;/p>
&lt;p>&lt;strong>位图索引适合&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>相异基数(distinct cardinality)低&lt;/strong>的字段进行快速查询 (复合查询)
&lt;ul>
&lt;li>可以取的值的范围小: 性别、真假,年龄段 等.&lt;/li>
&lt;li>使用B树索引,需要复合索引时 组合数多. 且共同的值多, 可能使得叶子结点远少于索引结点.&lt;/li>
&lt;li>使用哈希索引,碰撞率贼高.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>大量临时查询的聚合&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e7%b4%a2%e5%bc%95%e5%8f%8a%e7%89%a9%e7%90%86%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84/image-20230308162526006.png" alt="image-20230308162526006" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>缺点&lt;/strong>: &lt;strong>对于写操作非常不友好&lt;/strong>&lt;/p>
&lt;p>&lt;strong>原因&lt;/strong>: 位图索引的&lt;strong>键值指向多行&lt;/strong>, 如果一个session修改了一个索引的数据,则&lt;strong>该索引指向的所有行都会被查找到&lt;/strong>.无法锁定单独一个条目,&lt;strong>可能在修改时要锁住整个目录&lt;/strong>,导致并发性下降严重 几乎变成串行化.&lt;/p>
&lt;p>这就是位图索引&lt;strong>不能应用在OLTP&lt;/strong>应用中的原因.&lt;/p>
&lt;h3 id="42-位图连结索引--bitmap-join-index">4.2 位图连结索引 bitmap join index&lt;/h3>
&lt;p>oracle 九代? 之后,出现的.&lt;/p>
&lt;p>一般情况下,我们都是在 &lt;strong>一张表上建立索引,且只使用这个表上的列&lt;/strong>.&lt;/p>
&lt;p>而位图联结索引:&lt;/p>
&lt;ul>
&lt;li>允许使用&lt;strong>另外某个表的列&lt;/strong> 对 &lt;strong>一个给定表&lt;/strong> 建立索引。&lt;/li>
&lt;li>实际上，这就是允许&lt;strong>对一个索引结构&lt;/strong>(而不是表本身)中的数据进行&lt;strong>逆规范化&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>下图的例子,常常需要对多个表进行联结后进行查询.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e7%b4%a2%e5%bc%95%e5%8f%8a%e7%89%a9%e7%90%86%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84/image-20230308164014658.png" alt="image-20230308164014658" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>一般的索引方法:&lt;/p>
&lt;ul>
&lt;li>在部门表的部门名称上构建一个索引,,&lt;/li>
&lt;li>并用它来查询 部门名称为&amp;quot;销售&amp;quot; 的所有部门编号id&lt;/li>
&lt;li>再回到员工表使用索引 查找根据部门编号匹配的行.&lt;/li>
&lt;/ul>
&lt;p>位图联结索引:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>对部门名称建立索引后,指向员工表&lt;/strong>.&lt;/li>
&lt;/ul>
&lt;p>位图联结索引的&lt;strong>前提条件&lt;/strong>:&lt;/p>
&lt;p>&lt;strong>必须连接到另一张表的主键/唯一键&lt;/strong>&lt;/p>
&lt;h3 id="43mysql没有位图索引该怎么办">&lt;strong>4.3Mysql没有位图索引,该怎么办&lt;/strong>&lt;/h3>
&lt;p>1.优化替代&lt;strong>索引组合&lt;/strong>:(&lt;strong>传统办法&lt;/strong>)&lt;/p>
&lt;ul>
&lt;li>Select * from profiles where sex= &amp;lsquo;M’ order by rating limit 10;
可以添加sex，rating列上的&lt;strong>复合索引&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>2.&lt;strong>低选择性添加特殊索引&lt;/strong> 最重要的手段&lt;/p>
&lt;ul>
&lt;li>select * from profiles wheresex= &amp;lsquo;M’ order by rating limit 100000, 10;
依旧很慢，更好的策略是&lt;strong>限制用户查看的页数&lt;/strong>。&lt;/li>
&lt;li>也可以: Select * from t inner join (
Select id from t
Where x.sex = &amp;rsquo;m&amp;rsquo; order by rating limit 100000, 10) AS x USING id;&lt;/li>
&lt;/ul>
&lt;p>Google刚发布时用了limit限制, 如果看很后面的页数还是会很卡. 后面直接最多限制20页.&lt;/p>
&lt;h2 id="5索引使用的典型问题">5.索引使用的典型问题&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>使不使用索引大部分情况&lt;/strong>由数据库引擎自己决定&lt;/li>
&lt;li>程序员&lt;strong>只负责构建索引&lt;/strong>，数据库&lt;strong>引擎判断是否应该使用索引&lt;/strong>&lt;/li>
&lt;li>&lt;strong>如果索引不被查询使用&lt;/strong>，将产生巨大的负担，就不该被构建&lt;/li>
&lt;/ul>
&lt;p>索引使用的典型问题&lt;/p>
&lt;ul>
&lt;li>函数和类型转化对索引的影响&lt;/li>
&lt;li>索引和外键&lt;/li>
&lt;li>同一个字段，多个索引&lt;/li>
&lt;li>系统生成键&lt;/li>
&lt;/ul>
&lt;h3 id="51函数和类型转化对索引的影响">5.1函数和类型转化对索引的影响&lt;/h3>
&lt;p>Where f(indexed_col)=some value&lt;/p>
&lt;p>这种检索条件会使索引无法发挥作用&lt;/p>
&lt;ul>
&lt;li>&lt;strong>函数&lt;/strong>&lt;/li>
&lt;li>&lt;strong>隐式类型转化&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>例:&lt;strong>字符串列和数字比较时&lt;/strong>，大多数数据库引擎不会立即生成运行时错误，
而是&lt;strong>隐式地将字符串列转换为数字&lt;/strong>。此时会&lt;strong>跳过索引&lt;/strong>。&lt;/p>
&lt;h3 id="52外键索引的问题">5.2外键索引的问题&lt;/h3>
&lt;p>系统对外键建立索引很&lt;strong>普遍&lt;/strong>。&lt;/p>
&lt;p>为什么要对外键建立索引？&lt;/p>
&lt;ul>
&lt;li>删除操作时，可以快速通过外键的索引找到要删除的行。&lt;/li>
&lt;li>并发时需要 A表加锁/B表加锁。 添加索引能够让上锁后操作的时间边短。&lt;/li>
&lt;li>&lt;strong>例外&lt;/strong>：表B只是一个字典表，就不需要对表A的外键建立索引。
&lt;ul>
&lt;li>因为字典表不容易被修改。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>建立索引必须有理由
, 无论是对外键，或是其他字段都是如此.&lt;/p>
&lt;h3 id="53同一字段多个索引">5.3同一字段，多个索引&lt;/h3>
&lt;p>索引中字段顺序影响大，但表中顺序无影响。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e7%b4%a2%e5%bc%95%e5%8f%8a%e7%89%a9%e7%90%86%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84/image-20230308193218951.png" alt="image-20230308193218951" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>如这个Order_details是由两个外键构成. 且Article是字典表,因此article_id不需要构建索引.&lt;/p>
&lt;p>如果Order_id 在前面,article_id在后, 则自动构建的索引是复合索引(Order_id,article_id),此时只需要一个索引.&lt;/p>
&lt;p>如果article_id在前,Order_id 在后, 则自动构建的索引是复合索引(article_id,order_id),此时还需要一个外键索引order_id, 共有两个索引.性能下降.&lt;/p>
&lt;h3 id="54系统生成键">5.4系统生成键&lt;/h3>
&lt;p>构建数据库时经常使用&lt;strong>系统提供自增字段&lt;/strong>,作为主键 它性能也最高。&lt;/p>
&lt;p>系统生成键:&lt;/p>
&lt;ul>
&lt;li>系统生产序列号远好于
寻找当前最大值并加1
并 用一个专用表保存“下一个值”且加锁更新&lt;/li>
&lt;/ul>
&lt;p>但系统生成键作为主键仍然存在并发的问题:&lt;/p>
&lt;ul>
&lt;li>主键索引的主要用途是&lt;strong>确保主键的唯一性&lt;/strong>.&lt;/li>
&lt;li>并发插入时 &lt;strong>生成的序列号非常接近&lt;/strong>,将&lt;strong>键值插入到主键索引中同一个块&lt;/strong>的可能性变大了.&lt;/li>
&lt;li>此时进程将竞争同一个索引页,插入并发性大幅度下降.&lt;/li>
&lt;/ul>
&lt;p>解决方案：反向键索引,此时属于同一个结点的块几率更小.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e7%b4%a2%e5%bc%95%e5%8f%8a%e7%89%a9%e7%90%86%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84/image-20230227161032966.png" alt="image-20230227161032966" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="总结为什么查询优化器没有使用我创建的索引">总结:为什么查询优化器没有使用我创建的索引?&lt;/h3>
&lt;p>情况1:&lt;strong>索引列不在使用的最前列(复合索引时)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>假设: T, T(X,Y)上有索引，做SELECT * FROM T WHERE Y=5&lt;/li>
&lt;/ul>
&lt;p>情况2: B树索引&lt;strong>不能为NULL建立索引条目&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>使用SELECT COUNT(*) FROMT,而且T上有索引，但是优化器仍然全表扫描&lt;/li>
&lt;/ul>
&lt;p>情况3:函数值问题&lt;/p>
&lt;p>情况4:隐形函数转化&lt;/p>
&lt;p>情况5:使用索引，实际反而会更慢.&lt;/p>
&lt;ul>
&lt;li>当做了测试后,证明索引确实能提高查询效率时,才建立索引.&lt;/li>
&lt;/ul>
&lt;p>情况6:查询优化器做出了错误的判断&lt;/p>
&lt;ul>
&lt;li>优化器根据统计信息来判断索引的使用.&lt;/li>
&lt;li>没有正确的统计信息，造成查询优化器无法做出正确的选择&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>不使用索引原因&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>不能使用索引，使用索引会返回不正确的结果&lt;/li>
&lt;li>不该使用索引，如果使用了索引就会变得更慢&lt;/li>
&lt;/ul>
&lt;p>总结: 根据索引访问的不同特点, 充分理解要处理的数据做出合理的判断，才能获得高效方案。&lt;/p>
&lt;h2 id="6数据库的物理组织形式">6.数据库的物理组织形式&lt;/h2>
&lt;p>这里的物理实现是讲基本概念, cmu15-445更详细.&lt;/p>
&lt;p>&lt;strong>关系型数据库的核心特点: 读写冲突&lt;/strong>&lt;/p>
&lt;p>在并发用户数很大的系统时,选择&lt;/p>
&lt;ul>
&lt;li>尽量以紧凑的方式存储数据,利于读&lt;/li>
&lt;li>尽量将数据分散存储,利于并发写入&lt;/li>
&lt;/ul>
&lt;p>数据库基本的物理存储细节&lt;/p>
&lt;ul>
&lt;li>数据查询要快, 要建立索引&lt;/li>
&lt;li>数据更新要快, 不要建立索引&lt;/li>
&lt;/ul>
&lt;p>但没有两全其美的&lt;strong>并发的修改密集型&lt;/strong>, 即不能做到 查询快时更新也快.&lt;/p>
&lt;p>核心思想：&lt;/p>
&lt;p>所有&lt;strong>有利于读的技术一定不利于写&lt;/strong>，&lt;strong>有利于写的技术一定不利于读&lt;/strong>.&lt;/p>
&lt;p>如果都有利于,则会丧失一些特征. 如 NoSOL放弃的是关系型数据库的强一致性的特点.&lt;/p>
&lt;h3 id="61-页模式">6.1 页模式&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e7%b4%a2%e5%bc%95%e5%8f%8a%e7%89%a9%e7%90%86%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84/image-20230227161540696.png" alt="image-20230227161540696" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>行迁移&lt;/strong>: 块被填满 且 修改记录变大时, 一个块会分裂成两个块.也就是一条记录存在两个块中. 物理IO读次数增加到2.&lt;/p>
&lt;p>如果记录继续变大填满了两个块, 则数据库会找一个非常大的块来容纳该条记录 并 删除原来两个块. 以防多次行迁移.&lt;/p>
&lt;p>多次行迁移的发生,是数据库使用越久越慢的原因.&lt;/p>
&lt;p>&lt;strong>为了避免行迁移&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>数据库使用更为冗余的策略:
保持大概30%的空间来处理未来的更新。&lt;/p>
&lt;ul>
&lt;li>也就是说, 块被填满70%的空间时，对数据库引擎来说，不能再插入记录。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>每一页将通过前后指针, 将块组织成链表模式, 其目的是优化全表查询效率&lt;/p>
&lt;/li>
&lt;li>
&lt;p>目录页的本质也是页，普通页中存的数据是项目数据，而目录页中
存的数据是普通页的地址。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>表的物理存储是一一个树状的结构。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>所有的叶节点都是&lt;strong>随机文件&lt;/strong>，是&lt;strong>堆文件的组织形式&lt;/strong>。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>以上也是数据库基本的物理存储细节.&lt;/p>
&lt;h3 id="62把索引当成数据仓库">6.2把索引当成数据仓库&lt;/h3>
&lt;p>把尽量在索引中多存储数据的原则扩展到极限，构建一个&lt;strong>以主键为首位的索引&lt;/strong>，&lt;strong>存储表中所有的数据&lt;/strong>。 即(复合索引包括所有列)&lt;/p>
&lt;p>即索引本身就是表.&lt;/p>
&lt;p>Oracle中的对应的数据存储模式: IOT， &lt;strong>索引组织表&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>比较索引组织表与只有主键索引的表插入的开销&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e7%b4%a2%e5%bc%95%e5%8f%8a%e7%89%a9%e7%90%86%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84/image-20230308200056061.png" alt="image-20230308200056061" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;ul>
&lt;li>IOT是一种&lt;strong>顺序文件&lt;/strong>，麻烦的两件事是&lt;strong>宽表的随机插入(复合索引字段多)&lt;strong>和&lt;/strong>数据包含长字符串&lt;/strong>。&lt;/li>
&lt;li>对于正常的事务型数据库使用IOT是得不偿失的.&lt;/li>
&lt;/ul>
&lt;p>IOT最大的优点：&lt;strong>内部已经排好序&lt;/strong>，利于范围的查询 如时间范围搜寻.&lt;/p>
&lt;h3 id="记录强制排序">记录强制排序&lt;/h3>
&lt;p>为了使得&lt;strong>表中数据有序&lt;/strong>, 很多数据库使用了&lt;strong>聚簇索引&lt;/strong>.&lt;/p>
&lt;p>聚簇索引
-clustered index
或者 -clustering index&lt;/p>
&lt;ul>
&lt;li>
&lt;p>范围查询效率非常高&lt;/p>
&lt;/li>
&lt;li>
&lt;p>代价:非范围查询也要进行范围扫描&lt;/p>
&lt;/li>
&lt;li>
&lt;p>主键更新会导致记录的重新排序，从而导致记录物理位置的变化&lt;/p>
&lt;/li>
&lt;li>
&lt;p>为了更加安全, 聚簇索引可以和索引组织表一样，根据主键来定义. 因为主键被更新的概率小,或者说不应该被更新.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>聚簇索引也可以是非主键索引,这是和索引组织表不一样的地方.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e7%b4%a2%e5%bc%95%e5%8f%8a%e7%89%a9%e7%90%86%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84/image-20230227162104411.png" alt="image-20230227162104411" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>一旦出现&lt;strong>范围查询&lt;/strong>,聚簇索引的性能是非聚簇索引的二十倍.&lt;/p>
&lt;h3 id="总结">总结&lt;/h3>
&lt;p>聚簇索引, 索引组织表, 这种从物理结构上的优化, 必然存在明显的缺点.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e7%b4%a2%e5%bc%95%e5%8f%8a%e7%89%a9%e7%90%86%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84/image-20230227162152856.png" alt="image-20230227162152856" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>聚簇结构&lt;/strong>&lt;/p>
&lt;p>优点:某些情况下能成倍地，一个数量级地提高效率。&lt;/p>
&lt;p>缺点:会使其它操作的效率降低。&lt;/p>
&lt;p>&lt;strong>优化方案&lt;/strong>:&lt;/p>
&lt;p>可以和社交网络, nosql一样.&lt;/p>
&lt;p>用顺序文件实现数据组织, 同时需要禁止一切更新操作.&lt;/p>
&lt;h2 id="7分区的介绍">7.分区的介绍&lt;/h2>
&lt;p>分区(partition)也是一种最常用的物理组织技术. 也是数据分组的方式.&lt;/p>
&lt;p>可以很好的应对大数据量和高并发.&lt;/p>
&lt;p>分区，简单地讲，就是将一个大型的表，在物理上分成多个小型的表。但借助数据库引擎，看到的仍是一张完整的表.&lt;/p>
&lt;p>分区使得查询效率和并发(concurrency)效率在很多情况下得到提升. 并且这种方式是可以自然扩充的. 即系统架构的可伸缩性 (scalable)&lt;/p>
&lt;p>分区采用的是分而治之思想, 但分而治之不一定对所有事情有帮助, 比如对于售后来说基本上没有什么差别.&lt;/p>
&lt;p>要从以下几点了解分区:&lt;/p>
&lt;ul>
&lt;li>分区的底层逻辑是什么?&lt;/li>
&lt;li>有哪几种分区的方式?&lt;/li>
&lt;li>每种分区方式能解决什么样的问题?&lt;/li>
&lt;li>不同的分区方式对项目会带来怎么样的影响?&lt;/li>
&lt;/ul>
&lt;h3 id="71循环分区">7.1循环分区&lt;/h3>
&lt;p>分区技术的由来&lt;/p>
&lt;p>最早由sybase提出分区这个概念，把60G的数据分成10个区，也就是10个
物理文件。这样，每次备份，相当于顺序备份十个文件，每个文件6分钟。&lt;/p>
&lt;p>因此分区最早&lt;strong>用于数据库高效管理&lt;/strong>的而不是数据管理.&lt;/p>
&lt;p>那个时候使用的是&lt;strong>循环分区&lt;/strong>, 不受数据影响的内部机制。&lt;/p>
&lt;ul>
&lt;li>分区定义为各个磁盘的存储区域，插入数据时，数据会按照某种方法循环的加载到各个分区上，以保持插入时磁盘IO操作的平衡。&lt;/li>
&lt;li>对并发的随机查询很有帮助(&lt;strong>即越分散越适合并发&lt;/strong>)，循环分区可以看作是随机分布数据的一
种机制。&lt;/li>
&lt;/ul>
&lt;p>和循环分区很像, 分布式，也是一种分散的方式，也是一种&lt;strong>透明分散&lt;/strong>的逻辑。&lt;/p>
&lt;p>循环分区是为了方便管理,但开发者发现了分区的好处, 为了方便开发者, 出现了数据驱动分区.&lt;/p>
&lt;h3 id="72-数据驱动分区">7.2 数据驱动分区&lt;/h3>
&lt;p>数据驱动的分区，最核心的一个概念是&lt;strong>分区键(partition key)&lt;/strong>,&lt;/p>
&lt;p>也就是说, 分区时根据&lt;strong>一个或多个字段的值&lt;/strong>，来决定这条记录应该放入哪个分区中。此时不同分区的数据有 或强或弱的联系.&lt;/p>
&lt;blockquote>
&lt;p>就像范围查询一样: 如果某一个&lt;strong>范围的数据都集中在一个页&lt;/strong>中，那么&lt;strong>查询的效率将大幅度提高&lt;/strong>。&lt;/p>
&lt;/blockquote>
&lt;p>分区也一样，只不过粒度从页扩展到了分区。&lt;/p>
&lt;p>&lt;strong>滑动窗口&lt;/strong>是 &lt;strong>最早数据驱动分区&lt;/strong>方式。&lt;/p>
&lt;p>最大的数据库一般都是金融业, 电信, 移动互联网, 社交网络.&lt;/p>
&lt;p>&lt;strong>大量的历史数据&lt;/strong> 就是其数据库庞大的主要原因.&lt;/p>
&lt;p>但现实往往对&lt;strong>最新的数据比较感兴趣&lt;/strong>, 随着数据的增加, 对历史数据的兴趣会消退.&lt;/p>
&lt;p>&lt;strong>最常被查询的往往是那些可把比较新的数据&lt;/strong>。&lt;/p>
&lt;p>因此，&lt;strong>以根据日期/时间进行分区&lt;/strong>，&lt;strong>常用的数据和不常用的数据分别放在不同的分区当中.&lt;/strong>&lt;/p>
&lt;p>&lt;strong>总结&lt;/strong>:&lt;/p>
&lt;p>分区实现的本质: 逻辑上是一张表，物理上是多个物理文件，甚至是多个物理环境.&lt;/p>
&lt;p>&lt;strong>OB的表分区就是生成多个副本，存储在不同区域的OB服务器中&lt;/strong>&lt;/p>
&lt;h2 id="8分区的方式和应用">8.分区的方式和应用&lt;/h2>
&lt;h3 id="81数据驱动分区的实现方式">8.1数据驱动分区的实现方式&lt;/h3>
&lt;p>用数据值来划分分区&lt;/p>
&lt;p>&lt;strong>哈希分区(Hash-partitioning)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>对&lt;strong>分区键进行哈希运算&lt;/strong>，根据运算结果进行分区.&lt;/li>
&lt;li>能保证&lt;strong>根据分区键可以快速找到记录&lt;/strong>，但对范围搜索没有任何帮助。&lt;/li>
&lt;li>其实更接近与循环分区, 只是它还能 负载均衡提高并发的能力.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>范围分区(Range- partitioning)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>滑动窗口，就是范围分区，根据连续数据的范围对数据进行分区。&lt;/li>
&lt;li>&lt;strong>非常适合处理历史数据&lt;/strong>，每一个分区专门用来存储特定范围内的数据。&lt;/li>
&lt;li>一般系统还会设定else分区,来存储所有&lt;strong>可能漏网的数据&lt;/strong>(其他)&lt;/li>
&lt;li>应用: 时间范围, 字母范围&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>列表分区(List-partitioning)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>是一种最具手工风格的分区类型，适合&lt;strong>定制某种特殊的解决方案&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>分区键必须明确指定&lt;/strong>，但&lt;strong>分区键只能有一列&lt;/strong>，不能像范围或者哈希分区那样同时指定多个列做为分区键，但它的&lt;strong>单个分区对应值可以是多个&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>一旦插入的列值不在分区范围内，则插入/更新就会失败.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>因此
通常建议使用列表分区时，要创建一个&lt;strong>default分区&lt;/strong>存储那些&lt;strong>不在指定列表内的记录&lt;/strong>。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>很多数据库中分区可以嵌套，即分区可以再建立子分区，叫sub partition.子分区是分区内的分区。&lt;/p>
&lt;ul>
&lt;li>一种二位分区处理的方法，比如在时间的分区中，建立哈希分区等&lt;/li>
&lt;li>&lt;strong>OB把它叫做二级分区&lt;/strong>，再举个例子，&lt;strong>类似于用户账单领域，会按照user id做哈希分区，按照账单创建时间做范围分区&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>数据驱动的分区是最常使用的分区方式，用数据值本身作为分区的基础，这时候&lt;strong>数据分区最具有开发使用的价值&lt;/strong>。&lt;/p>
&lt;h3 id="82分区是把双刃剑">8.2分区是把双刃剑&lt;/h3>
&lt;p>&lt;strong>数据驱动的分区并没有全部地解决并发问题&lt;/strong>.&lt;/p>
&lt;p>例如，一个表如果按照时间分区，把一年的数据按星期分入五十二个不同的分区中，&lt;strong>查询起来确实非常快&lt;/strong>, &lt;strong>但更新呢?&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>如果滑动窗口是52个星期, 则每个星期的事务将&lt;strong>涌入同一个分区&lt;/strong> 来插入新数据库.&lt;/li>
&lt;li>此时,并发开销，内存争用都会大幅度提升，因为大型表中的其它数据都不访问&lt;strong>只访问最近的区域&lt;/strong>.&lt;/li>
&lt;/ul>
&lt;p>有时候，52个分区这样的滑动窗口也没有任何问题，比如数据仓库中，所有的数据都是通过单一进程进行插入，根本毫无并发压力。&lt;/p>
&lt;p>按照地理分区来方便插入时, 一旦进行时间范围查询, 反而此时数据分散, 效率很低.&lt;/p>
&lt;p>但最常使用的方式是多层分区的方式, 先时间分区,再地区分区.&lt;/p>
&lt;p>&lt;strong>IOT类似的问题:“冲突”&lt;/strong>&lt;/p>
&lt;p>A.通过分区键将数据聚集，利于高速检索;&lt;/p>
&lt;p>B.对于并发执行的插入操作，分散的数据可以避免访问过于集中的问题。&lt;/p>
&lt;p>在时间空间中, AB目标可能是相互矛盾的. 所以需要搞清楚主要问题是什么,并且根据主要问题进行分区. 同时计算两方面的得失,看看结果是否可以接受.&lt;/p>
&lt;p>因为&lt;strong>数据库的性能是以吞吐量为指标,而不是某一类型的操作效率.&lt;/strong>&lt;/p>
&lt;h3 id="83分区与数据分布">8.3分区与数据分布&lt;/h3>
&lt;p>表非常大，且希望避免并发写入数据的冲突就一定要用分区吗?&lt;/p>
&lt;ul>
&lt;li>假设有一个客户订单明细表，该表中大部分数据都来自于同一个客户20%的客户贡献了80%的销量，&lt;/li>
&lt;li>那么&lt;strong>按照客户的ID对数据进行分区&lt;/strong>，就&lt;strong>不会有太大的帮助&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>查询小客户数据: 在客户ID上的索引可选择性就会很高，因此查询效率也会很高。&lt;/p>
&lt;ul>
&lt;li>此时&lt;strong>完全不需要分区&lt;/strong>.&lt;/li>
&lt;li>聪明的查询优化器在获得关于键值分布的统计数据
之后，就可以检测到数据分布的不均衡，&lt;strong>而选择使用索引&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>查询大客户数据:&lt;/p>
&lt;ul>
&lt;li>优化器也知道&lt;strong>扫描表是效率最高的处理方式&lt;/strong>，由于
大客户的数据在表中占很大的比例，比如80%， 仅仅扫描该客户所在的分区&lt;strong>并不比全表扫描快多少&lt;/strong>，
所以性能提升也不大。&lt;/li>
&lt;/ul>
&lt;p>对分区表进行查询时，当&lt;strong>数据按分区键均匀分布时，&lt;/strong>
&lt;strong>收益最大&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>比如时间分区，往往一年
中多个分区的数据相对比较&lt;strong>均衡&lt;/strong>，&lt;strong>均衡分布，使用分区的收益才是最大的&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;h3 id="84数据分区的最佳方法">8.4数据分区的最佳方法&lt;/h3>
&lt;p>整体改善业务处理的操作,才是&lt;strong>选择分区的目标&lt;/strong>. 也就是说,改善不合理的业务流程,才是设计的重中之重.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>当有多个处理执行时，解决方案就不应该过度偏袒其中任何一个.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>只要是&lt;strong>根据数据值决定物理位置的存储方式&lt;/strong>，如聚簇索引、分区, &lt;strong>更新数据的代价都非常高&lt;/strong>。&lt;/p>
&lt;ul>
&lt;li>对普通表的更新，几乎是&lt;strong>在物理地址不变&lt;/strong>的情况下进行，最多只是修改和移动表中的一些字节。&lt;/li>
&lt;li>但&lt;strong>如果选择了索引和分区&lt;/strong>，更新很可能导致一系列的删除、插入和
相关的索引、分区的维护工作。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>一旦更新分区键，就像更新索引键值一样，都会&lt;strong>引起数据的移动&lt;/strong>。&lt;/p>
&lt;ul>
&lt;li>分区数据移动的代价更大,因为不同分区的数据移动&lt;strong>可能是不同物理区域,甚至是不同机器的传输和拷贝&lt;/strong>, 一般来说,要&lt;strong>避免不同分区的数据移动&lt;/strong>.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>除了**默认存储方式(堆文件, 单库单表)**外，都会带来复杂性。如果复杂性超过好处,就坚决避免.&lt;/p>
&lt;p>选错存储方式会带来大幅度的性能降低.&lt;/p>
&lt;p>任何需求都会有变化，任何商业的流程都会发生改变，&lt;strong>任何计划周详数据库设计都可能被推倒重来.&lt;/strong>&lt;/p>
&lt;p>在表不段变大的过程中,分区基本上是必然的处理手段,但还是谨慎地选择物理模式 并且小心地测试. 由于最初物理设计不佳而导致大型数据库推倒重来的代价是巨大的.&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/%E9%AB%98%E6%80%A7%E8%83%BD%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E5%8E%9F%E5%88%99/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/%E9%AB%98%E6%80%A7%E8%83%BD%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E5%8E%9F%E5%88%99/</guid><description>&lt;p>计算机程序首要目标完成业务需求。&lt;/p>
&lt;p>容易只重视技术手段，忽略了商业活动的数据质量，仅仅想按期交付完成需求功能的程序。&lt;/p>
&lt;p>&lt;strong>需要关注的问题：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>数据代表了什么&lt;/li>
&lt;li>数据之间有什么关系&lt;/li>
&lt;li>数据能推导出什么有价值的结论&lt;/li>
&lt;li>数据的质量到底怎么样&lt;/li>
&lt;li>怎么提高数据质量&lt;/li>
&lt;/ul>
&lt;p>未来是数据的世界。&lt;/p>
&lt;p>强调良好的模型和合理的数据库设计是任何信息系统的基础，是互联网企业的钱袋子&lt;/p>
&lt;h2 id="1规范化设计">1.规范化设计&lt;/h2>
&lt;p>学习任何数据库产品，无论是关系的，还是非关系的，本质上是对现实世界的一种模型。&lt;/p>
&lt;p>不同类型的数据库，本质上存储数据的模型是不一样。&lt;/p>
&lt;p>和任何模型一样，数据库也不是精确的模型，而仅仅是对纷繁复杂的现实世界有限的描述，对特定的一个业务活动的描述往往不止一种方法。这些在技术上都可以是语义正确的。&lt;/p>
&lt;p>但通常只有一种办法最贴近业务需求。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227205706284.png" alt="image-20230227205706284" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>被接受为真理不需要证明的事实，就是公理体系，其它学科叫原理而推演出来的新事实，就是定理。&lt;/p>
&lt;p>关系表中的一行，就是一个对事实的描述。&lt;/p>
&lt;p>表就相当于公理，通过一张表或者多张表的join操作，获得的其它事实，就是从公理推导出的定理。&lt;/p>
&lt;p>&lt;strong>表是公理系统，视图和查询是定理系统&lt;/strong>。&lt;/p>
&lt;p>保证数据的一致性，即保证基于数据库的任何查询与原始数据具有同样有效性。&lt;/p>
&lt;p>NoSql 无法在数学上保持一致性。&lt;/p>
&lt;h3 id="11关系理论与实现的差异">1.1关系理论与实现的差异&lt;/h3>
&lt;ul>
&lt;li>关系理论中，&lt;strong>关系是不包含重复数据&lt;/strong>的。
&lt;ul>
&lt;li>现实中间结果集包含重复数据。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>关系是处理&lt;strong>无限数据集&lt;/strong>的
&lt;ul>
&lt;li>关系数据库再大，它也是处理有限数据集的，有限数据集不仅要保证正确，
还要提高效率。&lt;/li>
&lt;li>中间结果集的产生，就是不需要把多个表完整的做完笛卡尔积再进行条件的筛选和投影，而是一步一步进行，以提高效率，&lt;strong>中间结果集未必包含全部的字段或者记录&lt;/strong>，有可能出现重复数据。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>关系理论中，&lt;strong>记录之间没有顺序的&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>规范化的原理&lt;/strong>：按照严格的逻辑要求，将不同的数据项组织在一起，变成结构化信息。&lt;/p>
&lt;p>数据库设计的三大范式：为了建立冗余较小、结构合理的数据库，设计数据库时必须遵循一定的规则。&lt;/p>
&lt;p>数据库领域的理想主义者认为数据的分析应超越三范式，至少要满足BC范式，甚至是五范式。&lt;/p>
&lt;p>规范化为什么重要：规范化能让混沌变得有序
数据库的表经过规范化之后，结构非常自然。&lt;/p>
&lt;p>严格逻辑规则的三范式：为清晰地获得常识，提供清单指南。&lt;/p>
&lt;p>&lt;strong>表结构如果没有规范化就会面临天大的风险?&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>主要是数据的不一致性&lt;/li>
&lt;li>不满足规范化，或者模型出现一些问题，会导致数据处理的代码在性能很庞大的数据库应用中犯错率大大提高&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227210328227.png" alt="image-20230227210328227" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h2 id="2字段设计---地址和空值处理">2.字段设计 - 地址和空值处理&lt;/h2>
&lt;p>第一范式
数据库表中的所有字段都是&lt;strong>单一属性，不可再分&lt;/strong>。&lt;/p>
&lt;p>第二范式
数据库的表中不存在非关键字段对任一候选关键字段的&lt;strong>部分函数依赖&lt;/strong>。&lt;/p>
&lt;p>第三范式
在第二范式的基础之上定义的。如果数据表中不存在非关键字段对任意候选关键字段的传递函数依赖则符合第三范式。&lt;/p>
&lt;h3 id="21地址">2.1地址&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227210531541.png" alt="image-20230227210531541" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>把地址拆分成什么程度，取决于要如何使用地址，&lt;strong>业务需求决定原子级的地址属性&lt;/strong>。&lt;/p>
&lt;p>拆分不是凭空揣测，也不是根据书上的或者其它组织项目的拆分的方式，而&lt;strong>只取决于项目的实际情况&lt;/strong>。&lt;/p>
&lt;p>如果将地址继续拆分为小区、楼栋、门牌号等原子型数据项，很多时候会无法处理，甚至需要合并几个字段，会制造麻烦&lt;/p>
&lt;h3 id="22空值的处理">2.2空值的处理&lt;/h3>
&lt;p>空值的核心含义是 &lt;strong>我不知道&lt;/strong>&lt;/p>
&lt;p>一般认为，数据表中，存在空值意味着关系模型设计上存在问题,
因为它会动摇查询优化的基础。&lt;/p>
&lt;p>本质上，关系模型的&lt;strong>完备性是以二值逻辑为基础&lt;/strong>。真或者假。&lt;/p>
&lt;p>如where需要。&lt;/p>
&lt;p>数据库不得不处理这种三值模型，T，F，再加上is null&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230309210351915.png" alt="image-20230309210351915" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>如果在需求中间，有80%的客户，这&lt;strong>三个地址都是一种&lt;/strong>公冒，一个，不是那种公司、是在一起的小公司，那该如何处理？&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227210853582.png" alt="image-20230227210853582" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>隐含逻辑会导致程序逻辑变复杂，代码出错风险提高。&lt;/p>
&lt;p>几乎没有任何十全十美的设计，每一种设计都有麻烦
根据数据的情况，不同类型公司的比例，查询和更新事务的比例，一定存在一个可能最适合的方案，但一定不存在一个一定适合的方案。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227211013862.png" alt="image-20230227211013862" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>空值对程序逻辑是危险的，如果必须使用空值，要清楚它在特定情况的影响，做出最佳性能的设计。&lt;/strong>&lt;/p>
&lt;h2 id="3布尔类型和历史数据">3.布尔类型和历史数据&lt;/h2>
&lt;h3 id="31限用布尔类型">3.1限用布尔类型&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227211205919.png" alt="image-20230227211205919" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>还可以用不同的表来跟踪订单。&lt;/p>
&lt;p>追求数据密度极端的例子:四个属性取值都是T/F， 可以用0-15这16个数值代表
四个属性所有组合状态。但可能违反了原子性的原则。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227211351061.png" alt="image-20230227211351061" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>只有程序员知道，优化器不知道。&lt;/p>
&lt;p>特别是若字符串型的字段&lt;strong>有时包含字符有时包含数字&lt;/strong>，对数据库设计来说不是技巧，而是说明最初的数据库设计，对领域的定义比较混乱。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227211434846.png" alt="image-20230227211434846" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>用更通用的表，然后建立子类型。&lt;/p>
&lt;p>例如:“如果账单寄送地址是null，就是用总部地址
” 不好&lt;/p>
&lt;p>尽可能多的&lt;strong>定义约束&lt;/strong>，把语义的约束通过字段类型
和字段长度放在DBMS中去
检查去约束。&lt;/p>
&lt;p>提高健壮性、可读性扩展性，&lt;strong>数据的语义属于DBMS，别放到应用程序&lt;/strong>中&lt;/p>
&lt;h3 id="32历史数据">3.2历史数据&lt;/h3>
&lt;p>关系设计的真正难题：处理&lt;strong>时间段&lt;/strong>的数据。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227211559404.png" alt="image-20230227211559404" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>可以设置&lt;strong>价值终止时间&lt;/strong>。当前价值有效，终止时间为空。&lt;/p>
&lt;p>但在查询方面有根本缺陷。&lt;/p>
&lt;p>如双十一的价格自动变化。&lt;/p>
&lt;p>当前的价格由当前日期之前的最大日期决定。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230309211503210.png" alt="image-20230309211503210" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>也可用非规范化建模&lt;/p>
&lt;p>当前价格的选择，是每一个产品页面刷新的必须进行的一个数据库操作，操
作非常频繁，为了提高这
个操作的效率，非规范化
打破范式是一个好的选择。&lt;/p>
&lt;p>同时&lt;strong>保存价格失效和生效日期，或者同时保存价格生效日期和有效天数&lt;/strong>。&lt;/p>
&lt;p>此时可以在数据插入或者更新时，增加更多检查以维护数据的完整性，但代价是性能下降。&lt;/p>
&lt;p>&lt;strong>另一种方式&lt;/strong>&lt;/p>
&lt;p>分别创建当前价格表和历史价格表，并定义一个操作触发器，当价格改变时
将数据从当前价格表移到历史价格表。 适合特定应用，但不适合预设价格。&lt;/p>
&lt;p>也可以通过分区的方式
把失效的历史价格丢到历史的分区中，然后所谓的
price_ history表就客观上小多了，查询更快。&lt;/p>
&lt;h2 id="4数据的处理模式和存储设计">4.数据的处理模式和存储设计&lt;/h2>
&lt;h3 id="41处理模式操作模式">4.1处理模式（操作模式）&lt;/h3>
&lt;p>操作模式：指数据应该以&lt;strong>异步模式&lt;/strong>处理(例如批处理系统)
，
还是&lt;strong>同步模式处理&lt;/strong>(例如
实时交易系统)&lt;/p>
&lt;p>操作模式&lt;/p>
&lt;ul>
&lt;li>
&lt;p>异步模式处理(批处理) :是所有数据处理方式的先驱。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>同步模式处理(实时交易)&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>处理数据的方式会影响物理结构的设计&lt;/p>
&lt;ul>
&lt;li>如果某些操作过于复杂，要跨很多系统很多物理环境时，等待同步实时交易，不可控因素会很大，这时需采用异步方式，放弃实时性的好处，而追求更直接的健壮和稳定性&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>大规模的批处理，我们需要关注吞吐量&lt;/strong>&lt;/p>
&lt;p>&lt;strong>如何选择异步和同步&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>选择不同模式，是整个系统需求，以及所处理数据所在的&lt;strong>物理结构所决定&lt;/strong>的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>从性能的角度来说，如果&lt;strong>无需必要，可以不选择同步&lt;/strong>的方式。&lt;/p>
&lt;p>比如网络爬虫，天生就应该使用异步的方式，数据库多库之间的数据传输，也大概率应该采用异步的方式。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>往往采用批处理这种异步方式时，&lt;strong>很容易发现某些事情&lt;/strong>花的时间太长，也
就是异步的批处理方式，比较&lt;strong>容易发现问题&lt;/strong>，批处理系统一-直在压榨系统的
性能。&lt;/p>
&lt;p>&lt;strong>同步不容易发现问题&lt;/strong>，只有在高并发和大数据量时暴露，在最糟的时候才会暴露，会极大影响业务。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>尽量只在必须要同步的时候，才设计成同步，否则都可尝试使用异步模式&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="42存储层面的设计">4.2存储层面的设计&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227212319650.png" alt="image-20230227212319650" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>不需要考虑节点的协调问题。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227212331338.png" alt="image-20230227212331338" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>网格集群包括现在最重要的云计算等皆是采用数据分布式的模式，
经常提到的&lt;strong>OB数据库就是典型的分布式数据库&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>结构越复杂，健壮性越低&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>性能的杀手:对远程数据的透明访问&lt;/strong>&lt;/p>
&lt;p>原因:&lt;/p>
&lt;ul>
&lt;li>无论看起来有多透明，跨多个软件层或者网络层的代价都很高&lt;/li>
&lt;li>试试执行一个在本地数据表中插入几千行数据的代码，相对比的是，执行另一个跨机器的同样程序通过指向连接进行操作。差异是几倍的。&lt;/li>
&lt;li>来自不同数据源的分布式数据结合起来非常困难。比较数据源A和数据源B的数据，必须&lt;strong>拷贝A的数据到B&lt;/strong>，或者反过来，拷贝B的数据到A，无论怎样都要面对开销很大的数据传输的代价。&lt;/li>
&lt;/ul>
&lt;p>远程的数据拷贝，&lt;strong>脱离了数据源环境&lt;/strong>，就&lt;strong>不能从数据规划中获益&lt;/strong>&lt;/p>
&lt;p>理论上来说，查询本地数据最有效的方式是嵌套的循环，程序员知道最佳过滤条件分布，
优化器能快速定位和找到最好的查询计划。&lt;/p>
&lt;p>但如果部分数据位于远程，只能选择：&lt;/p>
&lt;ul>
&lt;li>使用嵌套的循环，每次循环开销很大&lt;/li>
&lt;li>建立远程数据的本地副本，然后操作该副本，但此副本没有任何索引&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>数据库该如何部署？&lt;/strong>&lt;/p>
&lt;p>&lt;strong>平衡&lt;/strong>，离数据越近，访问越快。&lt;/p>
&lt;p>&lt;strong>那为什么说分布式比集中式更快？&lt;/strong>&lt;/p>
&lt;p>因为&lt;strong>吞吐量&lt;/strong>，分布式吞吐量的上限高于集中式。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227212606684.png" alt="image-20230227212606684" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>分布式吞吐量优&lt;/p>
&lt;p>&lt;strong>总结&lt;/strong>&lt;/p>
&lt;p>讨论了进行数据库规划的基础知识，包括数据建模的基本原则，特别是规范化、字段设计、历史数据等等问题。&lt;/p>
&lt;p>以及在不同情况下，错误的设计是如何导致各种后果的。&lt;/p>
&lt;p>忽视基本设计原则，会导致性能问题，而解决这些问题会浪费惊人的精力和智慧。&lt;/p>
&lt;h2 id="81大尺度的问题">8.1大尺度的问题&lt;/h2>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227212741617.png" alt="image-20230227212741617" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>如果一个系统很大，可是还使用过去小尺度下的规则，就会出问题。&lt;/p>
&lt;p>一旦尺度变大，&lt;strong>就需要用工程化的方式去组织，花费更多的成本去协调。&lt;/strong>&lt;/p>
&lt;p>不可能用没有并发的系统，去应付高并发、大数据量场景。&lt;/p>
&lt;p>绝大多数人的编程技术和数据处理能力，都需要在更大的项目中去领悟去提高。&lt;/p>
&lt;p>一个软件系统，一个复杂的数据库，太容易出错。系统越复杂，出错的频率就不成比例地增加。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227212917499.png" alt="image-20230227212917499" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>timestamp不确定&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227212937661.png" alt="image-20230227212937661" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>一个数据库系统整体的工作如果是100%，实现业务需求，所需要的工作大概只有20%，剩下80%的工作是性能、监控、审计、备份、恢复、错误处理安全机制等一系列的工作。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227213016939.png" alt="image-20230227213016939" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227213036444.png" alt="image-20230227213036444" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227213052829.png" alt="image-20230227213052829" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227213106792.png" alt="image-20230227213106792" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227213124961.png" alt="image-20230227213124961" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227213214194.png" alt="image-20230227213214194" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227213226552.png" alt="image-20230227213226552" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>棘手问题
棘手问题不是用来解决的，它也许根本解决不了，只能应付。&lt;/p>
&lt;p>好的判断来自经验
而经验来自坏的判断&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227213342294.png" alt="image-20230227213342294" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%9F%BA%E7%A1%80/</guid><description>&lt;h1 id="知识图谱基础">知识图谱基础&lt;/h1>
&lt;h2 id="参考">参考&lt;/h2>
&lt;p>&lt;a href="https://www.cnblogs.com/huangyc/p/10043749.html" target="_blank" rel="noopener">通俗易懂解释知识图谱（Knowledge Graph）&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://support.huaweicloud.com/qs-kg/kg_05_0002.html" target="_blank" rel="noopener">华为最佳实践-快速构建知识图谱&lt;/a>&lt;/p>
&lt;h2 id="知识图谱技术架构">知识图谱技术架构&lt;/h2>
&lt;p>构建知识图谱的过程:&lt;/p>
&lt;ul>
&lt;li>信息抽取：从各种类型的数据源中提取出实体、属性以及实体间的相互关系，在此基础上形成本体化的知识表达；&lt;/li>
&lt;li>知识融合：在获得新知识之后，需要对其进行整合，以消除矛盾和歧义，比如某些实体可能有多种表达，某个特定称谓也许对应于多个不同的实体等；&lt;/li>
&lt;li>知识加工：对于经过融合的新知识，需要经过质量评估之后（部分需要人工参与甄别），才能将合格的部分加入到知识库中，以确保知识库的质量。&lt;/li>
&lt;/ul>
&lt;p>知识图谱在逻辑上可分为模式层与数据层两个层次。&lt;/p>
&lt;ul>
&lt;li>模式层构建在数据层之上，是知识图谱的核心，通常采用本体库来管理知识图谱的模式层。本体是结构化知识库的概念模板，通过本体库而形成的知识库不仅层次结构较强，并且冗余程度较小。&lt;/li>
&lt;/ul>
&lt;p>模式层：实体-关系-实体，实体-属性-属性值&lt;/p>
&lt;ul>
&lt;li>数据层主要是由一系列的事实组成，而知识将以事实为单位进行存储。如果用(实体1，关系，实体2)、(实体、属性，属性值)这样的三元组来表达事实，可选择图数据库作为存储介质，例如开源的Neo4j、Twitter的FlockDB、sones的GraphDB等。&lt;/li>
&lt;/ul>
&lt;p>数据层：比尔盖茨-妻子-梅琳达·盖茨，比尔盖茨-总裁-微软&lt;/p>
&lt;h3 id="信息提取">信息提取&lt;/h3>
&lt;p>步骤:&lt;/p>
&lt;ul>
&lt;li>实体抽取(Entity Extraction)
&lt;ul>
&lt;li>又称为命名实体识别（named entity recognition，NER），是指从文本数据集中自动识别出命名实体。&lt;/li>
&lt;li>这里的实体是抽象实体,如&amp;quot;电影&amp;quot;、&amp;ldquo;人物&amp;quot;等,而不是确切的实体对象。&lt;/li>
&lt;li>实体抽取的质量（准确率和召回率）对后续的知识获取效率和质量影响极大，因此是信息抽取中最为基础和关键的部分。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>关系抽取(Relation Extraction)&lt;/li>
&lt;li>属性抽取(Attribute Extraction)
&lt;ul>
&lt;li>这里理解的属性是指实体的特征，如&amp;quot;电影&amp;quot;的&amp;quot;导演&amp;rdquo;、&amp;ldquo;上映时间&amp;quot;等。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="知识融合">知识融合&lt;/h3>
&lt;p>步骤:&lt;/p>
&lt;ul>
&lt;li>实体链接: 是指对于从文本中抽取得到的实体对象，将其链接到知识库中对应的正确实体对象的操作。&lt;/li>
&lt;li>知识合并: 常见的知识合并需求有两个，一个是合并外部知识库，另一个是合并关系数据库。&lt;/li>
&lt;/ul>
&lt;h3 id="知识加工">知识加工&lt;/h3>
&lt;p>事实本身并不等于知识。要想最终获得结构化，网络化的知识体系，还需要经历知识加工的过程。&lt;/p>
&lt;ul>
&lt;li>本体构建
&lt;ul>
&lt;li>本体（ontology）是指工人的概念集合、概念框架，如“人”、“事”、“物”等。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>知识推理
&lt;ul>
&lt;li>在我们完成了本体构建这一步之后，一个知识图谱的雏形便已经搭建好了。但可能在这个时候，知识图谱之间大多数关系都是残缺的，缺失值非常严重，那么这个时候，我们就可以使用知识推理技术，去完成进一步的知识发现。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>质量评估
&lt;ul>
&lt;li>可以对知识的可信度进行量化，通过舍弃置信度较低的知识来保障知识库的质量。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="知识更新">知识更新&lt;/h3>
&lt;p>全面更新：指以更新后的全部数据为输入，从零开始构建知识图谱。这种方法比较简单，但资源消耗大，而且需要耗费大量人力资源进行系统维护；&lt;/p>
&lt;p>增量更新：以当前新增数据为输入，向现有知识图谱中添加新增知识。这种方式资源消耗小，但目前仍需要大量人工干预（定义规则等），因此实施起来十分困难。&lt;/p>
&lt;h2 id="知识图谱分类">知识图谱分类&lt;/h2>
&lt;p>而知识图谱在知识体系的层面上又有三种具体的组织分类，包括Ontology、Taxonomy和Folksonomy。&lt;/p>
&lt;p>层级关系的三种不同严格程度的区分。&lt;/p>
&lt;ul>
&lt;li>Ontology为树状结构，对不同层节点之间具有最严格的IsA关系
&lt;ul>
&lt;li>（打个比方，Human activities -&amp;gt; sports -&amp;gt; football），这类图谱的优点是便于&lt;strong>知识推理&lt;/strong>，但是&lt;strong>无法表示概念关系的多样性&lt;/strong>；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Taxonomy也是树状结构，但是层级严格程度低一些，节点间是以Hypernym-Hyponym关系构建，这样的好处的概念关系比较丰富，但是也因此容易造成歧义，很难有效地推理；
&lt;ul>
&lt;li>例: 广泛地用来表示互联网上的网络结构，比如：文件列表（想象一下本地文件左侧展示的文本目录）、购物网站搜索的分类、百科网站的目录（含一级标题，二级标题等）。换言之，taxonomy中的节点，往往是以Hypernym-Hyponym关系构建的。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Folksonomy则是非层级的结构，全部节点以标签分类，除了灵活以外，语义的精确性、推理能力也全都丧失了。&lt;/li>
&lt;/ul>
&lt;p>目前，Taxonomy的组织结构是互联网行业内较为流行的类型，因为它在一定程度上兼顾上下层关系和标签体系，在各类应用上的灵活性最好.&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E7%AE%97%E6%B3%95/acmer%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E7%AE%97%E6%B3%95/acmer%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98/</guid><description>&lt;h1 id="写在前面">写在前面&lt;/h1>
&lt;p>笔试上机题型基本是经典算法题，且难度最多leetcode hard。但面试的题目类型很多，如场景题、NP问题等没有最优解的问题。&lt;/p>
&lt;p>以下对求职面试算法题做整理，主要面向ACMer，是对比赛中不常见的算法题的补充。&lt;/p>
&lt;p>篇幅有限，仅给出简要思路，正解代码可选择该篇，或者自行搜索。背代码没用，经过思考后自己写一遍，面试时才能写出来。&lt;/p>
&lt;h1 id="经典算法题">经典算法题&lt;/h1>
&lt;h2 id="链表">链表&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="k">struct&lt;/span> &lt;span class="nc">node&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">x_&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">node&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">nex_&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">nullptr&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//需要初始化
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">node&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">x_&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">node&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="链表翻转-空间o1-时间on">链表翻转 空间O(1) 时间O(n)&lt;/h3>
&lt;p>&lt;a href="https://leetcode.cn/problems/reverse-linked-list-ii/" target="_blank" rel="noopener">例题&lt;/a>&lt;/p>
&lt;h3 id="归并排序链表on-时间onlogn">归并排序链表O(n) 时间O(nlogn)&lt;/h3>
&lt;p>&lt;a href="https://www.luogu.com.cn/problem/P1177" target="_blank" rel="noopener">例题&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">node&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="nf">merge&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">node&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">ha&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">node&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">hb&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">node&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">head&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">node&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">node&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">now&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">head&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">node&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">na&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">ha&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">nex_&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">node&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">nb&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">hb&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">nex_&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">na&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="k">nullptr&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">nb&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="k">nullptr&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">na&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">x_&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">nb&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">x_&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">now&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">nex_&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">na&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">na&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">na&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">nex_&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">now&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">nex_&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">nb&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">nb&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">nb&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">nex_&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">now&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">now&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">nex_&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">na&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="k">nullptr&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">now&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">nex_&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">na&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">nb&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="k">nullptr&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">now&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">nex_&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">nb&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">head&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">node&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="nf">sort&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">node&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">head&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">head&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">nex_&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="k">nullptr&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="n">head&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">nex_&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">nex_&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="k">nullptr&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">head&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// traverse(head);
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//split 交替
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">node&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">ha&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">head&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">node&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">hb&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">node&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">node&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">now&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">head&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">nex_&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">node&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">nb&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">hb&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">node&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">na&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">ha&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">bool&lt;/span> &lt;span class="n">oe&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">now&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="k">nullptr&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">oe&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">nb&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">nex_&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">now&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">nb&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">now&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">na&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">nex_&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">now&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">na&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">now&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">now&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">now&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">nex_&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">oe&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">!&lt;/span>&lt;span class="n">oe&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">na&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">nex_&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">nullptr&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">nb&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">nex_&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">nullptr&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">hb&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">sort&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">hb&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ha&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">sort&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ha&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// return head;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">merge&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ha&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">hb&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="数据结构树状数组">数据结构(树状数组)&lt;/h2>
&lt;h3 id="单点加区间和">单点加,区间和&lt;/h3>
&lt;p>&lt;a href="https://www.luogu.com.cn/problem/P3368" target="_blank" rel="noopener">树状数组1例题&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>&lt;span class="k">using&lt;/span> &lt;span class="k">namespace&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">typedef&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">ll&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">const&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">N&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mf">1e6&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">7&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">N&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">t&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">N&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">inline&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">lowbit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="o">&amp;amp;&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">k&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">k&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">k&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">lowbit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">t&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">sum&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">r&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">res&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">r&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">r&lt;/span> &lt;span class="o">-=&lt;/span> &lt;span class="n">lowbit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">res&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">t&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">res&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">sum&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">l&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">r&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">sum&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">sum&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">l&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">build&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//O(n)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">t&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">lowbit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">j&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">t&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">t&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">m&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">cin&lt;/span> &lt;span class="o">&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">n&lt;/span> &lt;span class="o">&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">m&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">scanf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%d&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">build&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">m&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">op&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">scanf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%d&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">op&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">op&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">k&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">scanf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%d%d&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">k&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">l&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">r&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">scanf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%d%d&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%d&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">sum&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">r&lt;/span>&lt;span class="p">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="区间改单点查">区间改,单点查&lt;/h3>
&lt;p>&lt;a href="https://www.luogu.com.cn/problem/P3368" target="_blank" rel="noopener">树状数组2例题&lt;/a>&lt;/p>
&lt;p>把原数组不做任何处理.
树状数组维护一个前缀和数组(初始为0).&lt;/p>
&lt;p>把区改变成端点处的单改
单查变成区查&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>&lt;span class="k">using&lt;/span> &lt;span class="k">namespace&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">typedef&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">ll&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">const&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">N&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mf">1e6&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">7&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">N&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">t&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">N&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">inline&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">lowbit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="o">&amp;amp;&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">k&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">k&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">k&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">lowbit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">t&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">l&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">r&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//要使得 sum(r) - sum(l-1) 加了x的话，需要在l处+x，同时在r+1处-x
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">r&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">ll&lt;/span> &lt;span class="nf">sum&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">r&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ll&lt;/span> &lt;span class="n">res&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">r&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">r&lt;/span> &lt;span class="o">-=&lt;/span> &lt;span class="n">lowbit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">res&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">t&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">res&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">m&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">cin&lt;/span> &lt;span class="o">&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">n&lt;/span> &lt;span class="o">&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">m&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">scanf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%d&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">m&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">op&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">scanf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%d&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">op&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">op&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">k&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">scanf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%d%d%d&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">k&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">scanf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%d&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%lld&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">sum&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="排序">排序&lt;/h2>
&lt;p>&lt;a href="https://www.luogu.com.cn/problem/P1177" target="_blank" rel="noopener">例题&lt;/a>&lt;/p>
&lt;h3 id="手写快排">手写快排&lt;/h3>
&lt;h3 id="归并排序求逆序对">归并排序(求逆序对)&lt;/h3>
&lt;p>&lt;a href="https://www.luogu.com.cn/problem/P1908" target="_blank" rel="noopener">求逆序对&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>&lt;span class="k">using&lt;/span> &lt;span class="k">namespace&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">typedef&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">ll&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">const&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">N&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mf">5e6&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">7&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">ll&lt;/span> &lt;span class="n">ans&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="n">tmp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">N&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">N&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">merge&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">l&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">r&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">mid&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">ti&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">l&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">li&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">l&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">ri&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">mid&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">li&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">mid&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">ri&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">r&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">lw&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">li&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">rw&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">ri&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">lw&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">rw&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">tmp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">ti&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">li&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">tmp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">ti&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">ri&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//按理来说，右边的数组应该在左边所有都放完再放
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//因此，如果提前放了，那么剩下左边有多少个没放的 都 和它组成一个逆序对
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//即 mid-li+1
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">ans&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">mid&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">li&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">li&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">mid&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">tmp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">ti&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">li&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">ri&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">r&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">tmp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">ti&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">ri&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">l&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">r&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">a&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">tmp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">sort&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">l&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">r&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">l&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="n">r&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// cout &amp;lt;&amp;lt; l &amp;lt;&amp;lt; &amp;#34; &amp;#34; &amp;lt;&amp;lt; r &amp;lt;&amp;lt; endl;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">mid&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">l&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">r&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">sort&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">l&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">mid&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">sort&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">mid&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">r&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">merge&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">l&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">r&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">mid&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">cin&lt;/span> &lt;span class="o">&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">scanf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%d&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">sort&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">cout&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">ans&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="第k大数-on">第k大数 O(n)&lt;/h3>
&lt;p>&lt;a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">例题&lt;/a>
补充: 第K大数,而不是第K个不同的数.&lt;/p>
&lt;p>和求排序后的第k个数本质一致,转换一下即可.&lt;/p>
&lt;h4 id="思路">思路&lt;/h4>
&lt;p>回忆一下二分法和快排:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>二分法形成一棵二叉树. 每层所有序列长度总和为n, 二叉树高度为h, 时间复杂度为 O(n*h)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>最优的情况: 每个结点的左儿子和右儿子序列长度相等. h = logn, 时间复杂度为O(n*logn)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>因此快排最优是O(n*logn)&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h4 id="如何优化到on">如何优化到O(n)&lt;/h4>
&lt;p>显然, 对于求排序后第k个数. 在二分时,每次可以只选择一个儿子继续搜索.&lt;/p>
&lt;p>即在最优情况下,每次二分结果为 l,mid,r&lt;/p>
&lt;ul>
&lt;li>mid == k ,答案就是a[mid]&lt;/li>
&lt;li>mid &amp;gt; k, 只需要继续在 (l,mid-1)中搜&lt;/li>
&lt;li>mid &amp;lt; k, 只需要继续在 (mid+1,r)中搜&lt;/li>
&lt;/ul>
&lt;p>因此与快排形成的二叉树不同. 该方法每层的搜索总长度是递减的.&lt;/p>
&lt;p>即 n + n/2 + n/4 + n/8 + &amp;hellip;&lt;/p>
&lt;p>易得上述公式的近似为 2*n, 时间复杂度O(n)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">int findk(int* a, int l, int r, int k)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">{
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> while (1) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> int flagi = (l + r) / 2;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> swap(a[flagi], a[l]);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> int i = l, j = r;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> int flag = a[i];
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> while (i &amp;lt; j) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> while (i &amp;lt; j &amp;amp;&amp;amp; a[j] &amp;gt;= flag)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> j--;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> a[i] = a[j];
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> while (i &amp;lt; j &amp;amp;&amp;amp; a[i] &amp;lt;= flag)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> i++;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> a[j] = a[i];
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> a[i] = flag;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> if (i == k)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> return a[i];
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> else if (i &amp;lt; k) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> l = i + 1;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> } else {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> r = i - 1;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="串">串&lt;/h2>
&lt;h3 id="字符串全排列httpsleetcodecnproblemszi-fu-chuan-de-pai-lie-lcof">&lt;a href="https://leetcode.cn/problems/zi-fu-chuan-de-pai-lie-lcof/" target="_blank" rel="noopener">字符串全排列&lt;/a>&lt;/h3>
&lt;h3 id="最长回文子串---on">最长回文子串&amp;ndash; O(n)&lt;/h3>
&lt;p>思路:&lt;a href="https://blog.csdn.net/qq_51116518/article/details/117370554" target="_blank" rel="noopener">马拉车算法&lt;/a>&lt;/p>
&lt;h4 id="证明on">证明O(n):&lt;/h4>
&lt;p>即证while内的p[i]++ 执行次数总和为O(n)级别&lt;/p>
&lt;p>首先考虑什么情况下才需要进入while循环&lt;/p>
&lt;ul>
&lt;li>i &amp;lt; mx, 且 i 为 id 所在回文串的右四等分点之后.
&lt;ul>
&lt;li>此时p[i]是以mx-i 开始增加, 即i + p[i] &amp;gt;= mx&lt;/li>
&lt;li>也就是while内的操作每执行一次 mx++&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>i &amp;gt; mx, 无法使用之前的预处理.
&lt;ul>
&lt;li>while内的操作没执行一次 mx++&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>可知while的操作次数等于 mx从0加到n-1的次数, 因此while内操作次数的总和为n&lt;/p>
&lt;p>总时间复杂度 O(n)&lt;/p>
&lt;h2 id="动态规划非背包">动态规划(非背包)&lt;/h2>
&lt;h3 id="最长公共连续子序列-onm">最长公共连续子序列 O(nm)&lt;/h3>
&lt;h3 id="最长上升子序列-onlogn">最长上升子序列 O(nlogn)&lt;/h3>
&lt;p>思路:动态规划+二分&lt;/p>
&lt;h2 id="背包类">背包类&lt;/h2>
&lt;p>货币面值组成&lt;/p>
&lt;h3 id="砝码称重httpswwwacwingcomproblemcontentdescription3420-on--s">&lt;a href="https://www.acwing.com/problem/content/description/3420/" target="_blank" rel="noopener">砝码称重&lt;/a> O(n * s)&lt;/h3>
&lt;p>题意：有天平和 N 个砝码重量是 Wi。可以称出多少种不同的重量？砝码可以放在天平两边。&lt;/p>
&lt;p>N&amp;lt;100 ,Σwi &amp;lt; 1e5&lt;/p>
&lt;p>思路：&lt;/p>
&lt;p>01背包， 称重为i的可以从 abs(i-w) ， i+w 中转移。 不过要注意开个滚动数组防止重复放砝码。&lt;/p>
&lt;h2 id="数学题">数学题&lt;/h2>
&lt;h4 id="小凯的疑惑">小凯的疑惑&lt;/h4>
&lt;h1 id="实现题">实现题&lt;/h1>
&lt;h2 id="实现vector">实现vector&lt;/h2>
&lt;p>构造，析构，push_back，operator[]，resize，reserve&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c++" data-lang="c++">&lt;span class="line">&lt;span class="cl">&lt;span class="k">template&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="k">typename&lt;/span> &lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">Vector&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">private&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">T&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">size&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">capacity&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">public&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Vector&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">size&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">capacity&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">data&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">T&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">capacity&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">~&lt;/span>&lt;span class="n">Vector&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">delete&lt;/span>&lt;span class="p">[]&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">void&lt;/span> &lt;span class="nf">push_back&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">T&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">size&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">capacity&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">reserve&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">capacity&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">data&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">size&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">T&lt;/span>&lt;span class="o">&amp;amp;&lt;/span> &lt;span class="k">operator&lt;/span>&lt;span class="p">[](&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">void&lt;/span> &lt;span class="nf">resize&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">capacity&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">reserve&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">size&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">void&lt;/span> &lt;span class="nf">reserve&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">capacity&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">capacity&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">T&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">new_data&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">T&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">capacity&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">size&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">new_data&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">delete&lt;/span>&lt;span class="p">[]&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">data&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">new_data&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="实现哈希表">实现哈希表&lt;/h2>
&lt;p>实现：put/get，在总数超过factor时扩容&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">template&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="k">typename&lt;/span> &lt;span class="n">K&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">typename&lt;/span> &lt;span class="n">V&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">HashTable&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">private&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">struct&lt;/span> &lt;span class="nc">Node&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">K&lt;/span> &lt;span class="n">key&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">V&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Node&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">next&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Node&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">K&lt;/span> &lt;span class="n">k&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">V&lt;/span> &lt;span class="n">v&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">key&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">k&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">value&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">v&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">next&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">nullptr&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Vector&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Node&lt;/span>&lt;span class="o">*&amp;gt;*&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">capacity&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">size&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">double&lt;/span> &lt;span class="n">factor&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="nf">hash&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">K&lt;/span> &lt;span class="n">key&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">key&lt;/span> &lt;span class="o">%&lt;/span> &lt;span class="n">capacity&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">public&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">HashTable&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">cap&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mf">1e6&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">double&lt;/span> &lt;span class="n">f&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mf">0.75&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">capacity&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">cap&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">factor&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">f&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">size&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">data&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Vector&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Node&lt;/span>&lt;span class="o">*&amp;gt;&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">capacity&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">~&lt;/span>&lt;span class="n">HashTable&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">delete&lt;/span>&lt;span class="p">[]&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">void&lt;/span> &lt;span class="nf">put&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">K&lt;/span> &lt;span class="n">key&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">V&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">h&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">hash&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">h&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">size&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">h&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">key&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">key&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">data&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">h&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">value&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">data&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">h&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">push_back&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">new&lt;/span> &lt;span class="n">Node&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">size&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">size&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">capacity&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">factor&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">resize&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">capacity&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">V&lt;/span> &lt;span class="nf">get&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">K&lt;/span> &lt;span class="n">key&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">h&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">hash&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">h&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">size&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">h&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">key&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">key&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">h&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">V&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">void&lt;/span> &lt;span class="nf">resize&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">new_capacity&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Vector&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Node&lt;/span>&lt;span class="o">*&amp;gt;*&lt;/span> &lt;span class="n">new_data&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Vector&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Node&lt;/span>&lt;span class="o">*&amp;gt;&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">new_capacity&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">capacity&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">size&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">j&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">h&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">hash&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">new_data&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">h&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">push_back&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">delete&lt;/span>&lt;span class="p">[]&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">data&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">new_data&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">capacity&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">new_capacity&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="stl用法">STL用法&lt;/h1>
&lt;p>&lt;a href="https://www.luogu.com.cn/article/ig60mcky" target="_blank" rel="noopener">Vector代替平衡树&lt;/a>
1.插入一个数 x。
2.删除一个数 x(若有多个相同的数，应只删除一个)
3.查询 x 的排名(定义排名为比当前数小的数的个数+1)
4.查询数据结构中排名为 x 的数。
5.求 x 的前驱(前驱定义为小于x，且最大的数)
6.求 x 的后继(后继定义为大于x，且最小的数)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="n">scanf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%d%d&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">op&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">op&lt;/span>&lt;span class="o">==&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">insert&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">upper_bound&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">begin&lt;/span>&lt;span class="p">(),&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">end&lt;/span>&lt;span class="p">(),&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">op&lt;/span>&lt;span class="o">==&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">erase&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">lower_bound&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">begin&lt;/span>&lt;span class="p">(),&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">end&lt;/span>&lt;span class="p">(),&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">op&lt;/span>&lt;span class="o">==&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%d&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">lower_bound&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">begin&lt;/span>&lt;span class="p">(),&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">end&lt;/span>&lt;span class="p">(),&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">begin&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">op&lt;/span>&lt;span class="o">==&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%d&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">op&lt;/span>&lt;span class="o">==&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%d&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">*--&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">lower_bound&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">begin&lt;/span>&lt;span class="p">(),&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">end&lt;/span>&lt;span class="p">(),&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">)));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">op&lt;/span>&lt;span class="o">==&lt;/span>&lt;span class="mi">6&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%d&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">upper_bound&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">begin&lt;/span>&lt;span class="p">(),&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">end&lt;/span>&lt;span class="p">(),&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">)));&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>vector的查找和插入&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">bool&lt;/span> &lt;span class="nf">cmp&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">a1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">a2&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">a1&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">a2&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">vector&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="n">in&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">lower_bound&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">begin&lt;/span>&lt;span class="p">(),&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">end&lt;/span>&lt;span class="p">(),&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">cmp&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">begin&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="思维题">思维题&lt;/h1>
&lt;h4 id="小球称重问题">小球称重问题&lt;/h4>
&lt;p>8个小球，其中1个偏重，1个天平，要秤几次才能找到重的球？&lt;/p>
&lt;p>2次&lt;/p>
&lt;ul>
&lt;li>两边各放3个
&lt;ul>
&lt;li>如果相同重
&lt;ul>
&lt;li>剩下两个第二次必测得出&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>如果其中第一次其中一边重的话
&lt;ul>
&lt;li>就把那3个挑两个出来&lt;/li>
&lt;li>如果一样重剩下那个就是重 否则直接就测出来&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="开关问题">开关问题&lt;/h3>
&lt;p>三个开关放在一个房间里面，另一个房间有灯泡。问你：如何在只进出有灯泡的房间一次，就可以判断出三个开关中具体哪一个是控制该灯泡的&lt;/p>
&lt;p>A：打开一个开关，等一会儿，然后关闭它。然后打开另一个开关，然后进入房间。如果灯泡亮着，那么是第二个开关。如果灯泡是暗的，摸一下灯泡。如果灯泡是热的，那么是第一个开关。如果灯泡是冷的，那么是第三个开关。&lt;/p>
&lt;h1 id="np问题">NP问题&lt;/h1>
&lt;h2 id="集合覆盖问题">集合覆盖问题&lt;/h2>
&lt;h1 id="杂项">杂项&lt;/h1>
&lt;h3 id="随机加权采样算法-aliashttpsleetcodecnproblemsrandom-pick-with-weight">&lt;a href="https://leetcode.cn/problems/random-pick-with-weight/" target="_blank" rel="noopener">随机加权采样算法 alias&lt;/a>&lt;/h3>
&lt;p>&lt;a href="https://www.cnblogs.com/Lee-yl/p/12749070.html" target="_blank" rel="noopener">https://www.cnblogs.com/Lee-yl/p/12749070.html&lt;/a>&lt;/p>
&lt;h1 id="杂谈后话">杂谈后话&lt;/h1>
&lt;p>写一点求职的经验和所见所闻吧！&lt;strong>不保证时效性和真实性，参考与否自行斟酌&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>面评记录对求职的影响&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>针对人群：想&lt;strong>刷面试经验&lt;/strong>，而&lt;strong>不是真正急着找工作的&lt;/strong>。&lt;/li>
&lt;li>请&lt;strong>珍惜每次面试机会&lt;/strong>，尤其是面试喜欢的公司时。&lt;/li>
&lt;li>面试一般都会有记录和面试评价。&lt;/li>
&lt;li>所见所闻：大佬A大二时投递了理想公司的实习，意图刷该公司的面试经验。结果表现不佳，导致在真正需要找实习的时候，因之前的面评太差，导致没过简历/排序靠后（记不太清了）&lt;/li>
&lt;/ul></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E7%AE%97%E6%B3%95/%E6%99%BA%E5%8A%9B%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E7%AE%97%E6%B3%95/%E6%99%BA%E5%8A%9B%E9%A2%98/</guid><description>&lt;h1 id="智力题">智力题&lt;/h1>
&lt;p>&lt;a href="https://www.cnblogs.com/XJT2018/p/11539661.html" target="_blank" rel="noopener">https://www.cnblogs.com/XJT2018/p/11539661.html&lt;/a>&lt;/p>
&lt;p>8个小球，其中1个偏重，1个天平，要秤几次才能找到重的球？&lt;/p>
&lt;p>2次&lt;/p>
&lt;ul>
&lt;li>两边各放3个
&lt;ul>
&lt;li>如果相同重
&lt;ul>
&lt;li>剩下两个第二次必测得出&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>如果其中第一次其中一边重的话
&lt;ul>
&lt;li>就把那3个挑两个出来&lt;/li>
&lt;li>如果一样重剩下那个就是重 否则直接就测出来&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>A和B面前有个N个石头，A必须先手，每人每次最多拿3个最少拿1个，请问N在什么情况下，A可以必胜，必胜的策略是？&lt;/p>
&lt;p>N是4的倍数&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E7%AE%97%E6%B3%95/%E7%AC%94%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E7%AE%97%E6%B3%95/%E7%AC%94%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98/</guid><description>&lt;p>1.已知平面上的一个圆和若干点 快速求出包含点数最少的多边形使得圆在多边形中&lt;/p>
&lt;p>预处理：圆内的点删去&lt;/p>
&lt;p>点排序，按照射线的角度排序。O(nlogn)&lt;/p>
&lt;p>如黑色的三个点要排序，就是按与圆相切的射线的角度排序。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="%e7%ac%94%e8%af%95%e7%ae%97%e6%b3%95%e9%a2%98/img/image-20230414155250711.png" alt="image-20230414155250711" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>把每一个点当作起点贪心。&lt;/p>
&lt;p>每次贪心：&lt;/p>
&lt;p>​ 从一个S出发，选择一个点T ，点T角度最大，且满足ST与圆不相交 且 圆心在ST射线的右侧。（即顺时针）然后再以T点出发，选择下一个点，直到遍历过的角度大于360度。每次选择 logn，最多选择n次，因此每次贪心是nlogn。&lt;/p>
&lt;p>做n次贪心，总时间复杂度是n^2logn&lt;/p>
&lt;p>给出一无序数组 求所有长度大于等于k的连续子序列的中位数的最大值 定义中位数为第&lt;a href="%e5%90%91%e4%b8%8a%e5%8f%96%e6%95%b4">l/2&lt;/a>(l为数组长度)个数&lt;/p>
&lt;p>二分答案，从小到大排序后二分，选择X为中位数。判断是否有大于等于X的中位数满足条件。&lt;/p>
&lt;p>预处理数组为 -1 ， 0 ， 1（小于X，等于X，大于X），On跑一遍找是否有长度大于K的和大于等于0。 求前缀和并维护最小前缀和即可。&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/</guid><description/></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E7%BC%93%E5%AD%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E7%BC%93%E5%AD%98/</guid><description/></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</guid><description>&lt;p>分布式事务的中间件Seata&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/</guid><description>&lt;h2 id="经典问题">经典问题&lt;/h2>
&lt;p>拜占庭将军问题
描述： 一组将军围攻一座城市，他们需要达成一致的决策，但是其中一些将军可能是叛徒，他们会向其他将军发送错误的信息。这个问题的目标是找到一种算法，使得所有忠诚的将军能够达成一致的决策，即使有叛徒存在。
经典设置：&lt;/p>
&lt;ol>
&lt;li>每个将军都是一个节点，他们之间通过消息进行通信。&lt;/li>
&lt;li>每个将军都有一个二值的决策，即攻击或者撤退。&lt;/li>
&lt;li>每个将军都知道自己是不是叛徒，但是不知道其他将军是不是叛徒。&lt;/li>
&lt;li>叛徒将军可以发送错误的消息。&lt;/li>
&lt;li>总共有m个将军，其中n个是忠诚的，m-n个是叛徒。&lt;/li>
&lt;li>问题的目标是找到一种算法，使得所有忠诚的将军能够达成一致的决策，即使有叛徒存在。&lt;/li>
&lt;/ol>
&lt;h2 id="cap--base理论">CAP &amp;amp; Base理论&lt;/h2>
&lt;p>CAP理论是分布式系统设计中的一个重要理论，它指出在一个分布式系统中，一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）这三个要素不可兼得，最多只能同时满足其中的两个。&lt;/p>
&lt;ul>
&lt;li>一致性（Consistency）：在分布式系统中的所有节点上的数据是一致的，即一个节点上的数据发生了变化，那么在其他节点上也应该立即发生变化。&lt;/li>
&lt;li>可用性（Availability）：分布式系统中的所有节点都能够正常响应客户端的请求。&lt;/li>
&lt;li>分区容错性（Partition tolerance）：分布式系统中的节点之间可能会因为网络分区而无法通信，分区容错性指的是系统能够继续工作，即使节点之间无法通信。&lt;/li>
&lt;/ul>
&lt;p>网络分区: 分布式系统中，多个节点之间的网络本来是连通的，但是因为某些故障（比如部分节点网络出了问题）某些节点之间不连通了，整个网络就分成了几块区域，这就叫 网络分区。&lt;/p>
&lt;p>CAP一般要满足两个，而P是必须的，所以CAP理论一般是AP或者CP。&lt;/p>
&lt;ul>
&lt;li>CP：HBase、MongoDB等分布式数据库是CP系统，它要求数据一致性和分区容错性，但是无法保证所有节点的可用性。&lt;/li>
&lt;li>AP：Cassandra、DynamoDB等分布式数据库是AP系统，它要求可用性和分区容错性，但是无法保证数据一致性。&lt;/li>
&lt;/ul>
&lt;p>注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小。&lt;/p>
&lt;p>常见的可以作为注册中心的组件有：ZooKeeper、Eureka、Nacos&lt;/p>
&lt;p>ZooKeeper保证的是CP，Eureka保证的是AP，Nacos既可以保证CP也可以保证AP。&lt;/p>
&lt;h2 id="分布式算法">分布式算法&lt;/h2>
&lt;p>Paxos算法&lt;/p>
&lt;p>Raft算法&lt;/p>
&lt;h2 id="分布式id">分布式ID&lt;/h2>
&lt;p>一个最基本的分布式 ID 需要满足下面这些要求：&lt;/p>
&lt;ul>
&lt;li>全局唯一：ID 的全局唯一性肯定是首先要满足的！&lt;/li>
&lt;li>高性能：分布式 ID 的生成速度要快，对本地资源消耗要小。&lt;/li>
&lt;li>高可用：生成分布式 ID 的服务要保证可用性无限接近于 100%。&lt;/li>
&lt;li>方便易用：拿来即用，使用方便，快速接入！&lt;/li>
&lt;/ul>
&lt;h3 id="解决方案">解决方案&lt;/h3>
&lt;h4 id="数据库主键自增">数据库主键自增&lt;/h4>
&lt;p>基于数据库的号段模式来生成分布式 ID。&lt;/p>
&lt;p>NoSQL 方案使用 Redis 多一些。我们通过 Redis 的 incr 命令即可实现对 id 原子顺序递增&lt;/p>
&lt;h4 id="uuid">UUID&lt;/h4>
&lt;p>UUID 是 Universally Unique Identifier（通用唯一标识符） 的缩写。UUID 包含 32 个 16 进制数字（8-4-4-4-12）。JDK 就提供了现成的生成 UUID&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//输出示例：cb4a9ede-fa5e-4585-b9bb-d60bce986eaa&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">UUID&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">randomUUID&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="开源框架-雪花算法号段模式">开源框架 雪花算法/号段模式&lt;/h4>
&lt;ul>
&lt;li>雪花算法&lt;/li>
&lt;/ul>
&lt;p>雪花算法是 Twitter 开源的分布式 ID 生成算法，其核心思想是：使用一个 64 位的 long 型的数字作为全局唯一 ID。在雪花算法中，64 位 long 型的数字中，其中 1 位是不用的，然后用其中的 41 位作为毫秒数，用 10 位作为工作机器 id，12 位作为序列号。&lt;/p>
&lt;ul>
&lt;li>号段模式&lt;/li>
&lt;/ul>
&lt;p>号段模式是数据库号段模式的一种变种，号段模式的核心思想是：每次从数据库中取一段 id，然后在内存中递增生成 id，当这一段 id 用完了之后，再去数据库中取一段 id。&lt;/p>
&lt;h2 id="分布式锁">分布式锁&lt;/h2>
&lt;p>如何才能实现共享资源的互斥访问呢？ 锁是一个比较通用的解决方案，更准确点来说是悲观锁。&lt;/p>
&lt;p>一个最基本的分布式锁需要满足：&lt;/p>
&lt;p>互斥：任意一个时刻，锁只能被一个线程持有。
高可用：锁服务是高可用的，当一个锁服务出现问题，能够自动切换到另外一个锁服务。并且，即使客户端的释放锁的代码逻辑出现问题，锁最终一定还是会被释放，不会影响其他线程对共享资源的访问。这一般是通过超时机制实现的。
可重入：一个节点获取了锁之后，还可以再次获取锁。
除了上面这三个基本条件之外，一个好的分布式锁还需要满足下面这些条件：&lt;/p>
&lt;p>高性能：获取和释放锁的操作应该快速完成，并且不应该对整个系统的性能造成过大影响。
非阻塞：如果获取不到锁，不能无限期等待，避免对系统正常运行造成影响。&lt;/p>
&lt;h3 id="实现方式">实现方式&lt;/h3>
&lt;p>常见分布式锁实现方案如下：&lt;/p>
&lt;p>基于关系型数据库比如 MySQL 实现分布式锁。
基于分布式协调服务 ZooKeeper 实现分布式锁。
基于分布式键值存储系统比如 Redis 、Etcd 实现分布式锁。
关系型数据库的方式一般是通过唯一索引或者排他锁实现。不过，一般不会使用这种方式，问题太多比如性能太差、不具备锁失效机制。&lt;/p>
&lt;p>基于 ZooKeeper 或者 Redis 实现分布式锁这两种实现方式要用的更多一些，我专门写了一篇文章来详细介绍这两种方案：分布式锁常见实现方案总结。&lt;/p>
&lt;h2 id="分布式事务">分布式事务&lt;/h2>
&lt;p>两阶段提交是一种常用的分布式事务处理协议,它分为以下两个阶段:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>准备阶段(Phase 1):&lt;/p>
&lt;ul>
&lt;li>协调者(Coordinator)询问参与者(Participant)是否准备好提交事务。&lt;/li>
&lt;li>参与者检查自己是否准备好提交,并反馈给协调者。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>提交阶段(Phase 2):&lt;/p>
&lt;ul>
&lt;li>如果所有参与者都准备好了,协调者会发出提交命令。&lt;/li>
&lt;li>参与者执行提交操作,并向协调者发送提交完成通知。&lt;/li>
&lt;li>协调者收到所有参与者的提交完成通知后,整个事务提交成功。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>在你描述的场景中,协调者在收到参与者提交完成通知后挂掉了,这种情况下参与者可以采取以下措施:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>重试:参与者可以尝试重复发送提交完成通知,直到协调者恢复。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>超时重试:如果长时间没有收到协调者的响应,参与者可以假设协调者已经挂掉,启动超时恢复机制。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>手动介入:如果前两种方法无法解决,可能需要人工介入,检查系统状态并决定如何进行事务恢复。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>使用日志:参与者可以记录事务的执行状态和结果,以便在协调者恢复后重现事务处理过程。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>总之,两阶段提交协议提供了一种可靠的分布式事务处理机制,但在某些极端情况下,如协调者故障,参与者需要采取一定的措施来保证事务的一致性和完整性。&lt;/p>
&lt;p>分布式事务的中间件Seata&lt;/p>
&lt;h2 id="todo-分布式缓存">TODO: 分布式缓存&lt;/h2>
&lt;h3 id="一致性哈希算法">一致性哈希算法&lt;/h3>
&lt;h3 id="redis使用的哈希槽">Redis使用的哈希槽&lt;/h3></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%AD%98%E5%82%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%AD%98%E5%82%A8/</guid><description/></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%A1%86%E6%9E%B6hadoop/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%A1%86%E6%9E%B6hadoop/</guid><description/></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/</guid><description>&lt;h2 id="nacos">Nacos&lt;/h2></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</guid><description>&lt;h1 id="消息队列">消息队列&lt;/h1>
&lt;h2 id="mq的作用">MQ的作用&lt;/h2>
&lt;h3 id="解耦">解耦&lt;/h3>
&lt;p>场景：A订单系统，B库存系统，A下单后需要减少库存。
传统做法：A调用B的接口。
问题：&lt;/p>
&lt;ul>
&lt;li>B无法访问时，A的操作将失败&lt;/li>
&lt;li>A需要知道B的存在，如果B接口需要修改时，A也需要修改&lt;/li>
&lt;/ul>
&lt;p>消息队列：A只与消息队列交互，不直接与B交互&lt;/p>
&lt;ul>
&lt;li>B的系统崩溃和更改对A没有关系&lt;/li>
&lt;/ul>
&lt;h3 id="异步">异步&lt;/h3>
&lt;p>场景：A下单后，需要B发送短信和C发送邮件&lt;/p>
&lt;p>传统做法：&lt;/p>
&lt;ul>
&lt;li>串行：A下单后，调用B发送短信，B发送成功后调用C发送邮件&lt;/li>
&lt;li>并行：A下单后，调用B发送短信，同时调用C发送邮件&lt;/li>
&lt;/ul>
&lt;p>问题：&lt;/p>
&lt;ul>
&lt;li>A的等待时间过长，且BC不是必须的业务逻辑&lt;/li>
&lt;/ul>
&lt;p>消息队列&lt;/p>
&lt;ul>
&lt;li>A下单后，发送消息到消息队列，B和C监听消息队列，收到消息后发送短信和邮件&lt;/li>
&lt;li>这样A不需要等待BC的操作，提高了响应速度&lt;/li>
&lt;/ul>
&lt;h3 id="流量削峰">流量削峰&lt;/h3>
&lt;p>场景：秒杀活动，瞬间大量请求&lt;/p>
&lt;p>传统做法：&lt;/p>
&lt;ul>
&lt;li>直接请求，导致系统崩溃&lt;/li>
&lt;li>限流，丢弃部分请求&lt;/li>
&lt;/ul>
&lt;p>消息队列&lt;/p>
&lt;ul>
&lt;li>请求先发送到消息队列，然后慢慢处理&lt;/li>
&lt;li>如果消息队列处理不过来，可以通过增加消费者来处理&lt;/li>
&lt;li>如果消息队列过长才会丢弃部分请求&lt;/li>
&lt;/ul>
&lt;h3 id="消息通信">消息通信&lt;/h3>
&lt;p>点对点通信：客户端A和客户端B都使用同一个队列，A发送消息到队列，B从队列中取出消息&lt;/p>
&lt;p>聊天室通信：客户端A，客户端B，客户端N订阅同一主题，进行消息发布和接收。实现类似聊天室效果。&lt;/p>
&lt;h3 id="日志处理">日志处理&lt;/h3>
&lt;p>使用消息队列完成日志处理&lt;/p>
&lt;ul>
&lt;li>日志采集客户端，负责日志数据采集，定时写受写入Kafka队列&lt;/li>
&lt;li>Kafka消息队列，负责日志数据的接收，存储和转发&lt;/li>
&lt;li>日志处理应用：订阅并消费kafka队列中的日志数据&lt;/li>
&lt;/ul>
&lt;h2 id="mq的问题">MQ的问题&lt;/h2>
&lt;p>保证高可用&lt;/p>
&lt;p>重复消费消息问题&lt;/p>
&lt;p>消息丢失问题&lt;/p>
&lt;p>消费的顺序性问题&lt;/p>
&lt;p>分布式事务问题&lt;/p>
&lt;p>消息堆积问题&lt;/p>
&lt;h2 id="三个消息队列的区别">三个消息队列的区别&lt;/h2>
&lt;p>RabbitMQ、Kafka和RocketMQ是三种不同特点的开源消息队列系统，各自适用于不同的场景。总结如下：&lt;/p>
&lt;ul>
&lt;li>RabbitMQ适用于需要可靠消息传递和灵活消息模型的场景，具有丰富的插件和社区支持。&lt;/li>
&lt;li>Kafka适用于高吞吐量、低延迟的实时数据处理和事件驱动架构场景，具有良好的可伸缩性和持久性。&lt;/li>
&lt;li>RocketMQ适用于高性能、高可用性的消息传递场景，具有丰富的消息过滤和分布式事务特性。&lt;/li>
&lt;/ul>
&lt;h2 id="kafka">Kafka&lt;/h2>
&lt;p>是一个分布式流式处理平台&lt;/p>
&lt;p>RocketMQ 的消息模型和 Kafka 基本是完全一样的。唯一的区别是 Kafka 中没有队列这个概念，与之对应的是 Partition（分区）。&lt;/p>
&lt;h2 id="rocketmq">RocketMQ&lt;/h2>
&lt;p>使用主题模型&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97/RocketMQ%e7%9a%84%e4%b8%bb%e9%a2%98%e6%a8%a1%e5%9e%8b.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>主题中会存在多个队列&lt;/p>
&lt;p>多个队列可以提高并发能力&lt;/p>
&lt;p>每个主题中都有多个队列(分布在不同的 Broker中，如果是集群的话，Broker又分布在不同的服务器中)，集群消费模式下，一个消费者集群多台机器共同消费一个 topic 的多个队列，一个队列只会被一个消费者消费。&lt;/p>
&lt;p>一般来讲要控制 消费者组中的消费者个数和主题中队列个数相同 。&lt;/p>
&lt;p>每个消费组在每个队列上维护一个消费位置
每次消费者组消费完会返回一个成功的响应，然后队列再把维护的消费位移加一，这样就不会出现刚刚消费过的消息再一次被消费了。&lt;/p>
&lt;h3 id="rocketmq结构">RocketMQ结构&lt;/h3>
&lt;p>Broker：主要负责消息的存储、投递和查询以及服务高可用保证。&lt;/p>
&lt;ul>
&lt;li>说白了就是消息队列服务器嘛，生产者生产消息到 Broker ，消费者从 Broker 拉取消息并消费。&lt;/li>
&lt;li>一个 Topic 分布在多个 Broker上，一个 Broker 可以配置多个 Topic ，它们是多对多的关系。&lt;/li>
&lt;/ul>
&lt;p>NameServer：注册中心&lt;/p>
&lt;ul>
&lt;li>主要提供两个功能：Broker 管理 和 路由信息管理 。&lt;/li>
&lt;li>说白了就是 Broker 会将自己的信息注册到 NameServer 中，此时 NameServer 就存放了很多 Broker 的信息(Broker 的路由表)，消费者和生产者就从 NameServer 中获取路由表然后照着路由表的信息和对应的 Broker 进行通信(生产者和消费者定期会向 NameServer 去查询相关的 Broker 的信息)。&lt;/li>
&lt;/ul>
&lt;p>Producer：消息发布的角色，支持分布式集群方式部署。说白了就是生产者。&lt;/p>
&lt;p>Consumer：消息消费的角色，支持分布式集群方式部署。支持以 push 推，pull 拉两种模式对消息进行消费。同时也支持集群方式和广播方式的消费，它提供实时消息订阅机制。说白了就是消费者。&lt;/p>
&lt;h3 id="消息类型">消息类型&lt;/h3>
&lt;p>普通消息&lt;/p>
&lt;p>定时消息&lt;/p>
&lt;p>顺序消息
Apache RocketMQ 保证相同消息组的消息存储在同一个队列中，如果不同业务场景的消息都集中在少量或一个消息组中，则这些消息存储压力都会集中到服务端的少量队列或一个队列中。&lt;/p>
&lt;p>事务消息&lt;/p>
&lt;h3 id="解决顺序问题">解决顺序问题&lt;/h3>
&lt;p>普通顺序模式 ，我们从上面学习知道了在 Producer 生产消息的时候会进行轮询(取决你的负载均衡策略)来向同一主题的不同消息队列发送消息。&lt;/p>
&lt;p>如果有几个消息分别是同一个订单的创建、支付、发货，在轮询的策略下这 &lt;strong>三个消息会被发送到不同队列&lt;/strong> ，因为在不同的队列此时就无法使用 RocketMQ 带来的队列有序特性来保证消息有序性了。&lt;/p>
&lt;p>解决方法: 将同一语义下的消息放入同一个队列(比如这里是同一个订单)&lt;/p>
&lt;p>队列选择算法:&lt;/p>
&lt;ul>
&lt;li>轮询&lt;/li>
&lt;li>最小投递延迟, 选择队列时优先选择消息延时小的队列，导致消息分布不均匀,按照如下设置即可&lt;/li>
&lt;/ul>
&lt;h3 id="分布式事务">分布式事务&lt;/h3>
&lt;p>RocketMQ 提供了事务消息 + 事务反查的机制来保证分布式事务的最终一致性。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97/RocketMQ%e5%ae%9e%e7%8e%b0%e5%88%86%e5%b8%83%e5%bc%8f%e4%ba%8b%e5%8a%a1.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>half消息: 在事务提交之前, 对于消费者来说是不可见的消息&lt;/p>
&lt;blockquote>
&lt;p>如何做到写入消息但是对用户不可见呢？RocketMQ 事务消息的做法是：如果消息是 half 消息，将备份原消息的主题与消息消费队列，然后 改变主题 为 RMQ_SYS_TRANS_HALF_TOPIC。由于消费组未订阅该主题，故消费端无法消费 half 类型的消息
RocketMQ 会开启一个定时任务，从 Topic 为 RMQ_SYS_TRANS_HALF_TOPIC 中拉取消息进行消费，根据生产者组获取一个服务提供者发送回查事务状态请求，根据事务状态来决定是提交或回滚消息。&lt;/p>
&lt;/blockquote>
&lt;h3 id="消费堆积问题">消费堆积问题&lt;/h3>
&lt;p>产生消息堆积的原因——生产者生产太快或者消费者消费太慢&lt;/p>
&lt;p>当流量到峰值的时候是因为生产者生产太快&lt;/p>
&lt;ul>
&lt;li>可以使用一些 限流降级 的方法&lt;/li>
&lt;li>可以增加多个消费者实例去水平扩展增加消费能力来匹配生产的激增。&lt;/li>
&lt;/ul>
&lt;p>如果消费者消费过慢的话&lt;/p>
&lt;ul>
&lt;li>先检查 是否是消费者出现了大量的消费错误&lt;/li>
&lt;li>打印一下日志查看是否是哪一个线程卡死，出现了锁资源不释放等等的问题。&lt;/li>
&lt;/ul>
&lt;h4 id="rocketmq的回溯消息">RocketMQ的回溯消息&lt;/h4>
&lt;p>回溯消费是指 Consumer 已经消费成功的消息，由于业务上需求需要重新消费，在RocketMQ 中， Broker 在向Consumer 投递成功消息后，消息仍然需要保留 。并且重新消费一般是按照时间维度，例如由于 Consumer 系统故障，恢复后需要重新消费 1 小时前的数据，那么 Broker 要提供一种机制，可以按照时间维度来回退消费进度。RocketMQ 支持按照时间回溯消费，时间维度精确到毫秒。&lt;/p>
&lt;h3 id="rocketmq的刷盘时机">RocketMQ的刷盘时机&lt;/h3>
&lt;p>在同步刷盘中需要等待一个刷盘成功的 ACK ，同步刷盘对 MQ 消息可靠性来说是一种不错的保障，但是 性能上会有较大影响 ，一般地适用于金融等特定业务场景。&lt;/p>
&lt;p>异步刷盘往往是开启一个线程去异步地执行刷盘操作。消息刷盘采用后台异步线程提交的方式进行， 降低了读写延迟 ，提高了 MQ 的性能和吞吐量，一般适用于如发验证码等对于消息保证要求不太高的业务场景。一般地，异步刷盘只有在 Broker 意外宕机的时候会丢失部分数据&lt;/p>
&lt;p>同步复制和异步复制&lt;/p>
&lt;ul>
&lt;li>同步复制：也叫 “同步双写”，也就是说，只有消息同步双写到主从节点上时才返回写入成功 。&lt;/li>
&lt;li>异步复制：消息写入主节点之后就直接返回写入成功 。
&lt;ul>
&lt;li>异步复制&lt;strong>不会&lt;/strong>像异步刷盘那样影响消息的可靠性&lt;/li>
&lt;li>但无法保证 严格顺序&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="rocketmq的存储机制">RocketMQ的存储机制&lt;/h3>
&lt;p>RocketMQ 消息存储架构中的三大角色——CommitLog、ConsumeQueue 和 IndexFile&lt;/p>
&lt;p>CommitLog：消息主体以及元数据的存储主体，存储 Producer 端写入的消息主体内容&lt;/p>
&lt;p>ConsumeQueue：消息消费队列，存储消息的消费队列，存储 Consumer 端消费的消息&lt;/p>
&lt;p>IndexFile：消息索引文件，存储消息的索引信息，用于快速检索消息&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97/RocketMQ%e7%9a%84%e5%ad%98%e5%82%a8%e7%bb%93%e6%9e%84.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>左边的生产者发送消息会指定 Topic、QueueId 和具体消息内容，而在 Broker 中管你是哪门子消息，他直接 &lt;strong>全部顺序存储到了 CommitLog&lt;/strong>。&lt;/p>
&lt;p>根据生产者指定的 Topic 和 QueueId 将这条消息本身在 CommitLog 的偏移(offset)，消息本身大小，和 tag 的 hash 值存入对应的 ConsumeQueue 索引文件中&lt;/p>
&lt;p>消费者拉取消息进行消费的时候只需要根据 ConsumeOffset 获取下一个未被消费的消息就行了。&lt;/p>
&lt;h2 id="rabbitmq">RabbitMQ&lt;/h2>
&lt;p>AMQP，即Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件同产品、不同的开发语言等条件的限制。&lt;/p>
&lt;h3 id="底层原理">底层原理&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97/RabbitMQ%e5%ba%95%e5%b1%82.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;ul>
&lt;li>Producer：消息生产者，负责生产消息，然后发送给 RabbitMQ 服务器.&lt;/li>
&lt;li>Exchange：消息交换机，接收生产者发送的消息，然后将消息发送给队列。&lt;/li>
&lt;li>Queue：消息队列，存储生产者发送的消息。&lt;/li>
&lt;li>Consumer：消息消费者，从队列中获取消息，进行消费。&lt;/li>
&lt;/ul>
&lt;p>Exchange(交换器) 有 4 种类型，不同的类型对应着不同的路由策略：direct(默认)，fanout, topic, 和 headers，&lt;/p>
&lt;p>生产者将消息发给交换器的时候，一般会指定一个 RoutingKey(路由键)，用来&lt;strong>指定这个消息的路由规则&lt;/strong>，当 BindingKey 和 RoutingKey 相匹配时，消息会被路由到对应的队列中&lt;/p>
&lt;p>多个消费者可以订阅同一个队列，这时队列中的消息会被平均分摊（Round-Robin，即轮询）给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理，这样避免消息被重复消费。RabbitMQ 不支持队列层面的广播消费,如果有广播消费的需求，需要在其上进行二次开发,这样会很麻烦，不建议这样做&lt;/p>
&lt;h3 id="死信队列">死信队列&lt;/h3>
&lt;h3 id="保证消费一致性">保证消费一致性&lt;/h3>
&lt;p>只有RocketMQ支持事务消息。&lt;/p>
&lt;h3 id="保证不重复消费幂等性问题">保证不重复消费（幂等性问题）？&lt;/h3>
&lt;p>想要保证不重复消费，其实还要结合业务来思考，这里给几个思路：&lt;/p>
&lt;p>比如你拿个数据要写库，你先根据主键查一下，如果这数据都有了，你就别插入了，update一下。&lt;/p>
&lt;p>比如你是写redis，那没问题了，反正每次都是set，天然幂等性。&lt;/p>
&lt;p>比如你不是上面两个场景，那做的稍微复杂一点，你需要让生产者发送每条数据的时候，里面加一个全局唯一的id，类似订单id之类的东西，然后你这里消费到了之后，先根据这个id去比如redis里查一下，之前消费过吗？如果没有消费过，你就处理，然后这个id写redis。如果消费过了，那你就别处理了，保证别重复处理相同的消息即可。&lt;/p>
&lt;p>还有比如基于数据库的唯一键来保证重复数据不会重复插入多条，我们之前线上系统就有这个问题，就是拿到数据的时候，每次重启可能会有重复，因为kafka消费者还没来得及提交offset，重复数据拿到了以后我们插入的时候，因为有唯一键约束了，所以重复数据只会插入报错，不会导致数据库中出现脏数据。&lt;/p>
&lt;h3 id="保证消息的顺序性">保证消息的顺序性？&lt;/h3>
&lt;p>RabbitMQ 的问题是由于不同的消息都发送到了同一个 queue 中，多个消费者都消费同一个 queue 的消息。&lt;/p>
&lt;p>拆分多个 queue(消息队列)，每个 queue(消息队列) 一个 consumer(消费者)，就是多一些 queue (消息队列)而已，确实是麻烦点；&lt;/p>
&lt;p>或者就一个 queue (消息队列)但是对应一个 consumer(消费者)，然后这个 consumer(消费者)内部用内存队列做排队，然后分发给底层不同的 worker 来处理。&lt;/p>
&lt;h3 id="实现延迟队列">实现延迟队列&lt;/h3>
&lt;p>消息被发送以后，并不想让消费者立刻拿到消息，而是等待特定时间后，消费者才能拿到这个消息进行消费。&lt;/p>
&lt;p>RabbitMQ本身没有延迟队列的实现&lt;/p>
&lt;p>RabbitMQ实现延迟队列的两种方式：&lt;/p>
&lt;ul>
&lt;li>死信交换机（Exchange）和消息的存活时间 TTL（Time To Live）。&lt;/li>
&lt;li>3.5.7 及以上的版本提供了一个插件（rabbitmq-delayed-message-exchange）来实现延迟队列功能。同时，插件依赖 Erlang/OPT 18.0 及以上。&lt;/li>
&lt;/ul>
&lt;h3 id="推拉">推拉&lt;/h3>
&lt;p>推模式：&lt;/p>
&lt;p>推模式是服务器端根据用户需要，由目的、按时将用户感兴趣的信息主动发送到用户的客户端。&lt;/p>
&lt;p>优点：&lt;/p>
&lt;p>对用户要求低，方便用户获取需要的信息；&lt;/p>
&lt;p>及时性好，服务器端及时地向客户端推送更新动态信息，吞吐量大。&lt;/p>
&lt;p>缺点：&lt;/p>
&lt;p>不能确保发送成功，推模式采用广播方式，只有服务器端和客户端在同一个频道上，推模式才有效，用户才能接收到信息；&lt;/p>
&lt;p>没有信息状态跟踪，推模式采用开环控制技术，一个信息推送后的状态，比如客户端是否接收等，无从得知；&lt;/p>
&lt;p>针对性较差。推送的信息可能并不能满足客户端的个性化需求。&lt;/p>
&lt;p>拉模式：&lt;/p>
&lt;p>拉模式是客户端主动从服务器端获取信息。&lt;/p>
&lt;p>优点：&lt;/p>
&lt;p>针对性强，能满足客户端的个性化需求；&lt;/p>
&lt;p>信息传输量较小，网络中传输的只是客户端的请求和服务器端对该请求的响应；&lt;/p>
&lt;p>服务器端的任务轻。服务器端只是被动接收查询，对客户端的查询请求做出响应。&lt;/p>
&lt;p>缺点：&lt;/p>
&lt;p>实时性较差，针对于服务器端实时更新的信息，客户端难以获取实时信息；&lt;/p>
&lt;p>对于客户端用户的要求较高，需要对服务器端具有一定的了解。&lt;/p>
&lt;h3 id="消息队列如何保证消息不丢">消息队列如何保证消息不丢&lt;/h3>
&lt;p>丢数据一般分为两种，一种是mq把消息丢了，一种就是消费时将消息丢了。下面从rabbitmq和kafka分别说一下，丢失数据的场景。&lt;/p>
&lt;p>RabbitMQ丢失消息分为如下几种情况：&lt;/p>
&lt;h4 id="生产者丢消息">生产者丢消息&lt;/h4>
&lt;ul>
&lt;li>
&lt;p>生产者将数据发送到RabbitMQ的时候，可能在传输过程中因为网络等问题而将数据弄丢了。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>可以选择使用RabbitMQ提供是&lt;strong>事务功能&lt;/strong>，就是生产者在发送数据之前开启事务，然后发送消息，如果消息没有成功被RabbitMQ接收到，那么生产者会受到异常报错，这时就可以回滚事务，然后尝试重新发送。如果收到了消息，那么就可以提交事务。这种方式有明显的缺点，即RabbitMQ事务开启后，就会变为同步阻塞操作，生产者会阻塞等待是否发送成功，太耗性能会造成吞吐量的下降。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>可以开启&lt;strong>confirm模式&lt;/strong>。在生产者那里设置开启了confirm模式之后，每次写的消息都会分配一个唯一的id，然后如何写入了RabbitMQ之中，RabbitMQ会给你回传一个ack消息，告诉你这个消息发送OK了。如果RabbitMQ&lt;strong>没能处理这个消息，会回调你一个nack接口&lt;/strong>，告诉你这个消息失败了，你可以进行重试。而且你可以结合这个机制知道自己在内存里维护每个消息的id，如果超过一定时间还没接收到这个消息的回调，那么你可以进行重发。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>事务机制是同步的，你提交了一个事物之后会阻塞住，但是confirm机制是异步的，发送消息之后可以接着发送下一个消息，然后RabbitMQ会回调告知成功与否。 一般在生产者这块避免丢失，都是用confirm机制。&lt;/p>
&lt;h4 id="rabbitmq自己丢消息">RabbitMQ自己丢消息&lt;/h4>
&lt;ul>
&lt;li>如果没有开启RabbitMQ的持久化，那么RabbitMQ一旦重启数据就丢了。&lt;/li>
&lt;li>所以必须&lt;strong>开启持久化将消息持久化到磁盘&lt;/strong>，这样就算RabbitMQ挂了，恢复之后会自动读取之前存储的数据，一般数据不会丢失。除非极其罕见的情况，RabbitMQ还没来得及持久化自己就挂了，这样可能导致一部分数据丢失。&lt;/li>
&lt;/ul>
&lt;p>设置消息持久化到磁盘，设置持久化有两个步骤：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>创建queue的时候将其设置为持久化的，这样就可以保证RabbitMQ持久化queue的元数据，但是不会持久化queue里面的数据。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>发送消息的时候讲消息的deliveryMode设置为2，这样消息就会被设为持久化方式，此时RabbitMQ就会将消息持久化到磁盘上。 必须要同时开启这两个才可以。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>而且持久化可以跟生产的confirm机制配合起来，只有消息持久化到了磁盘之后，才会通知生产者ack，这样就算是在持久化之前RabbitMQ挂了，数据丢了，生产者收不到ack回调也会进行消息重发。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h4 id="消费端丢消息">消费端丢消息&lt;/h4>
&lt;p>主要是因为消费者消费时，刚消费到还没有处理，结果消费者就挂了，这样你重启之后，RabbitMQ就认为你已经消费过了，然后就丢了数据。&lt;/p>
&lt;p>&lt;strong>使用RabbitMQ提供的ack机制&lt;/strong>，首先关闭RabbitMQ的自动ack，然后每次在确保处理完这个消息之后，在代码里手动调用ack。这样就可以避免消息还没有处理完就ack。&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F/%E7%BD%91%E5%85%B3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F/%E7%BD%91%E5%85%B3/</guid><description>&lt;h1 id="api网关">API网关&lt;/h1>
&lt;p>网关主要做了两件事情：请求转发 + 请求过滤。&lt;/p>
&lt;p>绝大部分网关可以提供下面这些功能（有一些功能需要借助其他框架或者中间件）：&lt;/p>
&lt;p>请求转发：将请求转发到目标微服务。
负载均衡：根据各个微服务实例的负载情况或者具体的负载均衡策略配置对请求实现动态的负载均衡。
安全认证：对用户请求进行身份验证并仅允许可信客户端访问 API，并且还能够使用类似 RBAC 等方式来授权。
参数校验：支持参数映射与校验逻辑。
日志记录：记录所有请求的行为日志供后续使用。
监控告警：从业务指标、机器指标、JVM 指标等方面进行监控并提供配套的告警机制。
流量控制：对请求的流量进行控制，也就是限制某一时刻内的请求数。
熔断降级：实时监控请求的统计信息，达到配置的失败阈值后，自动熔断，返回默认值。
响应缓存：当用户请求获取的是一些静态的或更新不频繁的数据时，一段时间内多次请求获取到的数据很可能是一样的。对于这种情况可以将响应缓存起来。这样用户请求可以直接在网关层得到响应数据，无需再去访问业务服务，减轻业务服务的负担。
响应聚合：某些情况下用户请求要获取的响应内容可能会来自于多个业务服务。网关作为业务服务的调用方，可以把多个服务的响应整合起来，再一并返回给用户。
灰度发布：将请求动态分流到不同的服务版本（最基本的一种灰度发布）。
异常处理：对于业务服务返回的异常响应，可以在网关层在返回给用户之前做转换处理。这样可以把一些业务侧返回的异常细节隐藏，转换成用户友好的错误提示返回。
API 文档： 如果计划将 API 暴露给组织以外的开发人员，那么必须考虑使用 API 文档，例如 Swagger 或 OpenAPI。
协议转换：通过协议转换整合后台基于 REST、AMQP、Dubbo 等不同风格和实现技术的微服务，面向 Web Mobile、开放平台等特定客户端提供统一服务。
证书管理：将 SSL 证书部署到 API 网关，由一个统一的入口管理接口，降低了证书更换时的复杂度。&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F/%E8%AE%A1%E7%AE%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F/%E8%AE%A1%E7%AE%97/</guid><description>&lt;h1 id="分布式计算">分布式计算&lt;/h1>
&lt;ul>
&lt;li>MapReduce&lt;/li>
&lt;li>Spark&lt;/li>
&lt;li>Flink&lt;/li>
&lt;/ul>
&lt;h2 id="mapreduce">MapReduce&lt;/h2>
&lt;p>MapReduce是一种编程模型，用于处理大规模数据集的并行计算。它由两个主要阶段组成：Map阶段和Reduce阶段。在Map阶段，输入数据集被划分为多个独立的数据块，然后由Map函数处理。在Reduce阶段，Map阶段的输出被分组，然后由Reduce函数处理。&lt;/p>
&lt;p>相关论文：&lt;a href="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/mapreduce-osdi04.pdf" target="_blank" rel="noopener">MapReduce: Simplified Data Processing on Large Clusters&lt;/a>&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F/%E9%80%9A%E4%BF%A1rpc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F/%E9%80%9A%E4%BF%A1rpc/</guid><description>&lt;h1 id="rpc">RPC&lt;/h1>
&lt;p>RPC（Remote Procedure Call） 即远程过程调用，通过名字我们就能看出 RPC 关注的是远程调用而非本地调用。&lt;/p>
&lt;p>整个 RPC 的 核心功能看作是下面 👇 5 个部分实现的：&lt;/p>
&lt;p>客户端（服务消费端）：调用远程方法的一端。
客户端 Stub（桩）：这其实就是一代理类。代理类主要做的事情很简单，就是把你调用方法、类、方法参数等信息传递到服务端。
网络传输：网络传输就是你要把你调用的方法的信息比如说参数啊这些东西传输到服务端，然后服务端执行完之后再把返回结果通过网络传输给你传输回来。网络传输的实现方式有很多种比如最基本的 Socket 或者性能以及封装更加优秀的 Netty（推荐）。
服务端 Stub（桩）：这个桩就不是代理类了。我觉得理解为桩实际不太好，大家注意一下就好。这里的服务端 Stub 实际指的就是接收到客户端执行方法的请求后，去执行对应的方法然后返回结果给客户端的类。
服务端（服务提供端）：提供远程方法的一端。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%80%9a%e4%bf%a1%28RPC%29/RPC%e5%8e%9f%e7%90%86%e5%9b%be.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;a href="https://xie.infoq.cn/article/eda414b9ee0f2b11437b546d6" target="_blank" rel="noopener">https://xie.infoq.cn/article/eda414b9ee0f2b11437b546d6&lt;/a>&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%AE%89%E5%85%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%AE%89%E5%85%A8/</guid><description/></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%AE%9E%E6%88%98%E6%A2%B3%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%AE%9E%E6%88%98%E6%A2%B3%E7%90%86/</guid><description>&lt;h1 id="实战梳理">实战梳理&lt;/h1>
&lt;h2 id="高性能设计">高性能设计&lt;/h2>
&lt;h3 id="cdn">CDN&lt;/h3>
&lt;h3 id="负载均衡">负载均衡&lt;/h3>
&lt;p>服务端负载均衡&lt;/p>
&lt;p>应用于系统外部 和 网关层 中间,&lt;/p>
&lt;p>软件负载均衡 。软件负载均衡通过软件（比如 LVS、Nginx、HAproxy ）实现负载均衡功能&lt;/p>
&lt;p>硬件负载均衡 。硬件负载均衡通过硬件设备（比如 F5、Radware ）实现负载均衡功能&lt;/p>
&lt;p>四层负载均衡 工作在 OSI 模型第四层，也就是传输层.&lt;/p>
&lt;ul>
&lt;li>能够看到数据包里的源端口地址以及目的端口地址，会基于这些信息通过一定的负载均衡算法将数据包转发到后端真实服务器。&lt;/li>
&lt;/ul>
&lt;p>执行第七层负载均衡的设备通常被称为 反向代理服务器 。&lt;/p>
&lt;ul>
&lt;li>核心是报文内容（如 URL、Cookie）层面的负载均衡&lt;/li>
&lt;/ul>
&lt;p>客户端负载均衡&lt;/p>
&lt;p>主要应用于系统内部的不同的服务之间，可以使用现成的负载均衡组件来实现。
Dubbo 属于是默认自带了负载均衡功能&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%ae%9e%e6%88%98%e6%a2%b3%e7%90%86/%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h4 id="负载均衡算法">负载均衡算法&lt;/h4>
&lt;p>随机算法: 有一个比较明显的缺陷：部分机器在一段时间之内无法被随机到，毕竟是概率算法，就算是大家权重一样， 也可能会出现这种情况。&lt;/p>
&lt;p>轮询法: 没有配置权重的话，每个请求按时间顺序逐一分配到不同的服务器处理。如果配置权重的话，权重越高的服务器被访问的次数就越多&lt;/p>
&lt;p>两次随机法: 两次随机算法是在随机算法的基础上进行了改进，通过两次随机选择来提高随机性，减少因随机数分布不均匀而导致的性能问题。&lt;/p>
&lt;p>哈希算法: 根据客户端 IP 地址或者请求 URL 计算哈希值，然后对服务器列表的大小进行取模运算，得到的结果就是要访问的服务器序号。&lt;/p>
&lt;p>一致性哈希法: 一致性哈希算法是一种分布式算法，主要用于负载均衡。一致性哈希算法的基本思想是将整个哈希值空间组织成一个虚拟的圆环，&lt;/p>
&lt;p>最小连接数法: 最小连接数法是根据后端服务器的当前连接情况来决定请求应该分发到哪一台服务器上，选择当前连接数最少的服务器来处理当前请求。&lt;/p>
&lt;p>加权最小连接数法: 加权最小连接数法是在最小连接数法的基础上增加了权重的概念，权重越高的服务器被选中的概率越大。&lt;/p>
&lt;p>最快响应时间法: 最快响应时间法是根据后端服务器的响应时间来决定请求应该分发到哪一台服务器上，选择响应时间最短的服务器来处理当前请求。&lt;/p>
&lt;h4 id="七层负载均衡解决方案">七层负载均衡解决方案&lt;/h4>
&lt;p>DNS 解析&lt;/p>
&lt;p>反向代理。&lt;/p>
&lt;h3 id="数据库优化">数据库优化&lt;/h3>
&lt;h3 id="消息队列">消息队列&lt;/h3>
&lt;h2 id="高可用设计">高可用设计&lt;/h2>
&lt;h2 id="典型问题">典型问题&lt;/h2>
&lt;h3 id="百万用户抢券的系统设计">百万用户抢券的系统设计&lt;/h3>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s/iZ9BX6cCCp_TB-SC3knuew" target="_blank" rel="noopener">字节高并发优惠券系统&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://juejin.cn/post/6844903847031226382" target="_blank" rel="noopener">如何设计一个百万级用户的抽奖系统？&lt;/a>&lt;/p>
&lt;h4 id="负载均衡层限流">负载均衡层限流&lt;/h4>
&lt;ol>
&lt;li>配置过滤脚本&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>判断如果同一个用户在1分钟之内多次发送请求来进行抽奖，就认为是恶意重复抽奖，或者是他们自己写的脚本在刷奖，这种流量一律认为是无效流量，在负载均衡设备那个层次就给直接屏蔽掉。&lt;/li>
&lt;li>使得请求的QPS为真实的用户数&lt;/li>
&lt;/ul>
&lt;ol start="2">
&lt;li>开奖后暴力拦截&lt;/li>
&lt;/ol>
&lt;p>1000个券，可能有1000万人来抢，但是只有1000个券，所以在券抢完后，就可以直接拦截所有请求，不再进行后续的处理。&lt;/p>
&lt;p>即拦截无效流量
做到50万人一起请求，结果就可能2万请求到了后台的Tomcat抽奖服务中，48万请求直接拦截掉了。&lt;/p>
&lt;p>可以通过Redis来共享抽奖状态&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%ae%9e%e6%88%98%e6%a2%b3%e7%90%86/Redis%e5%85%b1%e4%ba%ab%e6%8a%bd%e5%a5%96%e7%8a%b6%e6%80%81.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h4 id="服务层">服务层&lt;/h4>
&lt;p>线程数优化，选择合适的线程数&lt;/p>
&lt;p>用Redis代替MySQL实现业务逻辑&lt;/p>
&lt;h5 id="限流削峰">限流削峰&lt;/h5>
&lt;p>如果确实发放几w以上的奖品，那么抽奖服务还会调用礼品服务。&lt;/p>
&lt;p>而礼品服务等后续服务可能非常耗时，且不易扩展部署。&lt;/p>
&lt;p>可以通过消息中间件进行流量削峰，将抽奖服务和礼品服务解耦，礼品服务可以慢慢处理，不会影响抽奖服务的性能。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%ae%9e%e6%88%98%e6%a2%b3%e7%90%86/%e6%b5%81%e9%87%8f%e5%89%8a%e5%b3%b0%e5%90%8e.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>秒杀&lt;/p>
&lt;p>rpc调用的流程&lt;/p>
&lt;p>如何实现注册中心的高可用&lt;/p>
&lt;p>十亿条淘宝购买记录，怎么获取出现最多的前十个&lt;/p>
&lt;p>这是一道典型的有限内存的海量数据处理的题目。一般这类题目的解答无非是以下几种：&lt;/p>
&lt;p>分治，hash映射，堆排序，双层桶划分，Bloom Filter，bitmap，数据库索引，mapreduce等。&lt;/p>
&lt;p>具体情形都有很多不同的方案。这类题目可以到网上搜索一下，了解下套路，后面就基本都会了。&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/</guid><description>&lt;h1 id="编译原理基础">编译原理基础&lt;/h1>
&lt;h2 id="概述">概述&lt;/h2>
&lt;p>&lt;a href="https://messiahhh.github.io/blog/docs/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" target="_blank" rel="noopener">编译原理概述&lt;/a>&lt;/p>
&lt;p>编译原理是计算机科学的一个重要分支，它研究如何将高级语言翻译成机器语言。编译原理的研究内容包括词法分析、语法分析、语义分析、中间代码生成、代码优化和目标代码生成等。&lt;/p>
&lt;ul>
&lt;li>词法分析：词法分析器将源程序中的字符序列转换成单词序列，单词是语言中的基本单位，如标识符、关键字、运算符、界符等。&lt;/li>
&lt;li>语法分析：语法分析器将单词序列转换成语法树。&lt;/li>
&lt;li>语义分析：语义分析器对语法树进行语义检查，如类型检查、作用域检查等。&lt;/li>
&lt;li>中间代码生成：中间代码是一种抽象的机器语言，它比源程序更接近机器语言，但比机器语言更容易理解。&lt;/li>
&lt;li>代码优化：代码优化器对中间代码进行优化，以提高程序的性能。&lt;/li>
&lt;li>目标代码生成：目标代码生成器将中间代码转换成目标机器的机器语言。&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://juejin.cn/post/7080832945136599077" target="_blank" rel="noopener">以Babel和V8来举例&lt;/a>&lt;/p>
&lt;p>编译器的前端&lt;/p>
&lt;ul>
&lt;li>词法分析&lt;/li>
&lt;li>语法分析&lt;/li>
&lt;li>语义分析&lt;/li>
&lt;li>中间代码(IR)生成&lt;/li>
&lt;/ul>
&lt;p>编译器的后端&lt;/p>
&lt;ul>
&lt;li>代码优化&lt;/li>
&lt;li>目标代码生成&lt;/li>
&lt;/ul>
&lt;h2 id="编译器后端框架">编译器后端框架&lt;/h2>
&lt;p>&lt;a href="https://freegeektime.com/100034101/153192/" target="_blank" rel="noopener">后端技术的重用：LLVM&lt;/a>&lt;/p>
&lt;p>编译器后端功能&lt;/p>
&lt;h3 id="编译优化">编译优化&lt;/h3>
&lt;p>SSA&lt;/p>
&lt;h3 id="目标代码生成">目标代码生成&lt;/h3>
&lt;p>LLVM和GCC&lt;/p>
&lt;ul>
&lt;li>GCC是GNU Compiler Collection的缩写，是一个由GNU开发的编译器套件，它支持多种编程语言，如C、C++、Fortran、Java等。&lt;/li>
&lt;li>LLVM是Low Level Virtual Machine的缩写，是一个编译器基础设施，它包括编译器、汇编器、链接器等，支持多种编程语言，如C、C++、Rust、Swift等。&lt;/li>
&lt;li>LLVM和GCC都是开源软件，它们都是编译器后端的框架，可以用来开发编译器。&lt;/li>
&lt;/ul>
&lt;h3 id="llvm----low-level-virtual-machine">llvm &amp;ndash; Low Level Virtual Machine&lt;/h3></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E7%BD%91%E7%BB%9C/http/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E7%BD%91%E7%BB%9C/http/</guid><description>&lt;h1 id="http">HTTP&lt;/h1>
&lt;h2 id="结构">结构&lt;/h2>
&lt;h3 id="请求报文结构">请求报文结构&lt;/h3>
&lt;p>客户端发送一个请求报文给服务器，服务器根据请求报文中的信息进行处理，并将处理结果放入响应报文中返回给客户端。&lt;/p>
&lt;p>请求报文结构：&lt;/p>
&lt;p>第一行是包含了请求方法、URL、协议版本；
接下来的多行都是请求首部 Header，每个首部都有一个首部名称，以及对应的值。
一个空行用来分隔首部和内容主体 Body
最后是请求的内容主体&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-md" data-lang="md">&lt;span class="line">&lt;span class="cl">GET http://www.example.com/ HTTP/1.1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Accept-Encoding: gzip, deflate
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Accept-Language: zh-CN,zh;q=0.9,en;q=0.8
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Cache-Control: max-age=0
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Host: www.example.com
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">If-Modified-Since: Thu, 17 Oct 2019 07:18:26 GMT
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">If-None-Match: &amp;#34;3147526947+gzip&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Proxy-Connection: keep-alive
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Upgrade-Insecure-Requests: 1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">User-Agent: Mozilla/5.0 xxx
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">param1=1&lt;span class="err">&amp;amp;&lt;/span>param2=2
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="响应报文结构">响应报文结构&lt;/h3>
&lt;p>第一行包含协议版本、状态码以及描述，最常见的是 200 OK 表示请求成功了
接下来多行也是首部内容
一个空行分隔首部和内容主体
最后是响应的内容主体&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-md" data-lang="md">&lt;span class="line">&lt;span class="cl">HTTP/1.1 200 OK
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Age: 529651
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Cache-Control: max-age=604800
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Connection: keep-alive
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Content-Encoding: gzip
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Content-Length: 648
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Content-Type: text/html; charset=UTF-8
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Date: Mon, 02 Nov 2020 17:53:39 GMT
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Etag: &amp;#34;3147526947+ident+gzip&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Expires: Mon, 09 Nov 2020 17:53:39 GMT
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Keep-Alive: timeout=4
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Last-Modified: Thu, 17 Oct 2019 07:18:26 GMT
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Proxy-Connection: keep-alive
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Server: ECS (sjc/16DF)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Vary: Accept-Encoding
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">X-Cache: HIT
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&amp;lt;!doctype html&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">html&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">head&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">title&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>Example Domain&lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">title&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // 省略...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">body&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">html&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="请求方法">请求方法&lt;/h3>
&lt;p>HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD 方法。&lt;/p>
&lt;p>HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。&lt;/p>
&lt;p>按照RFC的定义:&lt;/p>
&lt;ul>
&lt;li>GET：请求指定的页面信息，并返回实体主体。&lt;/li>
&lt;li>HEAD：类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头。&lt;/li>
&lt;li>POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。&lt;/li>
&lt;li>PUT：从客户端向服务器传送的数据取代指定的文档的内容。&lt;/li>
&lt;li>DELETE：请求服务器删除指定的页面。&lt;/li>
&lt;li>CONNECT：HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。&lt;/li>
&lt;/ul>
&lt;p>如果遵守RFC的定义去实现，那么 GET 方法就是安全且幂等的, POST 方法就是不安全且非幂等的。&lt;/p>
&lt;p>这里的安全: GET方法是只读的，不会改变服务器的状态.&lt;/p>
&lt;p>幂等: 对同一URL的多次请求，返回的结果是一样的&lt;/p>
&lt;ul>
&lt;li>因此可以对幂等的GET请求做缓存, 缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），而且在浏览器中 GET 请求可以保存为书签。&lt;/li>
&lt;/ul>
&lt;p>实际实现中:&lt;/p>
&lt;ul>
&lt;li>是否幂等和安全，不是由方法本身决定的，而是由程序员的实现决定的。&lt;/li>
&lt;li>GET也可以带body.&lt;/li>
&lt;li>POST也可以带URL的参数.&lt;/li>
&lt;/ul>
&lt;h3 id="http版本">HTTP版本&lt;/h3>
&lt;p>见&lt;a href="##%e7%89%88%e6%9c%ac">版本&lt;/a>&lt;/p>
&lt;h3 id="状态码">状态码&lt;/h3>
&lt;p>1xx 类状态码属于&lt;strong>提示信息&lt;/strong>，是协议处理中的一种中间状态，实际用到的比较少。&lt;/p>
&lt;p>2xx 类状态码表示&lt;strong>服务器成功处理&lt;/strong>了客户端的请求，也是我们最愿意看到的状态。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>「200 OK」是最常见的成功状态码，表示一切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>「204 No Content」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>「206 Partial Content」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>3xx 类状态码表示&lt;strong>客户端请求的资源发生了变动&lt;/strong>，需要客户端用新的 URL 重新发送请求获取资源，也就是&lt;strong>重定向&lt;/strong>。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>「301 Moved Permanently」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>「302 Found」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>「304 Not Modified」不具有跳转的含义，表示资源未修改，&lt;strong>重定向已存在的缓冲文件，也称缓存重定向&lt;/strong>，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>4xx 类状态码表示&lt;strong>客户端发送的报文有误&lt;/strong>，服务器无法处理，也就是错误码的含义。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>「400 Bad Request」表示客户端请求的报文有错误，但只是个笼统的错误。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>「403 Forbidden」表示服务器禁止访问资源，并不是客户端的请求出错。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>「404 Not Found」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>5xx 类状态码表示客户端请求报文正确，但是&lt;strong>服务器处理时内部发生了错误&lt;/strong>，属于服务器端的错误码。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>「500 Internal Server Error」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>「501 Not Implemented」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>「502 Bad Gateway」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>「503 Service Unavailable」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="content-length">Content-Length&lt;/h3>
&lt;p>服务器在返回数据时，会有 Content-Length 字段，表明本次回应的数据长度。&lt;/p>
&lt;p>HTTP解决TCP &amp;ldquo;粘包&amp;rdquo; 问题的方法&lt;/p>
&lt;ul>
&lt;li>HTTP 协议通过设置回车符、换行符作为 HTTP header 的边界&lt;/li>
&lt;li>通过 Content-Length 字段作为 HTTP body 的边界&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="./TCP.md#%e9%9d%a2%e5%90%91%e5%ad%97%e8%8a%82%e6%b5%81%e7%9a%84%e5%8d%8f%e8%ae%ae">TCP粘包问题&lt;/a>&lt;/p>
&lt;h3 id="connect">Connect&lt;/h3>
&lt;p>最常用于客户端要求服务器使用「HTTP 长连接」机制，以便其他请求复用。&lt;/p>
&lt;p>&lt;a href="./TCP.md#HTTP%e7%9a%84keep-alive">HTTP的keep-alive&lt;/a>&lt;/p>
&lt;h3 id="控制返回内容的字段">控制返回内容的字段&lt;/h3>
&lt;p>&lt;code>Accept&lt;/code> 字段用于告诉服务器，客户端希望接收什么格式的数据。&lt;/p>
&lt;ul>
&lt;li>例如：&lt;code>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>&lt;code>Content-Type&lt;/code> 字段用于服务器回应时，告诉客户端，本次数据是什么格式。&lt;/p>
&lt;ul>
&lt;li>例如：&lt;code>Content-Type: text/html; charset=UTF-8&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>&lt;code>Accept-Encoding&lt;/code> 字段用于告诉服务器，客户端支持的压缩格式。&lt;/p>
&lt;ul>
&lt;li>例如：&lt;code>Accept-Encoding: gzip, deflate&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>&lt;code>Content-Encoding&lt;/code> 字段用于服务器回应时，告诉客户端，本次数据采用了什么压缩格式。&lt;/p>
&lt;ul>
&lt;li>例如：&lt;code>Content-Encoding: gzip&lt;/code>&lt;/li>
&lt;/ul>
&lt;h2 id="http缓存">HTTP缓存&lt;/h2>
&lt;p>对于一些具有重复性的 HTTP 请求，比如每次请求得到的数据都一样的，我们可以把这对「请求-响应」的数据都缓存在本地. 下次就直接读取本地的数据，不必在通过网络获取服务器的响应了，这样的话 HTTP/1.1 的性能肯定肉眼可见的提升。&lt;/p>
&lt;p>即, 通过缓存技术避免发送 HTTP 请求&lt;/p>
&lt;p>HTTP 设计者早在之前就考虑到了这点，因此 HTTP 协议的头部有不少是针对缓存的字段。&lt;/p>
&lt;p>HTTP 缓存有两种实现方式，分别是强制缓存和协商缓存。&lt;/p>
&lt;h3 id="强制缓存">强制缓存&lt;/h3>
&lt;p>只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。&lt;/p>
&lt;p>如下图中，返回的是 200 状态码，但在 size 项中标识的是 from disk cache，就是使用了强制缓存。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/HTTP/%e5%bc%ba%e5%88%b6%e7%bc%93%e5%ad%98.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>强缓存是利用下面这两个 HTTP 响应头部（Response Header）字段实现的，它们都用来表示资源在客户端缓存的有效期：&lt;/p>
&lt;ul>
&lt;li>Cache-Control， 是一个相对时间；&lt;/li>
&lt;li>Expires，是一个绝对时间；&lt;/li>
&lt;/ul>
&lt;p>如果 HTTP 响应头部同时有 Cache-Control 和 Expires 字段的话，&lt;strong>Cache-Control 的优先级高于 Expires&lt;/strong> 。&lt;/p>
&lt;p>Cache-control 选项更多一些，设置更加精细，所以建议使用 Cache-Control 来实现强缓存。&lt;/p>
&lt;p>具体的实现流程如下：&lt;/p>
&lt;ol>
&lt;li>当浏览器第一次请求访问服务器资源时，&lt;strong>服务器&lt;/strong>会在返回这个资源的同时，&lt;strong>在Response 头部加上 Cache-Control&lt;/strong>，Cache-Control 中设置了过期时间大小；&lt;/li>
&lt;li>浏览器再次请求访问服务器中的该资源时，会先通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期，&lt;strong>如果没有，则使用该缓存，否则重新请求服务&lt;/strong>&lt;/li>
&lt;li>服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。&lt;/li>
&lt;/ol>
&lt;h3 id="协商缓存">协商缓存&lt;/h3>
&lt;p>某些请求的响应码是 304&lt;/p>
&lt;p>是服务端告知客户端可以使用本地缓存的资源,这种方式叫做协商缓存。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/HTTP/%e5%8d%8f%e5%95%86%e7%bc%93%e5%ad%98%e8%bf%87%e7%a8%8b.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存。&lt;/p>
&lt;p>协商缓存可以基于两种头部来实现。&lt;/p>
&lt;p>第一种：&lt;/p>
&lt;ul>
&lt;li>响应头部中的 Last-Modified 字段: 标示这个响应资源的最后修改时间&lt;/li>
&lt;li>请求头部中的 If-Modified-Since 字段: 服务器收到请求后发现有 If-Modified-Since 则与被请求资源的最后修改时间进行对比（Last-Modified），如果最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP 200 OK；如果最后修改时间较旧（小），说明资源无新修改，直接响应 HTTP 304 走缓存。&lt;/li>
&lt;/ul>
&lt;p>第二种：&lt;/p>
&lt;ul>
&lt;li>响应头部中的 ETag 字段: 唯一标识响应资源&lt;/li>
&lt;li>请求头部中的 If-None-Match 字段: 当资源过期时，浏览器发现响应头里有 Etag，则再次向服务器发起请求时，会将请求头 If-None-Match 值设置为 Etag 的值。服务器收到请求后进行比对，如果资源没有变化返回 304，如果资源变化了返回 200。&lt;/li>
&lt;/ul>
&lt;p>第一种实现方式是基于时间实现的，第二种实现方式是基于一个唯一标识实现的，相对来说后者可以更加准确地判断文件内容是否被修改，避免由于时间篡改导致的不可靠问题。&lt;/p>
&lt;p>如果在第一次请求资源的时候，服务端返回的 HTTP 响应头部同时有 Etag 和 Last-Modified 字段，Etag 优先级更高。&lt;/p>
&lt;p>**为什么 ETag 的优先级更高？**这是因为 ETag 主要能解决 Last-Modified 几个比较难以解决的问题：&lt;/p>
&lt;ul>
&lt;li>在没有修改文件内容情况下文件的最后修改时间可能也会改变，这会导致客户端认为这文件被改动了，从而重新请求；&lt;/li>
&lt;li>可能有些文件是在秒级以内修改的，If-Modified-Since 能检查到的粒度是秒级的，使用 Etag就能够保证这种需求下客户端在 1 秒内能刷新多次；&lt;/li>
&lt;li>有些服务器不能精确获取文件的最后修改时间。&lt;/li>
&lt;/ul>
&lt;p>注意，协商缓存这两个字段&lt;strong>都需要配合强制缓存中 Cache-Control 字段&lt;/strong>来使用.
&lt;strong>只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求&lt;/strong>。&lt;/p>
&lt;h2 id="https">HTTPS&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>HTTPS 在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>HTTP 默认端口号是 80，HTTPS 默认端口号是 443。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>HTTP的风险&lt;/p>
&lt;ul>
&lt;li>窃听风险，比如通信链路上可以获取通信内容，用户号容易没。&lt;/li>
&lt;li>篡改风险，比如强制植入垃圾广告，视觉污染，用户眼容易瞎。&lt;/li>
&lt;li>冒充风险，比如冒充淘宝网站，用户钱容易没。&lt;/li>
&lt;/ul>
&lt;p>HTTPS的解决方案&lt;/p>
&lt;ul>
&lt;li>信息加密：交互信息无法被窃取，但你的号会因为「自身忘记」账号而没。
&lt;ul>
&lt;li>使用&lt;strong>混合加密&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>校验机制：无法篡改通信内容，篡改了就不能正常显示(但百度「竞价排名」依然可以搜索垃圾广告)
&lt;ul>
&lt;li>使用&lt;strong>摘要算法&lt;/strong>, 校验数据的完整性&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>身份证书：证明淘宝是真的淘宝网，但你的钱还是会因为「剁手」而没。
&lt;ul>
&lt;li>公钥放入&lt;strong>数字证书&lt;/strong>中.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="混合加密">混合加密&lt;/h3>
&lt;p>HTTPS 采用的是对称加密和非对称加密结合的「混合加密」方式：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>通信建立前&lt;/strong>, 采用 &lt;strong>非对称加密的方式交换「会话秘钥」&lt;/strong>
&lt;ul>
&lt;li>这里是公钥加密，私钥解密 &amp;ndash; 保证内容安全&lt;/li>
&lt;li>公私钥是服务器生成的，私钥保密，公钥发送给客户端&lt;/li>
&lt;li>客户端使用公钥加密&lt;strong>协商生成的随机数&lt;/strong>,用于&lt;strong>各自生成相同的「会话秘钥」&lt;/strong>，发送给服务器，服务器使用私钥解密, 具体&lt;a href="#TLS%e6%8f%a1%e6%89%8b">见TLS握手&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>通信过程中, 全部使用 &lt;strong>对称加密的「会话秘钥」&lt;/strong> 的方式加密明文数据。&lt;/li>
&lt;/ul>
&lt;p>采用「混合加密」的方式的原因：&lt;/p>
&lt;ul>
&lt;li>对称加密只使用一个密钥，运算速度快，密钥必须保密，&lt;strong>无法做到安全的密钥交换&lt;/strong>。&lt;/li>
&lt;li>非对称加密使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。&lt;/li>
&lt;/ul>
&lt;h3 id="摘要算法和数字签名">摘要算法和数字签名&lt;/h3>
&lt;p>摘要算法（哈希函数）来计算出内容的哈希值&lt;/p>
&lt;p>存在问题: 不能保证「内容 + 哈希值」不会被中间人替换，因为这里缺少对客户端收到的消息是否来源于服务端的证明。&lt;/p>
&lt;p>数字签名: 使用非对称加密算法对哈希值进行加密&lt;/p>
&lt;ul>
&lt;li>这里是私钥加密，公钥解密 &amp;ndash; 保证数据完整性&lt;/li>
&lt;/ul>
&lt;p>私钥是由服务端保管，然后&lt;strong>服务端会向客户端颁发对应的公钥&lt;/strong>。如果客户端收到的信息，能被公钥解密，就说明该消息是由服务器发送的。&lt;/p>
&lt;h3 id="数字证书">数字证书&lt;/h3>
&lt;p>数字证书是由 CA（证书权威机构）颁发的，用于证明服务器身份的一种方式。&lt;/p>
&lt;p>即, 验证服务器最开始发送的公钥是否是&lt;strong>真实的服务器的公钥&lt;/strong>&lt;/p>
&lt;p>需要确定CA是可信的, CA有一对公私钥是可信的, 服务器和客户端都知道CA的公钥.&lt;/p>
&lt;ol>
&lt;li>服务器使用CA的公钥加密 &lt;code>自己要提交证明的内容(服务器的公钥)&lt;/code>，发送给CA&lt;/li>
&lt;li>CA使用自己的私钥解密，得到服务器的公钥&lt;/li>
&lt;li>CA使用自己的私钥加密 &lt;code>服务器的公钥&lt;/code>, 即做了数字签名, 颁发数字证书: &lt;code>服务器信息 + 服务器的公钥 + CA的数字签名&lt;/code>&lt;/li>
&lt;/ol>
&lt;p>客户端验证服务器身份:&lt;/p>
&lt;ol>
&lt;li>客户端收到服务器的数字证书&lt;/li>
&lt;li>客户端使用CA的公钥解密数字签名，得到服务器的公钥, 证明服务器的公钥是真实的&lt;/li>
&lt;li>使用服务器的公钥进行后续加密&lt;/li>
&lt;/ol>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/HTTP/%e6%95%b0%e5%ad%97%e8%af%81%e4%b9%a6%e9%a2%81%e5%8f%91%e8%bf%87%e7%a8%8b.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="tls握手">TLS握手&lt;/h3>
&lt;ol>
&lt;li>客户端向服务器索要并验证服务器的公钥。&lt;/li>
&lt;li>双方协商生产「会话秘钥」。&lt;/li>
&lt;/ol>
&lt;p>TLS握手可基于RSA算法和ECDHE算法&lt;/p>
&lt;p>实际涉及四次通信:&lt;/p>
&lt;ol>
&lt;li>客户端向服务器发送一个「Client Hello」消息，包含了
&lt;ol>
&lt;li>客户端支持的SSL/TLS 版本&lt;/li>
&lt;li>随机数(Client Random), 用于生成会话密钥&lt;/li>
&lt;li>客户端支持的加密算法, 如RSA, AES等&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>服务器收到「Client Hello」消息后，会回复一个「Server Hello」消息,包含了
&lt;ol>
&lt;li>确认TLS协议版本,如果浏览器不支持,则关闭加密通信&lt;/li>
&lt;li>随机数(Server Random), 用于生成会话密钥&lt;/li>
&lt;li>确认的加密算法&lt;/li>
&lt;li>&lt;strong>服务器的数字证书(包含服务器的公钥)&lt;/strong>&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>客户端收到「Server Hello」消息后，会验证服务器的数字证书，如果验证通过, 会生成一个随机数(pre-master key). &lt;strong>客户端将使用三个随机数生成「会话秘钥」&lt;/strong>. 向服务器发送如下信息:
&lt;ol>
&lt;li>使用&lt;strong>服务器的公钥加密后&lt;/strong>的一个随机数(pre-master key)&lt;/li>
&lt;li>加密通信算法改变通知&lt;/li>
&lt;li>客户端握手结束通知, 表示客户端握手阶段结束, 包含之前所有内容的摘要&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>服务器收到客户端的信息后, 使用自己的私钥解密pre-master key, &lt;strong>使用三个随机数生成「会话秘钥」&lt;/strong>, 之后发送如下信息:
&lt;ol>
&lt;li>加密通信算法改变通知&lt;/li>
&lt;li>服务器握手结束通知, 表示服务器握手阶段结束, 包含之前所有内容的摘要&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>实际上, 上述过程会存在前向安全问题和证书信任链的问题&lt;/p>
&lt;h3 id="前向安全问题">前向安全问题&lt;/h3>
&lt;p>RSA 算法的 HTTPS 存在「前向安全」的问题：如果服务端的私钥泄漏了，过去被第三方截获的所有 TLS 通讯密文都会被破解。&lt;/p>
&lt;p>ECDHE 密钥协商算法解决了这个问题，目前大部分网站都使用 ECDHE 算法。&lt;/p>
&lt;p>ECDHE 密钥协商算法是 DH 算法演进过来的。&lt;/p>
&lt;h4 id="todo-dh算法">TODO: DH算法&lt;/h4>
&lt;p>DH 算法是非对称加密算法， 因此它可以用于密钥交换，该算法的核心数学思想是离散对数。&lt;/p>
&lt;p>根据私钥生成的方式，DH 算法分为两种实现：&lt;/p>
&lt;ul>
&lt;li>static DH 算法，这个是已经被废弃了；&lt;/li>
&lt;li>DHE 算法，现在常用的；&lt;/li>
&lt;/ul>
&lt;p>static DH 算法不具备前向安全性&lt;/p>
&lt;p>DHE算法保证前向安全性: 双方的私钥在每次密钥交换通信时，都是随机生成的、临时的，这个方式也就是 DHE 算法，E 全称是 ephemeral（临时性的）。&lt;/p>
&lt;p>ECDHE 算法是在 DHE 算法的基础上利用了 ECC 椭圆曲线特性，可以用更少的计算量计算出公钥，以及最终的会话密钥。&lt;/p>
&lt;h4 id="使用ecdhe算法的握手过程">使用ECDHE算法的握手过程&lt;/h4>
&lt;p>第一次与RSA算法的握手过程一样&lt;a href="#TLS%e6%8f%a1%e6%89%8b">RSA握手过程&lt;/a>，&lt;/p>
&lt;ol>
&lt;li>在第二次握手中,服务器还会发送「Server Key Exchange」消息
&lt;ol>
&lt;li>包括了服务端的椭圆曲线公钥&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>客户端会生成一个随机数作为客户端椭圆曲线的私钥，然后再根据服务端前面给的信息，生成客户端的椭圆曲线公钥，然后用「Client Key Exchange」消息发给服务端
&lt;ol>
&lt;li>最终的会话密钥，就是用「客户端随机数 + 服务端随机数 + x（ECDHE 算法算出的共享密钥） 」三个材料生成的。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h3 id="证书信任链的问题">证书信任链的问题&lt;/h3>
&lt;p>我们向 CA 申请的证书一般不是根证书签发的，而是由中间证书签发的，比如百度的证书，从下图你可以看到，证书的层级有三级:
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/HTTP/%e8%af%81%e4%b9%a6%e5%b1%82%e7%ba%a7.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>总括来说，由于用户信任 GlobalSign，所以由 GlobalSign 所担保的 baidu.com 可以被信任，另外由于用户信任操作系统或浏览器的软件商，所以由软件商预载了根证书的 GlobalSign 都可被信任。&lt;/p>
&lt;p>为什么需要证书链这么麻烦的流程？Root CA 为什么不直接颁发证书，而是要搞那么多中间层级呢？&lt;/p>
&lt;p>这是为了&lt;strong>确保根证书的绝对安全性&lt;/strong>，将根证书隔离地越严格越好，不然&lt;strong>根证书如果失守了，那么整个信任链都会有问题。&lt;/strong>&lt;/p>
&lt;h3 id="https-一定安全可靠吗">HTTPS 一定安全可靠吗？&lt;/h3>
&lt;p>问题场景是这样的：客户端通过浏览器向服务端发起 HTTPS 请求时，被「假基站」转发到了一个**「中间人服务器」**，于是客户端是和「中间人服务器」完成了 TLS 握手，然后这个「中间人服务器」再与真正的服务端完成 TLS 握手。&lt;/p>
&lt;p>实际情况:&lt;/p>
&lt;ul>
&lt;li>用户会收到一个「伪造的数字证书」，这个数字证书是「中间人服务器」伪造的.&lt;/li>
&lt;li>如果用户同意信任这个数字证书，那么「中间人服务器」就可以解密客户端发来的数据，然后再加密转发给服务端，这样就实现了「中间人攻击」。&lt;/li>
&lt;/ul>
&lt;p>HTTPS 协议本身到目前为止还是没有任何漏洞的，即使你成功进行中间人攻击，本质上是利用了客户端的漏洞（&lt;strong>用户点击继续访问或者被恶意导入伪造的根证书&lt;/strong>），并不是 HTTPS 不够安全。&lt;/p>
&lt;p>也可以使用 &lt;strong>HTTPS 双向认证&lt;/strong> 解决这个问题&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/HTTP/HTTPS%e5%8f%8c%e5%90%91%e8%ae%a4%e8%af%81.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h2 id="版本及特性">版本及特性&lt;/h2>
&lt;p>&lt;a href="https://www.zhihu.com/question/20085992" target="_blank" rel="noopener">HTTP 是基于 TCP 还是 UDP 的&lt;/a>&lt;/p>
&lt;h3 id="http10">HTTP/1.0&lt;/h3>
&lt;h3 id="http11">HTTP/1.1&lt;/h3>
&lt;h3 id="http2">HTTP/2&lt;/h3>
&lt;p>目前(2024.4)&lt;a href="https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-http2.html" target="_blank" rel="noopener">Spring Web&lt;/a>默认还是HTTP/2&lt;/p>
&lt;h3 id="http3">HTTP/3&lt;/h3>
&lt;p>HTTP/3.0 之前是基于 TCP 协议的，而 HTTP/3.0 将弃用 TCP，改用 基于 UDP 的 QUIC 协议&lt;/p>
&lt;h4 id="http2的队头阻塞问题">HTTP/2的队头阻塞问题&lt;/h4>
&lt;ul>
&lt;li>HTTP/2.0 在单个 TCP 连接上使用了多路复用
&lt;ul>
&lt;li>多个 HTTP 请求和响应共享一个 TCP 连接&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>受到 TCP 拥塞控制的影响，少量的丢包就可能导致整个 TCP 连接上的所有流被阻塞
&lt;ul>
&lt;li>如果其中一个请求或响应因为网络拥塞或丢包而被阻塞&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>那么后续的请求或响应也无法发送，导致整个连接的效率降低&lt;/li>
&lt;/ul></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E7%BD%91%E7%BB%9C/qa/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E7%BD%91%E7%BB%9C/qa/</guid><description>&lt;h3 id="tcp和udp的区别">TCP和UDP的区别&lt;/h3>
&lt;p>TCP:
User Datagram Protocol 用户数据报协议&lt;/p>
&lt;ul>
&lt;li>提供一种面向连接的、可靠交付的面向字节流服务&lt;/li>
&lt;li>TPDU: TCP 报文段(segment)&lt;/li>
&lt;li>传输开销大、报文头部大&lt;/li>
&lt;li>全双工&lt;/li>
&lt;/ul>
&lt;p>UDP：
User Datagram Protocol 用户数据报协议&lt;/p>
&lt;ul>
&lt;li>提供面向事务的简单不可靠信息传送服务&lt;/li>
&lt;li>TPDU: UDP 报文或用户数据报。&lt;/li>
&lt;li>传输开销小、报文头部小 8字节&lt;/li>
&lt;li>不面向连接没有双工的说法&lt;/li>
&lt;/ul>
&lt;h3 id="tcp握手">TCP握手&lt;/h3>
&lt;p>三次握手为什么不是四次呢&lt;/p>
&lt;p>服务器的回复和请求可以并成一次。&lt;/p>
&lt;p>第三次可以携带数据吗&lt;/p>
&lt;p>可以&lt;/p>
&lt;p>TCP四次挥手可以三次吗&lt;/p>
&lt;p>不可以，服务器那个时候可能还要发送数据。&lt;/p>
&lt;p>最后一次要等两个ttl，&lt;/p>
&lt;p>14.tcp为什么慢&lt;/p>
&lt;p>如重传机制，确认机制，拥塞控制机制&lt;/p>
&lt;p>15.udp的切包&lt;/p>
&lt;p>IP分片的概念
在TCP/IP分层中，数据链路层用MTU（Maximum Transmission Unit，最大传输单元）来限制所能传输的数据包大小，MTU是指一次传送的数据最大长度，不包括数据链路层数据帧的帧头，如以太网的MTU为1500字节，实际上数据帧的最大长度为1514字节，其中以太网数据帧的帧头为14字节&lt;/p>
&lt;p>当发送的IP数据包的大小超过了MTU时，IP层就需要对数据进行分片，否则数据将无法发送成功&lt;/p>
&lt;p>IP层是没有超时重传机制的，如果IP层对一个数据包进行了分片，只要有一个分片丢失了，只能依赖于传输层进行重传，结果是所有的分片都要重传一遍，这个代价有点大；公网传输，需要经过多个网络设备，IP分片容易造成丢包&lt;/p>
&lt;p>由此可见，IP分片会大大降低传输层传送数据的成功率，所以我们要避免IP分片&lt;/p>
&lt;p>33.了解一些常用的RPC框架吗&lt;/p>
&lt;p>RPC（Remote Procedure Call，远程服务调用），用来实现部署在不同机器之间系统的方法调用，使程序像当问本地系统资源一样，通过网络传出资源.&lt;/p>
&lt;p>dubbo：基于Netty的高性能RPC框架，是阿里巴巴开源的&lt;/p>
&lt;p>Netty介绍
Netty是一个异步的、基于事件驱动的网络应用框架，用以快速开发高性能、高可靠性的网络IO程序。
Netty主要针对在TCP协议下，面向Clients端的高并发应用，或者Peer-to-Peer场景下的大量数据持续传输的应用。
Netty本质是一个NIO框架，适用于服务器通讯相关的多种应用场景。&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E7%BD%91%E7%BB%9C/socketio%E6%A8%A1%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E7%BD%91%E7%BB%9C/socketio%E6%A8%A1%E5%9E%8B/</guid><description>&lt;h1 id="io模型">I/O模型&lt;/h1>
&lt;h2 id="一什么是io模型-及-io模型的分类">一、什么是I/O模型 及 I/O模型的分类&lt;/h2>
&lt;p>Unix 有五种 I/O 模型：&lt;/p>
&lt;p>阻塞式 I/O
非阻塞式 I/O
I/O 复用（select 和 poll）
信号驱动式 I/O（SIGIO）
异步 I/O（AIO）&lt;/p>
&lt;h2 id="io-多路复用">I/O 多路复用&lt;/h2>
&lt;p>它可以让单个进程具有处理多个 I/O 事件的能力。又被称为 Event Driven I/O，即事件驱动 I/O。&lt;/p>
&lt;h3 id="select">select&lt;/h3>
&lt;h3 id="poll">poll&lt;/h3>
&lt;h3 id="epoll">epoll&lt;/h3>
&lt;h2 id="实际应用">实际应用&lt;/h2>
&lt;h3 id="reactor模式">Reactor模式&lt;/h3>
&lt;h3 id="proactor模式">Proactor模式&lt;/h3>
&lt;h3 id="事件驱动模式">事件驱动模式&lt;/h3>
&lt;h2 id="socket">Socket&lt;/h2>
&lt;p>Socket listen怎么监听到TCP连接&lt;/p>
&lt;p>释放连接的状态转换&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E7%BD%91%E7%BB%9C/tcp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E7%BD%91%E7%BB%9C/tcp/</guid><description>&lt;h1 id="tcp">TCP&lt;/h1>
&lt;p>控制位:
ACK：该位为 1 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 SYN 包之外该位必须设置为 1 。
RST：该位为 1 时，表示 TCP 连接中出现异常必须强制断开连接。
SYN：该位为 1 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。
FIN：该位为 1 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 FIN 位为 1 的 TCP 段。&lt;/p>
&lt;p>netstat -napt&lt;/p>
&lt;h2 id="三次握手">三次握手&lt;/h2>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/TCP/%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;ul>
&lt;li>一开始，客户端和服务端都处于 CLOSE 状态。先是服务端主动监听某个端口，处于 LISTEN 状态&lt;/li>
&lt;li>客户端会随机初始化序号（client_isn），将此序号置于 TCP 首部的「序号」字段中，同时把 SYN 标志位置为 1，表示 SYN 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 SYN-SENT 状态。&lt;/li>
&lt;li>服务端收到客户端的 SYN 报文后，首先服务端也随机初始化自己的序号（server_isn），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 client_isn + 1, 接着把 SYN 和 ACK 标志位置为 1。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 SYN-RCVD 状态。&lt;/li>
&lt;li>客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 ACK 标志位置为 1 ，其次「确认应答号」字段填入 server_isn + 1 ，最后把报文发送给服务端，这次报文可以携带客户到服务端的数据，之后客户端处于 ESTABLISHED 状态。&lt;/li>
&lt;li>服务端收到客户端的应答报文后，也进入 ESTABLISHED 状态。&lt;/li>
&lt;/ul>
&lt;p>第三次握手是可以携带数据的，前两次握手是不可以携带数据的，这也是面试常问的题。&lt;/p>
&lt;h2 id="四次挥手">四次挥手&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>客户端打算关闭连接，此时会发送一个 TCP 首部 FIN 标志位被置为 1 的报文，也即 FIN 报文，之后客户端进入 FIN_WAIT_1 状态。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>服务端收到该报文后，就向客户端发送 ACK 应答报文，接着服务端进入 CLOSE_WAIT 状态。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>客户端收到服务端的 ACK 应答报文后，之后进入 FIN_WAIT_2 状态。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>等待服务端处理完数据后，也向客户端发送 FIN 报文，之后服务端进入 LAST_ACK 状态。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>客户端收到服务端的 FIN 报文后，回一个 ACK 应答报文，之后进入 TIME_WAIT 状态&lt;/p>
&lt;/li>
&lt;li>
&lt;p>服务端收到了 ACK 应答报文后，就进入了 CLOSE 状态，至此服务端已经完成连接的关闭。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>客户端在经过 2MSL 一段时间后，自动进入 CLOSE 状态，至此客户端也完成连接的关闭。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="tcp和http的keep-alive区别">TCP和HTTP的keep-alive区别&lt;/h2>
&lt;h3 id="tcp的keep-alive">TCP的keep-alive&lt;/h3>
&lt;p>TCP 的 Keepalive 是 &lt;strong>TCP 的保活机制&lt;/strong>，检测的是对端主机是否存活（而不是进程）&lt;/p>
&lt;p>原理：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/TCP/TCP%e4%bf%9d%e6%b4%bb%e6%9c%ba%e5%88%b6.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;ol>
&lt;li>如果两端的 TCP 连接一直没有数据交互，达到了触发 TCP 保活机制的条件，那么内核里的 TCP 协议栈就会发送探测报文。&lt;/li>
&lt;li>如果对端程序是正常工作的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 TCP 保活时间会被重置，等待下一个 TCP 保活时间的到来。&lt;/li>
&lt;li>如果对端主机宕机（注意&lt;strong>不是进程崩溃，进程崩溃后操作系统在回收进程资源的时候，会发送 FIN 报文&lt;/strong>，而主机宕机则是无法感知的，所以需要 TCP 保活机制来探测对方是不是发生了主机宕机）。或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后没有响应，连续几次，&lt;strong>达到保活探测次数&lt;/strong>后，TCP 会报告该 TCP 连接已经死亡。&lt;/li>
&lt;/ol>
&lt;p>TCP 保活机制可以在双方没有数据交互的情况，通过探测报文，来确定对方的 TCP 连接是否存活，&lt;strong>这个工作是在内核完成的&lt;/strong>。&lt;/p>
&lt;p>默认情况：
默认情况TCP 保活机制是关闭的，应用程序需要通过设置需要通过 socket 接口设置 SO_KEEPALIVE 选项才能够生效。&lt;/p>
&lt;h3 id="http的keep-alive">HTTP的keep-alive&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/TCP/HTTP%e9%95%bf%e8%bf%9e%e6%8e%a5.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>HTTP 的 Keepalive 是 &lt;strong>HTTP 长连接&lt;/strong>，目的是在一次TCP连接中可以发送多个HTTP请求，减少建立和关闭连接的开销。&lt;/p>
&lt;p>在 HTTP 1.0 中默认是关闭的，如果浏览器要开启 Keep-Alive，它必须在请求的包头中添加：&lt;code>Connection: Keep-Alive&lt;/code>。&lt;/p>
&lt;p>在 HTTP 1.1 开始, 默认是开启的，如果要关闭 Keep-Alive，可以在请求的包头中添加：&lt;code>Connection: close&lt;/code>。&lt;/p>
&lt;p>HTTP长连接支持了HTTP流水线,但同时也带来了队头阻塞问题。&lt;/p>
&lt;p>同时为了避免TCP连接一直保持，web 服务软件一般都会提供 keepalive_timeout 参数，用来指定 HTTP 长连接的超时时间。&lt;/p>
&lt;h4 id="http-流水线">HTTP 流水线&lt;/h4>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/TCP/HTTP%e6%b5%81%e6%b0%b4%e7%ba%bf.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>HTTP 流水线: 客户端可以先一次性发送多个请求，而在发送过程中不需先等待服务器的回应，可以减少整体的响应时间。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>服务器还是按照顺序响应, 即先响应第一个请求，再响应第二个请求，以此类推。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>而且要等服务器响应完客户端&lt;strong>第一批发送的请求&lt;/strong>后，客户端&lt;strong>才能发出下一批的请求&lt;/strong>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>于是就有了队头阻塞问题，即前面的请求处理时间过长，导致后面的请求被阻塞。&lt;/p>
&lt;h4 id="队头阻塞">队头阻塞&lt;/h4>
&lt;p>实际上队头阻塞问题由两种,一种是TCP本身的队头阻塞，一种是HTTP的队头阻塞。&lt;/p>
&lt;ul>
&lt;li>TCP本身的队头阻塞：TCP是一个面向字节流的协议，如果一个数据包丢失，那么后面的数据包都会被阻塞，直到丢失的数据包被重传成功。&lt;/li>
&lt;li>HTTP/1.x 的队头阻塞: 当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一并被阻塞&lt;/li>
&lt;li>HTTP/2 的队头阻塞: HTTP/2 通过多路复用解决了HTTP/1.x的队头阻塞问题，可以同时发送多个请求，而且不会被阻塞。&lt;/li>
&lt;li>HTTP/3 的队头阻塞: HTTP/3 使用了 UDP + QUIC 协议，解决了TCP队头阻塞问题。&lt;/li>
&lt;/ul>
&lt;h2 id="面向字节流的协议">面向字节流的协议&lt;/h2></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E7%BD%91%E7%BB%9C/%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E7%BD%91%E7%BB%9C/%E5%9F%BA%E7%A1%80/</guid><description>&lt;h1 id="计算机网络基础">计算机网络基础&lt;/h1>
&lt;h2 id="概述">概述&lt;/h2>
&lt;ul>
&lt;li>LAN：Local Area Network，局域网&lt;/li>
&lt;li>WAN：Wide Area Network，广域网&lt;/li>
&lt;li>&lt;strong>ISP&lt;/strong> Internet Service Provider 因特网服务提供商&lt;/li>
&lt;/ul>
&lt;h3 id="服务与协议">服务与协议&lt;/h3>
&lt;p>&lt;strong>协议&lt;/strong>是&lt;strong>水平&lt;/strong>的，&lt;strong>对等实体&lt;/strong>之间的&lt;strong>通信规则&lt;/strong>。&lt;strong>对等实体&lt;/strong>是指&lt;strong>同一层&lt;/strong>级&lt;strong>可发送接收&lt;/strong>信息的硬件或软件进程.&lt;/p>
&lt;p>&lt;strong>服务&lt;/strong>是&lt;strong>垂直&lt;/strong>的，是由下层为上层通过&lt;strong>层间接口&lt;/strong>提供的. 下层实现的&lt;strong>所有功能不都是服务&lt;/strong>,只有能够&lt;strong>被上层看得见的&lt;/strong>功能才是服务. 上层使用下层的&lt;strong>SAP&lt;/strong>访问下层的服务.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>SAP Service Access Point&lt;/strong>: 服务接入点.同⼀节点相邻两层交换信息的连接点.
&lt;ul>
&lt;li>数据链路层的SAP是MAC地址，网络层的SAP是IP地址，传输层的SAP是端口.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>SDU(服务数据单元): 为完成⽤户所要求的功能⽽应传送的数据&lt;/li>
&lt;li>PCI(协议控制信息): 控制协议操作的信息。&lt;/li>
&lt;li>PDU(协议数据单元): n-PDU = n-SDU + n-PCI。 n-PDU = (n-1)-SDU。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>协议三要素：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>语法: 规定信息格式&lt;/li>
&lt;li>语义: 说明通信双方应当怎么做;用于协调与差错处理的控制信息&lt;/li>
&lt;li>规则: (时序)定义了何时进行通信，先讲什么，后讲什么，讲话的速度等。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>服务的类型&lt;/strong>：&lt;/p>
&lt;p>面向连接服务与无连接服务&lt;/p>
&lt;ul>
&lt;li>面向连接服务：双方通信前要&lt;strong>事先建立&lt;/strong>一条&lt;strong>通信线路&lt;/strong>. 该线路包括建立连接、使用连接(通信)、释放连接这三个过程。&lt;/li>
&lt;li>无连接服务: 双方通信前不需要建立通信线路.&lt;/li>
&lt;/ul>
&lt;p>可靠服务与不可靠服务&lt;/p>
&lt;ul>
&lt;li>可靠服务:通过具有&lt;strong>检错,纠错,应答&lt;/strong>机制,保证&lt;strong>数据正确,可靠地&lt;/strong>传送到目的地.&lt;/li>
&lt;li>不可靠服务: 不保证数据正确,可靠地传送到目的地.&lt;/li>
&lt;/ul>
&lt;p>应答服务与不应答服务&lt;/p>
&lt;h3 id="模型">模型&lt;/h3>
&lt;p>&lt;strong>层次模型的好处：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>降低复杂度&lt;/li>
&lt;li>标准化接口&lt;/li>
&lt;li>灵活性好&lt;/li>
&lt;li>易于实现和维护&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%9f%ba%e7%a1%80/%e6%af%8f%e4%b8%80%e5%b1%82%e5%8d%8f%e8%ae%ae%e7%9a%84%e5%b0%81%e8%a3%85.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>OSI七层模型**&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>任务&lt;/th>
&lt;th>功能&lt;/th>
&lt;th>协议&lt;/th>
&lt;th>传输单位&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>物理层&lt;/td>
&lt;td>在物理媒介上为数据端设备执行任务&lt;/td>
&lt;td>&lt;strong>透明&lt;/strong>地传输比特流&lt;/td>
&lt;td>&lt;/td>
&lt;td>比特&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>数据链路&lt;/td>
&lt;td>将网络层传来的&lt;strong>数据报&lt;/strong>组装成帧&lt;/td>
&lt;td>封装成帧,&lt;strong>差错控制&lt;/strong>,&lt;strong>流量控制&lt;/strong>,传输管理&lt;/td>
&lt;td>SDLC,HDLC,PPP,STP,帧中继&lt;/td>
&lt;td>帧&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>网络层&lt;/td>
&lt;td>将分组传输到目的端,为分组交换网上的&lt;strong>主机&lt;/strong>提供通信服务.&lt;/td>
&lt;td>1.将传输层产⽣的&lt;strong>报⽂段&lt;/strong>或⽤户数据报封装成分组&lt;br />2.路由选择 3.&lt;strong>流量控制&lt;/strong> 4.拥塞控制 5.&lt;strong>差错控制&lt;/strong>&lt;/td>
&lt;td>IP, IPX.ICMP, IGMP,ARP,RARP,OSPF&lt;/td>
&lt;td>数据报,IP分组&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>传输层&lt;/td>
&lt;td>负责主机中两个&lt;strong>进程&lt;/strong>之间的通信(端到端)&lt;/td>
&lt;td>&lt;strong>流量控制, 差错控制&lt;/strong>,服务质量,数据传输管理&lt;/td>
&lt;td>TCP, UDP&lt;/td>
&lt;td>报文段TCP,用户数据报UDP&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>会话层&lt;/td>
&lt;td>&lt;strong>管理主机之间&lt;/strong>的会话&lt;strong>进程&lt;/strong>&lt;/td>
&lt;td>建立,管理,终止会话.也称建立同步SYN&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>表示层&lt;/td>
&lt;td>处理&lt;strong>两个通信系统&lt;/strong>之间&lt;strong>交换信息&lt;/strong>的&lt;strong>表现方式&lt;/strong>&lt;/td>
&lt;td>抽象的标准方法定义数据结构,数据压缩,加密,解密&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>应用层&lt;/td>
&lt;td>提供系统与⽤户的接口&lt;/td>
&lt;td>为特定类型的网络应用提供接入到OSI模型的手段&lt;/td>
&lt;td>FTP.SMTP,HTTP,DNS,Telnet,SNMP&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>五层模型
应⽤层:会话层+表⽰层+应⽤层。&lt;strong>处理高级协议，显示问题，编码和会话控制等问题&lt;/strong>&lt;/p>
&lt;p>TCP/IP四层模型
网络接入层: 物理层 + 数据链路层&lt;/p>
&lt;p>应用层是工作在操作系统中的用户态，传输层及以下则工作在内核态&lt;/p>
&lt;p>下面按照TCP/IP四层模型来讲解&lt;/p>
&lt;h4 id="物理层">物理层&lt;/h4>
&lt;p>物理层：负责&lt;strong>传输比特流&lt;/strong>，&lt;strong>物理连接&lt;/strong>，&lt;strong>电气特性&lt;/strong>，&lt;strong>机械特性&lt;/strong>等。&lt;/p>
&lt;h4 id="数据链路层">数据链路层&lt;/h4>
&lt;p>数据链路层：负责&lt;strong>封装成帧&lt;/strong>，&lt;strong>差错控制&lt;/strong>，&lt;strong>流量控制&lt;/strong>，&lt;strong>传输管理&lt;/strong>等。&lt;/p>
&lt;p>传输单位：帧 frame&lt;/p>
&lt;h4 id="网络层">网络层&lt;/h4>
&lt;p>&lt;strong>网络层&lt;/strong>：负责&lt;strong>将分组传输到目的端&lt;/strong>，为分组交换网上的&lt;strong>主机&lt;/strong>提供通信服务。&lt;/p>
&lt;h4 id="各层设备">各层设备&lt;/h4>
&lt;p>&lt;strong>物理层设备&lt;/strong>:集线器Hub、中继器、调制解调器&lt;/p>
&lt;p>&lt;strong>数据链路层设备&lt;/strong>: 网卡、交换机、网桥&lt;/p>
&lt;p>&lt;strong>网络层设备&lt;/strong>:网卡、路由&lt;/p>
&lt;h2 id="物理层-1">物理层&lt;/h2>
&lt;p>任务： 在各种传输媒体上，透明地传输比特流&lt;/p>
&lt;p>&lt;strong>传输介质&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>UTP Unshielded Twisted Pair 非屏蔽双绞线&lt;/li>
&lt;li>STP Shielded Twisted Pair 屏蔽双绞线 抗电磁干扰能力强&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>设备&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>中继器：用于放大数字信号&lt;/li>
&lt;li>集线器：多个端口的中继器&lt;/li>
&lt;li>特点：物理层设备既不能隔离冲突域也不能隔离广播域&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>三种通信方式&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>单⼯/ &lt;strong>simple&lt;/strong> Transmission:单向信号只能在⼀个⽅向上传播。(收⾳机)&lt;/li>
&lt;li>半双⼯/ &lt;strong>half-Duplex&lt;/strong> Transmission：信号可双向传播，但不能同时传播。(对讲机)&lt;/li>
&lt;li>全双⼯/ &lt;strong>full-Duplex&lt;/strong> Transmission：信号可以同时在两个⽅向上传播。(电话)&lt;/li>
&lt;/ul>
&lt;p>通道复用技术：&lt;/p>
&lt;ul>
&lt;li>频分复用（FDM，Frequency Division Multiplexing）：不同用户在不同频带，所用用户在同样时间占用不同带宽资源&lt;/li>
&lt;li>时分复用（TDM，Time Division Multiplexing）：不同用户在同一时间段的不同时间片，所有用户在不同时间占用同样的频带宽度&lt;/li>
&lt;li>波分复用（WDM，Wavelength Division Multiplexing）：光的频分复用&lt;/li>
&lt;li>码分复用（CDM，Code Division Multiplexing）：不同用户使用不同的码，可以在同样时间使用同样频带通信&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>三种数据传输方式&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>电路交换
&lt;ul>
&lt;li>通信前为双方建立专有的通信线路&lt;/li>
&lt;li>优点
&lt;ul>
&lt;li>传输快,时延小,&lt;strong>有序&lt;/strong>,避免冲突&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>缺点
&lt;ul>
&lt;li>信道利用率低,建立连接时间长,灵活性差&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>数据报交换
&lt;ul>
&lt;li>以报文为传输的数据单位, 采用&lt;strong>交换节点存储&lt;/strong>转发的方式&lt;/li>
&lt;li>优点
&lt;ul>
&lt;li>线路利用率搞，无连接,动态分配路线,&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>缺点
&lt;ul>
&lt;li>交换节点存储要求大&lt;/li>
&lt;li>&lt;strong>转发时延&lt;/strong>大&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>分组交换
&lt;ul>
&lt;li>面向连接的虚电路
&lt;ul>
&lt;li>通信前，在源主机和⽬的主机之间 建⽴⼀条虚连接，分组通过该路径顺序传送到⽬的主机。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>无连接的数据报
&lt;ul>
&lt;li>数据报的⽅式:将报⽂分割为较短的分组，交换机根据转发表转发分组传送到⽬的主机。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>将报文分割成多个分组，交换机根据&lt;strong>转发表&lt;/strong>逐个传输&lt;/li>
&lt;li>优点
&lt;ul>
&lt;li>,简化交换节点的存储，加速传输&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>缺点
&lt;ul>
&lt;li>传输时延大&lt;/li>
&lt;li>&lt;strong>失序&lt;/strong>,丢失重复问题&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="数据链路层-1">数据链路层&lt;/h2>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%9f%ba%e7%a1%80/TCP/IP%e5%8d%8f%e8%ae%ae%e6%a0%88.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>生成了 IP 头部之后，接下来要交给网络接口层（Link Layer）在 IP 头部的前面加上 MAC 头部，并封装成数据帧（Data frame）发送到网络上。&lt;/p>
&lt;h3 id="使用的协议">使用的协议&lt;/h3>
&lt;p>&lt;strong>WAN(广域网)&lt;/strong>:覆盖范围很广的&lt;strong>长距离网络&lt;/strong>，由具有&lt;strong>存储转发功能的结点交换机&lt;/strong>和&lt;strong>连接链路&lt;/strong>组成。采用&lt;strong>交换&lt;/strong>技术。&lt;/p>
&lt;p>&lt;strong>LAN(局域网)&lt;/strong>:某一较&lt;strong>小区域内&lt;/strong>由多台计算机相互连成的计算机网络。采用&lt;strong>广播&lt;/strong>技术。&lt;/p>
&lt;h3 id="广播信道----以太网">广播信道 &amp;ndash; 以太网&lt;/h3>
&lt;h4 id="局域网">局域网&lt;/h4>
&lt;p>局域网是一种典型的广播信道&lt;/p>
&lt;ul>
&lt;li>主要特点是网络为一个单位所拥有&lt;/li>
&lt;li>地理范围和站点数目均有限, 方便广播&lt;/li>
&lt;/ul>
&lt;p>主要有以太网、令牌环网、FDDI 和 ATM 等局域网技术，&lt;strong>目前以太网占领着有线局域网市场&lt;/strong>。&lt;/p>
&lt;p>局域网有以下拓扑结构:&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/2024-03-06-16-25-54.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>总线拓扑&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>优点: 所有的节点都能通信&lt;/li>
&lt;li>缺点: 一旦总线上的&lt;strong>一点断开&lt;/strong>,会影响到所有&lt;strong>两边的节点&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>双环型拓扑&lt;/strong>: 在环型拓扑基础上增加了一个冗余环路,增加了可靠性和灵活性.&lt;/p>
&lt;p>&lt;strong>星型&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>优点:允许所有的节点方便的交流&lt;/li>
&lt;li>缺点:中间节点崩溃会导致整个网络的崩溃.传输冲突也是一个严重的问题.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>网络型&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>优点:连通性和可靠性好&lt;/li>
&lt;li>缺点:介质的连接和数量无法控制.&lt;/li>
&lt;/ul>
&lt;h4 id="以太网">以太网&lt;/h4>
&lt;p>以太网是一种星型拓扑结构局域网, &lt;strong>IEEE 802.3&lt;/strong>标准.&lt;/p>
&lt;blockquote>
&lt;p>早期使用集线器进行连接，集线器是一种物理层设备， 作用于比特而不是帧，当一个比特到达接口时，集线器重新生成这个比特，并将其能量强度放大，从而扩大网络的传输距离，之后再将这个比特发送到其它所有接口。如果集线器同时收到两个不同接口的帧，那么就发生了碰撞。&lt;/p>
&lt;p>使用集线器的星形拓扑:&lt;/p>
&lt;ul>
&lt;li>星形拓扑的中心是 集线器 hub&lt;/li>
&lt;li>使用集线器的以太网&lt;strong>在逻辑上仍是一个总线网&lt;/strong>，各工作站使用的还是 CSMA/CD 协议，并共享逻辑上的总线。&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>目前以太网使用&lt;strong>交换机&lt;/strong>替代了集线器&lt;/p>
&lt;p>交换机是一种链路层设备，它不会发生碰撞，能根据 MAC 地址进行存储转发。&lt;/p>
&lt;p>&lt;strong>以太网分层&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>LLC 逻辑链路控制&lt;/strong> LLC (Logical Link Control)子层&lt;/p>
&lt;ul>
&lt;li>建⽴和释放数据链路层的&lt;strong>逻辑连接&lt;/strong>。&lt;/li>
&lt;li>提供与⽹络层的&lt;strong>接口&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>MAC 媒体接入控制&lt;/strong> MAC (Medium Access Control)子层。&lt;/p>
&lt;ul>
&lt;li>负责控制与&lt;strong>连接物理层的物理介质&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>网卡(适配器)&lt;/strong>：&lt;/p>
&lt;p>又称 通信适配器adapter 、&lt;strong>网络接口卡 NIC&lt;/strong> Network Interface Card&lt;/p>
&lt;p>功能就是&lt;/p>
&lt;ul>
&lt;li>串行/并行转换&lt;/li>
&lt;li>实现以太网协议&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>MAC地址&lt;/strong>&lt;/p>
&lt;p>网卡从网络上每收到一个 MAC帧 就首先用硬件检查 MAC帧 中的 MAC 地址.&lt;/p>
&lt;ul>
&lt;li>如果是发往本站的帧则收下，然后再进行其他的处理。&lt;/li>
&lt;li>否则就将此帧丢弃，不再进行其他的处理。&lt;/li>
&lt;/ul>
&lt;p>可以通过 ARP 协议获取对方的 MAC 地址&lt;/p>
&lt;p>&lt;strong>MAC帧格式&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%9f%ba%e7%a1%80/2024-04-22-16-20-06.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;ul>
&lt;li>&lt;strong>类型字段&lt;/strong> 标志&lt;strong>上一层&lt;/strong>使用的协议&lt;/li>
&lt;li>首部 14字节 尾部 4字节。&lt;/li>
&lt;li>数据最少是 64-18 = 46字节.少于64时，数据字段后面加入整数字节填充。&lt;/li>
&lt;li>在&lt;strong>MAC帧前面&lt;/strong>会加入用于&lt;strong>比特同步的8字节&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>无效的MAC帧&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>数据字段的长度与长度字段的值不一致；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>帧的长度不是整数个字节；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>用收到的帧检验序列 FCS 查出有差错；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>数据字段的长度不在 46 ~ 1500 字节之间。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>有效的 MAC 帧长度为 64 ~ 1518 字节之间。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对于检查出的无效 MAC 帧就简单地丢弃。以太网不负责重传丢弃的帧。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>以太网重要特性&lt;/strong>：&lt;/p>
&lt;p>使用 CSMA/CD 协议的以太网&lt;strong>不能进行全双工通信&lt;/strong>而&lt;strong>只能进行双向交替通信（半双工通信）&lt;/strong>。&lt;/p>
&lt;p>发送的不确定性使整个以太网的平均通信量远小于以太网的最高数据率。&lt;/p>
&lt;h4 id="介质访问控制">介质访问控制&lt;/h4>
&lt;p>使得 &lt;strong>使用广播信道的结点&lt;/strong> 隔离 &lt;strong>其他结点发送的信号&lt;/strong>,以协调活动结点的传输,&lt;/p>
&lt;p>&lt;strong>介质访问控制协议 处于MAC&lt;/strong>层。&lt;/p>
&lt;h5 id="信道划分技术">信道划分技术&lt;/h5>
&lt;p>通过&lt;strong>多路复用技术&lt;/strong>, 把多个信号组合传入同一个物理信道.&lt;/p>
&lt;ul>
&lt;li>FDM 频分多路复用 将物理信道&lt;strong>根据频率&lt;/strong>划分 成 多个子信道,&lt;strong>每个子信道&lt;/strong>传输一种信号.&lt;/li>
&lt;li>TDM 时分多路复用 将物理信道 按照时间划分成若干时间片, 不同信号轮流使用.&lt;/li>
&lt;li>STDM 统计时分多路复用 在TDM的基础上,通过按实际需要来分配时间片.&lt;/li>
&lt;li>WDM 波分多路复用 光的频分多路复用&lt;/li>
&lt;li>CDM 码分多路复用 各个信号不同编码,既&lt;strong>共享信道频率又共享时间&lt;/strong>.
&lt;ul>
&lt;li>CDMA 码分多址&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h5 id="随机访问">随机访问&lt;/h5>
&lt;p>通过&lt;strong>检测冲突&lt;/strong>的方法来实现介质访问控制.&lt;/p>
&lt;ul>
&lt;li>纯ALOHA协议 ：不检测直接发送,&lt;strong>若超时&lt;/strong>则随机时间重发.&lt;/li>
&lt;li>时隙ALOHA协议： 不检测直接发送,&lt;strong>若超时&lt;/strong>则固定时隙重发.&lt;/li>
&lt;li>CSMA协议 ：载波监听多点接入
&lt;ul>
&lt;li>1-坚持CSMA, 闲则发送,忙则继续监听&lt;/li>
&lt;li>p-坚持CSMA, &lt;strong>闲&lt;/strong>则以&lt;strong>p的概率发送&lt;/strong>, 1-p的概率等待下一个时隙,忙则&lt;strong>等待随机时间&lt;/strong> &lt;strong>监听&lt;/strong>&lt;/li>
&lt;li>非坚持CSMA, 闲则发送,忙则&lt;strong>等待随机时间&lt;/strong>重新监听.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>CSMA/CD 带碰撞检测的 CSMA
&lt;ul>
&lt;li>先听后发
&lt;ul>
&lt;li>发送前一直在监听,闲则发送.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>边听边发
&lt;ul>
&lt;li>发送的时候监听&lt;strong>是否有冲突&lt;/strong>.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>冲突停发
&lt;ul>
&lt;li>有冲突则停止发送.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>随机重发
&lt;ul>
&lt;li>停止发送后,随机一段时间重发&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>CSMA/CA (用于&lt;strong>无线网&lt;/strong>) Collision Avoidance
&lt;ul>
&lt;li>无线网进行碰撞检测的难度大,则将CSMA/CD的&lt;strong>碰撞检测&lt;/strong>改为了&lt;strong>碰撞避免&lt;/strong>.&lt;/li>
&lt;li>发送数据时⼴播告知其他节点，让其他节点在某段时间内不要发送数据。利⽤ACK信号，对信道进⾏预约，以免出现碰撞。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h5 id="轮询访问">轮询访问&lt;/h5>
&lt;p>适用于环型总线.&lt;/p>
&lt;p>令牌传递协议:在环形⽹络中，只有得到令牌的主机才能够发送数据。&lt;/p>
&lt;p>FDDI环(光纤分布式数据接口): 令牌环形网络的一种。&lt;/p>
&lt;h4 id="网桥">网桥&lt;/h4>
&lt;p>&lt;strong>用于连接多个以太网(局域网)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>透明网桥&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>(选择的&lt;strong>不是最佳路由&lt;/strong>):按照自学习算法填写转发表，按转发表转发。&lt;/li>
&lt;li>&lt;strong>工作原理&lt;/strong>
&lt;ul>
&lt;li>维护转发表：收到一个帧时，先将它的&lt;strong>源地址记录&lt;/strong>下来自学习。&lt;/li>
&lt;li>拿目的地址比较转发表，如果找到对应项，直接往对应项记录的接口发送该帧。&lt;/li>
&lt;li>否则，向出来接口X外的&lt;strong>其他接口广播&lt;/strong>该帧。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>STP(生成树协议)&lt;/strong>：
&lt;ul>
&lt;li>该协议应用于在&lt;strong>网络中建立树形拓扑&lt;/strong>，&lt;strong>消除&lt;/strong>网络中的&lt;strong>环路&lt;/strong>，&lt;strong>避免&lt;/strong>由于环路存在而造成的&lt;strong>广播风暴&lt;/strong>问题。&lt;/li>
&lt;li>即&lt;strong>互连在一起的网桥在进行彼此通信后，就能找出原来的网络拓扑的一个子集&lt;/strong>。在这个子集里，整个连通的网络中不存在回路，即在任何两个站之间只有一条路径。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>所谓&lt;strong>自学习建立转发表&lt;/strong>&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>MAC地址为A的设备A，发出的帧从接口X进入网桥。&lt;/li>
&lt;li>根据反向操作，网桥知道一定能从接口X发送帧给A设备。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>源路由网桥&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>(选择的是最佳路路由): 先发送 &lt;strong>发现帧&lt;/strong>，按返回结果转发。&lt;/li>
&lt;li>&lt;strong>工作原理&lt;/strong>
&lt;ul>
&lt;li>源站以广播的方式发送发现帧，每个&lt;strong>发现帧记录所经过的所有路由&lt;/strong>。&lt;/li>
&lt;li>发现帧到达目的后，返回源站。&lt;/li>
&lt;li>源站从这些发现帧中选择最佳路由。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="交换机">交换机&lt;/h4>
&lt;p>&lt;strong>交换式集线器&lt;/strong>常称为&lt;strong>以太网交换机(switch)&lt;strong>或&lt;/strong>第二层交换机&lt;/strong>.&lt;/p>
&lt;ul>
&lt;li>有十几个接口,实质上就是一个多接口的网桥。&lt;/li>
&lt;li>以太网交换机的&lt;strong>每个接口都直接与主机相连&lt;/strong>，并且一般都工作在&lt;strong>全双工&lt;/strong>方式。&lt;/li>
&lt;li>每个用户在通信时是独占传输媒体的带宽，对于拥有 &lt;em>N&lt;/em> 对接口的交换机的总容量为 &lt;em>N&lt;/em>´10 Mb/s。这正是交换机的最大优点。&lt;/li>
&lt;li>&lt;strong>工作原理与透明网桥一致,自学习&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>可用来实现VLAN&lt;/strong>&lt;/p>
&lt;p>&lt;strong>VLAN(虚拟局域网)&lt;/strong>: 网络中的站点&lt;strong>不拘泥于所处的物理位置&lt;/strong>，而可以根据需要灵活地加入不同的逻辑子网中的一种网络技术。&lt;/p>
&lt;h3 id="点对点信道----接入因特网">点对点信道 &amp;ndash; 接入因特网&lt;/h3>
&lt;p>协议: PPP协议&lt;/p>
&lt;p>互联网用户通常需要连接到某个 ISP 之后才能接入到因特网&lt;/p>
&lt;p>ISP: Internet Service Provider 因特网服务提供商&lt;/p>
&lt;p>PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议。&lt;/p>
&lt;p>为网络层提供服务&lt;/p>
&lt;ul>
&lt;li>无确认的无连接&lt;/li>
&lt;li>有确认的无连接
&lt;ul>
&lt;li>不用建立链路，但目的主机收到帧后需要发送确认帧。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>有确认的有连接
&lt;ul>
&lt;li>建立连接，传输数据，释放连接。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>链路管理&lt;/p>
&lt;ul>
&lt;li>管理建立、维持和释放链路的过程。&lt;/li>
&lt;/ul>
&lt;p>组帧 与 帧定界&lt;/p>
&lt;ul>
&lt;li>确定帧的&lt;strong>首部尾部&lt;/strong>等&lt;strong>控制信息&lt;/strong>的&lt;strong>界限&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>字符计数法&lt;/p>
&lt;ul>
&lt;li>&lt;strong>帧的头部&lt;/strong> 使用 &lt;strong>计数字段&lt;/strong> 标明帧内字符数&lt;/li>
&lt;li>&lt;strong>缺点:&lt;/strong> 计数字段出错,会导致不能划分帧边界。&lt;/li>
&lt;li>字符填充的首尾界符法
&lt;ul>
&lt;li>用于异步传输&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>比特填充首尾标志法
&lt;ul>
&lt;li>用于同步传输,用硬件来实现.&lt;/li>
&lt;li>每5个0后面加1个1.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>帧同步&lt;/p>
&lt;ul>
&lt;li>在二进制比特流中，&lt;strong>确定帧的开始和结束位置&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>透明传输&lt;/p>
&lt;ul>
&lt;li>比特流能在链路上传输, 不改变比特流的内容(网络层不需要关系实现)&lt;/li>
&lt;/ul>
&lt;p>差错控制&lt;/p>
&lt;ul>
&lt;li>确认发送的数据帧是否被&lt;strong>正确&lt;/strong>接受。
&lt;ul>
&lt;li>检错编码
&lt;ul>
&lt;li>奇偶校验法&lt;/li>
&lt;li>循环冗余码CRC&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>纠错编码
&lt;ul>
&lt;li>海明码&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>流量控制&lt;/p>
&lt;ul>
&lt;li>由接收方控制发送方的流量。
&lt;ul>
&lt;li>停等流量控制
&lt;ul>
&lt;li>与可靠传输中一致&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>滑动窗口流量控制&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>可靠传输&lt;/p>
&lt;ul>
&lt;li>ARQ法 : Automatic Repeat reQuest 重传出错的帧.
&lt;ul>
&lt;li>本质上是使用&lt;strong>确认&lt;/strong>机制和&lt;strong>超时重传&lt;/strong>机制&lt;/li>
&lt;li>ARQ分为&lt;/li>
&lt;li>停等协议
&lt;ul>
&lt;li>发送方发送一个帧之后,必须要等待对方确认后才可以发送下一个帧.&lt;/li>
&lt;li>若等待时间超过规定时间,则发送方超时,重传原始帧.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>GBN 后退N帧协议
&lt;ul>
&lt;li>发送方发送完一个帧后,可以继续再发送若干帧. 发送方若收到确认帧,则可以继续发送.&lt;/li>
&lt;li>对于每一个帧,发送方判断超时时,重传该帧即之后的所有帧(&lt;strong>包括被确认的帧&lt;/strong>).&lt;/li>
&lt;li>接收方发现某个帧出错, 则&lt;strong>丢弃该帧和后续所有帧&lt;/strong>( &lt;strong>不返回否定帧&lt;/strong> ).&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>SR选择重传机制
&lt;ul>
&lt;li>发送方只重传 &lt;strong>超时&lt;/strong> 或 &lt;strong>被出错(返回否定)&lt;/strong> 的帧.&lt;/li>
&lt;li>接收方应当&lt;strong>加大接收窗口&lt;/strong> 来 接收&lt;strong>不连续但是未出现差错&lt;/strong>的帧,等重新收到出错帧的重传帧后⼀并提交给主机。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="ppp协议">PPP协议&lt;/h4>
&lt;p>&lt;strong>PPP Point To Point Protocol 点对点协议&lt;/strong>：&lt;/p>
&lt;p>面向&lt;strong>字节&lt;/strong>的数据链路层协议，应用于&lt;strong>直接连接在两个节点的链路&lt;/strong>上，通过&lt;strong>拨号&lt;/strong>或者&lt;strong>专线&lt;/strong>方式，&lt;strong>建立点对点连接&lt;/strong>发送数据。&lt;/p>
&lt;p>&lt;strong>HDLC High-Level Data Link Control 高级数据链路控制协议&lt;/strong>&lt;/p>
&lt;p>面向&lt;strong>比特&lt;/strong>的数据链路层协议。提供了&lt;strong>编号&lt;/strong>和&lt;strong>确认&lt;/strong>机制，能够提供&lt;strong>可靠传输&lt;/strong>。&lt;/p>
&lt;p>PPP&lt;strong>协议特点&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>简单&lt;/strong>——这是首要的要求&lt;/li>
&lt;li>&lt;strong>不进行&lt;/strong>
&lt;ul>
&lt;li>纠错&lt;/li>
&lt;li>流量控制&lt;/li>
&lt;li>半双工或单工链路&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>三个组成部分&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>封装：一种封装多协议数据报的方法。PPP 封装提供了不同网络层协议同时在&lt;strong>同一链路传输的多路复用技术&lt;/strong>。&lt;/li>
&lt;li>&lt;strong>LCP&lt;/strong>链路控制协议 LCP (Link Control Protocol)&lt;/li>
&lt;li>&lt;strong>NCP&lt;/strong>网络控制协议 NCP (Network Control Protocol)&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>IPCP(网际协议控制协议)&lt;/strong>：用于&lt;strong>建立、配置&lt;/strong>和&lt;strong>检测&lt;/strong>数据链路连接的连接控制协议&lt;strong>LCP&lt;/strong> 以及 用于&lt;strong>建立和&lt;/strong>
&lt;strong>配置&lt;/strong>不同网络层协议的网络控制协议&lt;strong>NCP协议簇&lt;/strong>。&lt;/p>
&lt;h5 id="ppp-协议的帧格式">PPP 协议的帧格式&lt;/h5>
&lt;p>PPP 是面向字节的，所有的 PPP 帧的长度都是整数字节。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/2024-03-06-16-26-17.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>首部&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>标志字段&lt;/strong> F = 0x7E （符号“0x”表示后面的字符是用十六进制表示。十六进制的 7E 的二进制表示是 01111110） &lt;strong>标记首尾&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>地址字段&lt;/strong> A 只置为 0xFF。地址字段实际上并不起作用&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>控制字段&lt;/strong> C 通常置为 0x03&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>首部有5字节，尾部3字节&lt;/strong>&lt;/p>
&lt;p>&lt;strong>尾部&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>FCS：帧检验序列，一般由CRC得出但不是唯一方法
&lt;ul>
&lt;li>使用FCS表示使用了 &lt;strong>无差错接受&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>标志字段&lt;/strong> F=7E &lt;strong>标记首尾&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>透明传输&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>同步传输时 采用硬件来完成比特填充（和 HDLC 的做法一样）&lt;/li>
&lt;li>异步传输时 &lt;strong>特殊的字符填充法&lt;/strong>，当&lt;strong>信息字段中&lt;/strong>出现：
&lt;ul>
&lt;li>7E标志字段 转成 5E&lt;/li>
&lt;li>7D转义标记 转成 5D&lt;/li>
&lt;li>ASCII码字符（小于0x20的） 前面加入7D并改变编码&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>PPP 不提供序号&lt;/strong> 和 &lt;strong>确认的可靠传输&lt;/strong>的原因：&lt;/p>
&lt;ul>
&lt;li>PPP 的信息字段放入的数据是 IP 数据报。&lt;strong>数据链路层&lt;/strong>的&lt;strong>可靠传输&lt;/strong>并&lt;strong>不能保证网络层的传输&lt;/strong>也是&lt;strong>可靠&lt;/strong>的&lt;/li>
&lt;li>&lt;strong>帧检验序列 FCS&lt;/strong> 字段可&lt;strong>保证无差错接受&lt;/strong>&lt;/li>
&lt;li>数据链路层出现差错的概率不大时，使用比较&lt;strong>简单&lt;/strong>的 PPP 协议较为合理。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>PPP 协议的工作状态&lt;/strong>：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>当&lt;strong>用户拨号接入 ISP&lt;/strong> 时，&lt;strong>路由器&lt;/strong>的调制解调器对拨号&lt;strong>做出确认&lt;/strong>，并&lt;strong>建立&lt;/strong>一条&lt;strong>物理连接&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>PC 机&lt;/strong> 向 &lt;strong>路由器发送&lt;/strong>一系列的 &lt;strong>LCP 分组&lt;/strong>（封装成多个 PPP 帧）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>这些分组及其响应选择一些 &lt;strong>PPP 参数&lt;/strong>，和进行&lt;strong>网络层配置&lt;/strong>。&lt;strong>NCP&lt;/strong> 给新接入的 PC机&lt;strong>分配&lt;/strong>一个&lt;strong>临时的 IP 地址&lt;/strong>，使 &lt;strong>PC 机&lt;/strong>成为&lt;strong>因特网上的一个主机&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>通信完毕&lt;/strong>时，&lt;strong>NCP&lt;/strong> 释放&lt;strong>网络层连接&lt;/strong>，&lt;strong>收回&lt;/strong>原来分配出去的 &lt;strong>IP&lt;/strong> 地址。接着，&lt;strong>LCP&lt;/strong>释放&lt;strong>数据链路层连接&lt;/strong>。&lt;strong>最后释放&lt;/strong>的是&lt;strong>物理层连接&lt;/strong>。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="数据链路层设备特点">数据链路层设备特点&lt;/h3>
&lt;ul>
&lt;li>数据链路层设备&lt;strong>能够隔离冲突域&lt;/strong>但&lt;strong>不能隔离广播域&lt;/strong>。&lt;/li>
&lt;li>都&lt;strong>按MAC地址转发&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h2 id="网络层-1">网络层&lt;/h2>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e7%bd%91%e7%bb%9c%e5%9f%ba%e7%a1%80/%e7%bd%91%e7%bb%9c%e5%b1%82%e5%8d%8f%e8%ae%ae.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>网络层提供的两种服务&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>面向有连接的虚电路服务&lt;/p>
&lt;/li>
&lt;li>
&lt;p>面向无连接的数据报服务&lt;/p>
&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>对比的方面&lt;/th>
&lt;th>虚电路服务&lt;/th>
&lt;th>数据报服务&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>思路&lt;/td>
&lt;td>可靠通信应当由网络来保证&lt;/td>
&lt;td>可靠通信应当由用户主机来保证&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>连接的建立&lt;/td>
&lt;td>必须有&lt;/td>
&lt;td>不需要&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>终点地址&lt;/td>
&lt;td>仅在连接建立阶段使用，每个分组使用&lt;strong>短的虚电路号&lt;/strong>&lt;/td>
&lt;td>每个分组都&lt;strong>有终点的完整地址&lt;/strong>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>分组的转发&lt;/td>
&lt;td>属于同一条虚电路的分组均&lt;strong>按照同一路由&lt;/strong>进行转发&lt;/td>
&lt;td>每个分组&lt;strong>独立选择路由&lt;/strong>进行转发&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>当结点出故障时&lt;/td>
&lt;td>所有通过出故障的结点的虚电路&lt;strong>均不能工作&lt;/strong>&lt;/td>
&lt;td>出故障的结点可能会&lt;strong>丢失分组&lt;/strong>，一些路由可能会发生变化&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>分组的顺序&lt;/td>
&lt;td>总是&lt;strong>按发送顺序&lt;/strong>到达终点&lt;/td>
&lt;td>到达终点时&lt;strong>不一定按&lt;/strong>发送顺序&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>端到端的差错处理和流量控制&lt;/td>
&lt;td>可以由网络负责，也可以由用户主机负责&lt;/td>
&lt;td>由用户主机负责&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="ip协议-internet-protocol">IP协议 (Internet Protocol)&lt;/h3>
&lt;p>TCP/IP 协议中最重要的协议之一，属于网络层的协议，主要作用是定义数据包的格式、对数据包进行路由和寻址，以便它们可以跨网络传播并到达正确的目的地。&lt;/p>
&lt;p>目前 IP 协议主要分为两种，一种是过去的 IPv4，另一种是较新的 IPv6，目前这两种协议都在使用，但后者已经被提议来取代前者。&lt;/p>
&lt;p>IP协议格式：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%9f%ba%e7%a1%80/2024-04-23-10-49-09.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;ul>
&lt;li>IP 协议会将传输层的报文作为数据部分&lt;/li>
&lt;li>再加上 IP 包头组装成 IP 报文&lt;/li>
&lt;li>如果 IP 报文大小超过 MTU（以太网中一般为 1500 字节）就会再次进行分片，得到一个即将发送到网络的 IP 报文。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>三种IP地址的编址方法&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>分类&lt;/strong>地址（二级IP地址）: 最基本的编址方法&lt;/li>
&lt;li>&lt;strong>子网&lt;/strong>划分（三级IP地址）: 对最基本的编址方法的改进&lt;/li>
&lt;li>&lt;strong>超网&lt;/strong>: 比较新的&lt;strong>无分类编址 CIDR&lt;/strong>方法&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>传统分类地址&lt;/strong>：&lt;/p>
&lt;p>IP = 网络号 + 主机号
网络号的长度决定了整个因特网中能容纳多少网络，主机号的长度决定每个网络能容纳多少台主机。&lt;/p>
&lt;p>IPv4规定，因特网地址长度为32比特（IPv6规定地址长度为128比特）。IPv4的地址空间为2^32，即4 294 967 296个IP地址。IP地址一般用点分十进制数表示，例如202.119.84.120。这四个用点分隔的段分别对应四个字节。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%9f%ba%e7%a1%80/IP%e4%bc%a0%e7%bb%9f%e5%88%86%e7%b1%bb%e5%9c%b0%e5%9d%80.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>类别&lt;/th>
&lt;th>网络号(bit)&lt;/th>
&lt;th>主机号(bit)&lt;/th>
&lt;th>网络号范围&lt;/th>
&lt;th>每个网络最大主机数&lt;/th>
&lt;th>内网地址&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>A&lt;/td>
&lt;td>8&lt;/td>
&lt;td>24&lt;/td>
&lt;td>1~127&lt;/td>
&lt;td>16777214(2^24-2)&lt;/td>
&lt;td>10.0.0.0~10.255.255.255&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>B&lt;/td>
&lt;td>16&lt;/td>
&lt;td>16&lt;/td>
&lt;td>128.1~191.255&lt;/td>
&lt;td>65534(2^16-2)&lt;/td>
&lt;td>172.16.0.0~172.31.255.255&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>C&lt;/td>
&lt;td>24&lt;/td>
&lt;td>8&lt;/td>
&lt;td>192.0.1~223.255.255&lt;/td>
&lt;td>254(2^8 - 2)&lt;/td>
&lt;td>192.168.0.0~192.168.255.255&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>D&lt;/td>
&lt;td>&lt;strong>组播地址&lt;/strong>&lt;/td>
&lt;td>&lt;/td>
&lt;td>224.0.0.0~239.255.255.255&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>E&lt;/td>
&lt;td>保留&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>特殊地址&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>主机号不能为全0和全1&lt;/li>
&lt;li>&lt;strong>广播地址&lt;/strong>：除网络号外全为1&lt;/li>
&lt;li>&lt;strong>0.0.0.0&lt;/strong>：设置了缺省网关时的缺省路由&lt;/li>
&lt;li>127.0.0.1：本地保留地址&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>内网地址&lt;/strong>：&lt;/p>
&lt;p>RFC 1918 指明的专用地址(private address)（内网地址）&lt;/p>
&lt;p>10.0.0.0 到 10.255.255.255&lt;/p>
&lt;p>172.16.0.0 到 172.31.255.255&lt;/p>
&lt;p>192.168.0.0 到 192.168.255.255&lt;/p>
&lt;p>&lt;strong>划分子网方法&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>IP 地址中增加了一个 “&lt;strong>子网号&lt;/strong>字段”，使两级的 IP 地址变成为&lt;strong>三级&lt;/strong>的 IP 地址。&lt;strong>划分子网已成为因特网的正式标准协议&lt;/strong>。&lt;/li>
&lt;li>ABC类地址的&lt;strong>默认子网掩码&lt;/strong>就是对应网络号的位数。&lt;/li>
&lt;li>255.0.0.0 / 255.255.0.0 / 255.255.255.0&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>子网掩码&lt;/strong>: 通过&lt;strong>与IP地址进行与操作&lt;/strong>，将IP地址划分成网络地址和主机地址两个部分。&lt;/p>
&lt;p>&lt;strong>划分子网的匹配方法&lt;/strong>: 将IP地址 与 该网络的子网掩码相与得到网络号,判断是否匹配.(不能得出唯一网络地址)&lt;/p>
&lt;p>&lt;strong>无分类编址CIDR&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>CIDR Classless Inter-Domain Routing &lt;strong>无分类域间路由选择&lt;/strong>：使用&lt;strong>各种长度的网络前缀&lt;/strong>来代替分类地址中的&lt;strong>网络号和子网号&lt;/strong>的一种子网划分方式。&lt;/li>
&lt;li>格式：网络前缀 + 主机号。从三级地址回到两级地址。&lt;/li>
&lt;li>CIDR记法 128.14.32.0/20. 20表示的是网络前缀位数。主机号位数 = 32 - 网络前缀位数&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>VLSM (Variable Length Subnet Mask) 变长子网掩码&lt;/strong>：在一个划分子网的网络中可同时使用几个不同的子网掩码。CIDR是在VLSM基础上研究出的。&lt;/p>
&lt;p>IP 协议的寻址作用是下一个目的地
路由则是根据「下一个目的地」选择路径。&lt;/p>
&lt;p>&lt;strong>路由聚合(构成超网)&lt;/strong>: CIDR 地址块可以表示很多地址，这种地址的聚合常称为&lt;strong>路由聚合&lt;/strong>，它使得&lt;strong>路由表中的一个项目&lt;/strong>可以表示&lt;strong>很多个（例如上千个）&lt;strong>原来&lt;/strong>传统分类地址&lt;/strong>的&lt;strong>路由&lt;/strong>。&lt;/p>
&lt;ul>
&lt;li>缩短路由表尺寸&lt;/li>
&lt;li>支持不连续子网&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>超网&lt;/strong>：前缀长度&lt;strong>不超过 23&lt;/strong> 位的 CIDR 地址块都包含了多个 C 类地址。&lt;strong>这些 C 类地址合起来&lt;/strong>就构成了超网。&lt;/p>
&lt;p>&lt;strong>特定主机路由&lt;/strong>：为&lt;strong>特定的目的主机&lt;/strong> &lt;strong>指明一个路由&lt;/strong>。采用特定主机路由可使网络管理人员能够更&lt;strong>方便地控制&lt;/strong>网络和&lt;strong>测试&lt;/strong>网络，同时也可在需要考虑某种安全问题时采用这种特定主机路由。&lt;/p>
&lt;p>&lt;strong>默认路由&lt;/strong>：采用默认路由可以&lt;strong>减少路由表所占用的空间&lt;/strong>和&lt;strong>搜索路由表所用的时间&lt;/strong>。 当目的网络&lt;strong>不在路由表中&lt;/strong>就选择&lt;strong>默认路由&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>如何找下一跳路由器&lt;/strong>：路由器将IP送交&lt;strong>下层网络接口软件&lt;/strong>，&lt;strong>使用 ARP&lt;/strong> 负责将下一跳路由器的 IP 地址转换成硬件地址。硬件地址放在MAC帧首部，&lt;strong>根据硬件地址找到下一跳&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>分组转发算法工作原理&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>数据包首部提取主机IP地址D&lt;/li>
&lt;li>判断能否&lt;strong>直接交付&lt;/strong>
&lt;ul>
&lt;li>传统分类: 直接提取网络地址N,网络N与路由器直接相连就直接交付.&lt;/li>
&lt;li>划分子网: 将路由器相连的各网络进行匹配.匹配成功就直接交付.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>判断是否有&lt;strong>特定路由&lt;/strong>
&lt;ul>
&lt;li>都是通过判断是否有&lt;strong>目的地址为D&lt;/strong>的特定路由&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>在路由表中查找
&lt;ul>
&lt;li>传统分类:直接一一匹配.&lt;/li>
&lt;li>划分子网:IP地址 与 每一个项目的子网掩码相与后匹配.&lt;/li>
&lt;li>无分类编址: 使用&lt;strong>二叉线索树&lt;/strong>进行&lt;strong>最长前缀匹配&lt;/strong>.前缀越长,地址块越小,地址越具体.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>使用默认路由, 如没有&lt;/li>
&lt;li>报告转发失败.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>路由环路&lt;/strong>:用户的数据包不停在网络上循环发送，始终到达不了目的地，严重浪费网络资源。&lt;/p>
&lt;p>&lt;strong>路由环路解决方法&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>Defining a Maximum/定义最大跳数(一般为15)：&lt;strong>超过最大跳数&lt;/strong>则&lt;strong>抛弃报文&lt;/strong>。&lt;/li>
&lt;li>路由毒害/Route Poisoning:当路由信息的跳数超过定义最大跳时，不是直接从路由表中删除该路由信息，而是&lt;strong>向相邻路由发送&lt;/strong>相关路由信息，&lt;strong>通知其他路由该路径失效&lt;/strong>。&lt;/li>
&lt;li>Split Horizon/&lt;strong>水平分割&lt;/strong>:路由器从某个接口接收到的更新信息&lt;strong>不允许再从这个接口发回去&lt;/strong>。&lt;/li>
&lt;li>Hold-Down-Timers/抑制计时器器:如果一条路由更新的跳数大于路由表已记录的该路由的跳数，&lt;strong>启动计时器&lt;/strong>，在计时器超时前，路由器不再接收关于这条路由的更新信息。&lt;/li>
&lt;/ul>
&lt;h3 id="41-路由协议igp-rip-ospf-bgp">4.1 路由协议(IGP RIP OSPF, BGP)&lt;/h3>
&lt;p>&lt;strong>静态路由与动态路由&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>静态路由&lt;/strong>：非自适应路由，指由网络管理员&lt;strong>手工配置的路由&lt;/strong>信息。&lt;strong>简单开销小&lt;/strong>，但&lt;strong>不能及时适应&lt;/strong>网络变化。&lt;/li>
&lt;li>&lt;strong>动态路由&lt;/strong>：自适应路由选择，&lt;strong>通过路由交换的信息&lt;/strong>来构造路由表。&lt;strong>复杂开销大，能适应&lt;/strong>变化。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>自治系统 AS&lt;/strong>
(Autonomous System) ：&lt;/p>
&lt;p>一个 AS 对其他 AS 表现出的是一个&lt;strong>单一的&lt;/strong>和&lt;strong>一致的路由选择策略&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>IGP与EGP&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>内部网关协议 &lt;strong>IGP&lt;/strong> (Interior Gateway Protocol) 即在&lt;strong>一个自治系统内部使用的路由选择&lt;/strong>协议。目前这类路由选择协议使用得最多，如 &lt;strong>RIP 和 OSPF&lt;/strong> 协议。&lt;/li>
&lt;li>外部网关协议&lt;strong>EGP&lt;/strong> (External Gateway Protocol) 在自治系统之间使用的。在外部网关协议中目前使用最多的是 &lt;strong>BGP&lt;/strong>-4。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>DV 距离向量 / DVP(Distance Vector Protocol) 距离矢量协议&lt;/strong> ：所有结点都&lt;strong>定期&lt;/strong>地将他们整个&lt;strong>路由表传送给&lt;/strong>所有与之直接&lt;strong>相邻的结点&lt;/strong>。RIP IGRP.&lt;/p>
&lt;p>&lt;strong>LS 链路状态 / LSP(Link State Protocol) 链路状态协议&lt;/strong>： 主动测试&lt;strong>所有邻接结点的状态&lt;/strong>并定期将链路状态传播&lt;strong>给所有其他结点&lt;/strong>。OSPF&lt;/p>
&lt;p>&lt;strong>IGRP（Interior Gateway Routing Protocol）与 EIGRP 增强:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Cisco 专用协议，以延迟，带宽，负载，可靠性为度量标准
最大跳数：255 每 90 秒更新&lt;/li>
&lt;/ul>
&lt;p>**RIP **:&lt;/p>
&lt;ul>
&lt;li>基于&lt;strong>距离向量&lt;/strong>的路由选择协议（Bellman-Ford）
&lt;ul>
&lt;li>每个路由器维护从自己到其他网络的&lt;strong>跳数&lt;/strong>。&lt;/li>
&lt;li>使用&lt;strong>UDP&lt;/strong>,按固定的时间间隔(30s) 和 相邻路由器 交换 自己的路由表,并维护自己的路由表。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>在带宽、配置和管理方面要求低，适合于规模较小的网络中&lt;/li>
&lt;li>&lt;strong>好消息传播得快，而坏消息传播得慢&lt;/strong>。网络出故障的传播时间往往需要较长的时间(例如数分钟)。这是 RIP 的一个主要缺点。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>RIP工作原理&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>收到&lt;/strong>相邻路由器X的&lt;strong>RIP报文&lt;/strong>.&lt;/li>
&lt;li>&lt;strong>修改RIP报文&lt;/strong>,把所有项目的下一跳字段改成X,距离++.&lt;/li>
&lt;li>对于&lt;strong>每个项目&lt;/strong>
&lt;ul>
&lt;li>路由表中无该项目的&lt;strong>目的地址&lt;/strong>, 加入到路由表中.&lt;/li>
&lt;li>否则, 路由表已有的下一跳是X,直接替换.&lt;/li>
&lt;li>否则, 项目中的距离更小,直接替换.&lt;/li>
&lt;li>否则,啥都不做.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>检测相邻路由器心跳&lt;/strong>:3分钟没有收到相邻路由器传报文,将与它的距离置为16(不可达)&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>OSPF&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>是&lt;strong>分布式的链路状态&lt;/strong>协议。
&lt;ul>
&lt;li>只有当链路状态&lt;strong>发生变化&lt;/strong>时，路由器&lt;strong>直接用 IP 数据报&lt;/strong>用&lt;strong>洪泛法&lt;/strong>向&lt;strong>所有路由器&lt;/strong>发送 &lt;strong>与自己的相邻路由器的链路状态LSA（依据LSA而不是Hello）&lt;/strong>.
&lt;ul>
&lt;li>“链路状态” 就是说明本路由器都和哪些路由器相邻，以及该链路的**“度量”**(metric)。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Link - state database 链路状态数据库LSDB
&lt;ul>
&lt;li>全网的拓扑结构图.在全网范围内一致.&lt;/li>
&lt;li>能够较快更新.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>OSPF工作原理&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>OSPF路由器相互发送 HELLO 报文，&lt;strong>建立邻居&lt;/strong>关系&lt;/li>
&lt;li>&lt;strong>邻居&lt;/strong>路由器之间相互&lt;strong>通告自身的链路状态信息(LSA)&lt;/strong>;&lt;/li>
&lt;li>&lt;strong>经过&lt;/strong>一段时间的 &lt;strong>LSA 泛洪&lt;/strong>后所有路由器&lt;strong>形成统一的 LSDB&lt;/strong>&lt;/li>
&lt;li>路由器根据 SPF最短路 算法，以⾃⼰为根&lt;strong>计算最短⽣成树&lt;/strong>，&lt;strong>形成路由转发信息&lt;/strong>.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>BGP&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Border Gateway Protocol 边界网关协议,属于&lt;strong>EGP&lt;/strong>&lt;/p>
&lt;p>BGP 是不同自治系统的路由器之间交换路由信息的协议。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>边界网关协议 BGP 只能是力求寻找一条&lt;strong>能够到达目的网络且比较好&lt;/strong>的路由（不能兜圈子），而&lt;strong>并非要寻找一条最佳路由&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>BGP 协议交换路由信息的结点数量级是&lt;strong>自治系统数的量级&lt;/strong>，这要比这些自治系统中的网络数少很多。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>BGP &lt;strong>支持 CIDR&lt;/strong>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>BGP工作原理&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>每个自治系统至少有一个路由器作为BGP发言人。&lt;/li>
&lt;li>不同自治系统的
BGP发言人都过&lt;strong>建立TCP连接&lt;/strong>交换不同自治系统之间的路由信息。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>“转发”和“路由选择”的区别&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>“转发”(forwarding)就是&lt;strong>路由器根据转发表&lt;/strong>将用户的 &lt;strong>IP 数据报从合适的端口转发&lt;/strong>出去。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>“路由选择”(routing)则是按照&lt;strong>分布式算法&lt;/strong>，根据&lt;strong>从各相邻路由器得到的关于网络拓扑的变化&lt;/strong> 情况，动态地&lt;strong>改变所选择的路由&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>路由表&lt;/strong>是根据&lt;strong>路由选择算法&lt;/strong>得出的。而&lt;strong>转发表是从路由表得出&lt;/strong>的。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>ACL&lt;/strong>: 访问控制列表Access Control Lists
一些告诉路由哪些包该拒绝哪些包能通过的序列集。可以根据源地址，目的地址，链路协议来决定。如果包没有在ACL找到相应的条目，则会被丢弃。&lt;/p>
&lt;h3 id="42-ip多播组播igmpnat">4.2 IP多播/组播(IGMP,NAT)&lt;/h3>
&lt;p>&lt;strong>多播/组播&lt;/strong>: 主机之间 &lt;strong>一对一组&lt;/strong>的通讯模式，同组的主机可接收此组内所有数据. 发送者只需要发送一次, &lt;strong>组播路由器&lt;/strong>只向有需求者复制并转发其所需数据。&lt;/p>
&lt;p>&lt;strong>组播地址&lt;/strong>: 使用D类地址 224.0.0.0 ~ 239.255.255.255.每个D类地址标识一个组.&lt;/p>
&lt;p>&lt;strong>IGMP&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>网际组管理协议 IGMP&lt;/strong> (Internet Group Management Protocol&lt;/li>
&lt;li>&lt;strong>IGMP 使用 IP 数据报传递其报文&lt;/strong>，不把 IGMP 看成是一个单独的协议，而是属于&lt;strong>整个网际协议 IP 的一个组成部分&lt;/strong>&lt;/li>
&lt;li>&lt;strong>不是&lt;/strong>对所有组播成员管理的协议&lt;/li>
&lt;li>不知道成员数和成员分布情况&lt;/li>
&lt;li>让连接在本地局域网的&lt;strong>组播路由器&lt;/strong>知道是否有&lt;strong>主机加入/退出多播组&lt;/strong>.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>IGMP工作原理&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>主机的加入&lt;/strong>
&lt;ul>
&lt;li>想加入的主机,向&lt;strong>对应组播组的组播地址&lt;/strong>发送IGMP.&lt;/li>
&lt;li>&lt;strong>本地组播路由器&lt;/strong>收到后,将&lt;strong>该组成员关系&lt;/strong>发送给&lt;strong>因特网&lt;/strong>上的&lt;strong>其他组播路由器&lt;/strong>.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>探询主机&lt;/strong>
&lt;ul>
&lt;li>本地&lt;strong>组播路由器周期性探询&lt;/strong>本地主机.主机收到后响应.&lt;/li>
&lt;li>如有一个组经过几次探询都没有主机响应,则不再转发该组成员关系.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>VPN&lt;/strong>: 基于TCP/IP的虚拟专用网,分为内联网和外联网,使用&lt;strong>内网地址&lt;/strong>.&lt;/p>
&lt;p>&lt;strong>NAT&lt;/strong>:Network Address Translation 网络地址转换:实现&lt;strong>专用网络地址和公用网络地址&lt;/strong>之间的转化。当私有网和公网主机通信的私有IP经过NAT时，&lt;strong>将IP包中的私有IP与NAT的公有IP进行转换&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>NAT&lt;/strong> 软件 ：需要在&lt;strong>专用网连接到因特网&lt;/strong>的&lt;strong>路由器&lt;/strong>上安装 &lt;strong>NAT&lt;/strong> 软件&lt;/p>
&lt;p>&lt;strong>NAT路由器&lt;/strong>：装有 NAT 软件的路由器叫做 NAT路由器，它至少有一个有效的外部全球地址 IP&lt;em>G&lt;/em>。&lt;/p>
&lt;p>&lt;strong>PAT/NAPT(端口地址转换)&lt;/strong>:将本地网上的多个设备映射到一个单一的公共ip地址。&lt;/p>
&lt;h3 id="44-arp-rarp-dhcp">4.4 ARP RARP DHCP&lt;/h3>
&lt;p>&lt;strong>ARP&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>ARP 地址解析协议：源主机在向目标主机&lt;strong>发送IP包前&lt;/strong>，通过&lt;strong>广播ARP请求包&lt;/strong>，将&lt;strong>目标主机的IP地址映射为MAC地址&lt;/strong>。&lt;/li>
&lt;li>每一个主机都设有一个ARP 高速缓存(ARP cache)，里面有所在的局域网上的各主机和路由器的 &lt;strong>IP 地址到硬件地址&lt;/strong>的映射表。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>ARP的四种典型使用情况&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>发送方是主机 / 路由器，要发送IP数据报到&lt;strong>本网络的另一个主机&lt;/strong>。
&lt;ul>
&lt;li>用ARP找目的主机的硬件地址&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>发送方是主机 / 路由器，发送IP数据报的另一个网络上。
&lt;ul>
&lt;li>用ARP找到本网络 &lt;strong>另一个路由器&lt;/strong>的硬件地址。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>ARP工作原理&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>源主机在向⽬标主机发送 IP 包前，如果源主机不知道⽬标主机的 MAC地址。&lt;/li>
&lt;li>源主机&lt;strong>向以太网所有计算机广播&lt;/strong>一个填有⽬标主机IP的&lt;strong>ARP请求包&lt;/strong>。&lt;/li>
&lt;li>&lt;strong>目标主机接收请求&lt;/strong>后，向源主机回复填充上了⽬标主机的 MAC
地址&lt;strong>ARP 应答包&lt;/strong>。&lt;/li>
&lt;li>源主机得到 &lt;strong>ARP 应答&lt;/strong>后，将⽬标主机的 MAC 地址存入本机ARP高速缓存，便于下次使用。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>RARP(反向地址转换协议)&lt;/strong>:用于将局域网中的某个主机的&lt;strong>物理地址转换为IP地址&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>RARP协议工作原理&lt;/strong>:&lt;/p>
&lt;ol>
&lt;li>源主机发送一个&lt;strong>声明自己的MAC地址&lt;/strong>的&lt;strong>请求分配IP地址&lt;/strong>的本地的RARP广播包。&lt;/li>
&lt;li>本地网段上的&lt;strong>RARP服务器&lt;/strong>收到此请求后，检查其RARP列表，查找该MAC地址对应的IP地址；&lt;/li>
&lt;li>如果存在，RARP服务器就给源主机发送一个包含此IP地址响应数据包；如果不存在，&lt;strong>RARP服务器对此不做任何的响应&lt;/strong>；&lt;/li>
&lt;li>源主机如果收到从RARP服务器的响应信息，就利用得到的IP地址进行通讯；如果一直没有收到
RARP服务器的响应信息，表示初始化失败。&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>DHCP（动态主机配置协议 !!应用层!! ）&lt;/strong>：用于给网络中的主机&lt;strong>动态分配&lt;/strong>IP地址。&lt;/p>
&lt;p>&lt;strong>DHCP工作原理&lt;/strong>：&lt;/p>
&lt;ol>
&lt;li>寻找服务器：DHCP客户端广播”DHCP&lt;strong>发现&lt;/strong>消息”，寻找网络中的DHCP服务器。&lt;/li>
&lt;li>提供IP地址: DHCP服务器收到“DHCP&lt;strong>发现&lt;/strong>消息”后，就广播”DHCP&lt;strong>提供&lt;/strong>消息”，包括提供&lt;strong>客户端的IP地址和&lt;/strong>
&lt;strong>相关配置信息&lt;/strong>。&lt;/li>
&lt;li>请求分配IP: DHCP客户端收到“DHCP&lt;strong>提供&lt;/strong>消息”，如果接收客户端提供的相关参数，则广播“DHCP&lt;strong>请求&lt;/strong>消息”向DHCP服务端请求使用该IP地址。&lt;/li>
&lt;li>确认分配:DHCP服务端收
到”DHCP&lt;strong>请求&lt;/strong>消息后“，广播”DHCP&lt;strong>确认&lt;/strong>消息“，将IP地址分配给DHCP客户端。&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>DHCP和RARP的区别&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>RARP只能实现简单的从MAC地址到IP地址的&lt;strong>查询&lt;/strong>工作，RARP服务器上的
MAC地址和IP地址必须&lt;strong>事先静态配置&lt;/strong>好。&lt;/li>
&lt;li>DHCP可以实现除静态分配以外的&lt;strong>动态IP地址分配&lt;/strong>以及&lt;strong>IP地址租期管理等&lt;/strong>复杂功能。&lt;/li>
&lt;/ul>
&lt;h3 id="45-icmp">4.5 ICMP&lt;/h3>
&lt;p>&lt;strong>ICMP(英特网控制报文协议):&lt;/strong> 用来给&lt;strong>主机或路由器报告差错和异常&lt;/strong>情况。ICMP 报文作为 IP 层数据报的数据，加上数据报的首部，组成 IP 数据报发送出去。&lt;/p>
&lt;p>一种用于传输网络状态和错误消息的协议，常用于网络诊断和故障排除。例如，Ping 工具就使用了 ICMP 协议来测试网络连通性。&lt;/p>
&lt;p>&lt;strong>ICMP种类&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>ICMP 差错报告报文
&lt;ul>
&lt;li>终点不可达&lt;/li>
&lt;li>源点抑制(Source quench)&lt;/li>
&lt;li>时间超过&lt;/li>
&lt;li>参数问题&lt;/li>
&lt;li>改变路由（重定向）(Redirect)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ICMP 询问报文
&lt;ul>
&lt;li>有两类 &lt;strong>回送请求和回答报文&lt;/strong>、&lt;strong>时间戳请求和回答报文&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>PING&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Packet InterNet Groper 分组网间探测 ：&lt;/p>
&lt;/li>
&lt;li>
&lt;p>PING 是&lt;strong>应用层直接使用网络层 ICMP&lt;/strong> 的例子，它没有通过运输层的 TCP 或UDP。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>用来测试两个主机之间的连通性。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>PING 使用了 ICMP &lt;strong>回送请求与回送回答报文&lt;/strong>。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Traceroute/Trace&lt;/strong>：工作在&lt;strong>网络层&lt;/strong>，使用了&lt;strong>时间超过报文&lt;/strong>&lt;/p>
&lt;h3 id="45设备">4.5设备&lt;/h3>
&lt;p>网络层设备 &amp;ndash; 路由器: &lt;strong>既能隔离冲突域又能隔离广播域&lt;/strong>&lt;/p>
&lt;h2 id="传输层">传输层&lt;/h2>
&lt;p>核心是服务应用层，实际的传输功能是在网络层实现的。&lt;/p>
&lt;p>&lt;strong>传输层的功能&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>端到端的逻辑通信;&lt;/li>
&lt;li>收到的报文进行差错检测;&lt;/li>
&lt;li>提供面向连接的TCP和无连接的UDP.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>传输层提供的信道&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>TCP: 逻辑通信道就相当于一条全双工的可靠信道.&lt;/li>
&lt;li>UDP:不可靠的无连接信道.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>运输协议数据单元 TPDU&lt;/strong>.Transport Protocol Data Unit&lt;/p>
&lt;h3 id="udp">UDP&lt;/h3>
&lt;ul>
&lt;li>User Datagram Protocol 用户数据报协议&lt;/li>
&lt;li>提供&lt;strong>面向事务&lt;/strong>的&lt;strong>简单不可靠&lt;/strong>信息传送服务&lt;/li>
&lt;li>TPDU: UDP &lt;strong>报文或用户数据报&lt;/strong>。&lt;/li>
&lt;li>传输开销小、报文头部小 &lt;strong>8字节&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h3 id="tcp">TCP&lt;/h3>
&lt;ul>
&lt;li>Transmission Control Protocol 传输控制协议&lt;/li>
&lt;li>提供&lt;strong>面向连接&lt;/strong>的、&lt;strong>可靠&lt;/strong>的&lt;strong>字节流&lt;/strong>服务&lt;/li>
&lt;li>TPDU: &lt;strong>TCP 报文段&lt;/strong>(segment)&lt;/li>
&lt;li>传输开销大、报文头部大&lt;/li>
&lt;li>&lt;strong>全双工&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>应用需要传输的数据可能会非常大，如果直接传输就不好控制，因此当传输层的数据包大小超过 MSS（TCP 最大报文段长度） ，就要将数据包分块，这样即使中途有一个分块丢失或损坏了，只需要重新发送这一个分块，而不用重新发送整个数据包。在 TCP 协议中，我们把每个分块称为一个 TCP 段（TCP Segment）。&lt;/p>
&lt;p>当设备作为接收方时，传输层则要负责把数据包传给应用，但是一台设备上可能会有很多应用在接收或者传输数据，因此需要用一个编号将应用区分开来，这个编号就是端口。&lt;/p>
&lt;p>传输层的报文中会携带端口号，因此接收方可以识别出该报文是发送给哪个应用。&lt;/p>
&lt;p>&lt;strong>端口port&lt;/strong>：&lt;strong>2字节16位&lt;/strong>，用来&lt;strong>标识和区分某一台主机上的不同应用进程&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>套接字 Socket&lt;/strong>：由主机IP地址和端口号组成。唯一标识了某台主机上的某个应用进程。&lt;/p>
&lt;p>SSH 22&lt;/p>
&lt;p>HTTP 80，SNMP 161&lt;/p>
&lt;p>DNS 53，SMTP 25&lt;/p>
&lt;p>&lt;strong>TELNET 23&lt;/strong>，FTP 21&lt;/p>
&lt;h4 id="三种可靠传输机制">三种可靠传输机制&lt;/h4>
&lt;ul>
&lt;li>TCP数据&lt;strong>编号&lt;/strong>: 建立连接时协定初始编号,每一个&lt;strong>字节&lt;/strong>对应一个&lt;strong>编号&lt;/strong>,保证数据有序提交应用层。&lt;/li>
&lt;li>TCP数据&lt;strong>确认&lt;/strong>: 对接收到的数据的&lt;strong>最高序号表示确认&lt;/strong>。&lt;/li>
&lt;li>TCP&lt;strong>重传&lt;/strong>机制: 设置计时器&lt;strong>超时重传&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>流量控制&lt;/strong>： 端与端之间通信量的控制。&lt;strong>让发送方的发送速率不要太快&lt;/strong>，既要让接收方来得及接收，也不要使网络发生拥塞。一般使用滑动窗口进行流量控制。&lt;/p>
&lt;p>&lt;strong>拥塞控制&lt;/strong>：使网络能够承受现有的&lt;strong>网络负荷&lt;/strong>。本质是根据自己估算的网络拥塞程度&lt;strong>设置拥塞窗口的值cwnd&lt;/strong>来限定发送速率。&lt;/p>
&lt;h4 id="拥塞控制四种方法">拥塞控制四种方法&lt;/h4>
&lt;ul>
&lt;li>
&lt;p>慢开始: cwnd = 1，每收到一个确认cwnd++&lt;/p>
&lt;/li>
&lt;li>
&lt;p>拥塞避免: 设置慢开始门限 ssthresh&lt;/p>
&lt;ul>
&lt;li>当 cwnd &amp;lt; ssthresh 时，使用慢开始算法。&lt;/li>
&lt;li>当 cwnd &amp;gt; ssthresh 时，使用&lt;strong>拥塞避免算法&lt;/strong>：每过一个RTT往返时间cwnd++&lt;/li>
&lt;li>出现拥塞时，ssthresh 为 cwnd/2 ，cwnd = 1&lt;/li>
&lt;li>思想：乘法减小，加法增大&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>快重传:&lt;/p>
&lt;ul>
&lt;li>接收方&lt;strong>每收到一个 失序 的报文段&lt;/strong>后就&lt;strong>立即&lt;/strong>发出&lt;strong>重复确认&lt;/strong>。&lt;/li>
&lt;li>发送方只要&lt;strong>一连收到三个重复确认&lt;/strong>就应当立即&lt;strong>重传对方尚未收到的报文段&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>快恢复: 发送方&lt;strong>一连收到三个重复确认&lt;/strong>，ssthresh = cwnd/2，但cwnd不变，此时是由RRT线性增大。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h4 id="三次握手">三次握手&lt;/h4>
&lt;ul>
&lt;li>&lt;strong>第一次&lt;/strong>
&lt;ul>
&lt;li>客户机发送&lt;strong>连接请求报文段&lt;/strong>，请求建立连接&lt;/li>
&lt;li>client：置为syn_send，发送请求 SYN = 1, seq = x&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>第二次&lt;/strong>
&lt;ul>
&lt;li>服务机收到请求后,发回&lt;strong>确认报文段&lt;/strong>.&lt;/li>
&lt;li>同时发送自己的序列号.&lt;/li>
&lt;li>server：置为syn_recvd,发送 SYN = 1,seq = y，ACK x.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>第三次&lt;/strong>
&lt;ul>
&lt;li>客户端收到确认后，发回&lt;strong>确认报文段&lt;/strong>.&lt;/li>
&lt;li>A 的 TCP 通知上层应用进程，连接已经建立。&lt;/li>
&lt;li>client:置为established&lt;/li>
&lt;li>server 收到 该确认报文段后，置为established&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>TCP三次握手的原因&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>因为第二次服务端接收到连接请求的时候，也想建立连接，所以将SYN和ACK一起发送。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>第一次和第二次：为了保证&lt;strong>服务端能收接受到客户端&lt;/strong>的信息并能做出正确的应答。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>第二次和第三次：为了保证&lt;strong>客户端能收接受到服务端&lt;/strong>的信息并能做出正确的应答。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h4 id="四次挥手过程">四次挥手过程&lt;/h4>
&lt;ul>
&lt;li>&lt;strong>第一次&lt;/strong>：&lt;strong>客户端&lt;/strong>发送&lt;strong>FIN报文请求释放连接&lt;/strong>。用来关闭客户端到服务端的数据传送。单向关闭，客户端的状态变为FIN_WAIT_1。&lt;/li>
&lt;li>&lt;strong>第二次&lt;/strong>：&lt;strong>服务端&lt;/strong>收到这个FIN后，&lt;strong>发回ACK确认&lt;/strong>。客户端到服务端方向的连接释放，TCP处于半关闭。客户端无法向服务端发送数据，但服务端仍然可以向客户端发送数据。服务端的状态变为CLOSE_WAIT。客户端收到ACK后，状态变为FIN_WAIT_2。&lt;/li>
&lt;li>&lt;strong>第三次&lt;/strong>：&lt;strong>服务端&lt;/strong>发送&lt;strong>FIN报文释放连接&lt;/strong>，用来关闭服务端到客户端的数据传送。服务端的状态变为LAST_ACK。&lt;/li>
&lt;li>&lt;strong>第四次&lt;/strong>：&lt;strong>客户端发送ACK&lt;/strong>，并等待2MSL。客户端收到FIN后，状态变为TIME_WAIT。服务端等待客户端的确认。若客户端在2MSL内&lt;strong>未收到&lt;/strong>服务端&lt;strong>重发的FIN报文&lt;/strong>，则客户端在2MSL后关闭。TCP连接释放完成。服务端收到ACK后，状态变为CLOSED。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>TCP四次挥手原因&lt;/strong>&lt;/p>
&lt;p>当客户端请求释放连接时，服务端发回ACK确认，但是服务端并不一定也要关闭TCP连接。即服务端不一定会马上关闭SOCKET。所以会将&lt;strong>ACK报⽂文和FIN报文分开&lt;/strong>发送。&lt;/p>
&lt;p>&lt;strong>四次挥手的状态转换&lt;/strong>&lt;/p>
&lt;p>netstat -an&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e8%ae%a1%e7%bd%91%e5%9f%ba%e7%a1%80/%e7%8a%b6%e6%80%81%e8%bd%ac%e6%8d%a2%e5%9b%be.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
客户端处于 ESTABLISHED 状态时发送 FIN 报文，进入 FIN-WAIT-1 状态。&lt;/p>
&lt;p>服务端收到 FIN 报文后,发送 ACK 报文确认,进入 CLOSE-WAIT 状态。&lt;/p>
&lt;p>客户端收到 ACK 报文后,进入 FIN-WAIT-2 状态,等待服务端发送 FIN 报文。&lt;/p>
&lt;p>服务端准备好关闭连接时,发送 FIN 报文,进入 LAST-ACK 状态。&lt;/p>
&lt;p>客户端收到 FIN 报文后,发送 ACK 报文确认,进入 TIME-WAIT 状态,等待 2MSL(最大报文生存时间)后进入 CLOSED 状态。&lt;/p>
&lt;p>服务端收到 ACK 报文后,进入 CLOSED 状态,TCP 连接关闭。&lt;/p>
&lt;p>&lt;strong>TCP最后一次挥手客户端要等待2MSL(最长报文寿命)时间的原因:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>若&lt;strong>客户端&lt;/strong>发送&lt;strong>最后的ACK丢失&lt;/strong>，
则&lt;strong>服务端会在经过MSL后重发FIN报文&lt;/strong>。若客户端此时已经关闭，则无法重发ACK，则&lt;strong>服务端则无法进入关闭状态&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>TCP建立的连接、虚电路建立的连接、电路交换三者区别：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>TCP建立的连接&lt;/strong>：只是在TCP的TCB(传输控制块中)存储了&lt;strong>目的地址&lt;/strong>的&lt;strong>端口信息&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>虚电路路建立的连接&lt;/strong>：指通信前，在&lt;strong>源主机&lt;/strong>和&lt;strong>目的主机&lt;/strong>之间建立一条虚连接，&lt;strong>分组&lt;/strong>通过&lt;strong>该路径顺序&lt;/strong>
传送到目的主机。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>电路交换&lt;/strong>：是建立&lt;strong>真实&lt;/strong>存在的&lt;strong>物理连接&lt;/strong>。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="应用层">应用层&lt;/h2>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e7%bd%91%e7%bb%9c%e5%9f%ba%e7%a1%80/%e5%ba%94%e7%94%a8%e5%b1%82%e5%8d%8f%e8%ae%ae.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="http">http&lt;/h3>
&lt;p>&lt;strong>HTTP&lt;/strong>: HyperText Transfer Protocol 超文本传输协议&lt;/p>
&lt;ul>
&lt;li>&lt;strong>面向事务的(transaction-oriented)应用层&lt;/strong>协议。HTTP 使用 &lt;strong>TCP 连接进行可靠的&lt;/strong>传送。HTTP是客户端与服务端交互的协议。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>HTTPS&lt;/strong>：HTTP&lt;strong>通信接口部分用SSL和TLS协议代替&lt;/strong>。通常是HTTP直接和TCP通信，当使用SSL时，则演变为先和SSL通信，再由SSL和TCP通信了。&lt;/p>
&lt;h3 id="smtp-pop3-imap电子邮件协议">SMTP POP3 IMAP(电子邮件协议)&lt;/h3>
&lt;p>都是基于TCP&lt;/p>
&lt;ul>
&lt;li>发送邮件的协议：SMTP&lt;/li>
&lt;li>读取邮件的协议：POP3 和 IMAP&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>SMTP&lt;/strong>(简单邮件传输协议)：规定了两个相互通信的SMTP进程之间如何交换信息&lt;/p>
&lt;p>&lt;strong>MIME&lt;/strong>: 在SMTP协议的基础上&lt;strong>增加了邮件主体的结构&lt;/strong>，并定义了&lt;strong>传送非ASCII码&lt;/strong>的编码规则。&lt;/p>
&lt;p>&lt;strong>POP3&lt;/strong>(&lt;strong>邮局版本协议&lt;/strong>3): 支持客户端&lt;strong>远程管理在服务器上的电子邮件&lt;/strong>，邮件发送到服务器上，&lt;strong>客户端调用邮件客户机程序以连接服务器&lt;/strong>，并&lt;strong>下载&lt;/strong>所有未阅读的电子邮件。&lt;/p>
&lt;p>&lt;strong>IMAP&lt;/strong>： Internet Message Access Protocol 互联网邮件访问协议 是一个&lt;strong>联机协议&lt;/strong>。当用户 PC 机上的 IMAP 客户程序打开 IMAP 服务器的邮箱时，用户就可看到邮件的首部。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>优点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>用户可以&lt;strong>在不同的地方使用不同的计算机&lt;/strong>随时上网阅读和处理自己的邮件&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>缺点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>如果用户没有将邮件复制到自己的 PC 上，则邮件一直是存放在 IMAP 服务器上。因此&lt;strong>用户需要经常与 IMAP 服务器建立连接&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>SMTP POP IMAP 三者的区别&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>发信人的用户代理&lt;/strong> 向 &lt;strong>源邮件服务器发送邮件&lt;/strong>，以及&lt;strong>源邮件服务器&lt;/strong> 向 &lt;strong>目的邮件服务器发送邮件&lt;/strong>，都是使用 &lt;strong>SMTP&lt;/strong> 协议。&lt;/li>
&lt;li>而 &lt;strong>POP&lt;/strong> 协议或 &lt;strong>IMAP&lt;/strong> 协议则是&lt;strong>用户&lt;/strong> 从 &lt;strong>目的邮件服务器&lt;/strong>上 &lt;strong>读取邮件&lt;/strong>所使用的协议。&lt;/li>
&lt;/ul>
&lt;h3 id="ftp-tftp">FTP TFTP&lt;/h3>
&lt;p>&lt;strong>FTP&lt;/strong>：(文本传输协议File Transfer Protocol): 运行在TCP之上，用于在&lt;strong>异构网络&lt;/strong>中任意计算机之间传送文件。FTP 是一种不安全的协议.&lt;/p>
&lt;p>&lt;strong>TFTP&lt;/strong>(简单文件传输协议 运行在UDP之上):用于在&lt;strong>客户端与服务端&lt;/strong>之间进行&lt;strong>简单文件传输&lt;/strong>。TFTP有自己的差错改正措施，不支持交互。&lt;/p>
&lt;p>&lt;strong>FTP工作原理&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>使用&lt;strong>客户服务器&lt;/strong>方式。&lt;/li>
&lt;li>可同时为多个客户进程提供服务。&lt;/li>
&lt;li>FTP 的服务器进程由两大部分组成：&lt;strong>一个主进程&lt;/strong>，负责接受新的请求；另外有&lt;strong>若干个从属进程&lt;/strong>，负责处理单个请求。&lt;/li>
&lt;li>使用两个TCP连接：
&lt;ul>
&lt;li>&lt;strong>控制连接&lt;/strong>在整个会话期间一直保持打开，FTP 客户发出的&lt;strong>传送请求&lt;/strong>通过控制连接&lt;strong>发送给&lt;/strong>服务器端的&lt;strong>控制进程&lt;/strong>。&lt;/li>
&lt;li>用于传输文件的是“&lt;strong>数据连接&lt;/strong>”，被 控制连接 创建。&lt;strong>端口20&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="telnet">Telnet&lt;/h3>
&lt;p>&lt;strong>TELNET&lt;/strong>：简单的&lt;strong>远程终端协议&lt;/strong>，使用C/S方式，使用TCP连接。&lt;/p>
&lt;p>Telnet 协议的最大缺点之一是所有数据（包括用户名和密码）均以明文形式发送，这有潜在的安全风险。这就是为什么如今很少使用 Telnet，而是使用一种称为 SSH 的非常安全的网络传输协议的主要原因。&lt;/p>
&lt;h3 id="sshsecure-shell-protocol安全的网络传输协议">SSH（Secure Shell Protocol，安全的网络传输协议）&lt;/h3>
&lt;p>基于 TCP 协议，通过加密和认证机制实现安全的访问和文件传输等业务&lt;/p>
&lt;h3 id="rtpreal-time-transport-protocol实时传输协议">RTP（Real-time Transport Protocol，实时传输协议）&lt;/h3>
&lt;p>通常基于 UDP 协议，但也支持 TCP 协议。它提供了端到端的实时传输数据的功能，但不包含资源预留存、不保证实时传输质量，这些功能由 WebRTC 实现。&lt;/p>
&lt;h3 id="dns-domain-name-system域名系统">DNS (Domain Name System)域名系统&lt;/h3>
&lt;p>基于 UDP 协议，用于解决域名和 IP 地址的映射问题。&lt;/p>
&lt;p>因特网采用&lt;strong>层次结构的命名树&lt;/strong>作为主机的名字，并使用&lt;strong>分布式&lt;/strong>的域名系统 DNS。用来将域名转换为IP地址。&lt;/p>
&lt;p>&lt;strong>域名服务器&lt;/strong>：&lt;strong>域名服务器程序在专&lt;/strong>设的结点上运行，运行该程序的机器称为&lt;strong>域名服务器&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>基础结构域名&lt;/strong>(infrastructure domain)：这种顶级域名只有一个，即 &lt;strong>arpa&lt;/strong>，用于&lt;strong>反向域名解析&lt;/strong>，因此又称为&lt;strong>反向域名&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>DNS查询方式 域名解析过程&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>主机向本地域名服务器&lt;/strong>的查询一般都是采用&lt;strong>递归查询&lt;/strong>。
&lt;ul>
&lt;li>知道则回复。如本地域名服务器不知道，则本地域名服务器就以 &lt;strong>DNS 客户&lt;/strong>的身份，&lt;strong>向其他域名服务器&lt;/strong>继续发出查询请求报文。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>本地域名服务器&lt;/strong>向&lt;strong>根域名服务器&lt;/strong>的查询通常是采用&lt;strong>迭代查询&lt;/strong>。
&lt;ul>
&lt;li>&lt;strong>根域名服务器要么&lt;/strong>给出所要查询的&lt;strong>IP 地址&lt;/strong>，要么告诉本地域名服务器：“你下一步&lt;strong>应当向哪一个域名服务器&lt;/strong>进行查询”。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="其他概念">其他概念&lt;/h3>
&lt;p>&lt;strong>WWW&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>万维网 WWW (World Wide Web)&lt;strong>并非某种特殊&lt;/strong>的&lt;strong>计算机网络&lt;/strong>。&lt;/li>
&lt;li>是一个&lt;strong>大规模的、联机式&lt;/strong>的&lt;strong>信息储藏所&lt;/strong>。是&lt;strong>分布式超媒体&lt;/strong>(hypermedia)系统，它是&lt;strong>超文本&lt;/strong>(hypertext)系统的扩充。&lt;/li>
&lt;li>&lt;strong>浏览器&lt;/strong>就是在用户计算机上的&lt;strong>万维网客户程序&lt;/strong>。&lt;/li>
&lt;li>&lt;strong>万维网服务器&lt;/strong>：&lt;strong>万维网文档&lt;/strong>所&lt;strong>驻留的计算机&lt;/strong>的&lt;strong>运行服务器程序&lt;/strong>&lt;/li>
&lt;li>&lt;strong>页面&lt;/strong>(page)：在一个&lt;strong>客户程序主窗口上显示出&lt;/strong>的&lt;strong>万维网文档&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>HTML&lt;/strong>(HyperText &lt;strong>Markup&lt;/strong> Language 超文本标记语言): &lt;strong>文档结构标记语言&lt;/strong>，使用约定的标记对页面上的信息进行描述。&lt;/p>
&lt;p>&lt;strong>URL&lt;/strong>: 统一资源定位符Uniform Resource Locator， 标识万维网上的各种文档。每个文档在整个因特网都具有唯一的URL。&lt;/p>
&lt;ul>
&lt;li>格式：&lt;code>协议(ftp/http)://主机:端口/路径&lt;/code>。&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e7%bd%91%e7%bb%9c%e5%9f%ba%e7%a1%80/URL%e7%9a%84%e7%bb%84%e6%88%90.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;ul>
&lt;li>协议。URL 的前缀通常表示了该网址采用了何种应用层协议，通常有两种——HTTP 和 HTTPS。当然也有一些不太常见的前缀头，比如文件传输时用到的ftp:。&lt;/li>
&lt;li>域名。域名便是访问网址的通用名，这里也有可能是网址的 IP 地址，域名可以理解为 IP 地址的可读版本，毕竟绝大部分人都不会选择记住一个网址的 IP 地址。&lt;/li>
&lt;li>端口。如果指明了访问网址的端口的话，端口会紧跟在域名后面，并用一个冒号隔开。&lt;/li>
&lt;li>资源路径。域名（端口）后紧跟的就是资源路径，从第一个/开始，表示从服务器上根目录开始进行索引到的文件路径，上图中要访问的文件就是服务器根目录下/path/to/myfile.html。早先的设计是该文件通常物理存储于服务器主机上，但现在随着网络技术的进步，该文件不一定会物理存储在服务器主机上，有可能存放在云上，而文件路径也有可能是虚拟的（遵循某种规则）。&lt;/li>
&lt;li>参数。参数是浏览器在向服务器提交请求时，在 URL 中附带的参数。服务器解析请求时，会提取这些参数。参数采用键值对的形式key=value，每一个键值对使用&amp;amp;隔开。参数的具体含义和请求操作的具体方法有关。&lt;/li>
&lt;li>锚点。锚点顾名思义，是在要访问的页面上的一个锚。要访问的页面大部分都多于一页，如果指定了锚点，那么在客户端显示该网页是就会定位到锚点处，相当于一个小书签。值得一提的是，在 URL 中，锚点以#开头，并且不会作为请求的一部分发送给服务端&lt;/li>
&lt;/ul>
&lt;h2 id="在浏览器上输入url后发生了什么">在浏览器上输入URL后发生了什么&lt;/h2>
&lt;h3 id="1解析url">1.解析URL&lt;/h3>
&lt;p>获得:&lt;/p>
&lt;ul>
&lt;li>协议&lt;/li>
&lt;li>域名&lt;/li>
&lt;li>端口&lt;/li>
&lt;li>资源路径
&lt;ul>
&lt;li>当资源路径为空时，服务器会默认返回一个 index.html 文件。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="2通过dns获得ip">2.通过DNS获得IP&lt;/h3>
&lt;h3 id="3建立tcp连接">3.建立TCP连接&lt;/h3>
&lt;h3 id="4建立tls连接">4.建立TLS连接&lt;/h3>
&lt;h3 id="heading">&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%9f%ba%e7%a1%80/HTTP%e6%8a%a5%e6%96%87%e6%a0%bc%e5%bc%8f.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>请求行:&lt;/p>
&lt;ul>
&lt;li>方法: GET&lt;/li>
&lt;li>sp: 空格&lt;/li>
&lt;li>URL&lt;/li>
&lt;li>版本: HTTP/1.1
&lt;ul>
&lt;li>版本的选择是由&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="操作系统协议栈----http传输工作">操作系统协议栈 &amp;ndash; HTTP传输工作&lt;/h3>
&lt;h3 id="tcp-1">TCP&lt;/h3>
&lt;h3 id="ip">IP&lt;/h3>
&lt;h3 id="mac">MAC&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>浏览器&lt;/strong>会&lt;strong>解析&lt;/strong>URL&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>浏览器&lt;/strong>会&lt;strong>查询&lt;/strong>DNS服务器，&lt;strong>获取&lt;/strong>URL中的&lt;strong>域名&lt;/strong>对应的&lt;strong>IP地址&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>浏览器&lt;/strong>会&lt;strong>向&lt;/strong>该&lt;strong>IP地址&lt;/strong>的&lt;strong>服务器&lt;/strong>发出&lt;strong>HTTP请求&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>服务器&lt;/strong>接收到&lt;strong>请求&lt;/strong>后，会&lt;strong>根据&lt;/strong>请求的&lt;strong>路径&lt;/strong>找到&lt;strong>对应的文件&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>服务器&lt;/strong>会&lt;strong>将&lt;/strong>该文件&lt;strong>返回&lt;/strong>给**浏览器&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>浏览器&lt;/strong>会&lt;strong>解析&lt;/strong>文件，&lt;strong>并&lt;/strong>将&lt;strong>解析&lt;/strong>后的&lt;strong>文件&lt;/strong>显示在&lt;strong>页面&lt;/strong>上&lt;/p>
&lt;/li>
&lt;li>
&lt;p>应用层决定请求URL后,由于IP地址还未知,首先会发起域名解析请求。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>域名解析请求通过UDP传输到本地DNS服务器。&lt;/p>
&lt;ul>
&lt;li>DNS服务器根据域名查询缓存或者递归查询根DNS、顶级域名服务器等,直到获取到目标主机的IP地址。&lt;/li>
&lt;li>DNS服务器回复客户端IP地址,此过程采用UDP传输。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>客户端获得IP后对请求进行封装,生成HTTP请求报文。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>传输层:HTTP请求报文交给TCP协议处理。TCP会为该通信会话建立连接,并将HTTP报文切成一个个TCP段,每个TCP段添加序列号等控制信息。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>网络层:TCP段交给IP处理。IP给每个TCP段添加源IP地址、目标IP地址、检查字以及其他控制信息,将其封装成IP数据报。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>链路层:IP数据报交给链路层(如以太网)处理。以太网将IP数据报装入以太网帧中,添加源MAC地址、目标MAC地址等,形成真正通过物理链路传输的帧格式数据。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>物理层:将以太网帧通过以太网卡发送到 physical network 即万兆交换机等,再通过光纤或电缆等物理传输媒介传输到目标主机。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>目的主机接收到帧后,各层逆向解析和处理,最终应用层获取到完整的HTTP请求报文。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>服务器应用处理请求逻辑,生成HTTP响应报文。响应报文经过TCP/IP封装打包成 frames 后,返回客户端,各层相反的顺序传送。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>客户端得到完整的HTTP响应,应用层解析响应,返回给用户,完成整个请求响应过程。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="todo-linux-收发网络包的过程">TODO: Linux 收发网络包的过程&lt;/h2></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E7%BD%91%E7%BB%9C/%E5%AE%9E%E6%88%98%E6%A2%B3%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E7%BD%91%E7%BB%9C/%E5%AE%9E%E6%88%98%E6%A2%B3%E7%90%86/</guid><description>&lt;h1 id="实战梳理">实战梳理&lt;/h1>
&lt;h2 id="协议">协议&lt;/h2>
&lt;h2 id="工具">工具&lt;/h2>
&lt;h3 id="tcpdump">tcpdump&lt;/h3>
&lt;h3 id="wireshark">wireshark&lt;/h3>
&lt;p>网络层
openwrt&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E7%BD%91%E7%BB%9C/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E7%BD%91%E7%BB%9C/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</guid><description>&lt;h1 id="计算机网络基础">计算机网络基础&lt;/h1>
&lt;h2 id="1概述">1.概述&lt;/h2>
&lt;p>LAN：Local Area Network，局域网&lt;/p>
&lt;p>WAN：Wide Area Network，广域网&lt;/p>
&lt;p>&lt;strong>ISP&lt;/strong> Internet Service Provider 因特网服务提供商&lt;/p>
&lt;h3 id="1服务与协议">&lt;strong>1.服务与协议&lt;/strong>&lt;/h3>
&lt;p>&lt;strong>协议&lt;/strong>是&lt;strong>水平&lt;/strong>的，&lt;strong>对等实体&lt;/strong>之间的&lt;strong>通信规则&lt;/strong>。&lt;strong>对等实体&lt;/strong>是指&lt;strong>同一层&lt;/strong>级&lt;strong>可发送接收&lt;/strong>信息的硬件或软件进程.&lt;/p>
&lt;p>&lt;strong>服务&lt;/strong>是&lt;strong>垂直&lt;/strong>的，是由下层为上层通过&lt;strong>层间接口&lt;/strong>提供的. 下层实现的&lt;strong>所有功能不都是服务&lt;/strong>,只有能够&lt;strong>被上层看得见的&lt;/strong>功能才是服务. 上层使用下层的&lt;strong>SAP&lt;/strong>访问下层的服务.&lt;/p>
&lt;p>&lt;strong>SAP Service Access Point&lt;/strong>:服务接入点.同⼀节点相邻两层交换信息的连接点.数据链路层的SAP是MAC地址，网络层的SAP是IP地址，传输层的SAP是端口.&lt;/p>
&lt;p>SDU(服务数据单元):为完成⽤户所要求的功能⽽应传送的数据。&lt;/p>
&lt;p>PCI(协议控制信息):控制协议操作的信息。&lt;/p>
&lt;p>PDU(协议数据单元):n-PDU = n-SDU + n-PCI。 n-PDU = (n-1)-SDU。&lt;/p>
&lt;p>&lt;strong>协议三要素：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>语法: 规定信息格式&lt;/li>
&lt;li>语义: 说明通信双方应当怎么做;用于协调与差错处理的控制信息&lt;/li>
&lt;li>规则: (时序)定义了何时进行通信，先讲什么，后讲什么，讲话的速度等。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>服务的类型&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>面向连接服务与无连接服务
&lt;ul>
&lt;li>面向连接服务：双方通信前要&lt;strong>事先建立&lt;/strong>一条&lt;strong>通信线路&lt;/strong>. 该线路包括建立连接、使用连接(通信)、释放连接这三个过程。&lt;/li>
&lt;li>无连接服务: 双方通信前不需要建立通信线路.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>可靠服务与不可靠服务
&lt;ul>
&lt;li>可靠服务:通过具有&lt;strong>检错,纠错,应答&lt;/strong>机制,保证&lt;strong>数据正确,可靠地&lt;/strong>传送到目的地.&lt;/li>
&lt;li>不可靠服务: 不保证数据正确,可靠地传送到目的地.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>应答服务与不应答服务&lt;/li>
&lt;/ul>
&lt;h3 id="2模型">2.模型&lt;/h3>
&lt;p>&lt;strong>层次模型的好处：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>降低复杂度；&lt;/li>
&lt;li>标准化接口；&lt;/li>
&lt;li>灵活性好;&lt;/li>
&lt;li>易于实现和维护&lt;/li>
&lt;/ol>
&lt;h4 id="21-osi七层模型">&lt;strong>2.1 OSI七层模型&lt;/strong>&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>任务&lt;/th>
&lt;th>功能&lt;/th>
&lt;th>协议&lt;/th>
&lt;th>传输单位&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>物理层&lt;/td>
&lt;td>在物理媒介上为数据端设备执行任务&lt;/td>
&lt;td>&lt;strong>透明&lt;/strong>地传输比特流&lt;/td>
&lt;td>&lt;/td>
&lt;td>比特&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>数据链路层&lt;/td>
&lt;td>将网络层传来的&lt;strong>数据报&lt;/strong>组装成帧&lt;/td>
&lt;td>封装成帧,&lt;strong>差错控制&lt;/strong>,&lt;strong>流量控制&lt;/strong>,传输管理&lt;/td>
&lt;td>SDLC,HDLC,PPP,STP,帧中继&lt;/td>
&lt;td>帧&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>网络层&lt;/td>
&lt;td>将分组传输到目的端,为分组交换网上的&lt;strong>主机&lt;/strong>提供通信服务.&lt;/td>
&lt;td>1.将传输层产⽣的&lt;strong>报⽂段&lt;/strong>或⽤户数据报封装成分组&lt;br />2.路由选择 3.&lt;strong>流量控制&lt;/strong> 4.拥塞控制 5.&lt;strong>差错控制&lt;/strong>&lt;/td>
&lt;td>IP, IPX.ICMP, IGMP,ARP,RARP,OSPF&lt;/td>
&lt;td>数据报,IP分组&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>传输层&lt;/td>
&lt;td>负责主机中两个&lt;strong>进程&lt;/strong>之间的通信(端到端)&lt;/td>
&lt;td>&lt;strong>流量控制, 差错控制&lt;/strong>,服务质量,数据传输管理&lt;/td>
&lt;td>TCP, UDP&lt;/td>
&lt;td>报文段TCP,用户数据报UDP&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>会话层&lt;/td>
&lt;td>&lt;strong>管理主机之间&lt;/strong>的会话&lt;strong>进程&lt;/strong>&lt;/td>
&lt;td>建立,管理,终止会话.也称建立同步SYN&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>表示层&lt;/td>
&lt;td>处理&lt;strong>两个通信系统&lt;/strong>之间&lt;strong>交换信息&lt;/strong>的&lt;strong>表现方式&lt;/strong>&lt;/td>
&lt;td>抽象的标准方法定义数据结构,数据压缩,加密,解密&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>应用层&lt;/td>
&lt;td>提供系统与⽤户的接口&lt;/td>
&lt;td>为特定类型的网络应用提供接入到OSI模型的手段&lt;/td>
&lt;td>FTP.SMTP,HTTP,DNS,Telnet,SNMP&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="22tcpip四层模型">2.2TCP/IP四层模型&lt;/h4>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/2024-03-06-16-25-32.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>网络接入层&lt;/strong>:物理层 + 数据链路层&lt;/p>
&lt;p>&lt;strong>网际互联层&lt;/strong>:网络层&lt;/p>
&lt;p>&lt;strong>传输层&lt;/strong>&lt;/p>
&lt;p>&lt;strong>应用层&lt;/strong>&lt;/p>
&lt;h4 id="23五层模型">2.3五层模型&lt;/h4>
&lt;p>①物理层:物理层&lt;/p>
&lt;p>②数据链路层:数据链路层。&lt;/p>
&lt;p>③⽹络层:⽹络层&lt;/p>
&lt;p>④传输层:传输层&lt;/p>
&lt;p>⑤应⽤层:会话层+表⽰层+应⽤层。&lt;strong>处理高级协议，显示问题，编码和会话控制等问题&lt;/strong>&lt;/p>
&lt;h4 id="25各层设备">2.5各层设备&lt;/h4>
&lt;p>&lt;strong>物理层设备&lt;/strong>:集线器Hub、中继器&lt;/p>
&lt;p>&lt;strong>数据链路层设备&lt;/strong>: 网卡、交换机、网桥&lt;/p>
&lt;p>&lt;strong>网络层设备&lt;/strong>:路由&lt;/p>
&lt;h3 id="3物理网络拓扑结构">3.物理网络拓扑结构&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/2024-03-06-16-25-54.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>总线拓扑&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>优点:所有的节点都能通信&lt;/li>
&lt;li>缺点:一旦总线上的&lt;strong>一点断开&lt;/strong>,会影响到所有&lt;strong>两边的节点&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>双环型拓扑&lt;/strong>: 在环型拓扑基础上增加了一个冗余环路,增加了可靠性和灵活性.&lt;/p>
&lt;p>&lt;strong>星型&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>优点:允许所有的节点方便的交流&lt;/li>
&lt;li>缺点:中间节点崩溃会导致整个网络的崩溃.传输冲突也是一个严重的问题.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>网络型&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>优点:连通性和可靠性好&lt;/li>
&lt;li>缺点:介质的连接和数量无法控制.&lt;/li>
&lt;/ul>
&lt;h2 id="2物理层">2.物理层&lt;/h2>
&lt;p>&lt;strong>传输介质&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>UTP Unshielded Twisted Pair 非屏蔽双绞线&lt;/li>
&lt;li>STP Shielded Twisted Pair 屏蔽双绞线 抗电磁干扰能力强&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>设备&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>中继器：用于放大数字信号&lt;/li>
&lt;li>集线器：多个端口的中继器&lt;/li>
&lt;li>特点：物理层设备既不能隔离冲突域也不能隔离广播域&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>三种通信方式&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>单⼯/ &lt;strong>simple&lt;/strong> Transmission:单向信号只能在⼀个⽅向上传播。(收⾳机)&lt;/li>
&lt;li>半双⼯/ &lt;strong>half-Duplex&lt;/strong> Transmission：信号可双向传播，但不能同时传播。(对讲机)&lt;/li>
&lt;li>全双⼯/ &lt;strong>full-Duplex&lt;/strong> Transmission：信号可以同时在两个⽅向上传播。(电话)&lt;/li>
&lt;/ul>
&lt;p>通道复用技术：&lt;/p>
&lt;ul>
&lt;li>频分复用（FDM，Frequency Division Multiplexing）：不同用户在不同频带，所用用户在同样时间占用不同带宽资源&lt;/li>
&lt;li>时分复用（TDM，Time Division Multiplexing）：不同用户在同一时间段的不同时间片，所有用户在不同时间占用同样的频带宽度&lt;/li>
&lt;li>波分复用（WDM，Wavelength Division Multiplexing）：光的频分复用&lt;/li>
&lt;li>码分复用（CDM，Code Division Multiplexing）：不同用户使用不同的码，可以在同样时间使用同样频带通信&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>三种数据传输方式&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>电路交换
&lt;ul>
&lt;li>通信前为双方建立专有的通信线路&lt;/li>
&lt;li>优点
&lt;ul>
&lt;li>传输快,时延小,&lt;strong>有序&lt;/strong>,避免冲突&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>缺点
&lt;ul>
&lt;li>信道利用率低,建立连接时间长,灵活性差&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>数据报交换
&lt;ul>
&lt;li>以报文为传输的数据单位, 采用&lt;strong>交换节点存储&lt;/strong>转发的方式&lt;/li>
&lt;li>优点
&lt;ul>
&lt;li>线路利用率搞，无连接,动态分配路线,&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>缺点
&lt;ul>
&lt;li>交换节点存储要求大&lt;/li>
&lt;li>&lt;strong>转发时延&lt;/strong>大&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>分组交换
&lt;ul>
&lt;li>面向连接的虚电路
&lt;ul>
&lt;li>通信前，在源主机和⽬的主机之间 建⽴⼀条虚连接，分组通过该路径顺序传送到⽬的主机。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>无连接的数据报
&lt;ul>
&lt;li>数据报的⽅式:将报⽂分割为较短的分组，交换机根据转发表转发分组传送到⽬的主机。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>将报文分割成多个分组，交换机根据&lt;strong>转发表&lt;/strong>逐个传输&lt;/li>
&lt;li>优点
&lt;ul>
&lt;li>,简化交换节点的存储，加速传输&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>缺点
&lt;ul>
&lt;li>传输时延大&lt;/li>
&lt;li>&lt;strong>失序&lt;/strong>,丢失重复问题&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>xDSL&lt;/strong> Digital Subscriber Line：用数字技术对现有的模拟电话用户线进行改造，使它能够承载宽带业务。前缀 x 则表示在数字用户线上实现的不同宽带方案。&lt;/p>
&lt;p>&lt;strong>ADSL&lt;/strong> (Asymmetric Digital Subscriber Line) &lt;strong>非对称数字用户线&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>它因为上行和下行带宽不对 称，因此称为非对称数字用户线环路。&lt;/li>
&lt;/ul>
&lt;ul>
&lt;li>属于DSL技术的一种，亦可称作非对称数字用户环路。是一种新的数据传输方式。&lt;/li>
&lt;li>ADSL采用&lt;strong>频分复用&lt;/strong>技术把普通的电话线分成了电话、上行和下行三个相对独立的信道，从而避免了相互之间的干扰。即使边打电话边上网，也不会发生上网速率和通话质量下降的 情况。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>FTTx&lt;/strong> Fiber To The X：实现宽带居民接入网的方案。这里字母 x 可代表不同意思。&lt;/p>
&lt;h2 id="3数据链路层">3.数据链路层&lt;/h2>
&lt;p>主要信道：&lt;/p>
&lt;ul>
&lt;li>点对点信道&lt;/li>
&lt;li>广播信道&lt;/li>
&lt;/ul>
&lt;h3 id="1九大功能">1.九大功能&lt;/h3>
&lt;h4 id="11为网络层提供服务">1.1为网络层提供服务&lt;/h4>
&lt;ul>
&lt;li>无确认的无连接&lt;/li>
&lt;li>有确认的无连接
&lt;ul>
&lt;li>不用建立链路，但目的主机收到帧后需要发送确认帧。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>有确认的有连接
&lt;ul>
&lt;li>建立连接，传输数据，释放连接。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="12链路管理">1.2链路管理&lt;/h4>
&lt;p>管理建立、维持和释放链路的过程。&lt;/p>
&lt;h4 id="13组帧-与-帧定界">1.3组帧 与 帧定界&lt;/h4>
&lt;p>确定帧的&lt;strong>首部尾部&lt;/strong>等&lt;strong>控制信息&lt;/strong>的&lt;strong>界限&lt;/strong>。&lt;/p>
&lt;h4 id="131字符计数法">1.3.1字符计数法&lt;/h4>
&lt;p>&lt;strong>帧的头部&lt;/strong> 使用 &lt;strong>计数字段&lt;/strong> 标明帧内字符数&lt;/p>
&lt;p>&lt;strong>缺点:&lt;/strong> 计数字段出错,会导致不能划分帧边界。&lt;/p>
&lt;h4 id="132字符填充的首尾界符法">1.3.2字符填充的首尾界符法&lt;/h4>
&lt;p>用于异步传输&lt;/p>
&lt;p>当&lt;strong>信息字段中&lt;/strong>出现：&lt;/p>
&lt;ul>
&lt;li>7E标志字段 转成 5E&lt;/li>
&lt;li>7D转义标记 转成 5D&lt;/li>
&lt;li>ASCII码字符（小于0x20的） 前面加入7D并改变编码&lt;/li>
&lt;/ul>
&lt;h4 id="133比特填充首尾标志法">1.3.3比特填充首尾标志法&lt;/h4>
&lt;p>用于同步传输,用硬件来实现.&lt;/p>
&lt;p>每5个0后面加1个1.&lt;/p>
&lt;h4 id="14帧同步">1.4帧同步&lt;/h4>
&lt;p>在二进制比特流中，&lt;strong>确定帧的开始和结束位置&lt;/strong>。&lt;/p>
&lt;h4 id="15透明传输">1.5透明传输&lt;/h4>
&lt;p>不管什么样的比特流都能在链路上传输。&lt;/p>
&lt;h4 id="16差错控制">1.6差错控制&lt;/h4>
&lt;p>确认发送的数据帧是否被&lt;strong>正确&lt;/strong>接受。&lt;/p>
&lt;ul>
&lt;li>检错编码
&lt;ul>
&lt;li>奇偶校验法&lt;/li>
&lt;li>循环冗余码CRC&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>纠错编码
&lt;ul>
&lt;li>海明码&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="17流量控制">1.7流量控制&lt;/h4>
&lt;p>由接收方控制发送方的流量。&lt;/p>
&lt;h5 id="171停等流量控制">1.7.1停等流量控制&lt;/h5>
&lt;p>与可靠传输中一致&lt;/p>
&lt;h5 id="172滑动窗口流量控制">1.7.2滑动窗口流量控制&lt;/h5>
&lt;h4 id="18可靠传输">1.8可靠传输&lt;/h4>
&lt;p>ARQ法 : Automatic Repeat reQuest 重传出错的帧.&lt;/p>
&lt;p>本质上是使用&lt;strong>确认&lt;/strong>机制和&lt;strong>超时重传&lt;/strong>机制&lt;/p>
&lt;p>ARQ分为&lt;/p>
&lt;h5 id="181停等协议">1.8.1停等协议&lt;/h5>
&lt;p>发送方发送一个帧之后,必须要等待对方确认后才可以发送下一个帧.&lt;/p>
&lt;p>若等待时间超过规定时间,则发送方超时,重传原始帧.&lt;/p>
&lt;h5 id="182gbn-后退n帧协议">1.8.2GBN 后退N帧协议&lt;/h5>
&lt;ul>
&lt;li>发送方发送完一个帧后,可以继续再发送若干帧. 发送方若收到确认帧,则可以继续发送.&lt;/li>
&lt;li>对于每一个帧,发送方判断超时时,重传该帧即之后的所有帧(&lt;strong>包括被确认的帧&lt;/strong>).&lt;/li>
&lt;li>接收方发现某个帧出错, 则&lt;strong>丢弃该帧和后续所有帧&lt;/strong>( &lt;strong>不返回否定帧&lt;/strong> ).&lt;/li>
&lt;/ul>
&lt;h5 id="183sr选择重传机制">1.8.3SR选择重传机制&lt;/h5>
&lt;p>发送方只重传 &lt;strong>超时&lt;/strong> 或 &lt;strong>被出错(返回否定)&lt;/strong> 的帧.&lt;/p>
&lt;p>接收方应当&lt;strong>加大接收窗口&lt;/strong> 来 接收&lt;strong>不连续但是未出现差错&lt;/strong>的帧,等重新收到出错帧的重传帧后⼀并提交给主机。&lt;/p>
&lt;h4 id="19介质访问控制-局域网">1.9介质访问控制 局域网&lt;/h4>
&lt;p>应用在&lt;strong>广播信道&lt;/strong>当中.&lt;/p>
&lt;p>介质访问控制：使得 &lt;strong>使用信道的结点&lt;/strong> 隔离 &lt;strong>其他结点发送的信号&lt;/strong>,以协调活动结点的传输,&lt;/p>
&lt;p>&lt;strong>介质访问控制协议处于MAC&lt;/strong>层。&lt;/p>
&lt;h5 id="191信道划分">1.9.1信道划分&lt;/h5>
&lt;p>通过&lt;strong>多路复用技术&lt;/strong>,把多个信号组合传入同一个物理信道.&lt;/p>
&lt;ul>
&lt;li>FDM 频分多路复用 将物理信道&lt;strong>根据频率&lt;/strong>划分 成 多个子信道,&lt;strong>每个子信道&lt;/strong>传输一种信号.&lt;/li>
&lt;li>TDM 时分多路复用 将物理信道 按照时间划分成若干时间片, 不同信号轮流使用.&lt;/li>
&lt;li>STDM 统计时分多路复用 在TDM的基础上,通过按实际需要来分配时间片.&lt;/li>
&lt;li>WDM 波分多路复用 光的频分多路复用&lt;/li>
&lt;li>CDM 码分多路复用 各个信号不同编码,既&lt;strong>共享信道频率又共享时间&lt;/strong>.
&lt;ul>
&lt;li>CDMA 码分多址&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h5 id="192随机访问">1.9.2随机访问&lt;/h5>
&lt;p>通过&lt;strong>检测冲突&lt;/strong>的方法来实现介质访问控制.&lt;/p>
&lt;ul>
&lt;li>纯ALOHA协议 ：不检测直接发送,&lt;strong>若超时&lt;/strong>则随机时间重发.&lt;/li>
&lt;li>时隙ALOHA协议： 不检测直接发送,&lt;strong>若超时&lt;/strong>则固定时隙重发.&lt;/li>
&lt;li>CSMA协议 ：载波监听多点接入
&lt;ul>
&lt;li>1-坚持CSMA, 闲则发送,忙则继续监听&lt;/li>
&lt;li>p-坚持CSMA, &lt;strong>闲&lt;/strong>则以&lt;strong>p的概率发送&lt;/strong>, 1-p的概率等待下一个时隙,忙则&lt;strong>等待随机时间&lt;/strong> &lt;strong>监听&lt;/strong>&lt;/li>
&lt;li>非坚持CSMA, 闲则发送,忙则&lt;strong>等待随机时间&lt;/strong>重新监听.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>CSMA/CD 带碰撞检测的 CSMA
&lt;ul>
&lt;li>先听后发
&lt;ul>
&lt;li>发送前一直在监听,闲则发送.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>边听边发
&lt;ul>
&lt;li>发送的时候监听&lt;strong>是否有冲突&lt;/strong>.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>冲突停发
&lt;ul>
&lt;li>有冲突则停止发送.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>随机重发
&lt;ul>
&lt;li>停止发送后,随机一段时间重发&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>CSMA/CA (用于&lt;strong>无线网&lt;/strong>) Collision Avoidance
&lt;ul>
&lt;li>无线网进行碰撞检测的难度大,则将CSMA/CD的&lt;strong>碰撞检测&lt;/strong>改为了&lt;strong>碰撞避免&lt;/strong>.&lt;/li>
&lt;li>发送数据时⼴播告知其他节点，让其他节点在某段时间内不要发送数据。利⽤ACK信号，对信道进⾏预约，以免出现碰撞。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h5 id="193轮询访问">1.9.3轮询访问&lt;/h5>
&lt;p>适用于环型总线.&lt;/p>
&lt;p>令牌传递协议:在环形⽹络中，只有得到令牌的主机才能够发送数据。&lt;/p>
&lt;p>FDDI环(光纤分布式数据接口): 令牌环形网络的一种。&lt;/p>
&lt;h3 id="2使用的协议">2.使用的协议&lt;/h3>
&lt;p>&lt;strong>WAN(广域网)&lt;/strong>:覆盖范围很广的&lt;strong>长距离网络&lt;/strong>，由具有&lt;strong>存储转发功能的结点交换机&lt;/strong>和&lt;strong>连接链路&lt;/strong>组成。采用&lt;strong>交换&lt;/strong>技术。&lt;/p>
&lt;p>&lt;strong>LAN(局域网)&lt;/strong>:某一较&lt;strong>小区域内&lt;/strong>由多台计算机相互连成的计算机网络。采用&lt;strong>广播&lt;/strong>技术。&lt;/p>
&lt;h4 id="21-广域网的协议使用点对点信道">2.1 广域网的协议（使用点对点信道）&lt;/h4>
&lt;p>&lt;strong>PPP Point To Point Protocol 点对点协议&lt;/strong>：&lt;/p>
&lt;p>面向&lt;strong>字节&lt;/strong>的数据链路层协议，应用于&lt;strong>直接连接在两个节点的链路&lt;/strong>上，通过&lt;strong>拨号&lt;/strong>或者&lt;strong>专线&lt;/strong>方式，&lt;strong>建立点对点连接&lt;/strong>发送数据。&lt;/p>
&lt;p>&lt;strong>HDLC High-Level Data Link Control 高级数据链路控制协议&lt;/strong>&lt;/p>
&lt;p>面向&lt;strong>比特&lt;/strong>的数据链路层协议。提供了&lt;strong>编号&lt;/strong>和&lt;strong>确认&lt;/strong>机制，能够提供&lt;strong>可靠传输&lt;/strong>。&lt;/p>
&lt;p>PPP&lt;strong>协议特点&lt;/strong>：&lt;/p>
&lt;p>&lt;strong>简单&lt;/strong>——这是首要的要求&lt;/p>
&lt;p>&lt;strong>不进行&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>纠错&lt;/li>
&lt;li>流量控制&lt;/li>
&lt;li>半双工或单工链路&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>三个组成部分&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>封装：一种封装多协议数据报的方法。PPP 封装提供了不同网络层协议同时在&lt;strong>同一链路传输的多路复用技术&lt;/strong>。&lt;/li>
&lt;li>&lt;strong>LCP&lt;/strong>链路控制协议 LCP (Link Control Protocol)&lt;/li>
&lt;li>&lt;strong>NCP&lt;/strong>网络控制协议 NCP (Network Control Protocol)&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>IPCP(网际协议控制协议)&lt;/strong>：用于&lt;strong>建立、配置&lt;/strong>和&lt;strong>检测&lt;/strong>数据链路连接的连接控制协议&lt;strong>LCP&lt;/strong> 以及 用于&lt;strong>建立和&lt;/strong>
&lt;strong>配置&lt;/strong>不同网络层协议的网络控制协议&lt;strong>NCP协议簇&lt;/strong>。&lt;/p>
&lt;h5 id="322-ppp-协议的帧格式">3.2.2 PPP 协议的帧格式&lt;/h5>
&lt;p>PPP 是面向字节的，所有的 PPP 帧的长度都是整数字节。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/2024-03-06-16-26-17.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>首部&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>标志字段&lt;/strong> F = 0x7E （符号“0x”表示后面的字符是用十六进制表示。十六进制的 7E 的二进制表示是 01111110） &lt;strong>标记首尾&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>地址字段&lt;/strong> A 只置为 0xFF。地址字段实际上并不起作用&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>控制字段&lt;/strong> C 通常置为 0x03&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>首部有5字节，尾部3字节&lt;/strong>&lt;/p>
&lt;p>&lt;strong>尾部&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>FCS：帧检验序列，一般由CRC得出但不是唯一方法
&lt;ul>
&lt;li>使用FCS表示使用了 &lt;strong>无差错接受&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>标志字段&lt;/strong> F=7E &lt;strong>标记首尾&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>透明传输&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>同步传输时 采用硬件来完成比特填充（和 HDLC 的做法一样）&lt;/li>
&lt;li>异步传输时 &lt;strong>特殊的字符填充法&lt;/strong>，当&lt;strong>信息字段中&lt;/strong>出现：
&lt;ul>
&lt;li>7E标志字段 转成 5E&lt;/li>
&lt;li>7D转义标记 转成 5D&lt;/li>
&lt;li>ASCII码字符（小于0x20的） 前面加入7D并改变编码&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>PPP 不提供序号&lt;/strong> 和 &lt;strong>确认的可靠传输&lt;/strong>的原因：&lt;/p>
&lt;ul>
&lt;li>PPP 的信息字段放入的数据是 IP 数据报。&lt;strong>数据链路层&lt;/strong>的&lt;strong>可靠传输&lt;/strong>并&lt;strong>不能保证网络层的传输&lt;/strong>也是&lt;strong>可靠&lt;/strong>的&lt;/li>
&lt;li>&lt;strong>帧检验序列 FCS&lt;/strong> 字段可&lt;strong>保证无差错接受&lt;/strong>&lt;/li>
&lt;li>数据链路层出现差错的概率不大时，使用比较&lt;strong>简单&lt;/strong>的 PPP 协议较为合理。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>PPP 协议的工作状态&lt;/strong>：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>当&lt;strong>用户拨号接入 ISP&lt;/strong> 时，&lt;strong>路由器&lt;/strong>的调制解调器对拨号&lt;strong>做出确认&lt;/strong>，并&lt;strong>建立&lt;/strong>一条&lt;strong>物理连接&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>PC 机&lt;/strong> 向 &lt;strong>路由器发送&lt;/strong>一系列的 &lt;strong>LCP 分组&lt;/strong>（封装成多个 PPP 帧）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>这些分组及其响应选择一些 &lt;strong>PPP 参数&lt;/strong>，和进行&lt;strong>网络层配置&lt;/strong>。&lt;strong>NCP&lt;/strong> 给新接入的 PC机&lt;strong>分配&lt;/strong>一个&lt;strong>临时的 IP 地址&lt;/strong>，使 &lt;strong>PC 机&lt;/strong>成为&lt;strong>因特网上的一个主机&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>通信完毕&lt;/strong>时，&lt;strong>NCP&lt;/strong> 释放&lt;strong>网络层连接&lt;/strong>，&lt;strong>收回&lt;/strong>原来分配出去的 &lt;strong>IP&lt;/strong> 地址。接着，&lt;strong>LCP&lt;/strong>释放&lt;strong>数据链路层连接&lt;/strong>。&lt;strong>最后释放&lt;/strong>的是&lt;strong>物理层连接&lt;/strong>。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h4 id="22以太网协议使用广播信道">2.2以太网协议（使用广播信道）&lt;/h4>
&lt;p>&lt;strong>局域网的特点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>范围有限，站点有限&lt;/li>
&lt;li>方便广播&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>局域网的规约&lt;/strong>&lt;/p>
&lt;p>IEEE 802.3标准 —— &lt;strong>以太网&lt;/strong>&lt;/p>
&lt;p>&lt;strong>以太网分层&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>LLC 逻辑链路控制&lt;/strong> LLC (Logical Link Control)子层&lt;/p>
&lt;ul>
&lt;li>1.建⽴和释放数据链路层的&lt;strong>逻辑连接&lt;/strong>。2.提供与⽹络层的&lt;strong>接口&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>MAC 媒体接入控制&lt;/strong> MAC (Medium Access Control)子层。&lt;/p>
&lt;ul>
&lt;li>负责控制与&lt;strong>连接物理层的物理介质&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>适配器&lt;/strong>：&lt;/p>
&lt;p>又称 通信适配器adapter 、&lt;strong>网络接口卡 NIC&lt;/strong> Network Interface Card 、&lt;strong>网卡&lt;/strong>&lt;/p>
&lt;p>功能就是&lt;/p>
&lt;ul>
&lt;li>串行/并行转换&lt;/li>
&lt;li>实现以太网协议&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>使用集线器的星形拓扑:&lt;/strong>&lt;/p>
&lt;p>星形拓扑的中心是 集线器 hub&lt;/p>
&lt;p>使用集线器的以太网&lt;strong>在逻辑上仍是一个总线网&lt;/strong>，各工作站使用的还是 CSMA/CD 协议，并共享逻辑上的总线。&lt;/p>
&lt;p>&lt;strong>MAC地址&lt;/strong>&lt;/p>
&lt;p>适配器从网络上每收到一个 MAC 帧就首先用硬件检查 MAC 帧中的 MAC 地址.&lt;/p>
&lt;ul>
&lt;li>如果是发往本站的帧则收下，然后再进行其他的处理。&lt;/li>
&lt;li>否则就将此帧丢弃，不再进行其他的处理。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>MAC帧格式&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/image-20221027211935439.png" alt="image-20221027211935439" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>类型字段&lt;/strong> 标志&lt;strong>上一层&lt;/strong>使用的协议&lt;/p>
&lt;p>首部 14字节 尾部 4字节。&lt;/p>
&lt;p>数据最少是 64-18 = 46字节.少于64时，数据字段后面加入整数字节填充。&lt;/p>
&lt;p>在&lt;strong>MAC帧前面&lt;/strong>会加入用于&lt;strong>比特同步的8字节&lt;/strong>&lt;/p>
&lt;p>&lt;strong>无效的MAC帧&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>数据字段的长度与长度字段的值不一致；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>帧的长度不是整数个字节；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>用收到的帧检验序列 FCS 查出有差错；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>数据字段的长度不在 46 ~ 1500 字节之间。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>有效的 MAC 帧长度为 64 ~ 1518 字节之间。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对于检查出的无效 MAC 帧就简单地丢弃。以太网不负责重传丢弃的帧。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>以太网重要特性&lt;/strong>：&lt;/p>
&lt;p>使用 CSMA/CD 协议的以太网&lt;strong>不能进行全双工通信&lt;/strong>而&lt;strong>只能进行双向交替通信（半双工通信）&lt;/strong>。&lt;/p>
&lt;p>发送的不确定性使整个以太网的平均通信量远小于以太网的最高数据率。&lt;/p>
&lt;h3 id="3设备及其特点">3.设备及其特点&lt;/h3>
&lt;h4 id="31网桥">3.1网桥&lt;/h4>
&lt;p>&lt;strong>用于连接多个以太网(局域网)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>透明网桥&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>(选择的&lt;strong>不是最佳路由&lt;/strong>):按照自学习算法填写转发表，按转发表转发。&lt;/li>
&lt;li>&lt;strong>工作原理&lt;/strong>
&lt;ul>
&lt;li>维护转发表：收到一个帧时，先将它的&lt;strong>源地址记录&lt;/strong>下来自学习。&lt;/li>
&lt;li>拿目的地址比较转发表，如果找到对应项，直接往对应项记录的接口发送该帧。&lt;/li>
&lt;li>否则，向出来接口X外的&lt;strong>其他接口广播&lt;/strong>该帧。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>STP(生成树协议)&lt;/strong>：
&lt;ul>
&lt;li>该协议应用于在&lt;strong>网络中建立树形拓扑&lt;/strong>，&lt;strong>消除&lt;/strong>网络中的&lt;strong>环路&lt;/strong>，&lt;strong>避免&lt;/strong>由于环路存在而造成的&lt;strong>广播风暴&lt;/strong>问题。&lt;/li>
&lt;li>即&lt;strong>互连在一起的网桥在进行彼此通信后，就能找出原来的网络拓扑的一个子集&lt;/strong>。在这个子集里，整个连通的网络中不存在回路，即在任何两个站之间只有一条路径。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>所谓&lt;strong>自学习建立转发表&lt;/strong>&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>MAC地址为A的设备A，发出的帧从接口X进入网桥。&lt;/li>
&lt;li>根据反向操作，网桥知道一定能从接口X发送帧给A设备。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>源路由网桥&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>(选择的是最佳路路由): 先发送 &lt;strong>发现帧&lt;/strong>，按返回结果转发。&lt;/li>
&lt;li>&lt;strong>工作原理&lt;/strong>
&lt;ul>
&lt;li>源站以广播的方式发送发现帧，每个&lt;strong>发现帧记录所经过的所有路由&lt;/strong>。&lt;/li>
&lt;li>发现帧到达目的后，返回源站。&lt;/li>
&lt;li>源站从这些发现帧中选择最佳路由。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="32交换机">3.2交换机&lt;/h4>
&lt;p>&lt;strong>交换式集线器&lt;/strong>常称为&lt;strong>以太网交换机(switch)&lt;strong>或&lt;/strong>第二层交换机&lt;/strong>.&lt;/p>
&lt;p>以太网交换机:有十几个接口,实质上就是一个多接口的网桥。&lt;/p>
&lt;p>以太网交换机的&lt;strong>每个接口都直接与主机相连&lt;/strong>，并且一般都工作在&lt;strong>全双工&lt;/strong>方式。&lt;/p>
&lt;p>每个用户在通信时是独占传输媒体的带宽，对于拥有 &lt;em>N&lt;/em> 对接口的交换机的总容量为 &lt;em>N&lt;/em>´10 Mb/s。这正是交换机的最大优点。&lt;/p>
&lt;p>&lt;strong>工作原理与透明网桥一致&lt;/strong>&lt;/p>
&lt;p>可用来实现VLAN&lt;/p>
&lt;p>&lt;strong>VLAN(虚拟局域网)&lt;/strong>: 网络中的站点&lt;strong>不拘泥于所处的物理位置&lt;/strong>，而可以根据需要灵活地加入不同的逻辑子网中的一种网络技术。&lt;/p>
&lt;h4 id="33特点">3.3特点&lt;/h4>
&lt;ul>
&lt;li>数据链路层设备&lt;strong>能够隔离冲突域&lt;/strong>但&lt;strong>不能隔离广播域&lt;/strong>。&lt;/li>
&lt;li>都&lt;strong>按MAC地址转发&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h2 id="4网络层">4.网络层&lt;/h2>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e7%bd%91%e7%bb%9c%e5%9f%ba%e7%a1%80/%e7%bd%91%e7%bb%9c%e5%b1%82%e5%8d%8f%e8%ae%ae.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>网络层提供的两种服务&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>面向有连接的虚电路服务&lt;/p>
&lt;/li>
&lt;li>
&lt;p>面向无连接的数据报服务&lt;/p>
&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>对比的方面&lt;/th>
&lt;th>虚电路服务&lt;/th>
&lt;th>数据报服务&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>思路&lt;/td>
&lt;td>可靠通信应当由网络来保证&lt;/td>
&lt;td>可靠通信应当由用户主机来保证&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>连接的建立&lt;/td>
&lt;td>必须有&lt;/td>
&lt;td>不需要&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>终点地址&lt;/td>
&lt;td>仅在连接建立阶段使用，每个分组使用&lt;strong>短的虚电路号&lt;/strong>&lt;/td>
&lt;td>每个分组都&lt;strong>有终点的完整地址&lt;/strong>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>分组的转发&lt;/td>
&lt;td>属于同一条虚电路的分组均&lt;strong>按照同一路由&lt;/strong>进行转发&lt;/td>
&lt;td>每个分组&lt;strong>独立选择路由&lt;/strong>进行转发&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>当结点出故障时&lt;/td>
&lt;td>所有通过出故障的结点的虚电路&lt;strong>均不能工作&lt;/strong>&lt;/td>
&lt;td>出故障的结点可能会&lt;strong>丢失分组&lt;/strong>，一些路由可能会发生变化&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>分组的顺序&lt;/td>
&lt;td>总是&lt;strong>按发送顺序&lt;/strong>到达终点&lt;/td>
&lt;td>到达终点时&lt;strong>不一定按&lt;/strong>发送顺序&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>端到端的差错处理和流量控制&lt;/td>
&lt;td>可以由网络负责，也可以由用户主机负责&lt;/td>
&lt;td>由用户主机负责&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>传统分类地址&lt;/strong>：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>类别&lt;/th>
&lt;th>网络号&lt;/th>
&lt;th>主机号&lt;/th>
&lt;th>第一个网络号&lt;/th>
&lt;th>最后一个网络号&lt;/th>
&lt;th>每个网络最大主机数&lt;/th>
&lt;th>内网地址&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>A&lt;/td>
&lt;td>8&lt;/td>
&lt;td>24&lt;/td>
&lt;td>1&lt;/td>
&lt;td>126&lt;/td>
&lt;td>16777214&lt;/td>
&lt;td>10.0.0.0 到 10.255.255.255&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>B&lt;/td>
&lt;td>16&lt;/td>
&lt;td>16&lt;/td>
&lt;td>128.1&lt;/td>
&lt;td>191.255&lt;/td>
&lt;td>65534&lt;/td>
&lt;td>172.16.0.0 到 172.31.255.255&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>C&lt;/td>
&lt;td>24&lt;/td>
&lt;td>8&lt;/td>
&lt;td>192.0.1&lt;/td>
&lt;td>223.255.255&lt;/td>
&lt;td>254&lt;/td>
&lt;td>192.168.0.0 到 192.168.255.255&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>D&lt;/td>
&lt;td>&lt;strong>组播地址&lt;/strong>&lt;/td>
&lt;td>&lt;/td>
&lt;td>224.0.0.0&lt;/td>
&lt;td>239.255.255.255&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>E&lt;/td>
&lt;td>保留&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>特殊地址&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>广播地址&lt;/strong>：除网络号外全为1&lt;/li>
&lt;li>127.0.0.1：本地保留地址&lt;/li>
&lt;li>&lt;strong>0.0.0.0&lt;/strong>：设置了缺省网关时的缺省路由&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>内网地址&lt;/strong>：&lt;/p>
&lt;p>RFC 1918 指明的专用地址(private address)（内网地址）&lt;/p>
&lt;p>10.0.0.0 到 10.255.255.255&lt;/p>
&lt;p>172.16.0.0 到 172.31.255.255&lt;/p>
&lt;p>192.168.0.0 到 192.168.255.255&lt;/p>
&lt;h3 id="41-路由协议igp-rip-ospf-bgp">4.1 路由协议(IGP RIP OSPF, BGP)&lt;/h3>
&lt;p>&lt;strong>静态路由与动态路由&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>静态路由&lt;/strong>：非自适应路由，指由网络管理员&lt;strong>手工配置的路由&lt;/strong>信息。&lt;strong>简单开销小&lt;/strong>，但&lt;strong>不能及时适应&lt;/strong>网络变化。&lt;/li>
&lt;li>&lt;strong>动态路由&lt;/strong>：自适应路由选择，&lt;strong>通过路由交换的信息&lt;/strong>来构造路由表。&lt;strong>复杂开销大，能适应&lt;/strong>变化。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>自治系统 AS&lt;/strong>
(Autonomous System) ：&lt;/p>
&lt;p>一个 AS 对其他 AS 表现出的是一个**单一的 **和 &lt;strong>一致的路由选择策略&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>IGP与EGP&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>内部网关协议 &lt;strong>IGP&lt;/strong> (Interior Gateway Protocol) 即在&lt;strong>一个自治系统内部使用的路由选择&lt;/strong>协议。目前这类路由选择协议使用得最多，如 &lt;strong>RIP 和 OSPF&lt;/strong> 协议。&lt;/li>
&lt;li>外部网关协议&lt;strong>EGP&lt;/strong> (External Gateway Protocol) 在自治系统之间使用的。在外部网关协议中目前使用最多的是 &lt;strong>BGP&lt;/strong>-4。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>DV 距离向量 / DVP(Distance Vector Protocol) 距离矢量协议&lt;/strong> ：所有结点都&lt;strong>定期&lt;/strong>地将他们整个&lt;strong>路由表传送给&lt;/strong>所有与之直接&lt;strong>相邻的结点&lt;/strong>。RIP IGRP.&lt;/p>
&lt;p>&lt;strong>LS 链路状态 / LSP(Link State Protocol) 链路状态协议&lt;/strong>： 主动测试&lt;strong>所有邻接结点的状态&lt;/strong>并定期将链路状态传播&lt;strong>给所有其他结点&lt;/strong>。OSPF&lt;/p>
&lt;p>&lt;strong>IGRP（Interior Gateway Routing Protocol）与 EIGRP 增强:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Cisco 专用协议，以延迟，带宽，负载，可靠性为度量标准
最大跳数：255 每 90 秒更新&lt;/li>
&lt;/ul>
&lt;p>**RIP **:&lt;/p>
&lt;ul>
&lt;li>基于&lt;strong>距离向量&lt;/strong>的路由选择协议（Bellman-Ford）
&lt;ul>
&lt;li>每个路由器维护从自己到其他网络的&lt;strong>跳数&lt;/strong>。&lt;/li>
&lt;li>使用&lt;strong>UDP&lt;/strong>,按固定的时间间隔(30s) 和 相邻路由器 交换 自己的路由表,并维护自己的路由表。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>在带宽、配置和管理方面要求低，适合于规模较小的网络中&lt;/li>
&lt;li>&lt;strong>好消息传播得快，而坏消息传播得慢&lt;/strong>。网络出故障的传播时间往往需要较长的时间(例如数分钟)。这是 RIP 的一个主要缺点。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>RIP工作原理&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>收到&lt;/strong>相邻路由器X的&lt;strong>RIP报文&lt;/strong>.&lt;/li>
&lt;li>&lt;strong>修改RIP报文&lt;/strong>,把所有项目的下一跳字段改成X,距离++.&lt;/li>
&lt;li>对于&lt;strong>每个项目&lt;/strong>
&lt;ul>
&lt;li>路由表中无该项目的&lt;strong>目的地址&lt;/strong>, 加入到路由表中.&lt;/li>
&lt;li>否则, 路由表已有的下一跳是X,直接替换.&lt;/li>
&lt;li>否则, 项目中的距离更小,直接替换.&lt;/li>
&lt;li>否则,啥都不做.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>检测相邻路由器心跳&lt;/strong>:3分钟没有收到相邻路由器传报文,将与它的距离置为16(不可达)&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>OSPF&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>是&lt;strong>分布式的链路状态&lt;/strong>协议。
&lt;ul>
&lt;li>只有当链路状态&lt;strong>发生变化&lt;/strong>时，路由器&lt;strong>直接用 IP 数据报&lt;/strong>用&lt;strong>洪泛法&lt;/strong>向&lt;strong>所有路由器&lt;/strong>发送 &lt;strong>与自己的相邻路由器的链路状态LSA（依据LSA而不是Hello）&lt;/strong>.
&lt;ul>
&lt;li>“链路状态” 就是说明本路由器都和哪些路由器相邻，以及该链路的**“度量”**(metric)。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Link - state database 链路状态数据库LSDB
&lt;ul>
&lt;li>全网的拓扑结构图.在全网范围内一致.&lt;/li>
&lt;li>能够较快更新.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>OSPF工作原理&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>OSPF路由器相互发送 HELLO 报文，&lt;strong>建立邻居&lt;/strong>关系&lt;/li>
&lt;li>&lt;strong>邻居&lt;/strong>路由器之间相互&lt;strong>通告自身的链路状态信息(LSA)&lt;/strong>;&lt;/li>
&lt;li>&lt;strong>经过&lt;/strong>一段时间的 &lt;strong>LSA 泛洪&lt;/strong>后所有路由器&lt;strong>形成统一的 LSDB&lt;/strong>&lt;/li>
&lt;li>路由器根据 SPF最短路 算法，以⾃⼰为根&lt;strong>计算最短⽣成树&lt;/strong>，&lt;strong>形成路由转发信息&lt;/strong>.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>BGP&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Border Gateway Protocol 边界网关协议,属于&lt;strong>EGP&lt;/strong>&lt;/p>
&lt;p>BGP 是不同自治系统的路由器之间交换路由信息的协议。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>边界网关协议 BGP 只能是力求寻找一条&lt;strong>能够到达目的网络且比较好&lt;/strong>的路由（不能兜圈子），而&lt;strong>并非要寻找一条最佳路由&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>BGP 协议交换路由信息的结点数量级是&lt;strong>自治系统数的量级&lt;/strong>，这要比这些自治系统中的网络数少很多。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>BGP &lt;strong>支持 CIDR&lt;/strong>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>BGP工作原理&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>每个自治系统至少有一个路由器作为BGP发言人。&lt;/li>
&lt;li>不同自治系统的
BGP发言人都过&lt;strong>建立TCP连接&lt;/strong>交换不同自治系统之间的路由信息。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>“转发”和“路由选择”的区别&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>“转发”(forwarding)就是&lt;strong>路由器根据转发表&lt;/strong>将用户的 &lt;strong>IP 数据报从合适的端口转发&lt;/strong>出去。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>“路由选择”(routing)则是按照&lt;strong>分布式算法&lt;/strong>，根据&lt;strong>从各相邻路由器得到的关于网络拓扑的变化&lt;/strong> 情况，动态地&lt;strong>改变所选择的路由&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>路由表&lt;/strong>是根据&lt;strong>路由选择算法&lt;/strong>得出的。而&lt;strong>转发表是从路由表得出&lt;/strong>的。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>ACL&lt;/strong>: 访问控制列表Access Control Lists
一些告诉路由哪些包该拒绝哪些包能通过的序列集。可以根据源地址，目的地址，链路协议来决定。如果包没有在ACL找到相应的条目，则会被丢弃。&lt;/p>
&lt;h3 id="42-ip多播组播igmpnat">4.2 IP多播/组播(IGMP,NAT)&lt;/h3>
&lt;p>&lt;strong>多播/组播&lt;/strong>: 主机之间 &lt;strong>一对一组&lt;/strong>的通讯模式，同组的主机可接收此组内所有数据. 发送者只需要发送一次, &lt;strong>组播路由器&lt;/strong>只向有需求者复制并转发其所需数据。&lt;/p>
&lt;p>&lt;strong>组播地址&lt;/strong>: 使用D类地址 224.0.0.0 ~ 239.255.255.255.每个D类地址标识一个组.&lt;/p>
&lt;p>&lt;strong>IGMP&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>网际组管理协议 IGMP&lt;/strong> (Internet Group Management Protocol&lt;/li>
&lt;li>&lt;strong>IGMP 使用 IP 数据报传递其报文&lt;/strong>，不把 IGMP 看成是一个单独的协议，而是属于&lt;strong>整个网际协议 IP 的一个组成部分&lt;/strong>&lt;/li>
&lt;li>&lt;strong>不是&lt;/strong>对所有组播成员管理的协议&lt;/li>
&lt;li>不知道成员数和成员分布情况&lt;/li>
&lt;li>让连接在本地局域网的&lt;strong>组播路由器&lt;/strong>知道是否有&lt;strong>主机加入/退出多播组&lt;/strong>.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>IGMP工作原理&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>主机的加入&lt;/strong>
&lt;ul>
&lt;li>想加入的主机,向&lt;strong>对应组播组的组播地址&lt;/strong>发送IGMP.&lt;/li>
&lt;li>&lt;strong>本地组播路由器&lt;/strong>收到后,将&lt;strong>该组成员关系&lt;/strong>发送给&lt;strong>因特网&lt;/strong>上的&lt;strong>其他组播路由器&lt;/strong>.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>探询主机&lt;/strong>
&lt;ul>
&lt;li>本地&lt;strong>组播路由器周期性探询&lt;/strong>本地主机.主机收到后响应.&lt;/li>
&lt;li>如有一个组经过几次探询都没有主机响应,则不再转发该组成员关系.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>VPN&lt;/strong>: 基于TCP/IP的虚拟专用网,分为内联网和外联网,使用&lt;strong>内网地址&lt;/strong>.&lt;/p>
&lt;p>&lt;strong>NAT&lt;/strong>:Network Address Translation 网络地址转换:实现&lt;strong>专用网络地址和公用网络地址&lt;/strong>之间的转化。当私有网和公网主机通信的私有IP经过NAT时，&lt;strong>将IP包中的私有IP与NAT的公有IP进行转换&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>NAT&lt;/strong> 软件 ：需要在&lt;strong>专用网连接到因特网&lt;/strong>的&lt;strong>路由器&lt;/strong>上安装 &lt;strong>NAT&lt;/strong> 软件&lt;/p>
&lt;p>&lt;strong>NAT路由器&lt;/strong>：装有 NAT 软件的路由器叫做 NAT路由器，它至少有一个有效的外部全球地址 IP&lt;em>G&lt;/em>。&lt;/p>
&lt;p>&lt;strong>PAT/NAPT(端口地址转换)&lt;/strong>:将本地网上的多个设备映射到一个单一的公共ip地址。&lt;/p>
&lt;h3 id="43-网际协议-ip">4.3 网际协议 IP&lt;/h3>
&lt;p>TCP/IP 协议中最重要的协议之一，属于网络层的协议，主要作用是定义数据包的格式、对数据包进行路由和寻址，以便它们可以跨网络传播并到达正确的目的地。目前 IP 协议主要分为两种，一种是过去的 IPv4，另一种是较新的 IPv6，目前这两种协议都在使用，但后者已经被提议来取代前者。&lt;/p>
&lt;p>&lt;strong>三种IP地址的编址方法&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>分类&lt;/strong>的 IP 地址（二级IP地址）。这是最基本的编址方法，&lt;/li>
&lt;li>&lt;strong>子网&lt;/strong>的划分（三级IP地址）。这是对最基本的编址方法的改进，&lt;/li>
&lt;li>构成&lt;strong>超网&lt;/strong>。这是比较新的&lt;strong>无分类编址 CIDR&lt;/strong>方法。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>传统分类方法&lt;/strong>：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>类别&lt;/th>
&lt;th>网络号&lt;/th>
&lt;th>主机号&lt;/th>
&lt;th>第一个网络号&lt;/th>
&lt;th>最后一个网络号&lt;/th>
&lt;th>每个网络最大主机数&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>A&lt;/td>
&lt;td>8&lt;/td>
&lt;td>24&lt;/td>
&lt;td>1&lt;/td>
&lt;td>126&lt;/td>
&lt;td>16777214&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>B&lt;/td>
&lt;td>16&lt;/td>
&lt;td>16&lt;/td>
&lt;td>128.1&lt;/td>
&lt;td>191.255&lt;/td>
&lt;td>65534&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>C&lt;/td>
&lt;td>24&lt;/td>
&lt;td>8&lt;/td>
&lt;td>192.0.1&lt;/td>
&lt;td>223.255.255&lt;/td>
&lt;td>254&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>D&lt;/td>
&lt;td>组播地址&lt;/td>
&lt;td>&lt;/td>
&lt;td>224.0.0.0&lt;/td>
&lt;td>239.255.255.255&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>E&lt;/td>
&lt;td>保留&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>划分子网方法&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>IP 地址中增加了一个 “&lt;strong>子网号&lt;/strong>字段”，使两级的 IP 地址变成为&lt;strong>三级&lt;/strong>的 IP 地址。划分子网已成为因特网的正式标准协议。&lt;/li>
&lt;li>ABC类地址的&lt;strong>默认子网掩码&lt;/strong>就是对应网络号的位数。&lt;/li>
&lt;li>255.0.0.0 / 255.255.0.0 / 255.255.255.0&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>子网掩码&lt;/strong>: 通过&lt;strong>与IP地址进行与操作&lt;/strong>，将IP地址划分成网络地址和主机地址两个部分。&lt;/p>
&lt;p>&lt;strong>划分子网的匹配方法&lt;/strong>: 将IP地址 与 该网络的子网掩码相与得到网络号,判断是否匹配.(不能得出唯一网络地址)&lt;/p>
&lt;p>&lt;strong>无分类编址CIDR&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>CIDR Classless Inter-Domain Routing &lt;strong>无分类域间路由选择&lt;/strong>：使用&lt;strong>各种长度的网络前缀&lt;/strong>来代替分类地址中的&lt;strong>网络号和子网号&lt;/strong>的一种子网划分方式。&lt;/li>
&lt;li>格式：网络前缀 + 主机号。从三级地址回到两级地址。&lt;/li>
&lt;li>CIDR记法 128.14.32.0/20. 20表示的是网络前缀位数。主机号位数 = 32 - 网络前缀位数&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>VLSM (Variable Length Subnet Mask) 变长子网掩码&lt;/strong>：在一个划分子网的网络中可同时使用几个不同的子网掩码。CIDR是在VLSM基础上研究出的。&lt;/p>
&lt;p>&lt;strong>路由聚合(构成超网)&lt;/strong>: CIDR 地址块可以表示很多地址，这种地址的聚合常称为&lt;strong>路由聚合&lt;/strong>，它使得&lt;strong>路由表中的一个项目&lt;/strong>可以表示&lt;strong>很多个（例如上千个）&lt;strong>原来&lt;/strong>传统分类地址&lt;/strong>的&lt;strong>路由&lt;/strong>。&lt;/p>
&lt;ul>
&lt;li>缩短路由表尺寸&lt;/li>
&lt;li>支持不连续子网&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>超网&lt;/strong>：前缀长度&lt;strong>不超过 23&lt;/strong> 位的 CIDR 地址块都包含了多个 C 类地址。&lt;strong>这些 C 类地址合起来&lt;/strong>就构成了超网。&lt;/p>
&lt;p>&lt;strong>特定主机路由&lt;/strong>：为&lt;strong>特定的目的主机&lt;/strong> &lt;strong>指明一个路由&lt;/strong>。采用特定主机路由可使网络管理人员能够更&lt;strong>方便地控制&lt;/strong>网络和&lt;strong>测试&lt;/strong>网络，同时也可在需要考虑某种安全问题时采用这种特定主机路由。&lt;/p>
&lt;p>&lt;strong>默认路由&lt;/strong>：采用默认路由可以&lt;strong>减少路由表所占用的空间&lt;/strong>和&lt;strong>搜索路由表所用的时间&lt;/strong>。 当目的网络&lt;strong>不在路由表中&lt;/strong>就选择&lt;strong>默认路由&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>如何找下一跳路由器&lt;/strong>：路由器将IP送交&lt;strong>下层网络接口软件&lt;/strong>，&lt;strong>使用 ARP&lt;/strong> 负责将下一跳路由器的 IP 地址转换成硬件地址。硬件地址放在MAC帧首部，&lt;strong>根据硬件地址找到下一跳&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>分组转发算法工作原理&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>数据包首部提取主机IP地址D&lt;/li>
&lt;li>判断能否&lt;strong>直接交付&lt;/strong>
&lt;ul>
&lt;li>传统分类: 直接提取网络地址N,网络N与路由器直接相连就直接交付.&lt;/li>
&lt;li>划分子网: 将路由器相连的各网络进行匹配.匹配成功就直接交付.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>判断是否有&lt;strong>特定路由&lt;/strong>
&lt;ul>
&lt;li>都是通过判断是否有&lt;strong>目的地址为D&lt;/strong>的特定路由&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>在路由表中查找
&lt;ul>
&lt;li>传统分类:直接一一匹配.&lt;/li>
&lt;li>划分子网:IP地址 与 每一个项目的子网掩码相与后匹配.&lt;/li>
&lt;li>无分类编址: 使用&lt;strong>二叉线索树&lt;/strong>进行&lt;strong>最长前缀匹配&lt;/strong>.前缀越长,地址块越小,地址越具体.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>使用默认路由, 如没有&lt;/li>
&lt;li>报告转发失败.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>路由环路&lt;/strong>:用户的数据包不停在网络上循环发送，始终到达不了目的地，严重浪费网络资源。&lt;/p>
&lt;p>&lt;strong>路由环路解决方法&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>Defining a Maximum/定义最大跳数(一般为15)：&lt;strong>超过最大跳数&lt;/strong>则&lt;strong>抛弃报文&lt;/strong>。&lt;/li>
&lt;li>路由毒害/Route Poisoning:当路由信息的跳数超过定义最大跳时，不是直接从路由表中删除该路由信息，而是&lt;strong>向相邻路由发送&lt;/strong>相关路由信息，&lt;strong>通知其他路由该路径失效&lt;/strong>。&lt;/li>
&lt;li>Split Horizon/&lt;strong>水平分割&lt;/strong>:路由器从某个接口接收到的更新信息&lt;strong>不允许再从这个接口发回去&lt;/strong>。&lt;/li>
&lt;li>Hold-Down-Timers/抑制计时器器:如果一条路由更新的跳数大于路由表已记录的该路由的跳数，&lt;strong>启动计时器&lt;/strong>，在计时器超时前，路由器不再接收关于这条路由的更新信息。&lt;/li>
&lt;/ul>
&lt;h3 id="44-arp-rarp-dhcp">4.4 ARP RARP DHCP&lt;/h3>
&lt;p>&lt;strong>ARP&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>ARP 地址解析协议：源主机在向目标主机&lt;strong>发送IP包前&lt;/strong>，通过&lt;strong>广播ARP请求包&lt;/strong>，将&lt;strong>目标主机的IP地址映射为MAC地址&lt;/strong>。&lt;/li>
&lt;li>每一个主机都设有一个ARP 高速缓存(ARP cache)，里面有所在的局域网上的各主机和路由器的 &lt;strong>IP 地址到硬件地址&lt;/strong>的映射表。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>ARP的四种典型使用情况&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>发送方是主机 / 路由器，要发送IP数据报到&lt;strong>本网络的另一个主机&lt;/strong>。
&lt;ul>
&lt;li>用ARP找目的主机的硬件地址&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>发送方是主机 / 路由器，发送IP数据报的另一个网络上。
&lt;ul>
&lt;li>用ARP找到本网络 &lt;strong>另一个路由器&lt;/strong>的硬件地址。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>ARP工作原理&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>源主机在向⽬标主机发送 IP 包前，如果源主机不知道⽬标主机的 MAC地址。&lt;/li>
&lt;li>源主机&lt;strong>向以太网所有计算机广播&lt;/strong>一个填有⽬标主机IP的&lt;strong>ARP请求包&lt;/strong>。&lt;/li>
&lt;li>&lt;strong>目标主机接收请求&lt;/strong>后，向源主机回复填充上了⽬标主机的 MAC
地址&lt;strong>ARP 应答包&lt;/strong>。&lt;/li>
&lt;li>源主机得到 &lt;strong>ARP 应答&lt;/strong>后，将⽬标主机的 MAC 地址存入本机ARP高速缓存，便于下次使用。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>RARP(反向地址转换协议)&lt;/strong>:用于将局域网中的某个主机的&lt;strong>物理地址转换为IP地址&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>RARP协议工作原理&lt;/strong>:&lt;/p>
&lt;ol>
&lt;li>源主机发送一个&lt;strong>声明自己的MAC地址&lt;/strong>的&lt;strong>请求分配IP地址&lt;/strong>的本地的RARP广播包。&lt;/li>
&lt;li>本地网段上的&lt;strong>RARP服务器&lt;/strong>收到此请求后，检查其RARP列表，查找该MAC地址对应的IP地址；&lt;/li>
&lt;li>如果存在，RARP服务器就给源主机发送一个包含此IP地址响应数据包；如果不存在，&lt;strong>RARP服务器对此不做任何的响应&lt;/strong>；&lt;/li>
&lt;li>源主机如果收到从RARP服务器的响应信息，就利用得到的IP地址进行通讯；如果一直没有收到
RARP服务器的响应信息，表示初始化失败。&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>DHCP（动态主机配置协议 !!应用层!! ）&lt;/strong>：用于给网络中的主机&lt;strong>动态分配&lt;/strong>IP地址。&lt;/p>
&lt;p>&lt;strong>DHCP工作原理&lt;/strong>：&lt;/p>
&lt;ol>
&lt;li>寻找服务器：DHCP客户端广播”DHCP&lt;strong>发现&lt;/strong>消息”，寻找网络中的DHCP服务器。&lt;/li>
&lt;li>提供IP地址: DHCP服务器收到“DHCP&lt;strong>发现&lt;/strong>消息”后，就广播”DHCP&lt;strong>提供&lt;/strong>消息”，包括提供&lt;strong>客户端的IP地址和&lt;/strong>
&lt;strong>相关配置信息&lt;/strong>。&lt;/li>
&lt;li>请求分配IP: DHCP客户端收到“DHCP&lt;strong>提供&lt;/strong>消息”，如果接收客户端提供的相关参数，则广播“DHCP&lt;strong>请求&lt;/strong>消息”向DHCP服务端请求使用该IP地址。&lt;/li>
&lt;li>确认分配:DHCP服务端收
到”DHCP&lt;strong>请求&lt;/strong>消息后“，广播”DHCP&lt;strong>确认&lt;/strong>消息“，将IP地址分配给DHCP客户端。&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>DHCP和RARP的区别&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>RARP只能实现简单的从MAC地址到IP地址的&lt;strong>查询&lt;/strong>工作，RARP服务器上的
MAC地址和IP地址必须&lt;strong>事先静态配置&lt;/strong>好。&lt;/li>
&lt;li>DHCP可以实现除静态分配以外的&lt;strong>动态IP地址分配&lt;/strong>以及&lt;strong>IP地址租期管理等&lt;/strong>复杂功能。&lt;/li>
&lt;/ul>
&lt;h3 id="45-icmp">4.5 ICMP&lt;/h3>
&lt;p>&lt;strong>ICMP(英特网控制报文协议):&lt;/strong> 用来给&lt;strong>主机或路由器报告差错和异常&lt;/strong>情况。ICMP 报文作为 IP 层数据报的数据，加上数据报的首部，组成 IP 数据报发送出去。&lt;/p>
&lt;p>一种用于传输网络状态和错误消息的协议，常用于网络诊断和故障排除。例如，Ping 工具就使用了 ICMP 协议来测试网络连通性。&lt;/p>
&lt;p>&lt;strong>ICMP种类&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>ICMP 差错报告报文
&lt;ul>
&lt;li>终点不可达&lt;/li>
&lt;li>源点抑制(Source quench)&lt;/li>
&lt;li>时间超过&lt;/li>
&lt;li>参数问题&lt;/li>
&lt;li>改变路由（重定向）(Redirect)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ICMP 询问报文
&lt;ul>
&lt;li>有两类 &lt;strong>回送请求和回答报文&lt;/strong>、&lt;strong>时间戳请求和回答报文&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>PING&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Packet InterNet Groper 分组网间探测 ：&lt;/p>
&lt;/li>
&lt;li>
&lt;p>PING 是&lt;strong>应用层直接使用网络层 ICMP&lt;/strong> 的例子，它没有通过运输层的 TCP 或UDP。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>用来测试两个主机之间的连通性。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>PING 使用了 ICMP &lt;strong>回送请求与回送回答报文&lt;/strong>。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Traceroute/Trace&lt;/strong>：工作在&lt;strong>网络层&lt;/strong>，使用了&lt;strong>时间超过报文&lt;/strong>&lt;/p>
&lt;h3 id="45设备">4.5设备&lt;/h3>
&lt;p>网络层设备 &amp;ndash; 路由器: &lt;strong>既能隔离冲突域又能隔离广播域&lt;/strong>&lt;/p>
&lt;h2 id="5传输层">5.传输层&lt;/h2>
&lt;p>&lt;strong>传输层的功能&lt;/strong>:端到端的逻辑通信;收到的报文进行差错检测;提供面向连接的TCP和无连接的UDP.&lt;/p>
&lt;p>&lt;strong>传输层提供的信道&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>使用TCP: 逻辑通信道就相当于一条全双工的可靠信道.&lt;/li>
&lt;li>UDP:不可靠的无连接信道.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>运输协议数据单元 TPDU&lt;/strong>.Transport Protocol Data Unit&lt;/p>
&lt;p>&lt;strong>TCP&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>Transmission Control Protocol 传输控制协议&lt;/li>
&lt;li>提供&lt;strong>面向连接&lt;/strong>的、&lt;strong>可靠&lt;/strong>的&lt;strong>字节流&lt;/strong>服务&lt;/li>
&lt;li>TPDU: TCP &lt;strong>报文段&lt;/strong>(segment)&lt;/li>
&lt;li>传输开销大、报文头部大&lt;/li>
&lt;li>&lt;strong>全双工&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>UDP&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>User Datagram Protocol 用户数据报协议&lt;/li>
&lt;li>提供&lt;strong>面向事务&lt;/strong>的&lt;strong>简单不可靠&lt;/strong>信息传送服务&lt;/li>
&lt;li>TPDU: UDP &lt;strong>报文或用户数据报&lt;/strong>。&lt;/li>
&lt;li>传输开销小、报文头部小 &lt;strong>8字节&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>端口port&lt;/strong>：&lt;strong>2字节16位&lt;/strong>，用来&lt;strong>标识和区分某一台主机上的不同应用进程&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>套接字 Socket&lt;/strong>：由主机IP地址和端口号组成。唯一标识了某台主机上的某个应用进程。&lt;/p>
&lt;p>HTTP 80，SNMP 161&lt;/p>
&lt;p>DNS 53，SMTP 25&lt;/p>
&lt;p>&lt;strong>TELNET 23&lt;/strong>，FTP 21&lt;/p>
&lt;p>&lt;strong>TCP的三种可靠传输机制&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>TCP数据&lt;strong>编号&lt;/strong>: 建立连接时协定初始编号,每一个&lt;strong>字节&lt;/strong>对应一个&lt;strong>编号&lt;/strong>,保证数据有序提交应用层。&lt;/li>
&lt;li>TCP数据&lt;strong>确认&lt;/strong>: 对接收到的数据的&lt;strong>最高序号表示确认&lt;/strong>。&lt;/li>
&lt;li>TCP&lt;strong>重传&lt;/strong>机制: 设置计时器&lt;strong>超时重传&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>流量控制&lt;/strong>： 端与端之间通信量的控制。&lt;strong>让发送方的发送速率不要太快&lt;/strong>，既要让接收方来得及接收，也不要使网络发生拥塞。一般使用滑动窗口进行流量控制。&lt;/p>
&lt;p>&lt;strong>拥塞控制&lt;/strong>：使网络能够承受现有的&lt;strong>网络负荷&lt;/strong>。本质是根据自己估算的网络拥塞程度&lt;strong>设置拥塞窗口的值cwnd&lt;/strong>来限定发送速率。&lt;/p>
&lt;p>&lt;strong>TCP的拥塞控制四种方法&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>慢开始: cwnd = 1，每收到一个确认cwnd++&lt;/p>
&lt;/li>
&lt;li>
&lt;p>拥塞避免: 设置慢开始门限 ssthresh&lt;/p>
&lt;ul>
&lt;li>当 cwnd &amp;lt; ssthresh 时，使用慢开始算法。&lt;/li>
&lt;li>当 cwnd &amp;gt; ssthresh 时，使用&lt;strong>拥塞避免算法&lt;/strong>：每过一个RTT往返时间cwnd++&lt;/li>
&lt;li>出现拥塞时，ssthresh 为 cwnd/2 ，cwnd = 1&lt;/li>
&lt;li>思想：乘法减小，加法增大&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>快重传:&lt;/p>
&lt;ul>
&lt;li>接收方&lt;strong>每收到一个 失序 的报文段&lt;/strong>后就&lt;strong>立即&lt;/strong>发出&lt;strong>重复确认&lt;/strong>。&lt;/li>
&lt;li>发送方只要&lt;strong>一连收到三个重复确认&lt;/strong>就应当立即&lt;strong>重传对方尚未收到的报文段&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>快恢复: 发送方&lt;strong>一连收到三个重复确认&lt;/strong>，ssthresh = cwnd/2，但cwnd不变，此时是由RRT线性增大。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>TCP三次握手&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>第一次&lt;/strong>
&lt;ul>
&lt;li>客户机发送&lt;strong>连接请求报文段&lt;/strong>，请求建立连接&lt;/li>
&lt;li>client：置为syn_send，发送请求 SYN = 1, seq = x&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>第二次&lt;/strong>
&lt;ul>
&lt;li>服务机收到请求后,发回&lt;strong>确认报文段&lt;/strong>.&lt;/li>
&lt;li>同时发送自己的序列号.&lt;/li>
&lt;li>server：置为syn_recvd,发送 SYN = 1,seq = y，ACK x.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>第三次&lt;/strong>
&lt;ul>
&lt;li>客户端收到确认后，发回&lt;strong>确认报文段&lt;/strong>.&lt;/li>
&lt;li>A 的 TCP 通知上层应用进程，连接已经建立。&lt;/li>
&lt;li>client:置为established&lt;/li>
&lt;li>server 收到 该确认报文段后，置为established&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>TCP三次握手的原因&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>因为第二次服务端接收到连接请求的时候，也想建立连接，所以将SYN和ACK一起发送。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>第一次和第二次：为了保证&lt;strong>服务端能收接受到客户端&lt;/strong>的信息并能做出正确的应答。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>第二次和第三次：为了保证&lt;strong>客户端能收接受到服务端&lt;/strong>的信息并能做出正确的应答。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>TCP四次挥手过程&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>第一次&lt;/strong>：&lt;strong>客户端&lt;/strong>发送&lt;strong>FIN报文请求释放连接&lt;/strong>。用来关闭客户端到服务端的数据传送。单向关闭。&lt;/li>
&lt;li>&lt;strong>第二次&lt;/strong>：&lt;strong>服务端&lt;/strong>收到这个FIN后，&lt;strong>发回ACK确认&lt;/strong>。客户端到服务端方向的连接释放，TCP处于半关闭。客户端无法向服务端发送数据，但服务端仍然可以向客户端发送数据。&lt;/li>
&lt;li>&lt;strong>第三次&lt;/strong>：&lt;strong>服务端&lt;/strong>发送&lt;strong>FIN报文释放连接&lt;/strong>，用来关闭服务端到客户端的数据传送。&lt;/li>
&lt;li>&lt;strong>第四次&lt;/strong>：&lt;strong>客户端发送ACK&lt;/strong>，并等待2MSL。若客户端在2MSL内&lt;strong>未收到&lt;/strong>服务端&lt;strong>重发的FIN报文&lt;/strong>，则客户端在
2MSL后关闭。TCP连接释放完成。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>TCP四次挥手原因&lt;/strong>:
当客户端请求释放连接时，服务端发回ACK确认，但是服务端并不一定也要关闭TCP连接。即服务端不一定会马上关闭SOCKET。所以会将&lt;strong>ACK报⽂文和FIN报文分开&lt;/strong>发送。&lt;/p>
&lt;p>&lt;strong>TCP最后一次挥手客户端要等待2MSL(最长报文寿命)时间的原因:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>若&lt;strong>客户端&lt;/strong>发送&lt;strong>最后的ACK丢失&lt;/strong>，
则&lt;strong>服务端会在经过MSL后重发FIN报文&lt;/strong>。若客户端此时已经关闭，则无法重发ACK，则&lt;strong>服务端则无法进入关闭状态&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>TCP建立的连接、虚电路建立的连接、电路交换三者区别：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>TCP建立的连接&lt;/strong>：只是在TCP的TCB(传输控制块中)存储了&lt;strong>目的地址&lt;/strong>的&lt;strong>端口信息&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>虚电路路建立的连接&lt;/strong>：指通信前，在&lt;strong>源主机&lt;/strong>和&lt;strong>目的主机&lt;/strong>之间建立一条虚连接，&lt;strong>分组&lt;/strong>通过&lt;strong>该路径顺序&lt;/strong>
传送到目的主机。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>电路交换&lt;/strong>：是建立&lt;strong>真实&lt;/strong>存在的&lt;strong>物理连接&lt;/strong>。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="6应用层">6.应用层&lt;/h2>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e7%bd%91%e7%bb%9c%e5%9f%ba%e7%a1%80/%e5%ba%94%e7%94%a8%e5%b1%82%e5%8d%8f%e8%ae%ae.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="61-http">6.1 http&lt;/h3>
&lt;p>&lt;strong>HTTP&lt;/strong>: HyperText Transfer Protocol 超文本传输协议&lt;/p>
&lt;ul>
&lt;li>&lt;strong>面向事务的(transaction-oriented)应用层&lt;/strong>协议。HTTP 使用 &lt;strong>TCP 连接进行可靠的&lt;/strong>传送。HTTP是客户端与服务端交互的协议。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>HTTPS&lt;/strong>：HTTP&lt;strong>通信接口部分用SSL和TLS协议代替&lt;/strong>。通常是HTTP直接和TCP通信，当使用SSL时，则演变为先和SSL通信，再由SSL和TCP通信了。&lt;/p>
&lt;h3 id="62-电子邮件协议">6.2 &lt;strong>电子邮件协议&lt;/strong>&lt;/h3>
&lt;p>都是基于TCP&lt;/p>
&lt;ul>
&lt;li>发送邮件的协议：SMTP&lt;/li>
&lt;li>读取邮件的协议：POP3 和 IMAP&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>SMTP&lt;/strong>(简单邮件传输协议)：规定了两个相互通信的SMTP进程之间如何交换信息&lt;/p>
&lt;p>&lt;strong>MIME&lt;/strong>: 在SMTP协议的基础上&lt;strong>增加了邮件主体的结构&lt;/strong>，并定义了&lt;strong>传送非ASCII码&lt;/strong>的编码规则。&lt;/p>
&lt;p>&lt;strong>POP3&lt;/strong>(&lt;strong>邮局版本协议&lt;/strong>3): 支持客户端&lt;strong>远程管理在服务器上的电子邮件&lt;/strong>，邮件发送到服务器上，&lt;strong>客户端调用邮件客户机程序以连接服务器&lt;/strong>，并&lt;strong>下载&lt;/strong>所有未阅读的电子邮件。&lt;/p>
&lt;p>&lt;strong>IMAP&lt;/strong>： Internet Message Access Protocol 互联网邮件访问协议 是一个&lt;strong>联机协议&lt;/strong>。当用户 PC 机上的 IMAP 客户程序打开 IMAP 服务器的邮箱时，用户就可看到邮件的首部。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>优点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>用户可以&lt;strong>在不同的地方使用不同的计算机&lt;/strong>随时上网阅读和处理自己的邮件&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>缺点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>如果用户没有将邮件复制到自己的 PC 上，则邮件一直是存放在 IMAP 服务器上。因此&lt;strong>用户需要经常与 IMAP 服务器建立连接&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>SMTP POP IMAP 三者的区别&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>发信人的用户代理&lt;/strong> 向 &lt;strong>源邮件服务器发送邮件&lt;/strong>，以及&lt;strong>源邮件服务器&lt;/strong> 向 &lt;strong>目的邮件服务器发送邮件&lt;/strong>，都是使用 &lt;strong>SMTP&lt;/strong> 协议。&lt;/li>
&lt;li>而 &lt;strong>POP&lt;/strong> 协议或 &lt;strong>IMAP&lt;/strong> 协议则是&lt;strong>用户&lt;/strong> 从 &lt;strong>目的邮件服务器&lt;/strong>上 &lt;strong>读取邮件&lt;/strong>所使用的协议。&lt;/li>
&lt;/ul>
&lt;h3 id="62-ftp">6.2 FTP&lt;/h3>
&lt;p>&lt;strong>FTP&lt;/strong>：(文本传输协议File Transfer Protocol): 运行在TCP之上，用于在&lt;strong>异构网络&lt;/strong>中任意计算机之间传送文件。FTP 是一种不安全的协议.&lt;/p>
&lt;p>&lt;strong>TFTP&lt;/strong>(简单文件传输协议 运行在UDP之上):用于在&lt;strong>客户端与服务端&lt;/strong>之间进行&lt;strong>简单文件传输&lt;/strong>。TFTP有自己的差错改正措施，不支持交互。&lt;/p>
&lt;p>&lt;strong>FTP工作原理&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>使用&lt;strong>客户服务器&lt;/strong>方式。&lt;/li>
&lt;li>可同时为多个客户进程提供服务。&lt;/li>
&lt;li>FTP 的服务器进程由两大部分组成：&lt;strong>一个主进程&lt;/strong>，负责接受新的请求；另外有&lt;strong>若干个从属进程&lt;/strong>，负责处理单个请求。&lt;/li>
&lt;li>使用两个TCP连接：
&lt;ul>
&lt;li>&lt;strong>控制连接&lt;/strong>在整个会话期间一直保持打开，FTP 客户发出的&lt;strong>传送请求&lt;/strong>通过控制连接&lt;strong>发送给&lt;/strong>服务器端的&lt;strong>控制进程&lt;/strong>。&lt;/li>
&lt;li>用于传输文件的是“&lt;strong>数据连接&lt;/strong>”，被 控制连接 创建。&lt;strong>端口20&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="63-telnet">6.3 Telnet&lt;/h3>
&lt;p>&lt;strong>TELNET&lt;/strong>：简单的&lt;strong>远程终端协议&lt;/strong>，使用C/S方式，使用TCP连接。&lt;/p>
&lt;p>Telnet 协议的最大缺点之一是所有数据（包括用户名和密码）均以明文形式发送，这有潜在的安全风险。这就是为什么如今很少使用 Telnet，而是使用一种称为 SSH 的非常安全的网络传输协议的主要原因。&lt;/p>
&lt;h3 id="64-sshsecure-shell-protocol安全的网络传输协议">6.4 SSH（Secure Shell Protocol，安全的网络传输协议）&lt;/h3>
&lt;p>基于 TCP 协议，通过加密和认证机制实现安全的访问和文件传输等业务&lt;/p>
&lt;h3 id="65-rtpreal-time-transport-protocol实时传输协议">6.5 RTP（Real-time Transport Protocol，实时传输协议）&lt;/h3>
&lt;p>通常基于 UDP 协议，但也支持 TCP 协议。它提供了端到端的实时传输数据的功能，但不包含资源预留存、不保证实时传输质量，这些功能由 WebRTC 实现。&lt;/p>
&lt;h3 id="66-dns-domain-name-system域名系统">6.6 DNS (Domain Name System)域名系统&lt;/h3>
&lt;p>基于 UDP 协议，用于解决域名和 IP 地址的映射问题。&lt;/p>
&lt;p>因特网采用&lt;strong>层次结构的命名树&lt;/strong>作为主机的名字，并使用&lt;strong>分布式&lt;/strong>的域名系统 DNS。用来将域名转换为IP地址。&lt;/p>
&lt;p>&lt;strong>域名服务器&lt;/strong>：&lt;strong>域名服务器程序在专&lt;/strong>设的结点上运行，运行该程序的机器称为&lt;strong>域名服务器&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>基础结构域名&lt;/strong>(infrastructure domain)：这种顶级域名只有一个，即 &lt;strong>arpa&lt;/strong>，用于&lt;strong>反向域名解析&lt;/strong>，因此又称为&lt;strong>反向域名&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>DNS查询方式 域名解析过程&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>主机向本地域名服务器&lt;/strong>的查询一般都是采用&lt;strong>递归查询&lt;/strong>。
&lt;ul>
&lt;li>知道则回复。如本地域名服务器不知道，则本地域名服务器就以 &lt;strong>DNS 客户&lt;/strong>的身份，&lt;strong>向其他域名服务器&lt;/strong>继续发出查询请求报文。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>本地域名服务器&lt;/strong>向&lt;strong>根域名服务器&lt;/strong>的查询通常是采用&lt;strong>迭代查询&lt;/strong>。
&lt;ul>
&lt;li>&lt;strong>根域名服务器要么&lt;/strong>给出所要查询的&lt;strong>IP 地址&lt;/strong>，要么告诉本地域名服务器：“你下一步&lt;strong>应当向哪一个域名服务器&lt;/strong>进行查询”。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="65-其他概念">6.5 其他概念&lt;/h3>
&lt;p>&lt;strong>WWW&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>万维网 WWW (World Wide Web)&lt;strong>并非某种特殊&lt;/strong>的&lt;strong>计算机网络&lt;/strong>。&lt;/li>
&lt;li>是一个&lt;strong>大规模的、联机式&lt;/strong>的&lt;strong>信息储藏所&lt;/strong>。是&lt;strong>分布式超媒体&lt;/strong>(hypermedia)系统，它是&lt;strong>超文本&lt;/strong>(hypertext)系统的扩充。&lt;/li>
&lt;li>&lt;strong>浏览器&lt;/strong>就是在用户计算机上的&lt;strong>万维网客户程序&lt;/strong>。&lt;/li>
&lt;li>&lt;strong>万维网服务器&lt;/strong>：&lt;strong>万维网文档&lt;/strong>所&lt;strong>驻留的计算机&lt;/strong>的&lt;strong>运行服务器程序&lt;/strong>&lt;/li>
&lt;li>&lt;strong>页面&lt;/strong>(page)：在一个&lt;strong>客户程序主窗口上显示出&lt;/strong>的&lt;strong>万维网文档&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>HTML&lt;/strong>(HyperText &lt;strong>Markup&lt;/strong> Language 超文本标记语言): &lt;strong>文档结构标记语言&lt;/strong>，使用约定的标记对页面上的信息进行描述。&lt;/p>
&lt;p>&lt;strong>URL&lt;/strong>: 统一资源定位符Uniform Resource Locator， 标识万维网上的各种文档。每个文档在整个因特网都具有唯一的URL。&lt;/p>
&lt;ul>
&lt;li>格式：协议(ftp/http)://主机:端口/路径。&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e7%bd%91%e7%bb%9c%e5%9f%ba%e7%a1%80/URL%e7%9a%84%e7%bb%84%e6%88%90.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;ul>
&lt;li>协议。URL 的前缀通常表示了该网址采用了何种应用层协议，通常有两种——HTTP 和 HTTPS。当然也有一些不太常见的前缀头，比如文件传输时用到的ftp:。&lt;/li>
&lt;li>域名。域名便是访问网址的通用名，这里也有可能是网址的 IP 地址，域名可以理解为 IP 地址的可读版本，毕竟绝大部分人都不会选择记住一个网址的 IP 地址。&lt;/li>
&lt;li>端口。如果指明了访问网址的端口的话，端口会紧跟在域名后面，并用一个冒号隔开。&lt;/li>
&lt;li>资源路径。域名（端口）后紧跟的就是资源路径，从第一个/开始，表示从服务器上根目录开始进行索引到的文件路径，上图中要访问的文件就是服务器根目录下/path/to/myfile.html。早先的设计是该文件通常物理存储于服务器主机上，但现在随着网络技术的进步，该文件不一定会物理存储在服务器主机上，有可能存放在云上，而文件路径也有可能是虚拟的（遵循某种规则）。&lt;/li>
&lt;li>参数。参数是浏览器在向服务器提交请求时，在 URL 中附带的参数。服务器解析请求时，会提取这些参数。参数采用键值对的形式key=value，每一个键值对使用&amp;amp;隔开。参数的具体含义和请求操作的具体方法有关。&lt;/li>
&lt;li>锚点。锚点顾名思义，是在要访问的页面上的一个锚。要访问的页面大部分都多于一页，如果指定了锚点，那么在客户端显示该网页是就会定位到锚点处，相当于一个小书签。值得一提的是，在 URL 中，锚点以#开头，并且不会作为请求的一部分发送给服务端&lt;/li>
&lt;/ul>
&lt;h4 id="输入url后发生了什么">输入URL后发生了什么&lt;/h4>
&lt;ul>
&lt;li>&lt;strong>浏览器&lt;/strong>会&lt;strong>解析&lt;/strong>URL&lt;/li>
&lt;li>&lt;strong>浏览器&lt;/strong>会&lt;strong>查询&lt;/strong>DNS服务器，&lt;strong>获取&lt;/strong>URL中的&lt;strong>域名&lt;/strong>对应的&lt;strong>IP地址&lt;/strong>&lt;/li>
&lt;li>&lt;strong>浏览器&lt;/strong>会&lt;strong>向&lt;/strong>该&lt;strong>IP地址&lt;/strong>的&lt;strong>服务器&lt;/strong>发出&lt;strong>HTTP请求&lt;/strong>&lt;/li>
&lt;li>&lt;strong>服务器&lt;/strong>接收到&lt;strong>请求&lt;/strong>后，会&lt;strong>根据&lt;/strong>请求的&lt;strong>路径&lt;/strong>找到&lt;strong>对应的文件&lt;/strong>&lt;/li>
&lt;li>&lt;strong>服务器&lt;/strong>会&lt;strong>将&lt;/strong>该文件&lt;strong>返回&lt;/strong>给**浏览器&lt;/li>
&lt;li>&lt;strong>浏览器&lt;/strong>会&lt;strong>解析&lt;/strong>文件，&lt;strong>并&lt;/strong>将&lt;strong>解析&lt;/strong>后的&lt;strong>文件&lt;/strong>显示在&lt;strong>页面&lt;/strong>上&lt;/li>
&lt;/ul></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90/</guid><description>&lt;h3 id="程序分析主要关注两大方面">程序分析主要关注两大方面：&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>程序优化&lt;/strong>侧重于提高程序的性能，通过对程序中关键函数的跟踪或者运行时信息的统计，找到系统性能的瓶颈，从而采取进一步行动对程序进行优化，同时减少资源使用。&lt;/li>
&lt;li>&lt;strong>程序正确性&lt;/strong>侧重于确保程序执行它应该做的事情，帮助开发者找出错误代码的位置。（本文以程序正确性的分析为主）&lt;/li>
&lt;/ul>
&lt;h3 id="程序分析方法">程序分析方法：&lt;/h3>
&lt;p>第一类是&lt;strong>静态程序分析&lt;/strong>，即在不执行程序的情况下进行程序分析。&lt;/p>
&lt;p>第二类是&lt;strong>动态程序分析&lt;/strong>，即通过运行程序或者在程序运行期间进行分析。&lt;/p>
&lt;p>&lt;a href="https://wiki.mbalib.com/wiki/%e5%8a%a8%e6%80%81%e5%88%86%e6%9e%90" target="_blank" rel="noopener">动态分析方法包括：调试、覆盖测试、剖面测试、动态切片、动态污点分析等&lt;/a>&lt;a href="https://wiki.mbalib.com/wiki/%e5%8a%a8%e6%80%81%e5%88%86%e6%9e%90" target="_blank" rel="noopener">1&lt;/a>。&lt;/p>
&lt;p>当然，也有很多研究工作是关于&lt;strong>如何有效结合静态和动态程序分析&lt;/strong>的。同时，因为通常无法拿到真正的程序正确性的需求，绝大多数的程序分析技术着重于分析&lt;strong>通用的程序正确性需求&lt;/strong>，比如如果有断言的话，我们尽量分析断言会不会被违背，再比如分析是否存在整数或者缓存溢出，再或者检测指针相关的安全漏洞等。&lt;/p>
&lt;p>&lt;strong>符号执行&lt;/strong>（通过用求解每条程序路上上的条件来生成测试用例）&lt;/p>
&lt;p>&lt;strong>模型检测&lt;/strong>（通过抽象并遍历所有的程序行为来判断程序是不是正确）&lt;/p>
&lt;p>&lt;strong>模糊测试&lt;/strong>（通过优化大量的生成测试用例）&lt;/p>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/396531255" target="_blank" rel="noopener">模型检查、符号执行、抽象解释等&lt;/a>&lt;a href="https://zhuanlan.zhihu.com/p/396531255" target="_blank" rel="noopener">1&lt;/a>。&lt;/p>
&lt;p>对基于静态分析（比如抽象解释，或者 lint）的工具，一个重要的问题就是&lt;strong>如何减少假警报&lt;/strong>的。&lt;/p>
&lt;p>而对于动态分析（比如测试）而言，对应的问题就是&lt;strong>如何减少漏报&lt;/strong>。&lt;/p>
&lt;p>除了把静态分析做的更精确（比如设计更复杂的 lint 规则），和把动态分析做的更完备（比如提要求更高的覆盖率标准）&lt;/p>
&lt;p>还有一个趋势，就是&lt;strong>结合不同的程序分析技术取长补短&lt;/strong>。比如 hybrid fuzzing 的做法是，通过有效的结合符号执行与模糊测试来提高测试的覆盖率。&lt;/p>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/396531255" target="_blank" rel="noopener">插桩、覆盖率、动态切片、动态污点分析等。&lt;/a>&lt;a href="https://zhuanlan.zhihu.com/p/396531255" target="_blank" rel="noopener">1&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/396531255" target="_blank" rel="noopener">技术分享 | 浅谈程序分析&lt;/a>&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid><description>&lt;h1 id="设计模式">设计模式&lt;/h1>
&lt;p>不到十五种，只考学了的&lt;/p>
&lt;p>分类:&lt;/p>
&lt;p>题型：
分析，设计，问答题&lt;/p>
&lt;p>要画类图, 多种模式组合&lt;/p>
&lt;p>接口的变化还是功能的变化, 功能的选择还是删减, 目的是创建还是复用对象&lt;/p>
&lt;p>只关注 设计原则 设计思想 和 设计模式本身&lt;/p>
&lt;h2 id="2策略模式">2.策略模式&lt;/h2>
&lt;p>策略类的层次结构定义了一系列算法或行为，以供上下文重用。
修改策略不符合开闭原则，增加策略符合开闭原则。
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/2023-12-28-13-19-58.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>与简单工厂模式的区别&lt;/p>
&lt;p>用途不一样
工厂是创建型模式,它的作用就是创建对象；
策略是行为型模式,它的作用是让一个对象在许多行为中选择一种行为;
关注点不一样
一个关注对象创建
一个关注行为的封装&lt;/p>
&lt;p>解决不同的问题
工厂模式是创建型的设计模式，它接受指令，创建出符合要求的实例；它主要解决的是资源的统一分发，将对象的创建完全独立出来，让对象的创建和具体的使用客户无关。主要应用在多数据库选择，类库文件加载等。
策略模式是为了解决的是策略的切换与扩展，更简洁的说是定义策略族，分别封装起来，让他们之间可以相互替换，策略模式让策略的变化独立于使用策略的客户。&lt;/p>
&lt;p>工厂相当于黑盒子，策略相当于白盒子；&lt;/p>
&lt;h2 id="3状态模式">3.状态模式&lt;/h2>
&lt;p>⼀个对象的⾏为取决于⼀个或多个动态变化的属性，这种属性叫做状态，这样的对象叫做有状态的对象
定义：允许⼀个对象在其内部状态改变时改变它的⾏为，对象看起来似乎修改了它的类
包含的⻆⾊：环境类、抽象状态类、具体状态类
环境类：拥有状态的对象，充当状态管理器 State Manager ，在环境类中切换状态&lt;/p>
&lt;p>抽象状态类：可以是抽象类或接⼝；将不同对象下的⾏为单独抽取出来封装到具体状态类中，使得
环境类在修改内部状态时改变其⾏为
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/2023-12-28-19-37-35.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>描述了对象状态的变化以及对象如何在每⼀种状态下表现出不同的⾏为
和策略模式的区别：策略模式是为了让⽤户透明地选择⼀个策略，从外部看，不同策略的⾏为是⼀致的；⽽状态模式是为了改变状态来改变⾏为，从外部看，不同状态的⾏为是不同的&lt;/p>
&lt;p>优点：封装了转换规则；枚举可能的状态；⽅便添加新的状态；状态转换逻辑与状态对象合成⼀体；让多个环境对象共享⼀个状态对象&lt;/p>
&lt;p>缺点：增加系统类和对象的个数；如果使⽤不当将导致程序结构和代码的混乱；对开闭原则的⽀持并不太好&lt;/p>
&lt;p>适⽤环境：⾏为依赖于它的状态（属性），可以根据他的状态改变⽽改变它的相关⾏为；代码包含⼤量与对象状态有关的条件语句&lt;/p>
&lt;p>模式扩展：共享状态；简单状态模式，不需要转换状态的模式，不关⼼状态切换，遵循开闭原则；&lt;/p>
&lt;p>可切换状态的状态模式，可以切换状态，添加新的状态类可能需要修改其他某些状态类甚⾄环境类的源代码&lt;/p>
&lt;h2 id="观察者模式">观察者模式&lt;/h2>
&lt;p>定义：定义了对象之间的⼀对多依赖，让多个观察者对象同时监听某⼀主题对象，当主题对象发⽣变化时，它的所有依赖者（观察者）都会收到通知并更新⾃⼰的状态&lt;/p>
&lt;p>Observer Pattern，⼜叫发布-订阅 Publish/Subscribe 模式、模型-视图 Model/View 模式、源-监听器 Source/Listener 模式、从属者 Dependents 模式&lt;/p>
&lt;p>定义：对象间的⼀种⼀对多依赖关系，使得每当⼀个对象状态发⽣改变时，其相关依赖对象皆得到通知并被⾃动更新
包含的角色：目标、具体目标、观察者、具体观察者&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/2023-12-28-20-21-53.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>优点：实现表示层和数据逻辑层的分离；贯彻⽬标和观察者之间建⽴⼀个抽象的耦合；⽀持⼴播通信；符合开闭原则&lt;/p>
&lt;p>缺点：通知所有观察者会花费很多时间；如果观察者和观察⽬标之间有循环依赖，可能导致系统崩溃；没有相应的机制让观察者知道所观察的⽬标对象是怎么发⽣变化的，仅仅只是知道观察目标发⽣了变化&lt;/p>
&lt;p>适⽤环境：⼀个⽅⾯依赖于另⼀个⽅⾯，将这些⽅⾯封装在独⽴的对象中使它们可以各⾃独⽴地改变和复⽤；⼀个对象的改变将导致其他⼀个或多个对象也发⽣改变，⽽不知道具体有多少对象将发⽣改变；⼀个对象必须通知其他对象，⽽并不知道这些对象是谁；需要在系统中创建⼀个触发链，A-&amp;gt;B, B-&amp;gt;C ……，可以⽤观察者模式创建⼀种链式触发机制&lt;/p>
&lt;p>模式扩展：Java 中的 Observable 和 Observer 类；MVC 模式&lt;/p>
&lt;h2 id="单例模式">单例模式&lt;/h2>
&lt;p>饿汉式&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">Singleton&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">static&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Singleton&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">uniqueInstance&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">Singleton&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">static&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Singleton&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">getUniqueInstance&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">if&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">uniqueInstance&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">==&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">uniqueInstance&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Singleton&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">uniqueInstance&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>懒汉式&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">static&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">synchronized&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Singleton&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">getUniqueInstance&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">if&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">uniqueInstance&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">==&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">uniqueInstance&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Singleton&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">uniqueInstance&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>双校验锁&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">Singleton&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">volatile&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">static&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Singleton&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">uniqueInstance&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">Singleton&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">static&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Singleton&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">getUniqueInstance&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">if&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">uniqueInstance&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">==&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">synchronized&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Singleton&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">if&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">uniqueInstance&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">==&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">uniqueInstance&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Singleton&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">uniqueInstance&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="装饰器模式">装饰器模式&lt;/h2>
&lt;p>⽤继承机制或关联机制可以给⼀个类或对象增加⾏为；以对客户透明的⽅式动态地给⼀个对象附加
更多的职责，并且不需要创造更多⼦类
定义：动态地给⼀个对象增加⼀些额外的职责，别名也叫包装器 Wrapper ，也称为油漆⼯模式
包含的⻆⾊：抽象构件、具体构件、抽象装饰类、具体装饰类&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/2023-12-28-20-28-11.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>与继承相⽐，装饰不会破坏类的封装性，⽽且继承是耦合度较⼤的静态关系，⽆法动态扩展
关联关系具有较好的松耦合性，系统更加容易维护，缺点是要创建更多的对象
以对⽤户透明的⽅式，动态地给⼀个对象附加更多的责任
优点：提供⽐继承更多的灵活性；通过⼀种动态的⽅法来扩展⼀个对象的功能；通过使⽤不同的具
体装饰类以及这些装饰类的排列组合，可以创造出很多不同⾏为的组合；具体构件类与具体装饰类
可以独⽴变化，符合开闭原则
缺点：产⽣很多⼩对象；⽐继承更容易出错，排错也很困难，多层装饰的对象调试时需要逐级排查
适⽤环境：以动态、透明的⽅式给单个对象添加职责；动态地给⼀个对象增加和撤销功能；当不能
采⽤继承的⽅式对系统进⾏扩充或者采⽤继承不利于系统扩展和维护时，如扩展很多、需要⼤量⼦
类，或者类是 ﬁnal 不能继承
模式应⽤：给 JList 装饰⼀个滚动条 JScrollPane ；Java ⾥的各种 **InputStream
模式简化时需要注意的问题：⼀个装饰类的接⼝与被装饰类的接⼝保持相同；不要把太多的逻辑和
状态放到具体构件中&lt;/p>
&lt;p>模式简化：如果只有⼀个具体构件类⽽没有抽象构件类，那么抽象装饰类可以作为具体构件类的直
接⼦类&lt;/p>
&lt;h2 id="工厂方法模式">工厂方法模式&lt;/h2>
&lt;p>⼯⼚⽅法模式
Factory Method Pattern，⼜称为虚拟构造器模式 Virtual Constructor Pattern 或者多态⼯⼚模式
Polymorphic Factory Pattern
“延迟实例化”：⼯⼚⽗类负责定义创建产品对象的公共接⼝，⽽⼯⼚⼦类则负责⽣成具体的产品对象；核⼼的⼯⼚类不再负责所有产品的创建，⽽是将具体创建⼯作交给⼦类去做允许系统在不修改⼯⼚⻆⾊的情况下引进新产品，符合开闭原则&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/2023-12-28-20-43-31.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>可以退化成简单⼯⼚模式&lt;/p>
&lt;p>优点：⽤户只关⼼所需产品对应的⼯⼚，⽆须关⼼创建细节甚⾄⽆须知道具体产品类的类名；可以⾃主确定创建何种产品对象，⽽如何创建这个对象的细节则完全封装在具体⼯⼚内部；在系统中加⼊新产品时，⽆须修改抽象⼯⼚和抽象产品提供的接⼝，⽆须修改客户端，也⽆须修改其他的具体⼯⼚和具体产品，⽽只要添加⼀个具体⼯⼚和具体产品就可以&lt;/p>
&lt;p>缺点：需要编写新的具体产品类，还要提供与之对应的具体⼯⼚类，系统中类的个数将成对增加，增加了系统复杂度；增加了系统的抽象性、理解难度、实现难度&lt;/p>
&lt;p>适⽤环境：⼀个类不知道它所需要的对象的类；⼀个类通过其⼦类来指定创建哪个对象；将创建对象的任务委托给多个⼯⼚⼦类中的某⼀个，客户端在使⽤时可以⽆须关⼼时哪个⼯⼚⼦类创建产品⼦类，需要时再动态指定&lt;/p>
&lt;h2 id="抽象模式">抽象⼯⼚模式&lt;/h2>
&lt;p>Abstract Factory Pattern
产品等级结构：抽象电视机与海尔电视机、海信电视机构成产品等级结构
产品族：由同⼀个⼯⼚⽣产的、位于不同产品等级结构中的⼀组产品，如海尔电视机、海尔电冰箱&lt;/p>
&lt;p>⼯⼚⽅法模式⾯对同⼀个产品等级结构，抽象⼯⼚模式⾯对多个产品等级结构提供⼀个创建⼀系列相关或相互依赖对象的接⼝，⽽⽆须指定它们具体的类&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/2023-12-28-20-43-48.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>包含的⻆⾊：抽象⼯⼚、具体⼯⼚、抽象产品、具体产品
优点：隔离了具体类的⽣成；只需改变具体⼯⼚的实例，就可以改变软件系统的⾏为；实现⾼内聚低耦合的设计⽬的；保证客户端始终只使⽤同⼀个产品族中的对象；增加新的具体⼯⼚和产品族很⽅便，⽆须修改已有系统，符合开闭原则&lt;/p>
&lt;p>缺点：难以扩展抽象⼯⼚来⽣产新种类的产品（涉及到对抽象⼯⼚和所有⼦类的修改）（开闭原则的倾斜性）&lt;/p>
&lt;p>适⽤环境：不应当依赖于产品类实例如何被创建、组合和表达的细节；有多于⼀个产品族；属于同⼀个产品族的产品将在⼀起使⽤；所有的产品以同样的接⼝出现，客户端不依赖具体实现&lt;/p>
&lt;p>⼯⼚模式的退化&lt;/p>
&lt;ul>
&lt;li>抽象⼯⼚➡ ⼯⼚⽅法：只存在⼀个产品等级结构&lt;/li>
&lt;li>⼯⼚⽅法➡ 简单⼯⼚：⼯⼚⽅法模式中抽象⼯⼚与具体⼯⼚合并，提供统⼀的⼯⼚来创建产品对象，并将创建对象的⼯⼚⽅法设计为静态⽅法&lt;/li>
&lt;/ul>
&lt;h2 id="适配器模式">适配器模式&lt;/h2>
&lt;p>将现有的接⼝转化为客户端期望的接⼝
定义：将⼀个接⼝转换成客户希望的另⼀个接⼝，使接⼝不兼容的那些类可以⼀起⼯作
也叫做包装器 Wrapper&lt;/p>
&lt;p>包含的⻆⾊：⽬标抽象类、适配器类（⽤来适配的类）、适配者类（被适配的类）、客户类
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/2023-12-28-20-49-41.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
优点：将⽬标类和适配者类解耦；增加了类的透明性和复⽤性；灵活性和扩展性都⾮常好&lt;/p>
&lt;p>对象适配器模式优点：可以把多个不同的适配者适配到同⼀个⽬标；同⼀个适配器可以把适配者类和它的⼦类都适配到⽬标接⼝&lt;/p>
&lt;p>对象适配器模式缺点：不容易置换适配者类的⽅法
类适配器模式优点：可以在适配器类中置换⼀些适配者的⽅法，灵活性更强
类适配器模式缺点：⼀次只能适配⼀个适配者类，⽬标抽象类只能为抽象类
适⽤环境：需要使⽤现有的类，但是类的接⼝不符合系统需要；想要建⽴⼀个可以重复使⽤的类，⽤于与⼀些彼此之间没有太⼤关联的⼀些类
模式应⽤：JDBC 中间件
模式扩展：默认适配器模式 Default Adapter Pattern（当不需要实现接⼝的全部⽅法时，可先设⼀个抽象类⽤空⽅法实现每个接⼝⽅法，那么抽象类的⼦类就可以有选择地覆盖⽗类的⽅法来实现需求，适⽤于⼀个接⼝不想使⽤其所有⽅法的情况，因此也称为单接⼝适配器模式）、双向适配器模式&lt;/p>
&lt;h2 id="外观模式">外观模式&lt;/h2>
&lt;p>定义：外部与⼀个⼦系统的通信必须通过⼀个统⼀的外观对象进⾏，为⼦系统中的⼀组接⼝提供⼀个⼀致的界⾯，外观模式定义了⼀个⾼层接⼝，使得这⼀⼦系统更加容易使⽤。⼜称为⻔⾯模式
包含的⻆⾊：外观⻆⾊、⼦系统⻆⾊&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/2023-12-28-20-51-50.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>单⼀职责原则：在软件中将⼀个系统划分为若⼲个⼦系统有利于降低整个系统的复杂性；引⼊⼀个
外观对象，为⼦系统的访问提供了⼀个简单⽽单⼀的⼊⼝&lt;/p>
&lt;p>迪⽶特法则：通过引⼊⼀个新的外观类可以降低原有系统的复杂度，降低客户类与⼦系统类的耦合度&lt;/p>
&lt;p>客户端只需要与外观对象打交道，⽽不需要与⼦系统内部的很多对象打交道；降低系统复杂度；提⾼了客户端使⽤的便捷性&lt;/p>
&lt;p>模式应⽤：电源总开关（多个电器⼀起开启和关闭）&lt;/p>
&lt;p>优点：对客户屏蔽⼦系统组件，减少了客户处理的对象数⽬并使得⼦系统使⽤起来更加容易；实现了⼦系统与客户之间的松耦合关系；降低了⼤型软件系统中的编译依赖性，并简化了系统在不同平台之间的移植过程；只是提供了⼀个访问⼦系统的统⼀⼊⼝，并不影响⽤户直接使⽤⼦系统类&lt;/p>
&lt;p>缺点：不能很好地限制客户使⽤⼦系统类；在不引⼊抽象外观类的情况下，增加新的⼦系统需要修改外观类或客户端的源代码，违背了开闭原则&lt;/p>
&lt;p>适⽤环境：当要为⼀个复杂⼦系统提供⼀个简单接⼝时可以使⽤外观模式；客户程序与多个⼦系统之间存在很⼤的依赖性；使⽤外观模式定义系统中每⼀层的⼊⼝，层与层之间不直接产⽣联系，⽽通过外观类建⽴联系，降低层之间的耦合度&lt;/p>
&lt;p>模式扩展：⼀般将外观类设计为单例类以节约系统资源，但在⼀个系统中可以设计多个外观类，每个外观类都负责和⼀些特定的⼦系统交互；不要试图通过外观类为⼦系统增加新⾏为；实现迪⽶特法则；引⼊抽象外观类，当增加新的⼦系统或者移除⼦系统时需要修改外观类，可以通过引⼊抽象外观类解决违背开闭原则的问题，客户端针对抽象外观类进⾏编程&lt;/p>
&lt;h2 id="模板方法模式">模板方法模式&lt;/h2>
&lt;p>定义：定义⼀个操作中算法的⻣架，⽽将⼀些步骤延迟到⼦类中，模板⽅法使得⼦类可以不改变⼀个算法的结构即可重定义该算法的某些特定步骤
基于继承，将相同代码放在⽗类中，以具体⽅法形式实现；声明⼀些抽象⽅法，让不同⼦类实现
包含的⻆⾊：抽象类、具体⼦类&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/2023-12-28-21-04-26.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>实现具体逻辑步骤的⽅法称为基本⽅法 Primitive Method，定义在抽象类中将基本⽅法汇总起来的⽅法称为模板⽅法 Template Method&lt;/p>
&lt;p>钩⼦⽅法 Hook Method：挂钩⽅法和空⽅法（返回布尔值来确定是否在模板⽅法中执⾏）实现⼦类对⽗类⾏为的反向控制（模板中调⽤⼀个返回布尔值的基本⽅法，根据返回值来判断是否执⾏某些&lt;/p>
&lt;p>代码；不同的⼦类返回不同的布尔值，来控制⽗类）&lt;/p>
&lt;p>优点：在⼀个类中抽象地定义算法，⽽由它的⼦类实现细节的处理；代码复⽤的基本技术；反向的控制结构，符合开闭原则；符合单⼀职责原则，使类内聚&lt;/p>
&lt;p>缺点：类的个数增加&lt;/p>
&lt;p>适⽤环境：将可变的⾏为留给⼦类来实现；各⼦类中公共的⾏为应被提取出来并集中到⼀个公共⽗类中；对⼀些复杂的算法进⾏分割；控制⼦类的扩展&lt;/p>
&lt;p>关于继承：应恰当使⽤继承，将可复⽤的⼀般性⾏为代码移到⽗类中。虽然继承复⽤存在⼀些问题，但是在某些情况下能给开发带来⽅便，模板⽅法模式体现了继承的优势&lt;/p>
&lt;p>模式扩展：好莱坞原则（⼦类不显式调⽤⽗类的⽅法，⽽是通过覆盖⽗类的⽅法来实现某些具体业务逻辑，通过⽗类来调⽤⼦类）；钩⼦⽅法（可使⼦类控制⽗类。⽗类提供空⽅法或⼀个默认实现⽅法，由⼦类覆盖。⽗类调⽤返回布尔值的⼦类⽅法，以判断是否执⾏某些代码）&lt;/p>
&lt;h2 id="命令模式">命令模式&lt;/h2>
&lt;p>Command Pattern，别名动作 Action 模式或事务 Transaction 模式
动机：让命令的发送者和接收者完全解耦
定义：将⼀个请求封装为⼀个对象，从⽽使我们可⽤不同的请求对客户进⾏参数化；对请求排队或者记录请求⽇志，以及⽀持可撤销的操作&lt;/p>
&lt;p>包含的⻆⾊：抽象命令类、具体命令类、调⽤者、接收者、客户类&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/2023-12-28-21-21-28.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>对命令进⾏封装，将发出命令的责任和执⾏命令的责任分隔开；请求⼀⽅发出操作请求，接受⼀⽅收到请求并执⾏；请求的⼀⽅不必知道接受请求的⼀⽅的接⼝&lt;/p>
&lt;p>使请求本身成为⼀个对象；引⼊了抽象命令接⼝，发送者针对抽象命令接⼝编程&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/2023-12-28-21-22-01.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>优点：降低系统耦合度；新的命令可以很容易地加⼊到系统中；⽐较容易设计⼀个命令队列和宏命令（组合命令）；⽅便地实现对请求的 Undo 和 Redo
缺点：导致某些系统由过多的具体命令类
适⽤环境：需要将请求调⽤者和请求接收者解耦；需要在不同的时间指定请求、将请求排队和执⾏&lt;/p>
&lt;p>请求；需要⽀持命令的撤销和恢复操作；需要将⼀组操作组合在⼀起，即⽀持宏命令
模式扩展：撤销操作的实现&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/2023-12-28-21-22-53.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>模式扩展：宏命令：⼜称为组合命令，是&lt;strong>命令模式和组合模式&lt;/strong>联⽤的产物；在调⽤宏命令的execute() ⽅法时，将递归调⽤它所包含的每个成员命令的 execute() ⽅法；宏命令的成员对象可以是简单命令，还可以继续是宏命令&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/2023-12-28-21-23-25.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h2 id="迭代器模式">迭代器模式&lt;/h2>
&lt;p>Iterator Pattern，又叫游标 Cursor 模式&lt;/p>
&lt;p>定义：提供⼀种⽅法顺序访问⼀个聚合对象中各个元素，⽽又⽆须暴露该对象的内部表示&lt;/p>
&lt;p>包含的⻆⾊：抽象迭代器、具体迭代器、抽象聚合类、具体聚合类&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/2023-12-28-21-24-01.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>优点：访问⼀个聚合对象的内容⽆需暴露它的内部表示；遍历任务交由迭代器完成，这简化了聚合类；它⽀持以不同的遍历⽅式遍历⼀个聚合，甚⾄可以同时遍历多个聚合对象；在同⼀个聚合上可以有多个遍历；在迭代器模式中，增加新的聚合类和迭代器类都很⽅便，无须修改原有代码；封装性良好，为遍历不同的聚合结构提供⼀个统⼀的接⼝&lt;/p>
&lt;p>缺点：增加了类的个数，这在⼀定程度上增加了系统的复杂性&lt;/p>
&lt;h2 id="代理模式">代理模式&lt;/h2>
&lt;p>Proxy Pattern 或 Surrogate Pattern
通过引⼊⼀个新的对象，来实现对真实对象的操作或者将新的对象作为真实对象的⼀个替身；通过引⼊代理对象来间接访问⼀个对象
客户和⽬标对象之间通过⼀个代理对象来实现间接引⽤，起到中介作⽤；通过代理对象去掉客户不能看到的内容和服务，或者添加客户需要的额外对象&lt;/p>
&lt;p>定义：给某⼀个对象提供⼀个代理，并由代理对象控制对原对象的引⽤
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/2023-12-28-21-34-06.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>包含的对象：抽象主题⻆⾊、代理主题⻆⾊、真实主题⻆⾊
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/2023-12-28-21-34-20.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>优点：协调调⽤者和被调⽤者，降低系统耦合度；远程代理使得客户端可以访问在远程机器上的对象；虚拟代理通过⼀个⼩对象来代表⼀个⼤对象，减少系统资源的消耗，对系统进⾏优化并提⾼运⾏速度；保护代理可以控制对真实对象的使⽤权限&lt;/p>
&lt;p>缺点：有些类型的代理模式可能会造成请求的处理速度变慢；实现代理模式需要额外的⼯作，有些⾮常复杂&lt;/p>
&lt;p>适⽤环境：远程 Remote 代理（⼜叫⼤使 Ambassador）、虚拟 Virtual 代理、Copy-On-Write 代理（真正需要⽤到对象的时候才克隆）、保护 Protect or Access 代理（控制权限）、缓冲 Cache 代理（为某个⽬标操作的结果提供临时存储空间，以便多个客户端可以共享这些结果）、防⽕墙 Firewall 代理、智能引⽤ Smart Reference 代理（当⼀个对象被引⽤时，提供⼀些额外的操作）&lt;/p>
&lt;p>模式应⽤：远程⽅法调⽤&lt;/p>
&lt;h2 id="组合模式">组合模式&lt;/h2>
&lt;p>Composite Pattern&lt;/p>
&lt;p>定义：组合多个对象形成树形结构以表示“整体-部分”的结构层次，对单个对象（即叶⼦对象）和组合对象（即容器对象）的使⽤具有⼀致性
⼜被称为“整体-部分”（Part-Whole）模式，将对象组织到树结构中，可以⽤来描述整体与部分的关系&lt;/p>
&lt;p>包含的⻆⾊：抽象构件、叶⼦构件、容器构件、客户类&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/2023-12-28-21-36-18.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
优点：分层次的复杂对象；客户端可以⼀致地使⽤组合结构或其中单个对象；定义了包含叶⼦对象和容器对象的类层次结构，形成复杂的树形结构；更容易在组合体内加⼊对象构件&lt;/p>
&lt;p>缺点：设计变得更加抽象；很难对容器中的构件类型进⾏限制&lt;/p>
&lt;p>适⽤环境：需要表示⼀个对象整体或部分层次；客户端可以针对抽象构件编程，⽆须关⼼对象层次&lt;/p>
&lt;p>结构的细节；对象的结构是动态的并且复杂程度不⼀样，但客户需要⼀致地处理它们&lt;/p>
&lt;p>模式应⽤：XML ⽂档解析；操作系统中的⽬录结构&lt;/p>
&lt;p>模式扩展：更复杂的组合模式（有多种叶⼦节点、有多种组合节点）、透明组合模式（叶⼦结点也有组合节点的⽅法）、安全组合模式（只有组合节点才有 add remove getChild 等⽅法）&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/</guid><description/></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/git/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/git/</guid><description>&lt;p>软件配置管理&lt;/p>
&lt;p>21.做代码管理用什么东西&lt;/p>
&lt;p>Git 代码仓库&lt;/p>
&lt;p>22.git rebase和git merge的区别&lt;/p>
&lt;p>Merge会自动根据两个分支的共同祖先和两个分支的最新提交 进行一个三方合并，然后将合并中修改的内容生成一个新的 commit，即merge合并两个分支并生成一个新的提交,并且仍然后保存原来分支的commit记录&lt;/p>
&lt;p>Rebase会从两个分支的共同祖先开始提取当前分支上的修改，然后将当前分支上的所有修改合并到目标分支的最新提交后面，如果提取的修改有多个，那git将依次应用到最新的提交后面。Rebase后只剩下一个分支的commit记录&lt;/p>
&lt;p>rebase会打乱时间线，但是更加整洁，merge保留了时间线信息&lt;/p>
&lt;h3 id="23git提交流程">23.git提交流程&lt;/h3>
&lt;p>&lt;a href="https://blog.csdn.net/weixin_44256848/article/details/123812716" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44256848/article/details/123812716&lt;/a>&lt;/p>
&lt;p>git pull 同步远程代码&lt;/p>
&lt;p>修改代码&lt;/p>
&lt;p>git status 显示被修改的文件&lt;/p>
&lt;p>git diff 文件名 显示文件具体变更&lt;/p>
&lt;p>git add 文件名 提交文件到本地缓存区&lt;/p>
&lt;p>git commit 提交到本地仓库&lt;/p>
&lt;p>git push 提交本地代码到远程仓库&lt;/p>
&lt;p>&lt;a href="https://blog.csdn.net/weixin_44256848/article/details/123812716" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44256848/article/details/123812716&lt;/a>&lt;/p>
&lt;p>生产分支（master）‌&lt;/p>
&lt;ul>
&lt;li>Master分支是仓库的主分支，也有人叫Production分支，这个分支包含最近发布到生产环境的代码，最近发布的Release， 这个分支只能从其他分支合并，不能在这个分支直接修改‌&lt;/li>
&lt;/ul>
&lt;p>补丁分支（hotfix）‌&lt;/p>
&lt;ul>
&lt;li>当我们在生产环境发现新的Bug时候，我们需要基于master分支创建一个Hotfix分支，然后在Hotfix分支上修复bug，完成Hotfix后，我们要把hotfix分支合并回Master和Develop分支‌，所以Hotfix的改动会进入下一个Release&lt;/li>
&lt;/ul>
&lt;p>发布分支（release)‌&lt;/p>
&lt;ul>
&lt;li>当你需要发布一个新功能的时候，要基于Develop分支创建一个Release分支，在Release分支测试并修复bug，完成release后，把release合并到master和develop分支‌&lt;/li>
&lt;/ul>
&lt;p>开发分支（develop）‌&lt;/p>
&lt;ul>
&lt;li>这个分支是我们的主开发分支，包含所有要发布到下一个Release的代码，这个主要合并与其他分支，比如Feature分支‌&lt;/li>
&lt;/ul>
&lt;p>功能分支（feature）‌&lt;/p>
&lt;ul>
&lt;li>feature分支主要是用来开发一个新的功能，一旦开发完成，我们合并回Develop分支进入下一个Release‌&lt;/li>
&lt;/ul></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/kubernetes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/kubernetes/</guid><description/></item><item><title/><link>https://ysyyhhh.github.io/docs/language/c++/modern-c++/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/language/c++/modern-c++/</guid><description>&lt;h1 id="modern-c">Modern C++&lt;/h1>
&lt;h2 id="面向对象">面向对象&lt;/h2>
&lt;h3 id="c多态">C++多态&lt;/h3>
&lt;p>多态分为两种，一种是运行时的多态，一种是编译时的多态。&lt;/p>
&lt;p>前者称为动态绑定，后者称为静态绑定。&lt;/p>
&lt;p>动态绑定时由虚函数来实现，静态绑定是由函数重载来实现。&lt;/p>
&lt;h2 id="语法">语法&lt;/h2>
&lt;h3 id="lambda表达式">lambda表达式&lt;/h3>
&lt;p>描述:&lt;/p>
&lt;ul>
&lt;li>一个匿名函数对象&lt;/li>
&lt;li>一个可调用的代码单元&lt;/li>
&lt;li>一个函数对象的语法糖&lt;/li>
&lt;/ul>
&lt;p>语法规则:
&lt;a href="">&lt;/a>{};&lt;br>
[]: lambda表达式的引导符
(): 参数列表&lt;/p>
&lt;p>具体示例&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">auto&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="kr">thread&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">threads&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">thread&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="kr">thread&lt;/span>&lt;span class="p">([&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">taskId&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">num_total_tasks&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">runnable&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">id&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">taskId&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">id&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">num_total_tasks&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">id&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">taskId&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">runnable&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">runTask&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">num_total_tasks&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在示例中, thread的初始化是一个lambda表达式, 该lambda表达式的参数列表为空, 函数体为&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">id&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">taskId&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">id&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">num_total_tasks&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">id&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">taskId&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">runnable&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">runTask&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">num_total_tasks&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样一个thread可以负载多个任务.&lt;/p>
&lt;p>如果不用lambda表达式, 那么就需要定义一个函数, 然后将函数的地址传递给thread, 这样就会增加代码量.&lt;/p>
&lt;p>也就是说实际上 thread的参数可以是一个函数对象, 也可以是一个函数指针, 也可以是一个lambda表达式.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">explicit
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">不能在传参时隐式调用构造函数。
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="err">使用&lt;/span>&lt;span class="n">reset来用子类覆盖父类&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">auto&lt;/span> &lt;span class="n">new_node&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">TrieNodeWithValue&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">move&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">**&lt;/span>&lt;span class="n">end_node&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">end_node&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">reset&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">new_node&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="空类包括什么成员">空类包括什么成员&lt;/h3>
&lt;p>默认构造函数、一个拷贝默认构造函数、一个默认拷贝赋值操作符和一个默认析构函数&lt;/p>
&lt;h3 id="浅拷贝和深拷贝">浅拷贝和深拷贝&lt;/h3>
&lt;p>浅拷贝/值拷贝 数据数量不变，共享同一片空间&lt;/p>
&lt;p>深拷贝 开辟一块新的空间存入数据&lt;/p>
&lt;h3 id="虚函数">虚函数&lt;/h3>
&lt;p>虚函数使用的其核心目的是&lt;strong>通过基类访问派生类定义的函数&lt;/strong>。&lt;/p>
&lt;p>有vptr（虚指针）和vtbl(虚表)&lt;/p>
&lt;p>在派生类中重写该虚函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。&lt;/p>
&lt;p>纯虚函数：virtual void fun()=0。即抽象类必须在子类实现这个函数，即先有名称，没有内容，在派生类实现内容。&lt;/p>
&lt;p>抽象类是指包括至少一个纯虚函数的类。&lt;/p>
&lt;h3 id="虚函数表">虚函数表&lt;/h3>
&lt;p>虚函数表是在谁身上？对象、类、子类、父类？
A: 虚函数表是在类的对象上的，每个对象都有一个虚函数表指针，指向虚函数表。&lt;/p>
&lt;h3 id="虚继承">虚继承&lt;/h3>
&lt;p>虚继承用于解决多继承条件下的菱形继承问题（浪费存储空间、存在二义性）。&lt;/p>
&lt;p>底层实现原理与编译器相关，一般通过虚基类指针和虚基类表实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）&lt;/p>
&lt;p>虚继承&lt;/p>
&lt;ul>
&lt;li>虚基类依旧存在继承类中，只占用存储空间&lt;/li>
&lt;li>虚基类表存储的是虚基类相对直接继承类的偏移
虚函数&lt;/li>
&lt;li>虚函数不占用存储空间&lt;/li>
&lt;li>虚函数表存储的是虚函数地址&lt;/li>
&lt;/ul>
&lt;h3 id="类的大小子类继承后的影响">类的大小，子类继承后的影响&lt;/h3>
&lt;ol>
&lt;li>非静态成员变量的内存占用之和&lt;/li>
&lt;li>考虑内存对其的问题；&lt;/li>
&lt;li>&lt;a href="https://so.csdn.net/so/search?q=%E8%99%9A%E5%87%BD%E6%95%B0&amp;amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener">虚函数&lt;/a>产生的额外内存开销，即虚函数表指针(Virtual Table Pointer);&lt;/li>
&lt;/ol>
&lt;p>空白类被继承后可能会被编译器优化掉&lt;/p>
&lt;h3 id="union-大端小端">union 大端小端&lt;/h3>
&lt;p>union 的赋值（考察大小端以及 union 的内存结构）
联合体变量中的成员是共用一个首地址，共占同一段内存空间，所以在任意时刻只能存放其中一个成员的值。&lt;/p>
&lt;p>大端：内存的低地址存数据的高字节
小端：
举例：假如一个int类型数，十六进制(就是给人看的)表示为： 0x0026F800
那么，如果是小端机器，它在内存中就是：00F82600 （上面的低字节还是在低地址） 内存中地址在这种表示法从左往右由低地址到高地址。
如果是大端机器，它在内存中就是 ：0026F800 (所见即得） （上面的低字节存到了高地址)
大小端是以字节为单位的，因为内存中最小单元就是字节。&lt;/p>
&lt;h2 id="内存相关">内存相关&lt;/h2>
&lt;h3 id="new-和-malloc">new 和 malloc&lt;/h3>
&lt;p>&lt;a href="https://blog.csdn.net/weixin_43899008/article/details/123261412" target="_blank" rel="noopener">new malloc&lt;/a>&lt;/p>
&lt;p>malloc(100M)一块大小，相应的虚拟内存有多少？ （我说这个不是可以自己设么）&lt;/p>
&lt;ul>
&lt;li>new是关键字，需要编译器支持；malloc是库函数，需要头文件支持。&lt;/li>
&lt;li>new申请内存无需指定内存大小，编译器会根据类型信息自行计算。除此之外，new会调用构造函数。&lt;/li>
&lt;li>malloc必须由我们计算需要申请的字节数，需要显式指出所需内存的尺寸，并且返回后强行转换为实际类型的指针。而且malloc只管分配内存，并不能对所得的内存进行初始化，所以得到的一片新内存中，其&lt;strong>值是随机&lt;/strong>的。&lt;/li>
&lt;li>new在自由储存区分配内存，malloc在堆上分配内存。&lt;/li>
&lt;/ul>
&lt;h3 id="悬空指针和野指针">悬空指针和野指针&lt;/h3>
&lt;p>悬空指针是指一个&lt;strong>没有指向任何内存单元&lt;/strong>的指针.&lt;/p>
&lt;p>使用悬空指针报&lt;strong>段错误&lt;/strong>。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">void *p = malloc(size);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">assert(p);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">free(p);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">// 现在 p 是“悬空指针”
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">p = NULL;//// 避免“悬空指针”
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>野指针是指一个不确定其具体指向的指针，最常来自于未初始化的指针。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">void *p;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">// 此时 p 是“野指针”
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">void *p = NULL;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">void *data = malloc(size);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>因为“野指针”可能指向任意内存段，因此它可能会损坏正常的数据，也有可能引发其他未知错误，所以C语言中的“野指针”危害性甚至比“悬空指针”还要严重。&lt;/p>
&lt;p>在实际的C语言程序开发中，定义指针时，一般都要尽量避免“野指针”的出现（赋初值）：&lt;/p>
&lt;h3 id="用c如何保证资源不泄露">用C++如何保证资源不泄露&lt;/h3>
&lt;p>遵循RAII原则。&lt;/p>
&lt;p>在初始化中获取资源 Resource acquisition is initialation&lt;/p>
&lt;p>对象管理自己的资源。&lt;/p>
&lt;p>智能指针是RAII原则的体现。&lt;/p>
&lt;h3 id="内存泄漏">内存泄漏&lt;/h3>
&lt;p>&lt;strong>内存泄露及解决办法&lt;/strong>：&lt;/p>
&lt;p>&lt;strong>什么是内存泄露？&lt;/strong>&lt;/p>
&lt;p>简单地说就是申请了一块内存空间，使用完毕后没有释放掉。&lt;/p>
&lt;ul>
&lt;li>new和malloc申请资源使用后，没有用delete和free释放；&lt;/li>
&lt;li>子类继承父类时，父类析构函数不是虚函数。
&lt;ul>
&lt;li>必须是虚函数这样才能触发动态绑定，这样才不会仅调用父类的析构函数&lt;/li>
&lt;li>是虚函数会先调用子类的虚构函数，再调用父类的虚构函数&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Windows句柄资源使用后没有释放。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>怎么检测？&lt;/strong>&lt;/p>
&lt;p>第一：良好的编码习惯，使用了内存分配的函数，一旦使用完毕,要记得使用其相应的函数释放掉。&lt;/p>
&lt;p>第二：将分配的内存的指针以链表的形式自行管理，使用完毕之后从链表中删除，程序结束时可检查改链表。&lt;/p>
&lt;p>第三：使用&lt;strong>智能指针&lt;/strong>。&lt;/p>
&lt;p>第四：一些常见的工具插件，如ccmalloc、Dmalloc、Leaky、Valgrind等等。&lt;/p>
&lt;h3 id="智能指针-shared_ptr与unique_ptr的开销比较">智能指针 shared_ptr与unique_ptr的开销比较&lt;/h3>
&lt;p>shared_ptr内部引用计数对象要通过new创建，这样所有的对象才能指向同一个引用计数变量；&lt;/p>
&lt;p>unique_ptr接近原生的性能&lt;/p>
&lt;p>&lt;a href="https://blog.csdn.net/codingcs/article/details/120403980" target="_blank" rel="noopener">https://blog.csdn.net/codingcs/article/details/120403980&lt;/a>&lt;/p>
&lt;h3 id="右值引用">右值引用&lt;/h3>
&lt;p>右值引用主要用于移动语义和完美转发&lt;/p>
&lt;h4 id="移动语义">移动语义&lt;/h4>
&lt;ul>
&lt;li>传统的拷贝构造函数和赋值操作符都是通过复制的方式来初始化一个新对象，这样会导致内存的分配和释放，效率较低。&lt;/li>
&lt;li>移动语义是一种新的语义，它允许将资源从一个对象转移到另一个对象，而不是复制资源。这样可以避免不必要的内存分配和释放，提高程序的效率。&lt;/li>
&lt;/ul>
&lt;h4 id="完美转发">完美转发&lt;/h4>
&lt;p>完美转发是指在函数模板中保持参数的原有类型，不改变参数的类型，将参数原封不动地传递给其他函数。&lt;/p>
&lt;h3 id="如果有多个重载函数那么我根据函数名打断点gdb会怎么执行呢是只执行一个还是全部都显示出来都显示出来">如果有多个重载函数，那么我根据函数名打断点，GDB会怎么执行呢，是只执行一个还是全部都显示出来（都显示出来）&lt;/h3>
&lt;h2 id="stl">STL&lt;/h2>
&lt;h3 id="vector">vector&lt;/h3>
&lt;p>可变长数组，用倍增的思想。&lt;/p>
&lt;p>vector在push_back以成倍增长可以在均摊后达到O(1)的事件复杂度&lt;/p>
&lt;p>2倍 gcc&lt;/p>
&lt;p>1.5倍 vs2019&lt;/p>
&lt;p>以2倍的方式扩容，导致&lt;strong>下一次申请的内存必然大于之前分配内存的总和&lt;/strong>，导致&lt;strong>之前分配的内存不能再被使用&lt;/strong>，所以最好倍增长因子设置为(1,2)之间.&lt;/p>
&lt;h3 id="map">map&lt;/h3>
&lt;p>map底层红黑树&lt;/p>
&lt;p>unordered_map底层哈希&lt;/p>
&lt;h3 id="bitset">bitset&lt;/h3>
&lt;p>二进制数组，bool类型的数组。&lt;/p>
&lt;p>可以加速到/64&lt;/p>
&lt;h3 id="迭代器失效的情况以及解决方法">迭代器失效的情况，以及解决方法&lt;/h3>
&lt;ol>
&lt;li>对于序列容器vector，deque来说，使用erase后，后边的每个元素的迭代器都会失效，后边每个元素都往前移动一位，&lt;strong>erase返回下一个有效的迭代器&lt;/strong>。&lt;/li>
&lt;li>对于关联容器map，set来说，使用了erase后，当前元素的迭代器失效，但是其结构是红黑树，删除当前元素，不会影响下一个元素的迭代器，所以&lt;strong>在调用erase之前，记录下一个元素的迭代器&lt;/strong>即可。&lt;/li>
&lt;li>对于list来说，它使用了不连续分配的内存，并且它的erase方法也会返回下一个有效的迭代器，因此上面两种方法都可以使用。&lt;/li>
&lt;/ol>
&lt;h3 id="哈希冲突的解决方法">哈希冲突的解决方法&lt;/h3>
&lt;p>开放地址法/再散列法&lt;/p>
&lt;ul>
&lt;li>冲突时采用&lt;/li>
&lt;li>线性探查&lt;/li>
&lt;li>二次探测&lt;/li>
&lt;li>伪随机&lt;/li>
&lt;/ul>
&lt;p>链表法/拉链法&lt;/p>
&lt;ul>
&lt;li>冲突时直接单链表&lt;/li>
&lt;/ul>
&lt;p>再哈希法&lt;/p>
&lt;ul>
&lt;li>输出是同一个位置就再次哈希（第二个哈希函数）&lt;/li>
&lt;/ul></description></item><item><title/><link>https://ysyyhhh.github.io/docs/language/c++/stl/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/language/c++/stl/</guid><description/></item><item><title/><link>https://ysyyhhh.github.io/docs/language/c++/%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/language/c++/%E5%9F%BA%E7%A1%80/</guid><description>&lt;h1 id="c基础">C++基础&lt;/h1>
&lt;p>union 的赋值（考察大小端以及 union 的内存结构）
union 的赋值（考察大小端以及 union 的内存结构）&lt;/p>
&lt;h2 id="类型">类型&lt;/h2>
&lt;h2 id="语法">语法&lt;/h2>
&lt;h3 id="泛型">泛型&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="k">template&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="k">typename&lt;/span> &lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">T&lt;/span> &lt;span class="n">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">T&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">T&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">a&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="运算符重载">运算符重载&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="k">template&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="k">typename&lt;/span> &lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">Vector&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">private&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">T&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">_data&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">_capacity&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">_size&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">public&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Vector&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">_data&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">T&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">_capacity&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">_size&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">void&lt;/span> &lt;span class="nf">push_back&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">T&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">_size&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">_capacity&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">resize&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">_capacity&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">_data&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">_size&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">T&lt;/span> &lt;span class="k">operator&lt;/span>&lt;span class="p">[](&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">index&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">assert&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">index&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">index&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">_size&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">_data&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">void&lt;/span> &lt;span class="nf">resize&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">newCapacity&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">T&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">newData&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">T&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">newCapacity&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">_size&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">newData&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">_data&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">_data&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">newData&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">_capacity&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">newCapacity&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="nf">size&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">_size&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="nf">capacity&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">_capacity&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">bool&lt;/span> &lt;span class="nf">empty&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">_size&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">void&lt;/span> &lt;span class="nf">print&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">_size&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">cout&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">_data&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34; &amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">cout&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">endl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">~&lt;/span>&lt;span class="n">Vector&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">delete&lt;/span>&lt;span class="p">[]&lt;/span> &lt;span class="n">_data&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Vector&lt;/span>&lt;span class="o">&amp;amp;&lt;/span> &lt;span class="k">operator&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="n">Vector&lt;/span>&lt;span class="o">&amp;amp;&lt;/span> &lt;span class="n">vec&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">this&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">vec&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">delete&lt;/span>&lt;span class="p">[]&lt;/span> &lt;span class="n">_data&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">_data&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">T&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">vec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">_capacity&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">_size&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">vec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">_size&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">_capacity&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">vec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">_capacity&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">_size&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">_data&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">vec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">_data&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Vector&lt;/span>&lt;span class="o">&amp;amp;&lt;/span> &lt;span class="k">operator&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="n">Vector&lt;/span>&lt;span class="o">&amp;amp;&lt;/span> &lt;span class="n">vec&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Vector&lt;/span> &lt;span class="nf">res&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">_size&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">vec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">_size&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">_size&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">res&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">push_back&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">_data&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">vec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">_size&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">res&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">push_back&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">vec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">_data&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">res&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Vector&lt;/span>&lt;span class="o">&amp;amp;&lt;/span> &lt;span class="k">operator&lt;/span>&lt;span class="o">+=&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="n">Vector&lt;/span>&lt;span class="o">&amp;amp;&lt;/span> &lt;span class="n">vec&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">vec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">_size&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">push_back&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">vec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">_data&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title/><link>https://ysyyhhh.github.io/docs/language/c++/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/language/c++/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</guid><description>&lt;h1 id="多线程">多线程&lt;/h1>
&lt;h2 id="锁">锁&lt;/h2>
&lt;h3 id="unique_lock-和-lock_guard">unique_lock 和 lock_guard&lt;/h3>
&lt;p>unique_lock 和 lock_guard 都是 RAII 的封装，都是用来管理 mutex 的，但是 unique_lock 比 lock_guard 更加灵活，可以随时 unlock 和 lock，而 lock_guard 只能在构造的时候 lock，在析构的时候 unlock。&lt;/p>
&lt;p>unique_lock:&lt;/p>
&lt;pre>&lt;code>```cpp
std::mutex mtx;
std::unique_lock&amp;lt;std::mutex&amp;gt; lck(mtx);
lck.unlock();
lck.lock();
```
&lt;/code>&lt;/pre>
&lt;p>lock_guard:&lt;/p>
&lt;pre>&lt;code>```cpp
std::mutex mtx;
std::lock_guard&amp;lt;std::mutex&amp;gt; lck(mtx);
```
&lt;/code>&lt;/pre>
&lt;h4 id="和-condition_variable-使用时的区别">和 condition_variable 使用时的区别&lt;/h4>
&lt;p>unique_lock 和 lock_guard 都可以和 condition_variable 一起使用，但是 unique_lock 更加灵活，可以随时 unlock 和 lock，而 lock_guard 只能在构造的时候 lock，在析构的时候 unlock。&lt;/p>
&lt;p>unique_lock:&lt;/p>
&lt;pre>&lt;code>```cpp
std::mutex mtx;
std::condition_variable cv;
std::unique_lock&amp;lt;std::mutex&amp;gt; lck(mtx);
cv.wait(lck);
/*
这部分仍然被锁住
*/
lck.unlock();
lck.lock();
```
&lt;/code>&lt;/pre>
&lt;p>lock_guard:&lt;/p>
&lt;pre>&lt;code>```cpp
std::mutex mtx;
std::condition_variable cv;
std::lock_guard&amp;lt;std::mutex&amp;gt; lck(mtx);
cv.wait(lck);
/*
这部分已经被解锁
*/
```
&lt;/code>&lt;/pre></description></item><item><title/><link>https://ysyyhhh.github.io/docs/language/c++/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/language/c++/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</guid><description>&lt;h1 id="面向对象">面向对象&lt;/h1>
&lt;h2 id="c类对象大小">C++类对象大小&lt;/h2>
&lt;p>&lt;a href="https://www.cnblogs.com/ZY-Dream/p/10016731.html" target="_blank" rel="noopener">https://www.cnblogs.com/ZY-Dream/p/10016731.html&lt;/a>&lt;/p>
&lt;p>主要是虚函数表、菱形继承、虚拟继承&lt;/p>
&lt;p>类的大小与它的构造函数、析构函数和其他成员函数无关，与静态成员变量也无关。&lt;/p>
&lt;p>普通的继承：类的大小 = 基类的大小 + 自身成员的大小
虚拟继承：类的大小 = 基类的大小 + 自身成员的大小 + 虚基类表指针&lt;/p>
&lt;p>空类：size == 1&lt;/p>
&lt;p>有虚函数：有一个指向虚函数表的指针（vptr），size == 4&lt;/p>
&lt;h2 id="加载顺序">加载顺序&lt;/h2>
&lt;p>父类构造函数–&amp;gt;成员类对象构造函数–&amp;gt;自身构造函数&lt;/p>
&lt;p>其中成员变量的初始化与声明顺序有关，构造函数的调用顺序是类派生列表中的顺序。&lt;/p>
&lt;p>下面是C++类成员变量初始化顺序：
1） 基类的静态变量或全局变量
2） 派生类的静态变量或全局变量
3） 基类的成员变量
4） 派生类的成员变量&lt;/p>
&lt;h2 id="析构顺序">析构顺序&lt;/h2>
&lt;p>析构顺序与构造顺序相反&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/language/java/javaio/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/language/java/javaio/</guid><description>&lt;h1 id="java-io">Java IO&lt;/h1>
&lt;h2 id="java-io流介绍">Java IO流介绍&lt;/h2>
&lt;p>Java IO流主要分为字节流和字符流，字节流主要用于处理二进制文件，字符流主要用于处理文本文件。&lt;/p>
&lt;p>四个抽象类：&lt;/p>
&lt;ul>
&lt;li>InputStream：字节输入流&lt;/li>
&lt;li>OutputStream：字节输出流&lt;/li>
&lt;li>Reader：字符输入流&lt;/li>
&lt;li>Writer：字符输出流&lt;/li>
&lt;/ul>
&lt;h3 id="字节流">字节流&lt;/h3>
&lt;p>字节流主要用于处理二进制文件，如图片、视频、音频等。&lt;/p>
&lt;p>FileInputStream和FileOutputStream是两个基本的字节流，用于读写文件。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">FileInputStreamTest&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">static&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">args&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">try&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">FileInputStream&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">fis&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">FileInputStream&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;test.txt&amp;#34;&lt;/span>&lt;span class="p">))&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">while&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">fis&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">read&lt;/span>&lt;span class="p">())&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">!=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">print&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="kt">char&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">catch&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">IOException&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">printStackTrace&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">FileOutputStreamTest&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">static&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">args&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">try&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">FileOutputStream&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">fos&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">FileOutputStream&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;test.txt&amp;#34;&lt;/span>&lt;span class="p">))&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">str&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;Hello, World!&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kt">byte&lt;/span>&lt;span class="o">[]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">bytes&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">str&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">getBytes&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">fos&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">write&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">bytes&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">catch&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">IOException&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">printStackTrace&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="字符流">字符流&lt;/h3>
&lt;p>字符流主要用于处理文本文件，如txt文件。&lt;/p>
&lt;p>为什么会有字符流&lt;/p>
&lt;ul>
&lt;li>字节流是以字节为单位读写数据，而字符流是以字符为单位读写数据&lt;/li>
&lt;li>字节流读取中文字符时可能会出现乱码，而字符流不会出现乱码&lt;/li>
&lt;/ul>
&lt;p>字符流默认采用unicode编码，可以指定编码格式。&lt;/p>
&lt;p>常用字符编码所占字节数&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>编码格式&lt;/th>
&lt;th>中文字符所占字节数&lt;/th>
&lt;th>英文字符所占字节数&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>GBK&lt;/td>
&lt;td>2&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>UTF-8&lt;/td>
&lt;td>3&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>UTF-16&lt;/td>
&lt;td>2&lt;/td>
&lt;td>2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>unicode&lt;/td>
&lt;td>2&lt;/td>
&lt;td>2&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>FileReader和FileWriter是两个基本的字符流，用于读写文件。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">FileReaderTest&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">static&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">args&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">try&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">FileReader&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">fr&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">FileReader&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;test.txt&amp;#34;&lt;/span>&lt;span class="p">))&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">while&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">fr&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">read&lt;/span>&lt;span class="p">())&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">!=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">print&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="kt">char&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">catch&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">IOException&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">printStackTrace&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">FileWriterTest&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">static&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">args&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">try&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">FileWriter&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">fw&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">FileWriter&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;test.txt&amp;#34;&lt;/span>&lt;span class="p">))&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">str&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;Hello, World!&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">fw&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">write&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">str&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">catch&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">IOException&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">printStackTrace&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="字节缓冲流">字节缓冲流&lt;/h3>
&lt;p>字节缓冲流主要用于提高读写文件的效率。&lt;/p>
&lt;p>BufferedInputStream和BufferedOutputStream是两个基本的字节缓冲流，用于读写文件。&lt;/p>
&lt;p>BufferedInputStream 内部维护了一个缓冲区，这个缓冲区实际就是一个字节数组，通过阅读 BufferedInputStream 源码即可得到这个结论.
缓冲器默认大小为 8192 字节，也就是 8KB，这个大小是可以通过构造函数来指定的。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">BufferedInputStream&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">extends&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">FilterInputStream&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 内部缓冲区数组&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">protected&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">volatile&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">byte&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="o">[]&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 缓冲区的默认大小&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">static&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">DEFAULT_BUFFER_SIZE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">8192&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 使用默认的缓冲区大小&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">BufferedInputStream&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">InputStream&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">in&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">in&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">DEFAULT_BUFFER_SIZE&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 自定义缓冲区大小&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">BufferedInputStream&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">InputStream&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">in&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">size&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">super&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">in&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">if&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">size&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;lt;=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">throw&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">IllegalArgumentException&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Buffer size &amp;lt;= 0&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">byte&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">size&lt;/span>&lt;span class="o">]&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="字符缓冲流">字符缓冲流&lt;/h3>
&lt;p>字符缓冲流主要用于提高读写文件的效率。&lt;/p>
&lt;h3 id="打印流">打印流&lt;/h3>
&lt;p>PrintStream和PrintWriter是两个基本的打印流，用于打印数据。&lt;/p>
&lt;p>System.out实际是获取了一个PrintStream对象，System.out.println()实际是调用了PrintStream对象的println()方法。&lt;/p>
&lt;h3 id="随机访问流">随机访问流&lt;/h3>
&lt;p>RandomAccessFile是一个基本的随机访问流，用于读写文件, 支持随机访问文件。
RandomAccessFile 的构造方法如下&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">RandomAccessFile&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">mode&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">throws&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">FileNotFoundException&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">!=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">?&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">File&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">mode&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>mode 参数指定了 RandomAccessFile 的访问模式，有 &amp;ldquo;r&amp;rdquo;、&amp;ldquo;rw&amp;rdquo;、&amp;ldquo;rws&amp;rdquo;、&amp;ldquo;rwd&amp;rdquo; 四种模式，分别表示：&lt;/p>
&lt;ul>
&lt;li>&amp;ldquo;r&amp;rdquo;：以只读方式打开&lt;/li>
&lt;li>&amp;ldquo;rw&amp;rdquo;：以读写方式打开&lt;/li>
&lt;li>&amp;ldquo;rws&amp;rdquo;：以读写方式打开，对文件的内容或元数据的每个更新都同步写入到底层存储设备&lt;/li>
&lt;li>&amp;ldquo;rwd&amp;rdquo;：以读写方式打开，对文件内容的每个更新都同步写入到底层存储设备&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">RandomAccessFileTest&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">static&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">args&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">try&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">RandomAccessFile&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">raf&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">RandomAccessFile&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;test.txt&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;rw&amp;#34;&lt;/span>&lt;span class="p">))&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">raf&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">write&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Hello, World!&amp;#34;&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">getBytes&lt;/span>&lt;span class="p">());&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">raf&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">seek&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kt">byte&lt;/span>&lt;span class="o">[]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">bytes&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">byte&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">1024&lt;/span>&lt;span class="o">]&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">len&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">while&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="n">len&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">raf&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">read&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">bytes&lt;/span>&lt;span class="p">))&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">!=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">bytes&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">len&lt;/span>&lt;span class="p">));&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">catch&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">IOException&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">printStackTrace&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="io中的设计模式">IO中的设计模式&lt;/h2>
&lt;h3 id="装饰器模式">装饰器模式&lt;/h3>
&lt;p>装饰器模式是一种结构型设计模式，允许你通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。&lt;/p>
&lt;p>装饰器模式的主要优点有：&lt;/p>
&lt;ul>
&lt;li>可以在不修改现有对象的情况下，动态地给一个对象增加一些额外的功能&lt;/li>
&lt;li>可以使用多个装饰器包装一个对象，得到功能更加强大的对象&lt;/li>
&lt;/ul>
&lt;p>字节流和字符流的装饰器模式
FilterInputStream和FilterOutputStream是两个基本的装饰器，用于装饰字节流。&lt;/p>
&lt;h3 id="适配器模式">适配器模式&lt;/h3>
&lt;p>适配器模式是一种结构型设计模式，它能使接口不兼容的对象能够相互合作。&lt;/p>
&lt;p>InputStreamReader和OutputStreamWriter是两个基本的适配器，用于适配字节流和字符流。&lt;/p>
&lt;p>InputStreamReader是字节流到字符流的适配器，OutputStreamWriter是字符流到字节流的适配器。&lt;/p>
&lt;h3 id="观察者模式">观察者模式&lt;/h3>
&lt;p>观察者模式是一种行为型设计模式，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。&lt;/p>
&lt;p>NIO中的文件监听器就是观察者模式的一种应用。&lt;/p>
&lt;p>NIO中的文件监听器基于WatchService接口和Watchable接口.&lt;/p>
&lt;h3 id="工厂模式">工厂模式&lt;/h3>
&lt;p>Files类的newInputStream()和newOutputStream()方法就是工厂模式的一种应用。&lt;/p>
&lt;h2 id="io模型">IO模型&lt;/h2>
&lt;p>IO操作的本质是数据的输入和输出，而IO模型是操作系统对IO操作的抽象。
平时接触最多的是磁盘IO和网络IO。&lt;/p>
&lt;p>UNIX系统下, IO模型有五种：&lt;/p>
&lt;ul>
&lt;li>同步阻塞IO&lt;/li>
&lt;li>同步非阻塞IO&lt;/li>
&lt;li>IO复用&lt;/li>
&lt;li>信号驱动IO&lt;/li>
&lt;li>异步IO&lt;/li>
&lt;/ul>
&lt;h3 id="java中的三种常见io">Java中的三种常见IO&lt;/h3>
&lt;ul>
&lt;li>BIO（Blocking IO）：同步阻塞IO&lt;/li>
&lt;li>NIO（Non-blocking IO）：同步非阻塞IO&lt;/li>
&lt;li>AIO（Asynchronous IO）：异步IO&lt;/li>
&lt;/ul>
&lt;p>BIO（Blocking IO）：同步阻塞IO&lt;/p>
&lt;ul>
&lt;li>一个线程只能处理一个连接&lt;/li>
&lt;li>适用于连接数较少的场景&lt;/li>
&lt;/ul>
&lt;p>当有大量的连接时，BIO的效率会很低，因为每个连接都需要一个线程来处理。&lt;/p>
&lt;p>IO多路复用（IO Multiplexing）：IO复用
线程首先发起IO请求，然后阻塞在IO复用器上，当IO复用器检测到有IO事件时，线程才会被唤醒。&lt;/p>
&lt;p>NIO（Non-blocking IO）：同步非阻塞IO&lt;/p>
&lt;p>NIO是一种同步非阻塞IO模型，适用于连接数较多的场景。
NIO的核心是Selector，Selector可以同时监控多个通道的IO事件。&lt;/p>
&lt;p>AIO（Asynchronous IO）：异步IO
AIO是一种异步IO模型，适用于连接数较多且数据量较大的场景。&lt;/p>
&lt;h2 id="javanio">JavaNIO&lt;/h2>
&lt;p>NIO的核心组件&lt;/p>
&lt;ul>
&lt;li>Channel: 通道, 用于读写数据&lt;/li>
&lt;li>Buffer: 缓冲区, 用于存储数据&lt;/li>
&lt;li>Selector: 多路复用器, 用于监控多个通道的IO事件&lt;/li>
&lt;/ul>
&lt;h3 id="nio零拷贝">NIO零拷贝&lt;/h3>
&lt;p>零拷贝是指数据在内存和磁盘之间传输时，不需要在中间进行数据拷贝。&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/language/java/java%E5%9F%BA%E7%A1%80/java%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/language/java/java%E5%9F%BA%E7%A1%80/java%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B/</guid><description>&lt;h1 id="java--编译与解释共存的语言">Java&amp;ndash;编译与解释共存的语言&lt;/h1>
&lt;p>&lt;a href="https://tech.meituan.com/2020/10/22/java-jit-practice-in-meituan.html" target="_blank" rel="noopener">基本功 | Java即时编译器原理解析及实践&lt;/a>&lt;/p>
&lt;p>编译型语言：
编译型语言是指在程序运行之前，需要先将源代码编译成机器码，然后再运行&lt;strong>编译后的机器码&lt;/strong>。编译型语言有C、C++、Rust、Go等。&lt;/p>
&lt;p>解释型语言：
解释型语言是指在程序运行时，需要通过解释器将源代码逐行解释成机器码，然后再运行机器码。解释型语言有Python、JavaScript、Ruby等。&lt;/p>
&lt;p>而Java是一种编译与解释共存的语言，它的编译与解释过程如下：&lt;/p>
&lt;ol>
&lt;li>编译：Java源代码首先通过javac编译器&lt;strong>编译成字节码&lt;/strong>（.class文件）。&lt;/li>
&lt;li>解释：然后通过Java虚拟机（JVM）将字节码解释成机器码，然后再运行机器码。&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>字节码(.class文件)：Java源代码经过编译后生成的中间代码，它不是机器码，而是一种介于源代码和机器码之间的代码。字节码可以在任何支持Java虚拟机的平台上运行，因此Java具有“一次编译，到处运行”的特性。&lt;/p>
&lt;/blockquote>
&lt;p>因此在性能上Java介于编译型语言和解释型语言之间，它的性能比解释型语言要好，但比编译型语言要差。&lt;/p>
&lt;h2 id="优化解释即时编译-jit-just-in-time-compilation技术">优化解释(即时编译 JIT, Just-In-Time Compilation)技术&lt;/h2>
&lt;p>为了优化性能,在第二步的解释中,Java使用了即时编译（JIT，Just-In-Time Compilation）技术&lt;/p>
&lt;p>当程序运行时，解释器首先发挥作用，代码可以直接执行。随着时间推移，即时编译器逐渐发挥作用，把越来越多的代码编译优化成本地代码，来获取&lt;strong>更高的执行效率&lt;/strong>（指热点代码这些可以得到更好的优化）。&lt;/p>
&lt;p>即时编译器与静态编译相比:&lt;/p>
&lt;ul>
&lt;li>可以选择热点代码进行编译，而不是整个程序&lt;/li>
&lt;li>即时编译器已经非常成熟，可以进行更多的优化，比如内联、逃逸分析、栈上分配等&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Java%e5%9f%ba%e7%a1%80/Java%e7%a8%8b%e5%ba%8f%e5%8f%98%e4%b8%ba%e6%9c%ba%e5%99%a8%e7%a0%81.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>同样使用JIT技术的还有&lt;a href="https://zh.wikipedia.org/zh-cn/LLVM" target="_blank" rel="noopener">LLVM&lt;/a>、V8引擎等。&lt;/p>
&lt;blockquote>
&lt;p>AOT: Ahead-Of-Time Compilation，预编译，是指在程序运行之前，将源代码编译成机器码(属于静态编译)。
JDK 9引入了AOT编译器。
AOT 避免了 JIT 预热等各方面的开销，可以提高 Java 程序的&lt;strong>启动速度&lt;/strong>，避免预热时间长。并且，AOT 还能减少内存占用和增强 Java 程序的安全性（AOT 编译后的代码不容易被反编译和修改），特别适合云原生场景。&lt;/p>
&lt;/blockquote>
&lt;h2 id="aot和jit">AOT和JIT&lt;/h2>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Java%e5%9f%ba%e7%a1%80/JITvsAOT.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>AOT 的主要优势在于启动时间、内存占用和打包体积。
JIT 的主要优势在于具备更高的极限处理能力，可以降低请求的最大延迟。&lt;/p>
&lt;blockquote>
&lt;p>GraalVM 是一种高性能的 JDK（完整的 JDK 发行版本），它可以运行 Java 和其他 JVM 语言，以及 JavaScript、Python 等非 JVM 语言。 GraalVM 不仅能提供 AOT 编译，还能提供 JIT 编译。&lt;/p>
&lt;/blockquote>
&lt;p>AOT 更适合当下的云原生场景，对微服务架构的支持也比较友好。
但AOT 编译无法支持 Java 的一些动态特性，如反射、动态代理、动态加载、JNI（Java Native Interface）等。而很多框架和库（如 Spring、CGLIB）都用到了这些特性。为了支持类似的动态特性，所以选择使用 JIT 即时编译器。&lt;/p>
&lt;blockquote>
&lt;p>如: CGLIB 动态代理使用的是 ASM 技术，而这种技术大致原理是运行时直接在内存中生成并加载修改后的字节码文件也就是 .class 文件，如果全部使用 AOT 提前编译，也就不能使用 ASM 技术了。&lt;/p>
&lt;/blockquote></description></item><item><title/><link>https://ysyyhhh.github.io/docs/language/java/java%E5%9F%BA%E7%A1%80/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/language/java/java%E5%9F%BA%E7%A1%80/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</guid><description>&lt;h1 id="基本概念">基本概念&lt;/h1>
&lt;h2 id="javasejavaeejavame">JavaSE、JavaEE、JavaME&lt;/h2>
&lt;ul>
&lt;li>JavaSE（Java Platform, Standard Edition）：Java平台标准版，是Java的核心部分，包括Java语言、Java虚拟机、Java API等。&lt;/li>
&lt;li>JavaEE（Java Platform, Enterprise Edition）：Java平台企业版，是JavaSE的扩展，用于开发企业级应用程序，包括Servlet、JSP、EJB等。&lt;/li>
&lt;li>JavaME（Java Platform, Micro Edition）：Java平台微型版，用于开发嵌入式设备和移动设备上的应用程序。&lt;/li>
&lt;/ul>
&lt;h2 id="jdkjrejvm">JDK、JRE、JVM&lt;/h2>
&lt;ul>
&lt;li>JVM（Java Virtual Machine）：Java虚拟机，用于执行Java字节码。&lt;/li>
&lt;li>JRE（Java Runtime Environment）：Java运行时环境，他包含了JVM和Java类库，用于运行Java程序。&lt;/li>
&lt;li>JDK（Java Development Kit）：Java&lt;strong>开发&lt;/strong>工具包，它包含了JRE，同时还包含了编译器javac、调试器jdb、文档生成器javadoc等开发工具。
&lt;ul>
&lt;li>开发时必须安装JDK，运行时通常只需要安装JRE（除非需要使用Java特性的开发工具，如JSP转换为Servlet，反射等）。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>Java1.0 到 Java9: 对应JDK1.0 到 JDK1.9&lt;/p>
&lt;p>Java10及之后: 对应JDK10及之后&lt;/p>
&lt;p>最新描述：
从JDK 9开始，不区分JDK和JRE，被模块系统取代：JDK（被重新组织成94个模块）和jlink工具。
并且从JDK 11开始，不再提供JRE，只提供JDK。&lt;/p>
&lt;h2 id="oracle-jdk-和-openjdk">Oracle JDK 和 OpenJDK&lt;/h2>
&lt;ul>
&lt;li>OpenJDK：由OpenJDK社区提供的JDK，是一个开源项目，不包含Oracle公司的商业特性，可以完全免费使用，基于GPLv2协议。&lt;/li>
&lt;li>Oracle JDK：由Oracle公司提供的JDK，一般是3年免费使用，之后需要付费。
&lt;ul>
&lt;li>JDK原本是SUN公司的产品且开源，后来SUN公司被Oracle公司收购，Oracle公司继续维护JDK，并且提供了商业特性。&lt;/li>
&lt;li>基于BCL/OTN协议。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>区别：&lt;/p>
&lt;ul>
&lt;li>更新频率：OpenJDK三个月更新一次，Oracle JDK每6个月更新一次。&lt;/li>
&lt;li>稳定性：Oracle JDK更稳定，OpenJDK更先进。&lt;/li>
&lt;/ul>
&lt;h2 id="java和c比较">Java和C++比较&lt;/h2>
&lt;p>不同点&lt;/p>
&lt;ul>
&lt;li>内存访问: Java是通过引用访问对象,内存更安全; 而C++是通过指针访问对象。
&lt;ul>
&lt;li>安全检查: Java有如空指针检查、数组边界检查等&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>类的继承: Java只支持单继承, C++支持多继承。&lt;/li>
&lt;li>运行环境: Java是跨平台的, C++不是。&lt;/li>
&lt;li>内存管理: Java有垃圾回收机制, C++需要手动管理内存。&lt;/li>
&lt;li>异常处理: Java使用异常处理机制, C++使用异常和错误码。&lt;/li>
&lt;li>重载: Java不支持运算符重载, C++支持。&lt;/li>
&lt;/ul></description></item><item><title/><link>https://ysyyhhh.github.io/docs/language/java/java%E5%9F%BA%E7%A1%80/%E5%B8%B8%E8%A7%81%E5%B7%A5%E5%85%B7%E7%B1%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/language/java/java%E5%9F%BA%E7%A1%80/%E5%B8%B8%E8%A7%81%E5%B7%A5%E5%85%B7%E7%B1%BB/</guid><description>&lt;h1 id="常见的java工具类">常见的Java工具类&lt;/h1>
&lt;h2 id="jwt">JWT&lt;/h2>
&lt;h3 id="jwt里面有什么httpsblogcsdnnetweixin_36378232articledetails113022878">jwt&lt;a href="https://blog.csdn.net/weixin_36378232/article/details/113022878" target="_blank" rel="noopener">里面有什么&lt;/a>&lt;/h3>
&lt;p>JWT主要由三个部分组成(前两部分可以通过base64解密得到)：头部(HEADER)，载荷(PAYLOAD)，签证(SIGNATURE)。&lt;/p>
&lt;ul>
&lt;li>头部描述该JWT的最基本信息，主要包含两个部分：声明类型 JWT 和声明加密算法(通常直接使用HMAC，SHA256)。
&lt;ul>
&lt;li>&lt;code>{ &amp;quot;alg&amp;quot;: &amp;quot;HS256&amp;quot;, //第三段字符串的不可逆加密类型HS256 &amp;quot;typ&amp;quot;: &amp;quot;JWT&amp;quot; //token类型JWT }&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>载荷主要是存放有效信息为自定义值，这些信息按照职能可以分成三个部分
&lt;ul>
&lt;li>标准的注册声明
&lt;ul>
&lt;li>人:签发者,jwt面向用户,接收jwt的一方.&lt;/li>
&lt;li>时间相关,过期时间,不可用时间.签发时间&lt;/li>
&lt;li>唯一标识, 可用于一次性token&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>公共的声明:公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息。但不建议添加敏感信息，因为该部分在客户端可解密。&lt;/li>
&lt;li>私有的声明:私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为BASE64是对称解密的，意味着该部分信息可以归类为明文信息。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>签证
&lt;ul>
&lt;li>先将第一段和第二段的密文&lt;strong>拼接&lt;/strong>起来&lt;/li>
&lt;li>对拼接起来的密文字符串和&lt;strong>自定义的盐&lt;/strong>进行上边&lt;strong>指定的HS256加密&lt;/strong>&lt;/li>
&lt;li>&lt;strong>对HS256加密后的密文再做base64加密&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>签证需要的自定义的盐、密钥等仅存在服务端，不会传输到客户端。&lt;/p>
&lt;p>因此签证可以证明Token的合法性，&lt;strong>防止Token被篡改&lt;/strong>。&lt;/p>
&lt;h3 id="要是想要传输密码怎么解决盐值怎么存储">要是想要传输密码，怎么解决？盐值怎么存储？&lt;/h3>
&lt;p>对称加密：&lt;/p>
&lt;ul>
&lt;li>AES、DES
非对称加密：&lt;/li>
&lt;li>RSA、ECC
哈希加密：&lt;/li>
&lt;li>MD5、SHA256加密算法，是一种不可逆的加密算法，可以用于加密密码。&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://blog.csdn.net/biubiubiubibibi/article/details/127579426" target="_blank" rel="noopener">BCryptPasswordEncoder&lt;/a>&lt;/p>
&lt;p>每次都是不一样的密文， 但是任意的一个结果密文和原文match , 得到的都是true。
是因为密文中包含了盐，每次加密的时候都会生成一个随机的盐。
match时，提取出密文的盐，然后用这个盐和原文再次加密，得到的密文和原来的密文进行比较。&lt;/p>
&lt;p>status字段是什么类型&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/language/java/java%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/language/java/java%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid><description>&lt;h1 id="数据类型">数据类型&lt;/h1>
&lt;p>八种基本数据类型:&lt;/p>
&lt;p>byte/8
char/16
short/16
int/32
float/32
long/64
double/64
boolean/~&lt;/p>
&lt;p>基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用&lt;strong>自动装箱与拆箱完成&lt;/strong>。&lt;/p>
&lt;h2 id="基本数据类型和包装类型的区别">基本数据类型和包装类型的区别&lt;/h2>
&lt;ul>
&lt;li>用途: 基本数据类型一般只用于常量和局部变量, 而包装类型可以用于类的成员变量, 方法参数和返回值&lt;/li>
&lt;li>内存占用: 基本数据类型占用的内存较小, 包装类型占用的内存较大&lt;/li>
&lt;li>默认值: 基本数据类型有默认值, 包装类型默认值为null&lt;/li>
&lt;li>引用: 基本数据类型不是对象, 包装类型是对象&lt;/li>
&lt;li>比较: 基本数据类型比较值, 包装类型&lt;strong>比较引用&lt;/strong>,比较内容需要使用equals方法&lt;/li>
&lt;li>存储方式: 基本数据类型的存储位置取决于变量的作用域和声明方式, 包装类型存储在堆中.(几乎所有的对象都存储在堆中)&lt;/li>
&lt;/ul>
&lt;h3 id="为什么说是几乎所有对象实例都存在于堆中呢-逃逸分析">为什么说是几乎所有对象实例都存在于堆中呢？ （逃逸分析）&lt;/h3>
&lt;p>这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存&lt;/p>
&lt;p>&lt;strong>基本数据类型的存储位置取决于它们的作用域和声明方式。&lt;/strong>&lt;/p>
&lt;p>私有：&lt;/p>
&lt;ul>
&lt;li>栈中:
&lt;ul>
&lt;li>局部变量&lt;/li>
&lt;li>方法参数&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>程序计数器
&lt;ul>
&lt;li>当前线程执行字节码的地址&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>本地方法栈
&lt;ul>
&lt;li>使用本地方法(Native Method)时的状态&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>公有：&lt;/p>
&lt;ul>
&lt;li>堆中:
&lt;ul>
&lt;li>对象实例&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>方法区：
&lt;ul>
&lt;li>已被JVM加载的类信息、常量、&lt;strong>静态变量&lt;/strong>、即时编译器编译后的代码等数据&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="自动装箱与拆箱">自动装箱与拆箱&lt;/h2>
&lt;p>自动装箱: 将基本数据类型转换为包装类型&lt;/p>
&lt;p>自动拆箱: 将包装类型转换为基本数据类型&lt;/p>
&lt;p>都是调用包装类型的valueOf方法和基本类型的xxxValue方法完成的&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="n">Integer&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">2&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// 装箱 调用了 Integer.valueOf(2)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// 拆箱 调用了 X.intValue()&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果频繁进行装箱和拆箱操作，会影响程序的性能.&lt;/p>
&lt;h3 id="装箱时使用的缓冲池">装箱时使用的缓冲池&lt;/h3>
&lt;p>new Integer(123) 与 Integer.valueOf(123) 的区别在于：&lt;/p>
&lt;ul>
&lt;li>new Integer(123) 每次都会新建一个对象；&lt;/li>
&lt;li>Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。&lt;/li>
&lt;/ul>
&lt;p>Java中的包装类型中，Integer、Byte、Short、Long、Character这几种包装类型默认会缓存-128到127之间的数值，这个区间的数值被缓存到了内部的缓冲池中，如果数值在这个区间内，就直接从缓冲池中获取对象，而不是重新创建一个新的对象。&lt;/p>
&lt;p>基本类型对应的缓冲池如下：&lt;/p>
&lt;p>boolean values true and false
all byte values
short values between -128 and 127
int values between -128 and 127
char in the range \u0000 to \u007F&lt;/p>
&lt;p>在使用这些基本类型对应的包装类型时，如果该数值范围在缓冲池范围内，就可以直接使用缓冲池中的对象。&lt;/p>
&lt;h4 id="integer-a--128b128两个相等吗">integer a = 128,b=128，两个相等吗&lt;/h4>
&lt;p>&lt;a href="https://blog.csdn.net/qq_42208194/article/details/117536553" target="_blank" rel="noopener">https://blog.csdn.net/qq_42208194/article/details/117536553&lt;/a>&lt;/p>
&lt;p>在Java中，对于Integer类型的对象，如果其值在-128到127之间，会被缓存到常量池中，因此当创建值在该范围内的Integer对象时，会直接从常量池中获取已有的对象。而对于值不在该范围内的Integer对象，则会创建新的对象。&lt;/p>
&lt;p>因此，对于Integer a = 128, b = 128，由于128不在-128到127之间，因此&lt;strong>会创建两个不同的Integer对象&lt;/strong>，即a和b不相等。&lt;/p>
&lt;p>而对于Integer a = 127, b = 127，由于127在-128到127之间，因此会从常量池中获取同一个Integer对象，即a和b相等。&lt;/p>
&lt;h3 id="自动拆箱引发的空指针异常">自动拆箱引发的空指针异常&lt;/h3>
&lt;p>自动拆箱会引发空指针异常，当包装类型为null时，调用其xxxValue方法会引发空指针异常。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="n">Integer&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// NullPointerException&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>三目运算符中隐含的自动拆箱可能引发空指针异常&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="n">Integer&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kc">false&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">?&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// NullPointerException&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c1">//正确写法 保持两者类型一致&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kc">false&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">?&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Integer&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">valueOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这是因为0是int类型，x会自动拆箱，而x为null，所以会引发空指针异常。&lt;/p>
&lt;blockquote>
&lt;p>阿里开发手册
【强制】三目运算符 condition?表达式1:表达式2中,高度注意表达式1和2在类型对产时，可能抛出因自动拆箱导致的 NPE 异常。说明:以下两种场景会触发类型对齐的拆箱操作:
1)表达式1或表达式2的值只要有一个是原始类型。
2)表达式1或表达式2的值的类型不一致，会强制拆箱升级成表示范围更大的那个类型&lt;/p>
&lt;/blockquote>
&lt;h2 id="高精度与大整数">高精度与大整数&lt;/h2>
&lt;h3 id="浮点数运算须使用bigdecimal">浮点数运算须使用BigDecimal&lt;/h3>
&lt;p>Java中的浮点数运算时会有精度丢失的问题，这是因为浮点数是用二进制表示的，而二进制无法精确表示某些十进制小数，比如0.1。&lt;/p>
&lt;p>而BigDecimal可以精确表示任意精度的十进制小数，因此在需要精确计算的场景下，应该使用BigDecimal来进行浮点数运算。&lt;/p>
&lt;h4 id="初始化">初始化&lt;/h4>
&lt;blockquote>
&lt;p>【强制】禁止使用构造方法 **BigDecimal(double)**的方式把 double 值转化为 BigDecimal 对象说明:BigDecimal(double)存在精度损失风险，在精确计算或值比较的场景中可能会导致业务逻辑异常。&lt;/p>
&lt;/blockquote>
&lt;p>如:BigDecimalg=new BigDecimal(0.1F);
实际的存储值为:0.10000000149&lt;/p>
&lt;p>正例:&lt;strong>优先推荐入参为 String 的构造方法，或使用 BigDecimal的valueOf方法&lt;/strong>，此方法内部其实执行之Double的 toString,而 Double 的 toString 按 double 的实际能表达的精度对尾数进行了截断。&lt;/p>
&lt;p>BigDecimal recommend1 = new BigDecimal(&amp;ldquo;0.1&amp;rdquo;);
BigDecimal recommend2 = BigDecimal.valueOf(0.1);&lt;/p>
&lt;h4 id="比较">比较&lt;/h4>
&lt;p>【强制】BigDecimal 的大小比较，推荐使用 compareTo 方法，equals 方法是同时比较值和精度，与预期不一致。说明:&lt;strong>compareTo 方法是比较值，equals 方法是比较值和精度&lt;/strong>。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="n">BigDecimal&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">BigDecimal&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;1&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">BigDecimal&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">BigDecimal&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;1.0&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">equals&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">));&lt;/span>&lt;span class="c1">//false&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="超过long的数据应该用biginteger">超过Long的数据应该用BigInteger&lt;/h3>
&lt;p>超过Long导致的溢出问题&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">long&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Long&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">MAX_VALUE&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// -9223372036854775808&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">==&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Long&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">MIN_VALUE&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// true&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>BigInteger可以表示任意精度的整数，因此在需要表示超过Long的整数时，应该使用BigInteger。&lt;/p>
&lt;p>BigInteger内部是用int[]来存储数据的，因此可以表示任意精度的整数，但是由于是数组存储，因此在进行加减乘除等运算时，性能会比较差。&lt;/p>
&lt;h2 id="object">Object&lt;/h2>
&lt;p>Object是所有类的父类，因此任何类的对象都可以赋值给Object类型的变量。&lt;/p>
&lt;p>创建一个对象用什么运算符?对象实体与对象引用有何不同?new 运算符，new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（&lt;strong>对象引用存放在栈内存中&lt;/strong>）。&lt;/p>
&lt;p>一个对象引用可以指向 &lt;strong>0 个或 1 个&lt;/strong>对象
一个对象可以有 n 个引用指向它&lt;/p>
&lt;p>对象的相等和引用相等的区别：
对象的相等一般比较的是内存中存放的内容是否相等。引用相等一般比较的是他们指向的内存地址是否相等。&lt;/p>
&lt;h3 id="hashcode-和-equals">hashCode 和 equals&lt;/h3>
&lt;p>equals默认是 使用 ==
对于基本数据类型来说，== 比较的是值。
对于引用数据类型来说，== 比较的是对象的内存地址。&lt;/p>
&lt;p>所以String重写了equals，使其比较的是内容。&lt;/p>
&lt;p>hashCode() 定义在 JDK 的 Object 类中,Object 的 hashCode() 方法是本地方法
&lt;code>public native int hashCode();&lt;/code>&lt;/p>
&lt;p>是本地方法因此不是Java代码实现的，而是由底层C++代码实现的。JVM不开源.&lt;/p>
&lt;p>要遵循下面的规则
equals相等 -&amp;gt; hashCode相等
hashCode相等 -&amp;gt; equals不一定相等&lt;/p>
&lt;p>所以在重写equals方法的同时，也要重写hashCode方法。&lt;/p>
&lt;h2 id="string">String&lt;/h2>
&lt;p>String是不可变的，一旦创建就不能被修改。
String的不可变性是&lt;strong>通过final关键字&lt;/strong>实现的，因此String类是不可继承的。&lt;/p>
&lt;p>String的不可变性有以下好处：&lt;/p>
&lt;ul>
&lt;li>可以缓存hash值&lt;/li>
&lt;li>String Pool的实现是基于不可变性的&lt;/li>
&lt;li>安全性&lt;/li>
&lt;li>线程安全&lt;/li>
&lt;/ul>
&lt;p>StringBuffer和StringBuilder是可变的字符串，它们的实现是通过字符数组实现的。&lt;/p>
&lt;p>StringBuffer&lt;/p>
&lt;ul>
&lt;li>线程安全的&lt;/li>
&lt;li>所有方法都是同步的&lt;/li>
&lt;/ul>
&lt;p>StringBuilder&lt;/p>
&lt;ul>
&lt;li>非线程安全的&lt;/li>
&lt;li>所有方法都不是同步的&lt;/li>
&lt;/ul>
&lt;p>Java本身不支持运算符重载，但String的+和+=操作符是专门针对String的重载的。&lt;/p>
&lt;p>字符串的+=默认使用StringBuilder实现的，因此在循环中使用+=拼接字符串会产生大量的StringBuilder对象，可以&lt;strong>在循环外使用StringBuilder来优化&lt;/strong>。&lt;/p>
&lt;blockquote>
&lt;p>JDK9之后，String的+和+=操作符的实现已经不是通过StringBuilder来实现的，而是通过invoke dynamic指令来实现的，这样可以更好的优化字符串的拼接操作。
但也有常量折叠的优化，所以在编译时会自动将字符串拼接操作优化为常量。&lt;/p>
&lt;/blockquote>
&lt;p>Object的equals方法是比较的引用，而String的equals方法是比较的内容。&lt;/p>
&lt;p>String.intern() 是一个 Native 方法，它的作用是如果&lt;strong>字符串常量池&lt;/strong>中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/language/java/java%E5%9F%BA%E7%A1%80/%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/language/java/java%E5%9F%BA%E7%A1%80/%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7/</guid><description>&lt;h1 id="语法特性">语法特性&lt;/h1>
&lt;h2 id="异常">异常&lt;/h2>
&lt;h3 id="异常分类">异常分类&lt;/h3>
&lt;p>异常属于Java.lang包中的Throwable类的子类, 分为两种&lt;/p>
&lt;ul>
&lt;li>Error
&lt;ul>
&lt;li>属于程序无法处理的错，OutOfMemoryError, IOError等&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Exception
&lt;ul>
&lt;li>属于程序可以处理的错误, 通过catch捕获,分为
&lt;ul>
&lt;li>受检异常
&lt;ul>
&lt;li>如果这些异常没用被catch或者throws, 编译器会报错&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>非受检异常: RuntimeException及其子类
&lt;ul>
&lt;li>NullPointerException(空指针异常)&lt;/li>
&lt;li>ArrayIndexOutOfBoundsException(数组越界异常)&lt;/li>
&lt;li>ClassCastException(类型转换异常)&lt;/li>
&lt;li>IllegalArgumentException(非法参数异常)&lt;/li>
&lt;li>NumberFormatException(数字格式异常)&lt;/li>
&lt;li>ArithmeticException(算术异常)&lt;/li>
&lt;li>IndexOutOfBoundsException(索引越界异常)&lt;/li>
&lt;li>ConcurrentModificationException(并发修改异常)&lt;/li>
&lt;li>UnsupportedOperationException(不支持的操作异常)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="异常处理机制">异常处理机制&lt;/h3>
&lt;p>try-catch-finally 和 try-with-resources&lt;/p>
&lt;ul>
&lt;li>try-catch-finally
&lt;ul>
&lt;li>try
&lt;ul>
&lt;li>包含可能抛出异常的代码&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>catch
&lt;ul>
&lt;li>捕获异常, 处理异常&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>finally
&lt;ul>
&lt;li>无论是否发生异常, 都会执行的代码块&lt;/li>
&lt;li>实际,如果cpu停止或者执行System.exit(0)方法, finally块不会执行&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>用Java 7之后的try-with-resources可以自动关闭资源, 例如文件流, 网络流, 数据库连接等,并且可以通过分号分隔多个资源&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="k">try&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">BufferedReader&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">br&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">BufferedReader&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">FileReader&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="p">));&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">BufferedWriter&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">bw&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">BufferedWriter&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">FileWriter&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="p">)))&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 读取文件&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">line&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">while&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="n">line&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">br&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">readLine&lt;/span>&lt;span class="p">())&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">!=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 写入文件&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">bw&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">write&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">line&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">catch&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">IOException&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">printStackTrace&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="泛型">泛型&lt;/h2>
&lt;p>三种使用方式: 泛型类、泛型接口、泛型方法&lt;/p>
&lt;h3 id="泛型类">泛型类&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">Generic&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">Generic&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">key&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">getKey&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="泛型接口">泛型接口&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">interface&lt;/span> &lt;span class="nc">Generator&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">next&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="泛型方法">泛型方法&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">static&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">E&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">printArray&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">E&lt;/span>&lt;span class="o">[]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">inputArray&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">for&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">E&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">element&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">inputArray&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">){&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;%s &amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">element&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c1">// 使用&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">Integer&lt;/span>&lt;span class="o">[]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">intArray&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">2&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">3&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">4&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">5&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">};&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">Character&lt;/span>&lt;span class="o">[]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">charArray&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sc">&amp;#39;H&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sc">&amp;#39;E&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sc">&amp;#39;L&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sc">&amp;#39;L&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sc">&amp;#39;O&amp;#39;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">};&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">printArray&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">intArray&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">printArray&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">charArray&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>项目中的泛型：&lt;/p>
&lt;ul>
&lt;li>接口返回值&lt;/li>
&lt;li>接口参数&lt;/li>
&lt;li>集合工具类&lt;/li>
&lt;/ul>
&lt;h3 id="泛型检查">泛型检查&lt;/h3>
&lt;p>一种编译时类型检查机制,它能确保在使用泛型类或者方法时,&lt;strong>传入的实际类型参数是正确的&lt;/strong>&lt;/p>
&lt;p>泛型擦除是指Java中的泛型只在编译期有效，在运行期间会被删除。也就是说所有泛型参数在编译后都会被清除掉。&lt;/p>
&lt;h2 id="反射">反射&lt;/h2>
&lt;p>反射是指程序在运行时能够获取自身的信息, 比如类的属性和方法, 并且可以调用类的方法和属性&lt;/p>
&lt;p>优点：&lt;/p>
&lt;ul>
&lt;li>为框架提供灵活性&lt;/li>
&lt;li>为IDE提供更好的编码体验&lt;/li>
&lt;/ul>
&lt;p>缺点：&lt;/p>
&lt;ul>
&lt;li>性能开销&lt;/li>
&lt;li>安全问题
&lt;ul>
&lt;li>反射可以&lt;strong>访问私有方法和属性&lt;/strong>&lt;/li>
&lt;li>反射可以&lt;strong>绕过泛型检查&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="反射的应用">反射的应用&lt;/h3>
&lt;ul>
&lt;li>动态代理&lt;/li>
&lt;li>注解&lt;/li>
&lt;/ul>
&lt;p>通过反射实现动态代理&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">ProxyHandler&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">implements&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">InvocationHandler&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Object&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">target&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">ProxyHandler&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Object&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">target&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">target&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">target&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nd">@Override&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Object&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">invoke&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Object&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">proxy&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Method&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">method&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Object&lt;/span>&lt;span class="o">[]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">args&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">throws&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Throwable&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;before&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">Object&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">result&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">method&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">invoke&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">target&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">args&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;after&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">result&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>注解的实现&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="nd">@Target&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ElementType&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">METHOD&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nd">@Retention&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">RetentionPolicy&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">RUNTIME&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nd">@interface&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">MyAnnotation&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">value&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">default&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;hello&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>解释:&lt;/p>
&lt;ul>
&lt;li>@Target(ElementType.METHOD) 表示注解可以用在方法上&lt;/li>
&lt;li>@Retention(RetentionPolicy.RUNTIME) 表示注解会在class字节码文件中存在, 并且可以通过反射获取到&lt;/li>
&lt;li>@interface 表示这是一个注解&lt;/li>
&lt;/ul>
&lt;h3 id="反射实战">反射实战&lt;/h3>
&lt;ol>
&lt;li>知道具体的类&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">Class&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">clazz&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">User&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="2">
&lt;li>通过类的全路径名&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="n">Class&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">clazz&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Class&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">forName&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;com.example.User&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="3">
&lt;li>通过对象实例&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="n">User&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">user&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">User&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">Class&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">clazz&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">user&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">getClass&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="4">
&lt;li>通过类加载器&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="n">ClassLoader&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">classLoader&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Thread&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">currentThread&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="na">getContextClassLoader&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">Class&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">clazz&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">classLoader&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">loadClass&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;com.example.User&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>具体的操作&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">class&lt;/span> &lt;span class="nc">User&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">age&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">sayHello&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Hello&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">Main&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">static&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">args&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">throws&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Exception&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">Class&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">clazz&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">User&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 获取类的属性&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">Field&lt;/span>&lt;span class="o">[]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">fields&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">clazz&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">getDeclaredFields&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">for&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Field&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">field&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">fields&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">field&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">getName&lt;/span>&lt;span class="p">());&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 使用指定属性&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">Field&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">field&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">clazz&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">getDeclaredField&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;name&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 修改属性的值&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">filed&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">setAccessible&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">filed&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">set&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">user&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;Tom&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 获取类的方法&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">Method&lt;/span>&lt;span class="o">[]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">methods&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">clazz&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">getDeclaredMethods&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">for&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Method&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">method&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">methods&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">method&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">getName&lt;/span>&lt;span class="p">());&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 使用指定方法&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">Method&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">method&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">clazz&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">getDeclaredMethod&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;sayHello&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 调用方法&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">method&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">invoke&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">user&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">//调用私有方法&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">Method&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">method&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">clazz&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">getDeclaredMethod&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;privateMethod&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">method&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">setAccessible&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">method&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">invoke&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">user&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 获取类的构造方法&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">Constructor&lt;/span>&lt;span class="o">[]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">constructors&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">clazz&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">getDeclaredConstructors&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">for&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Constructor&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">constructor&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">constructors&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">constructor&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">getName&lt;/span>&lt;span class="p">());&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="注解">注解&lt;/h2>
&lt;p>Annotation是一种标记, 可以在类, 方法, 字段, 参数等上使用, 用于提供信息给编译器, 代码分析工具或者运行时的处理器&lt;/p>
&lt;h3 id="内置注解">内置注解&lt;/h3>
&lt;ul>
&lt;li>@Override
&lt;ul>
&lt;li>用于标记方法重写&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>@Deprecated
&lt;ul>
&lt;li>用于标记方法或类已经过时&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="自定义注解">自定义注解&lt;/h3>
&lt;p>本质是继承了Annotation接口的接口, 并且可以添加属性&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="nd">@Target&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ElementType&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">METHOD&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nd">@Retention&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">RetentionPolicy&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">SOURCE&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nd">@interface&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">MyAnnotation&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">value&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">default&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;hello&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="注解的应用">注解的应用&lt;/h3>
&lt;p>主要分为两种解析方式&lt;/p>
&lt;ul>
&lt;li>编译时注解
&lt;ul>
&lt;li>通过注解处理器在编译时处理注解&lt;/li>
&lt;li>例如lombok, @Override, @Deprecated&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>运行时注解
&lt;ul>
&lt;li>通过反射在运行时处理注解&lt;/li>
&lt;li>例如Spring的@Service, @Autowired, @RequestMapping&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="spi">SPI&lt;/h2>
&lt;p>SPI(Service Provider Interface)是一种服务发现机制, 它通过在ClassPath路径下的META-INF/services文件夹查找文件, 自动加载文件里所定义的类&lt;/p>
&lt;p>SPI与API的区别&lt;/p>
&lt;ul>
&lt;li>API是应用程序接口, 是一种约定, 由开发者来实现&lt;/li>
&lt;li>SPI是服务提供接口, 是一种约定, 由服务提供者来实现&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e8%af%ad%e6%b3%95%e7%89%b9%e6%80%a7/SPI%20vs%20API.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>SPI的优缺点&lt;/p>
&lt;ul>
&lt;li>优点
&lt;ul>
&lt;li>松耦合&lt;/li>
&lt;li>可扩展&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>缺点
&lt;ul>
&lt;li>不能按需加载, 无法动态添加或删除实现类&lt;/li>
&lt;li>无法动态修改实现类的优先级&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="spi实战">SPI实战&lt;/h3>
&lt;p>&lt;a href="https://javaguide.cn/java/basis/spi.html#%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA" target="_blank" rel="noopener">参考&lt;/a>&lt;/p>
&lt;ol>
&lt;li>定义接口&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">interface&lt;/span> &lt;span class="nc">HelloService&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">sayHello&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="2">
&lt;li>实现接口&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">HelloServiceImpl1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">implements&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">HelloService&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nd">@Override&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">sayHello&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Hello1&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">HelloServiceImpl2&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">implements&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">HelloService&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nd">@Override&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">sayHello&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Hello2&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="3">
&lt;li>在META-INF/services文件夹下创建文件&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="n">com&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">example&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">HelloServiceImpl1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">com&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">example&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">HelloServiceImpl2&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="4">
&lt;li>加载实现类&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">Main&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">static&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">args&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">ServiceLoader&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">HelloService&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">serviceLoader&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ServiceLoader&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">load&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">HelloService&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">for&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">HelloService&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">helloService&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">serviceLoader&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">helloService&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">sayHello&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="序列化和反序列化">序列化和反序列化&lt;/h2>
&lt;p>序列化: 将对象转换为字节序列的过程
反序列化: 将字节序列转换为对象的过程&lt;/p>
&lt;h3 id="序列化的场景">序列化的场景&lt;/h3>
&lt;ul>
&lt;li>网络传输
&lt;ul>
&lt;li>远程调用&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>持久化存储
&lt;ul>
&lt;li>文件&lt;/li>
&lt;li>数据库&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>缓存&lt;/li>
&lt;/ul>
&lt;p>对应OSI七层模型中的应用层和表示层&lt;/p>
&lt;h3 id="序列化的实现">序列化的实现&lt;/h3>
&lt;h4 id="自带的序列化方式">自带的序列化方式&lt;/h4>
&lt;ul>
&lt;li>Java原生序列化
&lt;ul>
&lt;li>实现Serializable接口&lt;/li>
&lt;li>通过ObjectOutputStream和ObjectInputStream实现序列化和反序列化&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">User&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">implements&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Serializable&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">age&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">transient&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">password&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>serialVersionUID是用来验证版本一致性的, 如果不指定, 编译器会自动生成, 但是如果类的定义发生变化, 会导致serialVersionUID变化, 从而导致反序列化失败&lt;/p>
&lt;p>不想被序列化的字段可以使用transient关键字修饰
注意:&lt;/p>
&lt;ul>
&lt;li>静态变量没有transient修饰符, 也不会被序列化&lt;/li>
&lt;li>transient只能修饰变量, 不能修饰类和方法&lt;/li>
&lt;li>transient变量被序列化后会被赋予默认值&lt;/li>
&lt;/ul>
&lt;p>不推荐使用原生序列化, 因为&lt;/p>
&lt;ul>
&lt;li>性能差
&lt;ul>
&lt;li>序列化和反序列化的性能差&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>不支持跨语言
&lt;ul>
&lt;li>Java原生序列化是Java特有的, 不支持跨语言&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>不安全
&lt;ul>
&lt;li>反序列化会导致安全问题&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="第三方序列化方式">第三方序列化方式&lt;/h4>
&lt;p>Kryo&lt;/p>
&lt;p>Protobuf&lt;/p>
&lt;p>ProtoStuff&lt;/p>
&lt;h2 id="语法糖">语法糖&lt;/h2>
&lt;p>语法糖是指在编程语言中, 不影响语言功能和性能的情况下, 为程序员提供的更方便的语法&lt;/p>
&lt;p>语法糖被正确执行需要编译器的支持, JVM不能直接执行语法糖.
如,在com.sun.tools.javac.main.JavaCompiler中,有一个方法,public void compile(List&lt;JavaFileObject> compilationUnits),这个方法里有一个步骤是desugar,这个步骤就是将语法糖转换为普通的语法&lt;/p>
&lt;h3 id="常见的语法糖">常见的语法糖&lt;/h3>
&lt;ul>
&lt;li>自动装箱和拆箱
&lt;ul>
&lt;li>Integer i = 1; // 自动装箱&lt;/li>
&lt;li>int j = i; // 自动拆箱&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>泛型
&lt;ul>
&lt;li>List&lt;String> list = new ArrayList&amp;lt;&amp;gt;();&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>foreach
&lt;ul>
&lt;li>for (String s : list) {}&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>变长参数
&lt;ul>
&lt;li>public void test(String&amp;hellip; args) {}&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>枚举
&lt;ul>
&lt;li>enum Color {RED, GREEN, BLUE}&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>try-with-resources
&lt;ul>
&lt;li>try (BufferedReader br = new BufferedReader&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Lambda
&lt;ul>
&lt;li>(a, b) -&amp;gt; a + b&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title/><link>https://ysyyhhh.github.io/docs/language/java/java%E5%9F%BA%E7%A1%80/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/language/java/java%E5%9F%BA%E7%A1%80/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</guid><description>&lt;h1 id="面向对象">面向对象&lt;/h1>
&lt;h2 id="面向对象的特征">面向对象的特征&lt;/h2>
&lt;ul>
&lt;li>封装&lt;/li>
&lt;li>继承&lt;/li>
&lt;li>多态&lt;/li>
&lt;/ul>
&lt;h2 id="接口和抽象类的区别">接口和抽象类的区别&lt;/h2>
&lt;ul>
&lt;li>抽象类是对类的抽象，接口是对行为的抽象&lt;/li>
&lt;/ul>
&lt;p>类可以实现多个接口，但只能继承一个抽象类&lt;/p>
&lt;h2 id="深拷贝浅拷贝引用拷贝">深拷贝，浅拷贝，引用拷贝&lt;/h2>
&lt;ul>
&lt;li>浅拷贝：在堆上创建一个新的对象，但是只是复制了对象的引用，对象的内容并没有复制，所以新对象和原对象的内容是一样的&lt;/li>
&lt;li>深拷贝：在堆上创建一个新的对象，同时复制了对象的内容，所以新对象和原对象的内容是不一样的&lt;/li>
&lt;li>引用拷贝：不会创建新的对象，只是复制了对象的引用，所以新对象和原对象的内容是一样的&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1/%e4%b8%89%e7%a7%8d%e6%8b%b7%e8%b4%9d%e7%9a%84%e5%85%b3%e7%b3%bb.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。
如果属性是基本类型，&lt;strong>拷贝的就是基本类型的值&lt;/strong>；如果属性是内存地址（引用类型），&lt;strong>拷贝的就是内存地址&lt;/strong> ，因此如果其中一个对象对这个地址的对象进行修改，会影响到另一个对象。&lt;/p>
&lt;p>深拷贝是在堆内存中重新分配内存，拷贝对象，而不是对象的引用。因此，即使原始对象改变了，深拷贝的对象也不会改变。&lt;/p>
&lt;p>浅拷贝和引用拷贝的区别:&lt;/p>
&lt;ul>
&lt;li>浅拷贝是创建一个新对象，然后将当前对象的非静态字段复制到新对象中，如果字段是值类型的，那么对该字段执行复制；如果字段是引用类型的，那么复制的是引用，因此新对象和原对象的字段引用的是同一个对象&lt;/li>
&lt;/ul>
&lt;h2 id="object类">Object类&lt;/h2>
&lt;p>Object是所有类的父类，因此任何类的对象都可以赋值给Object类型的变量。&lt;/p>
&lt;h3 id="object的方法">Object的方法&lt;/h3>
&lt;ul>
&lt;li>&lt;code>equals&lt;/code>：比较的是内容&lt;/li>
&lt;li>&lt;code>hashCode&lt;/code>：返回对象的哈希码值&lt;/li>
&lt;/ul></description></item><item><title/><link>https://ysyyhhh.github.io/docs/language/java/java%E9%9B%86%E5%90%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/language/java/java%E9%9B%86%E5%90%88/</guid><description>&lt;h1 id="java集合体系">Java集合体系&lt;/h1>
&lt;p>Java 集合， 也叫作容器，主要是由两大接口派生而来：一个是 Collection接口，主要用于存放单一元素；另一个是 Map 接口，主要用于存放键值对。对于Collection 接口，下面又有三个主要的子接口：List、Set 和 Queue。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Java%e9%9b%86%e5%90%88/Java%e9%9b%86%e5%90%88%e7%9a%84%e7%bb%93%e6%9e%84.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>List: 有序，可重复&lt;/p>
&lt;ul>
&lt;li>ArrayList: Object[] 数组, 查询快, 增删慢&lt;/li>
&lt;li>Vector: Object[] 数组, 线程安全(与ArrayList区别)&lt;/li>
&lt;li>LinkedList: 双向链表, 查询慢, 增删快&lt;/li>
&lt;/ul>
&lt;p>Set: 元素不可重复&lt;/p>
&lt;ul>
&lt;li>HashSet: 基于HashMap实现, 无序&lt;/li>
&lt;li>TreeSet: 红黑树(自平衡的二叉查找树), 有序&lt;/li>
&lt;li>LinkedHashSet: 基于LinkedHashMap实现, 是HashSet的子类, 有序&lt;/li>
&lt;/ul>
&lt;p>Queue: 有序，可重复, 用于存放队列元素&lt;/p>
&lt;ul>
&lt;li>PriorityQueue: 优先级队列, Object[] 数组&lt;/li>
&lt;li>DelayQueue: 延迟队列, 用于存放延迟元素&lt;/li>
&lt;li>ArrayDeque: 双端队列, Object[] 数组&lt;/li>
&lt;/ul>
&lt;p>Map: 无序，不可重复，键值对&lt;/p>
&lt;ul>
&lt;li>HashMap: JDK1.8之前是数组+链表, JDK1.8之后是数组+链表/红黑树&lt;/li>
&lt;li>LinkedHashMap: 基于HashMap实现, 有序&lt;/li>
&lt;li>TreeMap: 红黑树(自平衡的二叉查找树), 有序&lt;/li>
&lt;li>HashTable: 数组(主体)+链表(解决哈希冲突), 线程安全&lt;/li>
&lt;/ul>
&lt;p>如何选用集合&lt;/p>
&lt;ul>
&lt;li>要键值对 - Map
&lt;ul>
&lt;li>需要排序 - TreeMap&lt;/li>
&lt;li>不需要排序 - HashMap&lt;/li>
&lt;li>需要线程安全 - HashTable&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>不需要键值对 - Collection
&lt;ul>
&lt;li>保证元素唯一 - Set
&lt;ul>
&lt;li>需要排序 - TreeSet&lt;/li>
&lt;li>不需要排序 - HashSet&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>允许重复元素 - List
&lt;ul>
&lt;li>需要高效的增删 - LinkedList&lt;/li>
&lt;li>需要高效的查询 - ArrayList&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="list">List&lt;/h2>
&lt;p>ArrayList 与 Array比较&lt;/p>
&lt;ul>
&lt;li>ArrayList是数组的封装，可以动态扩容，而数组是静态的&lt;/li>
&lt;li>ArrayList允许使用泛型&lt;/li>
&lt;/ul>
&lt;p>ArrayList 与 Vector比较&lt;/p>
&lt;ul>
&lt;li>ArrayList是非线程安全的，而Vector是线程安全的&lt;/li>
&lt;li>ArrayList是JDK1.2引入的(主要实现类,新)，而Vector是JDK1.0引入的&lt;/li>
&lt;/ul>
&lt;p>ArrayList&lt;/p>
&lt;ul>
&lt;li>底层是数组,支持随机访问&lt;/li>
&lt;li>可以添加null元素&lt;/li>
&lt;li>插入:
&lt;ul>
&lt;li>头部插入: O(n)&lt;/li>
&lt;li>尾部插入: O(1), 扩容时O(n),每次扩容是原来的1.5倍&lt;/li>
&lt;li>指定位置插入: O(n)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>删除:
&lt;ul>
&lt;li>只有尾部删除是O(1), 其他都是O(n)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>LinkedList&lt;/p>
&lt;ul>
&lt;li>底层是双向链表, 不支持随机访问&lt;/li>
&lt;li>头部和尾部的插入删除都是O(1)&lt;/li>
&lt;li>一般不使用,作者都不使用&lt;/li>
&lt;/ul>
&lt;h3 id="arraylist">ArrayList&lt;/h3>
&lt;p>底层是动态数组&lt;/p>
&lt;h4 id="声明arraylistjava语言会做什么操作">声明arraylist，java语言会做什么操作&lt;/h4>
&lt;p>A:声明ArrayList时，Java会创建一个长度为0的数组，当第一次添加元素时，会创建一个长度为10的数组，并将元素添加到数组中。当数组长度不够时，会创建一个原数组长度的1.5倍的新数组，并将原数组中的元素复制到新数组中。&lt;/p>
&lt;h4 id="arraylist什么时候扩容">arraylist什么时候扩容&lt;/h4>
&lt;p>A:ArrayList在添加元素时，会先判断当前数组的容量是否足够，如果不够则会进行扩容。扩容时，会创建一个原数组长度的1.5倍的新数组，并将原数组中的元素复制到新数组中。&lt;/p>
&lt;h4 id="arraylist是线程安全的吗">arraylist是线程安全的吗&lt;/h4>
&lt;p>A:ArrayList是非线程安全的，如果需要在多线程环境下使用ArrayList，可以使用Collections.synchronizedList()方法将ArrayList转换为线程安全的List。&lt;/p>
&lt;h4 id="线程安全的list有哪些">线程安全的list有哪些&lt;/h4>
&lt;p>A:线程安全的List有Vector和Collections.synchronizedList()方法转换的List。Vector是一种线程安全的List实现，而Collections.synchronizedList()方法可以将ArrayList转换为线程安全的List。&lt;/p>
&lt;h3 id="vector">Vector&lt;/h3>
&lt;p>Vector的底层&lt;/p>
&lt;p>为其所有需要保证线程安全的方法都添加了&lt;strong>synchronized关键字&lt;/strong>，锁住了整个对象&lt;/p>
&lt;h2 id="set">Set&lt;/h2>
&lt;p>对集合进行排序时,需要实现Comparable接口,重写compareTo方法&lt;/p>
&lt;p>集合的不可重复性是通过equals方法来判断的, 需要重写equals方法和hashCode方法&lt;/p>
&lt;h4 id="hashset了解过吗">hashset了解过吗&lt;/h4>
&lt;p>HashSet是一种基于哈希表的Set实现，其底层实现与HashMap类似，只不过HashSet中存储的是不重复的元素。HashSet中的元素是无序的，不保证元素的插入顺序和遍历顺序一致。&lt;/p>
&lt;h4 id="判断某对象是否在set中存在需要重写哪些方法">判断某对象是否在set中存在，需要重写哪些方法&lt;/h4>
&lt;p>为了判断某个对象是否在Set中存在，需要重写该对象的hashCode()和equals()方法。hashCode()方法用于计算对象的哈希值，equals()方法用于比较两个对象是否相等。在重写这两个方法时，需要保证相等的对象具有相同的哈希值，否则会导致Set中出现重复元素。&lt;/p>
&lt;h2 id="queue">Queue&lt;/h2>
&lt;p>ArrayDeque 和 LinkedList的区别&lt;/p>
&lt;ul>
&lt;li>都实现了Deque接口&lt;/li>
&lt;li>ArrayDeque是数组实现的双端队列, 随机访问快, 队列操作慢；LinkedList是双向链表实现的双端队列, 队列操作快&lt;/li>
&lt;li>ArrayDeque不支持null元素, LinkedList支持&lt;/li>
&lt;li>ArrayDeque存在扩容，但均摊快；LinkedList不存在，每次插入需要申请空间，均摊慢。&lt;/li>
&lt;/ul>
&lt;h3 id="priorityqueue">PriorityQueue&lt;/h3>
&lt;p>JDK1.5 引入的&lt;/p>
&lt;ul>
&lt;li>底层是堆, 默认是小顶堆, 可以通过传入Comparator来实现大顶堆&lt;/li>
&lt;li>是插入删除是O(logn)，查顶推是O(1)&lt;/li>
&lt;li>是非线程安全的，不支持null元素&lt;/li>
&lt;/ul>
&lt;p>典型算法题的应用&lt;/p>
&lt;ul>
&lt;li>推排序&lt;/li>
&lt;li>第k大数（不过这个一般用快排O(n)实现）&lt;/li>
&lt;li>带权图的遍历&lt;/li>
&lt;/ul>
&lt;h3 id="blockingqueue-阻塞队列">BlockingQueue 阻塞队列&lt;/h3>
&lt;p>是一个接口，继承于Queue。&lt;/p>
&lt;p>阻塞的原因是，支持当队列没用元素时一直阻塞，直到有元素。
如果队列已满，则等到队列有空间时再插入元素。&lt;/p>
&lt;p>常用于生产者消费者模型。&lt;/p>
&lt;h2 id="map">Map**&lt;/h2>
&lt;h3 id="hashmap">HashMap&lt;/h3>
&lt;p>HashMap 和 HashTable的区别&lt;/p>
&lt;ul>
&lt;li>HashMap是非线程安全的，而HashTable是线程安全的&lt;/li>
&lt;li>HashMap允许使用null作为键和值，而HashTable不允许&lt;/li>
&lt;li>效率：HashMap效率高，HashTable效率低&lt;/li>
&lt;li>容量大小：HashMap默认大小为16，HashTable默认大小为11&lt;/li>
&lt;li>扩容：HashMap扩容是原来的2倍，HashTable扩容是原来的2倍+1&lt;/li>
&lt;li>底层数据结构：HashMap是数组+链表/红黑树，HashTable是数组+链表
&lt;ul>
&lt;li>JDK1.8 HashMap在链表长度超过8时，链表会自动转化为红黑树，优化查询速度&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>HashMap 和 TreeMap的区别&lt;/p>
&lt;ul>
&lt;li>HashMap是无序的，而TreeMap是有序的&lt;/li>
&lt;/ul>
&lt;h4 id="hashmap原理">HashMap原理&lt;/h4>
&lt;p>HashMap是一种基于哈希表的Map实现，其底层实现主要包括数组和链表（或红黑树）两部分。数组用来存储哈希桶，链表（或红黑树）用来解决哈希冲突。&lt;/p>
&lt;p>数组+链表+红黑树。&lt;/p>
&lt;p>那么在jdk1.8的HashMap中，当链表的&lt;strong>长度超过8&lt;/strong>时，链表会自动转化为红黑树，优化查询速度。&lt;/p>
&lt;p>jdk1.8之前插入链表是头插法，jdk1.8之后是尾插法。&lt;/p>
&lt;p>头插法：效率高、满足时间局部性原理&lt;/p>
&lt;ul>
&lt;li>但在扩容后可能会导致链表逆序，影响查询效率。&lt;/li>
&lt;li>扩容时可能会导致死循环（多线程场景下，跟链表逆序有关）&lt;/li>
&lt;/ul>
&lt;p>put原理&lt;/p>
&lt;p>同时还有一个区别：发生“hash冲突”时，我们上面的做法是“头插法”，这是jdk1.7的做法，而在jdk1.8中，使用的是“尾插法”。&lt;/p>
&lt;h4 id="hash冲突解决方案">hash冲突解决方案&lt;/h4>
&lt;ul>
&lt;li>开放定址法
&lt;ul>
&lt;li>线性探测法&lt;/li>
&lt;li>二次探测法&lt;/li>
&lt;li>伪随机&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>链地址法
&lt;ul>
&lt;li>相同的hash值的元素，用链表存储&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>再哈希法
&lt;ul>
&lt;li>提供多个hash函数&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>建立公共溢出区
&lt;ul>
&lt;li>将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。&lt;/li>
&lt;li>在查找的时候，先与哈希表的相应位置比较，如果查找成功，则返回。否则去公共溢出区按顺序一一查找。在冲突数据少时性能好，冲突数据多的时候耗时。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="hashmap底层实现">hashmap底层实现&lt;/h4>
&lt;p>HashMap是一种基于哈希表的Map实现，其底层实现主要包括数组和链表（或红黑树）两部分。数组用来存储哈希桶，链表（或红黑树）用来解决哈希冲突。&lt;/p>
&lt;p>一般情况下，当元素数量超过阈值时便会触发扩容。每次扩容的容量都是之前容量的2倍。&lt;/p>
&lt;p>具体来说，HashMap中的每个元素都是一个键值对，其中键和值都可以为null。当向HashMap中添加元素时，首先根据键的哈希值计算出该元素在数组中的位置，如果该位置上已经有元素了，则需要使用链表（或红黑树）来解决哈希冲突。如果链表（或红黑树）中已经存在该键，则更新该键对应的值，否则将该键值对添加到链表（或红黑树）的末尾。&lt;/p>
&lt;p>当链表（或红黑树）的长度超过一定阈值时，链表（或红黑树）会被转换为红黑树（或链表），以提高查询效率。当链表（或红黑树）的长度小于等于6时，会使用链表来存储元素，当长度大于6时，会使用红黑树来存储元素。&lt;/p>
&lt;p>在HashMap中，数组的长度是2的幂次方，这是为了使哈希值的高位和低位都能够参与到计算中，提高哈希值的均匀性。同时，数组的长度也决定了HashMap中哈希桶的数量，当哈希桶的数量过少时，容易导致哈希冲突，影响查询效率；当哈希桶的数量过多时，会浪费内存空间。因此，在创建HashMap时，需要根据实际情况来选择合适的数组长度。&lt;/p>
&lt;h4 id="hashmap17和18区别">hashmap1.7和1.8区别&lt;/h4>
&lt;p>HashMap1.7和1.8的主要区别在于底层实现方式的改变。1.7中使用的是数组+链表的方式来解决哈希冲突，而1.8中引入了红黑树来优化链表过长的情况，提高了查询效率。此外，1.8中还引入了一些新的方法和特性，如forEach()方法、Lambda表达式等。&lt;/p>
&lt;h4 id="hashmap怎么让他线程安全的方法">hashmap怎么让他线程安全的方法&lt;/h4>
&lt;p>线程安全的map有哪些&lt;/p>
&lt;p>HashMap本身是非线程安全的，如果需要在多线程环境下使用HashMap，可以使用以下几种方法来保证线程安全：&lt;/p>
&lt;ol>
&lt;li>使用Collections.synchronizedMap()方法将HashMap转换为线程安全的Map。&lt;/li>
&lt;li>使用ConcurrentHashMap代替HashMap，ConcurrentHashMap是一种线程安全的Map实现。&lt;/li>
&lt;li>使用读写锁来保证HashMap的线程安全性，即使用ReentrantReadWriteLock来控制读写操作的并发访问。&lt;/li>
&lt;/ol>
&lt;h3 id="hashtable">HashTable&lt;/h3>
&lt;p>Hashtable与Vector类似，都是为每个方法添加了synchronized关键字，来实现的线程安全，锁住了整个对象。Hashtable是一个线程安全的集合,是单线程集合，它给几乎所有public方法都加上了synchronized关键字。&lt;/p>
&lt;h3 id="concurrenthashmap">ConcurrentHashMap&lt;/h3>
&lt;h4 id="concurrenthashmap原理">ConcurrentHashMap原理**&lt;/h4>
&lt;p>在 JDK 1.7 中它使用的是数组加链表的形式实现的，而数组又分为：大数组 Segment 和小数组 HashEntry
Segment 本身是基于 ReentrantLock 实现的加锁和释放锁的操作，这样就能保证多个线程同时访问 ConcurrentHashMap 时，同一时间只有一个线程能操作相应的节点，这样就保证了 ConcurrentHashMap 的线程安全了。&lt;/p>
&lt;p>分段锁的缺点是：在高并发的情况下，会出现大量线程阻塞，导致性能下降。&lt;/p>
&lt;p>JDK1.7之后
使用的是 CAS + volatile 或 synchronized 的方式来保证线程安全的
ConcurrentHashMap 已经摒弃了 Segment 的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。&lt;/p>
&lt;p>在 JDK 1.8 中，添加元素时首先会判断&lt;/p>
&lt;ul>
&lt;li>&lt;strong>容器是否为空，如果为空则使用 volatile 加 CAS 来初始化&lt;/strong>。&lt;/li>
&lt;li>如果容器不为空则根据存储的元素计算该位置是否为空
&lt;ul>
&lt;li>如果为空则利用 CAS 设置该节点；&lt;/li>
&lt;li>&lt;strong>如果不为空则使用 synchronize 加锁&lt;/strong>，遍历桶中的数据，替换或新增节点到桶中，最后再判断是否需要转为红黑树，这样就能保证并发访问时的线程安全了。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>我们把上述流程简化一下，我们可以简单的认为在 JDK 1.8 中，ConcurrentHashMap 是在头节点加锁来保证线程安全的，锁的粒度相比 Segment 来说更小了，发生冲突和加锁的频率降低了，并发操作的性能就提高了。而且 JDK 1.8 使用的是红黑树优化了之前的固定链表，那么当数据量比较大的时候，查询性能也得到了很大的提升，从之前的 O(n) 优化到了 O(logn) 的时间复杂&lt;/p>
&lt;p>13、concurrenthashmap最耗时的操作是什么
A: ConcurrentHashMap最耗时的操作是put操作，因为put操作需要保证线程安全，需要进行加锁操作，而加锁操作会影响并发性能。&lt;/p>
&lt;p>12、hashtable和concurrenthashmap的区别&lt;/p>
&lt;p>线程安全的类有哪些，为什么线程安全&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/language/java/jucjava%E5%B9%B6%E5%8F%91/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/language/java/jucjava%E5%B9%B6%E5%8F%91/</guid><description>&lt;h1 id="java-多线程">Java 多线程&lt;/h1>
&lt;h2 id="线程与进程">线程与进程&lt;/h2>
&lt;p>一个Java程序的运行是一个进程，包括一个main线程和多个其他线程&lt;/p>
&lt;p>Java的线程和操作系统的线程的区别&lt;/p>
&lt;ul>
&lt;li>JDK1.2之前使用的是JVM模拟的用户级线程，JDK1.2之后使用的是操作系统的内核级线程&lt;/li>
&lt;/ul>
&lt;p>用户级线程和内核级线程的区别&lt;/p>
&lt;ul>
&lt;li>用户线程：由用户空间程序管理和调度的线程，运行在用户空间（专门给应用程序使用）。&lt;/li>
&lt;li>内核线程：由操作系统内核管理和调度的线程，运行在内核空间（只有内核程序可以访问）。&lt;/li>
&lt;/ul>
&lt;p>线程模型是用户线程和内核线程之间的关联方式，常见的线程模型有这三种：&lt;/p>
&lt;ul>
&lt;li>一对一（一个用户线程对应一个内核线程）&lt;/li>
&lt;li>多对一（多个用户线程映射到一个内核线程）&lt;/li>
&lt;li>多对多（多个用户线程映射到多个内核线程）&lt;/li>
&lt;/ul>
&lt;p>Java采用的是一对一的线程模型，即一个用户线程对应一个内核线程。这种线程模型的优点是可以充分利用多核处理器的性能，缺点是创建和销毁线程的开销较大。&lt;/p>
&lt;p>JDK21正式引入了虚拟线程&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/JUC%28Java%E5%B9%B6%E5%8F%91%29/Java%E7%BA%BF%E7%A8%8B%E7%BB%93%E6%9E%84.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="java中没有协程">Java中没有协程&lt;/h3>
&lt;p>协程是多个协程对应一个内核线程的模型 协程是一种用户级的轻量级&amp;quot;线程&amp;quot;, 由程序员自己控制切换时机, 不需要操作系统内核介入。&lt;/p>
&lt;h3 id="为什么程序计数器虚拟机栈和本地方法栈是线程私有的呢">为什么程序计数器、虚拟机栈和本地方法栈是线程私有的呢？&lt;/h3>
&lt;p>程序计数器的功能：&lt;/p>
&lt;ul>
&lt;li>记录当前线程执行的字节码指令的地址，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。&lt;/li>
&lt;li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。&lt;/li>
&lt;/ul>
&lt;p>程序计数器是线程私有的，是为了线程切换时能够正确恢复执行现场。&lt;/p>
&lt;p>虚拟机栈&lt;/p>
&lt;ul>
&lt;li>每个线程在创建时都会创建一个虚拟机栈，用于存放线程的方法调用栈、局部变量表、操作数栈等信息。（执行的是Java方法）&lt;/li>
&lt;/ul>
&lt;p>本地方法栈&lt;/p>
&lt;ul>
&lt;li>用于支持本地方法调用，即调用C/C++编写的本地方法。&lt;/li>
&lt;/ul>
&lt;p>为了保证&lt;strong>线程的局部变量不被其他线程访问&lt;/strong>，虚拟机栈和本地方法栈是线程私有的。&lt;/p>
&lt;h3 id="为什么堆和方法区是线程共享的呢">为什么堆和方法区是线程共享的呢？&lt;/h3>
&lt;p>堆：是进程中所有线程共享的内存区域，用于存放对象实例。&lt;/p>
&lt;p>方法区：是进程中所有线程共享的内存区域，用于存放类的元数据信息、常量池、静态变量等。&lt;/p>
&lt;p>堆和方法区是线程共享的，是为了&lt;strong>方便线程之间共享数据&lt;/strong>。&lt;/p>
&lt;h3 id="并发并行同步异步">并发并行、同步异步&lt;/h3>
&lt;p>并发：指多个线程交替执行，从宏观上看是同时执行的。&lt;/p>
&lt;p>并行：指多个线程同时执行，从微观上看是同时执行的。&lt;/p>
&lt;p>同步：指多个线程按照一定的顺序执行。&lt;/p>
&lt;p>异步：指多个线程按照不确定的顺序执行。&lt;/p>
&lt;h2 id="多线程概念">多线程概念&lt;/h2>
&lt;h3 id="为什么要使用多线程">为什么要使用多线程？&lt;/h3>
&lt;p>多线程的主要优点有以下几点：&lt;/p>
&lt;ul>
&lt;li>线程间的切换开销小&lt;/li>
&lt;li>多线程高并发是高并发量的基础&lt;/li>
&lt;li>现在的CPU都是多核的，多线程可以充分利用CPU的性能&lt;/li>
&lt;/ul>
&lt;h3 id="多线程带来的问题">多线程带来的问题？&lt;/h3>
&lt;p>多线程的主要问题有以下几点：&lt;/p>
&lt;ul>
&lt;li>线程安全问题&lt;/li>
&lt;li>死锁问题&lt;/li>
&lt;li>内存泄漏问题&lt;/li>
&lt;/ul>
&lt;p>线程安全：&lt;/p>
&lt;ul>
&lt;li>线程安全是指多个线程访问共享资源时不会出现数据不一致的问题。&lt;/li>
&lt;/ul>
&lt;p>死锁：&lt;/p>
&lt;ul>
&lt;li>死锁是指两个或多个线程互相等待对方释放资源，导致所有线程都无法继续执行的问题。&lt;/li>
&lt;li>四个条件： 互斥条件、请求与保持条件、不剥夺条件、循环等待条件&lt;/li>
&lt;/ul>
&lt;p>内存泄漏：&lt;/p>
&lt;ul>
&lt;li>内存泄漏是指程序中的对象无法被垃圾回收器回收，导致内存占用过多的问题。&lt;/li>
&lt;/ul>
&lt;h3 id="单核上的多线程效率">单核上的多线程效率&lt;/h3>
&lt;p>单核上的多线程效率，取决于线程的类型&lt;/p>
&lt;ul>
&lt;li>CPU密集型线程：多线程效率不高，因为多个线程会争夺CPU资源，导致线程切换开销大。&lt;/li>
&lt;li>IO密集型线程：多线程效率较高，因为线程在等待IO时会释放CPU资源，不会争夺CPU资源。&lt;/li>
&lt;/ul>
&lt;h3 id="多线程的实现方式">多线程的实现方式&lt;/h3>
&lt;p>Java中实现多线程主要有两种方式：&lt;/p>
&lt;ol>
&lt;li>继承Thread类并重写run()方法。&lt;/li>
&lt;li>实现Runnable接口并实现run()方法，然后将其作为参数传递给Thread类的构造方法。&lt;/li>
&lt;li>实现Callable接口并实现call()方法，然后将其作为参数传递给FutureTask类的构造方法, 最后还是通过Thread来调用&lt;/li>
&lt;/ol>
&lt;p>严格来说，这两种都是实现Runnable接口的方式，只不过一种是直接继承Thread类，另一种是将Runnable接口的实现类作为参数传递给Thread类的构造方法。&lt;/p>
&lt;h4 id="实现runnable接口">实现Runnable接口&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">public class MyRunnable implements Runnable {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> @Override
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public void run() {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> System.out.println(&amp;#34;MyRunnable.run()&amp;#34;);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">public class Main {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public static void main(String[] args) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Thread thread = new Thread(new MyRunnable());
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> thread.start();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="继承thread类">继承Thread类&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-gdscript3" data-lang="gdscript3">&lt;span class="line">&lt;span class="cl">&lt;span class="n">public&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="n">MyThread&lt;/span> &lt;span class="k">extends&lt;/span> &lt;span class="ne">Thread&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">@&lt;/span>&lt;span class="n">Override&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">public&lt;/span> &lt;span class="n">void&lt;/span> &lt;span class="n">run&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;MyThread.run()&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">public&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="n">Main&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">public&lt;/span> &lt;span class="k">static&lt;/span> &lt;span class="n">void&lt;/span> &lt;span class="n">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="ne">String&lt;/span>&lt;span class="p">[]&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">MyThread&lt;/span> &lt;span class="n">myThread&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">new&lt;/span> &lt;span class="n">MyThread&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">myThread&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">start&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="实现callable接口">实现Callable接口&lt;/h4>
&lt;p>可以有返回值&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">public class MyCallable implements Callable&amp;lt;String&amp;gt; {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> @Override
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public String call() throws Exception {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> return &amp;#34;return value&amp;#34;;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">public class Main {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public static void main(String[] args) throws ExecutionException, InterruptedException {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> FutureTask&amp;lt;String&amp;gt; futureTask = new FutureTask&amp;lt;&amp;gt;(new MyCallable());
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Thread thread = new Thread(futureTask);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> thread.start();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> System.out.println(futureTask.get()); //阻塞 return value
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="实现接口-vs-继承类">实现接口 vs 继承类&lt;/h4>
&lt;p>实现接口的方式更加灵活，因为Java是单继承的，如果继承了Thread类就不能再继承其他类了。&lt;/p>
&lt;p>类一般只要求可执行就行, 继承了Thread类, 会有一些额外的方法, 比如start, stop等, 但是一般不会用到.&lt;/p>
&lt;h2 id="线程的生命周期和状态">线程的生命周期和状态&lt;/h2>
&lt;p>线程的生命周期主要包括以下几个状态：&lt;/p>
&lt;ul>
&lt;li>新建状态（New）：线程对象被创建后的状态, 还没有调用start()方法。&lt;/li>
&lt;li>运行状态（Runable）：线程对象调用start()方法后的状态。&lt;/li>
&lt;li>阻塞状态（Blocking）：需要等待锁被释放&lt;/li>
&lt;li>无限期等待状态（Waiting）：等待其它线程显式地唤醒&lt;/li>
&lt;li>超时等待状态 (TIME_WAITING) ：等待一段时间后自动唤醒&lt;/li>
&lt;li>终止状态（Terminated）：表示该线程已经运行完毕。&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/JUC%28Java%E5%B9%B6%E5%8F%91%29/Java%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="上下文切换">上下文切换&lt;/h3>
&lt;p>上下文切换是指CPU从一个线程切换到另一个线程时，需要保存当前线程的上下文信息，然后加载另一个线程的上下文信息。&lt;/p>
&lt;p>发生上下文切换的原因主要有以下几点：&lt;/p>
&lt;ul>
&lt;li>时间片耗尽&lt;/li>
&lt;li>调用阻塞类型的中断，如请求IO、sleep、wait、join等&lt;/li>
&lt;li>被终止&lt;/li>
&lt;/ul>
&lt;p>上下文切换的开销主要包括以下几个方面：&lt;/p>
&lt;ul>
&lt;li>保存和恢复寄存器&lt;/li>
&lt;li>保存和恢复程序计数器&lt;/li>
&lt;li>保存和恢复内存映射表&lt;/li>
&lt;/ul>
&lt;h3 id="线程死锁">线程死锁&lt;/h3>
&lt;p>四个条件： 互斥条件、请求与保持条件、不剥夺条件、循环等待条件&lt;/p>
&lt;h4 id="预防和避免">预防和避免&lt;/h4>
&lt;p>预防死锁是破坏死锁的后三个条件。&lt;/p>
&lt;ul>
&lt;li>破坏请求与保持条件：一次性申请所有资源。&lt;/li>
&lt;li>破坏不剥夺条件：如果一个线程申请不到资源，就释放已经占有的资源。&lt;/li>
&lt;li>破坏循环等待条件：按序申请资源。&lt;/li>
&lt;/ul>
&lt;p>避免死锁是通过银行家算法来实现的。&lt;/p>
&lt;ul>
&lt;li>银行家算法是一种避免死锁的算法，它通过判断系统是否处于安全状态来避免死锁。&lt;/li>
&lt;li>银行家算法的核心思想是：当一个进程申请资源时，系统会先判断该进程申请资源后系统是否处于安全状态，如果是则分配资源，否则等待。&lt;/li>
&lt;/ul>
&lt;h2 id="jmm">JMM&lt;/h2>
&lt;p>JMM是Java内存模型的缩写，是一种抽象的概念，用于描述Java程序中的内存访问规则。&lt;/p>
&lt;p>定义了一个线程之间如何通过内存进行通信的规范，即线程之间如何访问共享内存。&lt;/p>
&lt;p>JMM是Java解决多线程并发问题的核心，它定义了一套规范，用于保证多线程环境下的内存可见性、原子性和有序性。&lt;/p>
&lt;h3 id="jmm概念cpu缓存模型和指令重排序">JMM概念(CPU缓存模型和指令重排序)&lt;/h3>
&lt;h4 id="cpu缓存">CPU缓存&lt;/h4>
&lt;p>CPU 缓存是为了解决 CPU 处理速度和内存处理速度不对等的问题。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/JUC%28Java%E5%B9%B6%E5%8F%91%29/CPU%E7%BC%93%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>CPU Cache 的工作方式： 先复制一份数据到 CPU Cache 中，当 CPU 需要用到的时候就可以&lt;strong>直接从 CPU Cache 中读取数据&lt;/strong>，当运算完成后，再将运算得到的数据写回 Main Memory 中。&lt;/p>
&lt;p>CPU内部缓存不一致的解决 是通过&lt;strong>缓存一致性协议&lt;/strong>来解决的。&lt;/p>
&lt;p>常见的CPU内部缓存一致性协议主要有以下几种:&lt;/p>
&lt;ol>
&lt;li>&lt;strong>MESI协议&lt;/strong>:
&lt;ul>
&lt;li>该协议定义了四种缓存行状态：Modified(已修改)、Exclusive(独占)、Shared(共享)和Invalid(无效)。&lt;/li>
&lt;li>当一个CPU读取或修改缓存行时,会通过总线事务与其他CPU进行协调,以维护缓存一致性。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>MOESI协议&lt;/strong>:
&lt;ul>
&lt;li>在MESI协议的基础上,增加了Owned(拥有)状态。&lt;/li>
&lt;li>Owned状态表示该缓存行被某个CPU独占修改,但其他CPU也可读取。&lt;/li>
&lt;li>相比MESI,MOESI协议能更好地处理写回操作,提高性能。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Synapse协议&lt;/strong>:
&lt;ul>
&lt;li>这是一种基于目录的缓存一致性协议。&lt;/li>
&lt;li>每个缓存块都有一个目录项,记录该缓存块的状态和拥有该缓存块的处理器。&lt;/li>
&lt;li>当某个处理器要访问缓存块时,先查询目录项,根据状态信息进行适当的操作。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Dragon协议&lt;/strong>:
&lt;ul>
&lt;li>这是一种基于所有权的缓存一致性协议。&lt;/li>
&lt;li>每个缓存块都有一个所有权状态,指示该缓存块是被独占修改、共享还是无效。&lt;/li>
&lt;li>通过控制缓存块的所有权状态,可以实现缓存一致性。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>多机下的缓存一致性协议：&lt;/p>
&lt;ul>
&lt;li>写更新协议（Write-through）: 当数据被修改时,立即更新缓存和后端存储。这能保证缓存中的数据始终是最新的,但会增加写操作的延迟。&lt;/li>
&lt;li>写回协议（Write-back）: 当数据被修改时,只更新缓存,并将修改异步地刷新到后端存储。这能减少写操作的延迟,但可能会导致缓存中的数据暂时与后端不一致。&lt;/li>
&lt;li>失效协议（Write-invalidate）: 当数据被修改时,向其他缓存发送失效消息,使其失效。读取数据时,需要从后端重新加载。这能最大限度地减少写操作对读操作的影响。&lt;/li>
&lt;li>读独占协议（Read-exclusive）: 当一个缓存读取数据时,向其他缓存发送独占请求。其他缓存必须放弃该数据的副本,直到该缓存完成操作。这能避免读写冲突,但会增加读操作的延迟。&lt;/li>
&lt;/ul>
&lt;p>但同时操作系统也需要解决缓存不一致的问题.(JMM)&lt;/p>
&lt;h4 id="指令重排序">指令重排序&lt;/h4>
&lt;p>指令重排序是指 CPU 和编译器为了提高程序运行效率而对指令序列进行重新排序的一种手段。&lt;/p>
&lt;p>指令重排序可以保证&lt;strong>串行语义一致&lt;/strong>，但是没有义务保证多线程间的语义也一致 ，所以在多线程下，指令重排序可能会导致一些问题。&lt;/p>
&lt;p>编译器优化重排：&lt;/p>
&lt;ul>
&lt;li>编译器（包括 JVM、JIT 编译器等）在不改变单线程程序语义的前提下，重新安排语句的执行顺序。&lt;/li>
&lt;li>指令并行重排：现代处理器采用了指令级并行技术(Instruction-Level Parallelism，ILP)来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。&lt;/li>
&lt;li>内存系统的重排序：处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/JUC%28Java%E5%B9%B6%E5%8F%91%29/Java%E6%BA%90%E4%BB%A3%E7%A0%81%E7%BB%8F%E5%8E%86%E7%9A%84%E9%87%8D%E6%8E%92%E5%BA%8F.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>指令重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致 ，所以在多线程下，指令重排序可能会导致一些问题。&lt;/p>
&lt;p>编译器和处理器的指令重排序的处理方式不一样。对于编译器，通过禁止特定类型的编译器重排序的方式来禁止重排序。&lt;/p>
&lt;p>对于处理器，通过插入内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence）的方式来禁止特定类型的&lt;strong>处理器重排序&lt;/strong>。 &lt;strong>指令并行重排和内存系统重排都属于是处理器级别的指令重排序。&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence）是一种 CPU 指令，用来禁止处理器指令发生重排序（像屏障一样），从而保障指令执行的有序性。另外，为了达到屏障的效果，它也会使处理器写入、读取值之前，将主内存的值写入高速缓存，清空无效队列，从而保障变量的可见性。&lt;/p>
&lt;/blockquote>
&lt;h4 id="jmm-1">JMM&lt;/h4>
&lt;p>JMM是定义了一套规范，用于保证多线程环境下的内存可见性、原子性和有序性。包括:&lt;/p>
&lt;ul>
&lt;li>抽象了线程和主内存之间的关系&lt;/li>
&lt;li>规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/JUC%28Java%E5%B9%B6%E5%8F%91%29/JMM%28Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%29.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>Java内存区域的区别 JVM 内存结构和 Java 虚拟机的运行时区域相关，定义了 JVM 在运行时如何分区存储程序数据，就比如说堆主要用于存放对象实例。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/JUC%28Java%E5%B9%B6%E5%8F%91%29/JMM%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="并发问题的原因">并发问题的原因&lt;/h3>
&lt;p>CPU、内存、I/O 设备的速度是有极大差异的，为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系结构、操作系统、编译程序都做出了贡献，同时导致了并发问题。&lt;/p>
&lt;ul>
&lt;li>CPU 增加了缓存，以均衡与内存的速度差异.
&lt;ul>
&lt;li>导致可见性问题&lt;/li>
&lt;li>可见性是指当多个线程访问共享变量时，一个线程修改了共享变量的值，其他线程&lt;strong>能够看到修改后的值。&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异
&lt;ul>
&lt;li>导致原子性问题&lt;/li>
&lt;li>原子性: 是指一个操作是不可中断的，要么全部执行成功，要么全部不执行。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。
&lt;ul>
&lt;li>导致有序性问题&lt;/li>
&lt;li>有序性：代码的执行顺序按照代码的先后顺序执行。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="可见性问题">可见性问题&lt;/h4>
&lt;p>可见性问题,就是看不到修改后的值, 由CPU缓存导致. 多个线程访问共享变量时，由于缓存和指令重排等因素，导致某个线程修改了变量的值，而其他线程并没有立即看到修改后的值，从而出现数据不一致的问题。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">//线程1执行
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">int a = 0;//1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">a = 10;//2
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">//线程2执行
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">int j = a//3
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>假设,有两个CPU, CPU1执行线程1, CPU2执行线程2. 线程1执行语句2时, 会先把a=0这个初始值从主内存中加载到CPU1的高速缓存中, 然后在CPU1的高速缓存中赋值a=10, 并没有立即写入到主存.&lt;/p>
&lt;p>线程2 如果在 线程1写入主存之前,执行了语句3, 那么就会读取到a=0这个初始值, 而不是修改后的值10.&lt;/p>
&lt;h4 id="原子性问题">原子性问题&lt;/h4>
&lt;p>原子性问题由分时复用CPU导致.&lt;/p>
&lt;p>Java中只有对基本数据类型的&lt;strong>读取和赋值&lt;/strong>操作是原子性的，其他的操作都不是原子性的。 下面语句1是原子性的, 其他都不是原子性的.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">x = 10; //语句1: 直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">y = x; //语句2: 包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">x++; //语句3： x++包括3个操作：读取x的值，进行加1操作，写入新的值。
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">x = x + 1; //语句4： 同语句3
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>因此在执行一些常见,但不是原子性的操作时,会导致原子性问题.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">int i = 1;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">// 线程1执行
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">i += 1;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">// 线程2执行
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">i += 1;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>i += 1需要三条 CPU 指令&lt;/p>
&lt;ol>
&lt;li>将变量 i 从内存读取到 CPU寄存器；&lt;/li>
&lt;li>在CPU寄存器中执行 i + 1 操作；&lt;/li>
&lt;li>将最后的结果i写入内存（缓存机制导致可能写入的是 CPU 缓存而不是内存）。&lt;/li>
&lt;/ol>
&lt;p>如果线程1执行完1后, 轮到线程2执行三条指令, 线程1再执行2,3. 会导致i最后的值是2而不是3.&lt;/p>
&lt;h4 id="有序性问题">有序性问题&lt;/h4>
&lt;p>在执行程序时，为了提高性能，编译器和处理器会对指令进行重排序。 重排序不会影响单线程程序的执行结果，但是会影响多线程程序的执行结果。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">int i = 0;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">boolean flag = false;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">i = 1; //语句1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">flag = true; //语句2
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>比如语句1和语句2顺序可能会被重排.&lt;/p>
&lt;h3 id="解决并发问题">解决并发问题&lt;/h3>
&lt;p>第一个角度: Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法。&lt;/p>
&lt;ul>
&lt;li>volatile关键字&lt;/li>
&lt;li>synchronized关键字&lt;/li>
&lt;li>final关键字&lt;/li>
&lt;li>Happens-Before规则&lt;/li>
&lt;/ul>
&lt;p>第二个角度,通过可见性原子性有序性三个方面来解决并发问题.&lt;/p>
&lt;ul>
&lt;li>原子性问题：通过synchronized关键字和原子类来解决。
&lt;ul>
&lt;li>synchronized关键字可以&lt;strong>保证代码块的原子性&lt;/strong>。&lt;/li>
&lt;li>原子类可以保证对变量的操作是原子性的。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>可见性问题：通过volatile关键字来解决。
&lt;ul>
&lt;li>当一个变量被volatile修饰时，表示它是一个共享变量，能保证修改的值立即更新到主存中.&lt;/li>
&lt;li>synchronized和lock可以通过同步的方式来解决可见性问题。(即同一时刻只有一个线程获取锁,在释放锁之前会将修改的值刷新到主存中)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>有序性问题
&lt;ul>
&lt;li>通过volatile关键字来保证&lt;strong>一定的有序性&lt;/strong>。&lt;/li>
&lt;li>通过synchronized关键字来保证&lt;strong>有序性&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="volatile关键字">volatile关键字&lt;/h3>
&lt;h4 id="作用">作用&lt;/h4>
&lt;p>作用:&lt;/p>
&lt;ul>
&lt;li>保证可见性&lt;/li>
&lt;li>禁止指令重排&lt;/li>
&lt;/ul>
&lt;p>保证可见性 一个变量使用 volatile 修饰，这就指示 编译器，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。&lt;/p>
&lt;p>禁止指令重排 将变量声明为 volatile ，在对这个变量进行读写操作的时候，会通过&lt;strong>插入特定的内存屏障&lt;/strong> 的方式来禁止指令重排序。&lt;/p>
&lt;h4 id="volatile-实现原理">volatile 实现原理&lt;/h4>
&lt;p>在Java 中，当线程读取一个volatile 变量时，会从主内存中读取变量的最新值，并把它存储到线程的工作内存中。&lt;/p>
&lt;p>volatile主要通过汇编lock前缀指令，它会锁定当前内存区域的缓存（缓存行），并且立即将当前缓存行数据写入主内存（耗时非常短）&lt;/p>
&lt;p>当线程写入 volatile 变量时,会在写操作后加入一个 &amp;ldquo;写屏障&amp;rdquo; 指令,保证写操作立即刷新到主内存。&lt;/p>
&lt;ul>
&lt;li>写屏障指令会将当前 CPU 缓存行的数据立即刷新到主内存中 当线程读取 volatile 变量时,会在读操作前加入一个 &amp;ldquo;读屏障&amp;rdquo; 指令,保证读取的是主内存中的最新值。&lt;/li>
&lt;/ul>
&lt;p>内存屏障指令可以禁止 CPU 和编译器对相关指令进行重排序优化。&lt;/p>
&lt;h4 id="为什么volatile不能保证原子性">为什么volatile不能保证原子性&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">public class VolatileExample {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> private static volatile int count = 0;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public static void main(String[] args) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ExecutorService executorService = Executors.newCachedThreadPool();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> for (int i = 0; i &amp;lt; 1000; i++) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> executorService.execute(() -&amp;gt; count++);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> executorService.shutdown();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> System.out.println(count);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">Exception in thread &amp;#34;main&amp;#34; java.util.concurrent.RejectedExecutionException: Task java.util.concurrent.FutureTask@5e2de80c rejected from java.util.concurrent.ThreadPoolExecutor@3b9a45b3[Terminated, pool size = 0, active threads = 0, queued tasks = 0, completed tasks = 1000]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2063)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:830)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1379)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> at VolatileExample.main(VolatileExample.java:13)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>volatile不能保证原子性, &lt;strong>因为count++不是原子性的操作&lt;/strong>, 它包括三个步骤: 读取count的值, 将count的值加1, 写入count的值.&lt;/p>
&lt;h4 id="应用场景">应用场景&lt;/h4>
&lt;p>单例模式中的双重检查锁&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">public class Singleton {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> private static volatile Singleton instance;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> private Singleton() {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public static Singleton getInstance() {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> if (instance == null) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> synchronized (Singleton.class) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> if (instance == null) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> instance = new Singleton();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> return instance;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>为什么要volatile修饰instance? A: 保证instance是可见的, 避免指令重排.&lt;/p>
&lt;h3 id="synchronized关键字">synchronized关键字&lt;/h3>
&lt;p>见 &lt;a href="####synchronized">synchronized关键字&lt;/a>&lt;/p>
&lt;h3 id="final关键字">final关键字&lt;/h3>
&lt;h4 id="final的基础用法">final的基础用法&lt;/h4>
&lt;p>Q: 可以父类的final方法能不能够被子类重写?&lt;/p>
&lt;p>修饰类&lt;/p>
&lt;ul>
&lt;li>final类不能有子类&lt;/li>
&lt;li>final类的所有方法都隐式的是final的&lt;/li>
&lt;/ul>
&lt;p>Q: 如何理解private所修饰的方法是隐式的final? 说说final类型的类如何拓展? 比如String是final类型，我们想写个MyString复用所有String中方法，同时增加一个新的toMyString()的方法，应该如何做? 组合代替继承 final方法可以被重载吗?&lt;/p>
&lt;p>修饰方法&lt;/p>
&lt;ul>
&lt;li>&lt;strong>private方法&lt;/strong>隐式的是final的&lt;/li>
&lt;li>final方法不能被重写&lt;/li>
&lt;li>final方法可以被重载&lt;/li>
&lt;/ul>
&lt;p>修饰参数&lt;/p>
&lt;ul>
&lt;li>final参数不能被修改&lt;/li>
&lt;li>用于向匿名内部类传递参数&lt;/li>
&lt;/ul>
&lt;p>Q: 所有的final修饰的字段都是编译期常量吗?&lt;/p>
&lt;p>修饰变量&lt;/p>
&lt;ul>
&lt;li>final修饰的字段&lt;strong>不都是编译期常量&lt;/strong>&lt;/li>
&lt;li>但是final修饰的字段&lt;strong>只能被赋值一次&lt;/strong>&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">public class Test {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> //编译期常量
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> final int i = 1;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> final static int J = 1;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> final int[] a = {1,2,3,4};
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> //非编译期常量
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Random r = new Random();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> final int k = r.nextInt();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public static void main(String[] args) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果是 static final 修饰的字段, 就必须是在声明的时候就赋值, 不能在构造方法中赋值, 一定是编译期常量.&lt;/p>
&lt;p>blank final&lt;/p>
&lt;ul>
&lt;li>final修饰的字段, 在声明的时候不赋值, &lt;strong>在构造方法中赋值&lt;/strong>, 但是只能赋值一次.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">public class Test {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> final int i;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public Test() {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> i = 1;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以说说final域重排序规则?&lt;/p>
&lt;h4 id="todo-final域重排序">TODO: final域重排序&lt;/h4>
&lt;h5 id="final域为基本类型">final域为基本类型&lt;/h5>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">public class FinalDemo {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> private int a; //普通域
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> private final int b; //final域
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> private static FinalDemo finalDemo;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public FinalDemo() {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> a = 1; // 1. 写普通域
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> b = 2; // 2. 写final域
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public static void writer() {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> finalDemo = new FinalDemo();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public static void reader() {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> FinalDemo demo = finalDemo; // 3.读对象引用
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> int a = demo.a; //4.读普通域
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> int b = demo.b; //5.读final域
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>写final域重排序规则&lt;/p>
&lt;p>写final域的重排序规则&lt;strong>禁止对final域的写&lt;/strong>重排序到构造函数之外，这个规则的实现主要包含了两个方面：&lt;/p>
&lt;ul>
&lt;li>JMM禁止编译器把final域的写重排序到构造函数之外；&lt;/li>
&lt;li>编译器会在final域写之后，构造函数return之前，插入一个storestore屏障。这个屏障可以禁止处理器把final域的写重排序到构造函数之外。&lt;/li>
&lt;/ul>
&lt;p>我们再来分析writer方法，虽然只有一行代码，但实际上做了两件事情：&lt;/p>
&lt;ul>
&lt;li>构造了一个FinalDemo对象；&lt;/li>
&lt;li>把这个对象赋值给成员变量finalDemo。&lt;/li>
&lt;/ul>
&lt;p>我们来画下存在的一种可能执行时序图，如下：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/JUC%28Java%E5%B9%B6%E5%8F%91%29/%E5%86%99final%E5%9F%9F%E9%87%8D%E6%8E%92%E5%BA%8F.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>由于a,b之间没有数据依赖性，普通域(普通变量)a可能会被重排序到构造函数之外，线程B就有可能读到的是普通变量a初始化之前的值(零值)，这样就可能出现错误。&lt;/p>
&lt;p>而final域变量b，根据重排序规则，会禁止final修饰的变量b重排序到构造函数之外，从而b能够正确赋值，线程B就能够读到final变量初始化后的值。&lt;/p>
&lt;p>因此，写final域的重排序规则可以确保：在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了，而普通域就不具有这个保障。比如在上例，线程B有可能就是一个未正确初始化的对象finalDemo。&lt;/p>
&lt;p>读final域重排序规则&lt;/p>
&lt;p>在一个线程中，初次读对象引用和初次读该对象包含的final域，JMM会禁止这两个操作的重排序。(注意，这个规则仅仅是针对处理器)，处理器会在读final域操作的前面插入一个LoadLoad屏障。&lt;/p>
&lt;p>实际上，读对象的引用和读该对象的final域存在间接依赖性，一般处理器不会重排序这两个操作。但是有一些处理器会重排序，因此，这条禁止重排序规则就是针对这些处理器而设定的。&lt;/p>
&lt;p>read()方法主要包含了三个操作：&lt;/p>
&lt;ul>
&lt;li>初次读引用变量finalDemo;&lt;/li>
&lt;li>初次读引用变量finalDemo的普通域a;&lt;/li>
&lt;li>初次读引用变量finalDemo的final域b;&lt;/li>
&lt;/ul>
&lt;p>假设线程A写过程没有重排序，那么线程A和线程B有一种的可能执行时序为下图&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/JUC%28Java%E5%B9%B6%E5%8F%91%29/%E8%AF%BB%E9%87%8D%E6%8E%92%E5%BA%8F.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>读final域的重排序规则可以确保：在读一个对象的final域之前，一定会先读这个包含这个final域的对象的引用。&lt;/p>
&lt;h5 id="todo为引用类型">TODO：为引用类型&lt;/h5>
&lt;p>按照final修饰的数据类型分类： 基本数据类型:&lt;/p>
&lt;ul>
&lt;li>final域写：禁止final域写与构造方法重排序，即禁止final域写重排序到构造方法之外，从而保证该对象对所有线程可见时，该对象的final域全部已经初始化过。&lt;/li>
&lt;li>final域读：禁止初次读对象的引用与读该对象包含的final域的重排序。&lt;/li>
&lt;/ul>
&lt;p>引用数据类型：&lt;/p>
&lt;ul>
&lt;li>额外增加约束：禁止在构造函数对一个final修饰的对象的成员域的写入与随后将这个被构造的对象的引用赋值给引用变量 重排序&lt;/li>
&lt;/ul>
&lt;h4 id="说说final的原理">说说final的原理?&lt;/h4>
&lt;p>写final域会要求编译器在final域写之后，构造函数返回前插入一个StoreStore屏障。读final域的重排序规则会要求编译器在读final域的操作前插入一个LoadLoad屏障。&lt;/p>
&lt;h4 id="使用-final-的限制条件和局限性">使用 final 的限制条件和局限性?&lt;/h4>
&lt;h3 id="happens-before规则">Happens-Before规则&lt;/h3>
&lt;p>Happens-Before规则是Java内存模型中的一组规则，用于描述多线程环境下的内存可见性、原子性和有序性。&lt;/p>
&lt;p>Happens-Before规则主要包括以下几个规则：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>单一线程&lt;/strong>原则: 一个线程内部, 代码的执行顺序是按照代码的先后顺序执行的.&lt;/li>
&lt;li>&lt;strong>管程锁定&lt;/strong>规则: 对同一个锁unlock操作必须先于在lock操作.&lt;/li>
&lt;li>&lt;strong>volatile变量&lt;/strong>规则: 对一个volatile变量的写操作必须先于对该变量的读操作&lt;/li>
&lt;li>&lt;strong>线程启动&lt;/strong>规则: start()方法调用先于线程的每一个动作.&lt;/li>
&lt;li>&lt;strong>线程加入(join)&lt;/strong> 规则: Thread对象的&lt;strong>终止操作先于join()方法返回&lt;/strong>.&lt;/li>
&lt;li>&lt;strong>线程中断&lt;/strong>规则: 对线程interrupt()方法的调用先于被中断线程的代码检测到中断事件的发生. 即, 可以&lt;strong>用interrupt()方法来检测线程是否被中断&lt;/strong>.&lt;/li>
&lt;li>&lt;strong>对象终结&lt;/strong>规则: 对象的&lt;strong>构造函数执行结束&lt;/strong>先于finalize()方法的开始.&lt;/li>
&lt;li>&lt;strong>传递性&lt;/strong>: A先于B, B先于C, 那么A先于C.&lt;/li>
&lt;/ul>
&lt;h2 id="理解线程安全">理解线程安全&lt;/h2>
&lt;p>一个类在可以被多个线程安全调用时就是线程安全的。&lt;/p>
&lt;p>线程安全不是一个非真即假的命题，可以将共享数据按照安全程度的强弱顺序分成以下五类: 不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。&lt;/p>
&lt;h3 id="不可变">不可变&lt;/h3>
&lt;p>不可变(Immutable)的对象一定是线程安全的，不需要再采取任何的线程安全保障措施。 只要一个不可变的对象被正确地构建出来，永远也不会看到它在多个线程之中处于不一致的状态。&lt;/p>
&lt;p>多线程环境下，应当尽量使对象成为不可变，来满足线程安全。&lt;/p>
&lt;p>不可变的类型:&lt;/p>
&lt;ul>
&lt;li>final 关键字修饰的基本数据类型&lt;/li>
&lt;li>String&lt;/li>
&lt;li>枚举类型&lt;/li>
&lt;li>Number 部分子类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。
&lt;ul>
&lt;li>但同为 Number 的原子类 AtomicInteger 和 AtomicLong 则是可变的&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>对于集合类型，可以使用 Collections.unmodifiableXXX() 方法来获取一个不可变的集合。&lt;/p>
&lt;p>Collections.unmodifiableXXX() 先对原始的集合进行拷贝，需要对集合进行修改的方法都直接抛出异常。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">public class ImmutableExample {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public static void main(String[] args) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Map&amp;lt;String, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Map&amp;lt;String, Integer&amp;gt; unmodifiableMap = Collections.unmodifiableMap(map);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> unmodifiableMap.put(&amp;#34;a&amp;#34;, 1);//抛出异常
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">Exception in thread &amp;#34;main&amp;#34; java.lang.UnsupportedOperationException
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> at java.util.Collections$UnmodifiableMap.put(Collections.java:1457)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> at ImmutableExample.main(ImmutableExample.java:9)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>因为put被直接抛出异常, 所以unmodifiableMap是不可变的.&lt;/p>
&lt;h3 id="绝对线程安全">绝对线程安全&lt;/h3>
&lt;p>不管运行时环境如何，调用者都不需要任何额外的同步措施。&lt;/p>
&lt;h3 id="相对线程安全">相对线程安全&lt;/h3>
&lt;p>保证对这个对象单独的操作是线程安全的，在调用的时候不需要做额外的保障措施.&lt;/p>
&lt;p>但是对于特定复合操作，调用者需要额外的同步措施。&lt;/p>
&lt;p>Java的大部分&lt;strong>线程安全类&lt;/strong>, 都是这样.&lt;/p>
&lt;p>但如在Vector中, 两个线程都在遍历Vector, 一个线程删除了一个元素, 另一个线程可能会访问到一个不存在的元素.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">public class VectorUnsafeExample {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> private static Vector&amp;lt;Integer&amp;gt; vector = new Vector&amp;lt;&amp;gt;();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public static void main(String[] args) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> while (true) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> for (int i = 0; i &amp;lt; 100; i++) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> vector.add(i);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ExecutorService executorService = Executors.newCachedThreadPool();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> executorService.execute(() -&amp;gt; {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> for (int i = 0; i &amp;lt; vector.size(); i++) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> vector.remove(i);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> });
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> executorService.execute(() -&amp;gt; {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> for (int i = 0; i &amp;lt; vector.size(); i++) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> vector.get(i);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> });
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> executorService.shutdown();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>需要对删除和获取元素操作进行同步.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">executorService.execute(() -&amp;gt; {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> synchronized (vector) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> for (int i = 0; i &amp;lt; vector.size(); i++) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> vector.remove(i);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">});
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">executorService.execute(() -&amp;gt; {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> synchronized (vector) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> for (int i = 0; i &amp;lt; vector.size(); i++) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> vector.get(i);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">});
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="线程兼容">线程兼容&lt;/h3>
&lt;p>线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端使用加锁的方式来保证线程安全。&lt;/p>
&lt;p>如ArrayList, HashMap等.&lt;/p>
&lt;h3 id="线程对立">线程对立&lt;/h3>
&lt;p>线程对立是指对象本身并不是线程安全的，而且在调用端使用加锁的方式也无法保证线程安全。&lt;/p>
&lt;h2 id="线程安全的实现方式">线程安全的实现方式&lt;/h2>
&lt;h3 id="互斥同步-synchronized-和-reentrantlock">互斥同步 synchronized 和 ReentrantLock&lt;/h3>
&lt;p>互斥同步是指在同一时刻只允许一个线程访问共享资源。&lt;/p>
&lt;p>Java中提供了两种互斥同步的方式：synchronized和ReentrantLock。&lt;/p>
&lt;h4 id="synchronized">synchronized&lt;/h4>
&lt;p>synchronized是Java中的关键字，可以用来修饰方法或代码块。&lt;/p>
&lt;p>synchronized修饰方法时，表示整个方法是同步的，即同一时刻只允许一个线程访问该方法。&lt;/p>
&lt;p>synchronized修饰代码块时，需要&lt;strong>指定一个对象&lt;/strong>作为参数，表示对该对象进行同步，即同一时刻只允许一个线程访问该对象。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">public class SynchronizedExample {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public synchronized void method() {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // 代码
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">public class SynchronizedExample {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public void method() {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> synchronized (this) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // 代码
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>还可以同步一个类, 两个线程调用同一个类的&lt;strong>不同对象上的这种同步语句，也会进行同步&lt;/strong>。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">public class SynchronizedExample {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public void method() {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> synchronized (SynchronizedExample.class) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // 代码
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">public static void main(String[] args) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> SynchronizedExample e1 = new SynchronizedExample();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> SynchronizedExample e2 = new SynchronizedExample();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ExecutorService executorService = Executors.newCachedThreadPool();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> executorService.execute(() -&amp;gt; e1.func2());
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> executorService.execute(() -&amp;gt; e2.func2());
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>同步静态方法, 也是同步类的.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">public class SynchronizedExample {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public static synchronized void method() {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // 代码
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>同步语句块的实现使用的是 monitorenter 和 monitorexit 指令&lt;/p>
&lt;p>其中 &lt;strong>monitorenter 指令指向同步代码块的开始位置， monitorexit 指令则指明同步代码块的结束位置。&lt;/strong>&lt;/p>
&lt;p>在执行monitorenter时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。&lt;/p>
&lt;p>在执行 monitorexit 指令后，将锁计数器设为 0，表明锁被释放。&lt;/p>
&lt;p>如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。&lt;/p>
&lt;h4 id="reentrantlock">ReentrantLock&lt;/h4>
&lt;p>ReentrantLock是JUC包中的类，是一种可重入的互斥锁。&lt;/p>
&lt;p>TODO: 原理&lt;/p>
&lt;p>ReentrantLock可以替代synchronized进行同步，ReentrantLock可以提供更多的同步操作，如中断、超时、多个条件等。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">public class ReentrantLockExample {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> private ReentrantLock lock = new ReentrantLock();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public void method() {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> lock.lock();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> try {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // 代码
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> } finally {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> lock.unlock();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">public static void main(String[] args) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ReentrantLockExample example = new ReentrantLockExample();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ExecutorService executorService = Executors.newCachedThreadPool();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> executorService.execute(() -&amp;gt; example.method());
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> executorService.execute(() -&amp;gt; example.method());
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ReentrantLock 的底层实现主要依赖于 AbstractQueuedSynchronizer（AQS）这个抽象类。AQS 是一个提供了基本同步机制的框架，其中包括了队列、状态值等。&lt;/p>
&lt;p>ReentrantLock 在 AQS 的基础上通过内部类 Sync 来实现具体的锁操作。&lt;/p>
&lt;p>可重入锁是指同一个线程在获取了锁之后，可以再次重复获取该锁而不会造成死锁或其他问题。当一个线程持有锁时，如果再次尝试获取该锁，就会成功获取而不会被阻塞。&lt;/p>
&lt;p>ReentrantLock实现可重入锁的机制是基于线程持有锁的计数器。&lt;/p>
&lt;h4 id="synchronized-和-reentrantlock-的区别">synchronized 和 ReentrantLock 的区别&lt;/h4>
&lt;ul>
&lt;li>锁的实现: synchronized是Java的关键字, 是JVM层面的锁, 是隐式的, &lt;strong>不需要用户去手动释放锁&lt;/strong>; ReentrantLock是JUC包中的类, 是API层面的锁, 是显式的, 需要用户去手动释放锁.&lt;/li>
&lt;li>性能: synchronized的性能在JDK6之后得到了很大的提升, 但是在并发量很高的情况下, ReentrantLock的性能要优于synchronized.(优化后大致相同)&lt;/li>
&lt;li>等待可中断: 使用synchronized时, 如果获取不到锁, 线程会一直等待, 不能够中断; 使用ReentrantLock时, 可以设置超时时间, 可以中断.&lt;/li>
&lt;li>公平锁: ReentrantLock&lt;strong>可以设置为公平锁&lt;/strong>, synchronized是&lt;strong>非公平锁&lt;/strong>.
&lt;ul>
&lt;li>公平锁: 多个线程按照申请锁的顺序来获取锁.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>锁绑定多个条件: ReentrantLock可以同时绑定多个Condition对象.&lt;/li>
&lt;/ul>
&lt;p>如何选择: 除非要使用ReentrantLock的高级功能, 否则优先使用synchronized.&lt;/p>
&lt;ul>
&lt;li>这是因为synchronized是JVM层面的锁, 在JDK6之后进行了很多优化, 所以性能和ReentrantLock差不多, 且更加简洁.&lt;/li>
&lt;li>并且不用担心忘记释放锁, 也不用担心死锁问题.&lt;/li>
&lt;/ul>
&lt;h3 id="非阻塞同步">非阻塞同步&lt;/h3>
&lt;p>互斥同步的主要问题是阻塞，当一个线程获取锁后，其他线程只能等待。&lt;/p>
&lt;p>互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁(实际上虚拟机会优化掉一些不必要的加锁操作)。&lt;/p>
&lt;h4 id="cas-compare-and-swap">CAS (Compare And Swap)&lt;/h4>
&lt;p>CAS是一种乐观的并发策略，它总是认为不会出现竞争，只有在真的出现竞争的时候，才通过自旋重试来解决竞争问题。&lt;/p>
&lt;p>CAS是基于冲突检测的乐观并发策略. 先进行操作, 如果检测到没有冲突, 则操作成功, 否则不断重试.&lt;/p>
&lt;p>CAS的条件是 操作和检查是原子性的. 互斥同步是无法保证的, 只能依靠硬件完成.&lt;/p>
&lt;p>CAS指令有三个操作数，分别是内存位置V、旧的预期值A和新值B。CAS指令执行时，当且仅当V的值等于A时，将V的值更新为B，否则不做任何操作。&lt;/p>
&lt;p>CAS的实现是C++中的一个原子操作, 但是Java中的CAS是通过JNI来调用C++的CAS指令实现的.&lt;/p>
&lt;p>获取当前共享变量的值和期望值：&lt;/p>
&lt;ul>
&lt;li>CAS操作的第一步是获取共享变量的当前值，同时也需要提供一个期望值，这个期望值是用来比较共享变量的当前值是否与之相等的基准。&lt;/li>
&lt;li>先获取共享变量得到旧的预期值A&lt;/li>
&lt;li>执行业务，得到新值B&lt;/li>
&lt;/ul>
&lt;p>比较共享变量的当前值和期望值是否相等：&lt;/p>
&lt;ul>
&lt;li>在这一步，CAS会比较共享变量的当前值和之前提供的期望值是否相等。如果相等，说明共享变量的值符合预期，可以进行下一步操作。&lt;/li>
&lt;/ul>
&lt;p>更新共享变量的值：&lt;/p>
&lt;ul>
&lt;li>如果共享变量的当前值与期望值相等，CAS会将共享变量的值更新为要写入的新值。这个操作是原子性的，即在这个过程中不会有其他线程对该共享变量进行干扰。&lt;/li>
&lt;/ul>
&lt;p>处理失败的情况：&lt;/p>
&lt;ul>
&lt;li>如果共享变量的当前值与期望值不相等，说明此时有其他线程已经修改了共享变量的值。在这种情况下，当前线程需要重新获取共享变量的最新值，并重新执行步骤2和3，直至操作成功。&lt;/li>
&lt;/ul>
&lt;p>CAS的应用: AtomicInteger&lt;/p>
&lt;p>JUC包中的原子类, 其中的compareAndSet方法和getAndIncrement方法都是基于CAS实现的。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-gdscript3" data-lang="gdscript3">&lt;span class="line">&lt;span class="cl">&lt;span class="o">//&lt;/span>&lt;span class="n">incrementAndGet方法&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">public&lt;/span> &lt;span class="n">final&lt;/span> &lt;span class="ne">int&lt;/span> &lt;span class="n">incrementAndGet&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">unsafe&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">getAndAddInt&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">this&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">valueOffset&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">//&lt;/span>&lt;span class="n">getAndAddInt方法&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">public&lt;/span> &lt;span class="n">final&lt;/span> &lt;span class="ne">int&lt;/span> &lt;span class="n">getAndAddInt&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="ne">Object&lt;/span> &lt;span class="n">var1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">long&lt;/span> &lt;span class="n">var2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="ne">int&lt;/span> &lt;span class="n">var4&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="ne">int&lt;/span> &lt;span class="n">var5&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">do&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">var5&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">getIntVolatile&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">var1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">var2&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="k">while&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">compareAndSwapInt&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">var1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">var2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">var5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">var5&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">var4&lt;/span>&lt;span class="p">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">var5&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="aba-cas的问题">ABA (CAS的问题)&lt;/h4>
&lt;p>CAS存在一个问题，即ABA问题。&lt;/p>
&lt;p>ABA问题是指一个值原来是A，后来被改成了B，然后又被改回为A，那么CAS检查时会认为它没有被改过，但实际上已经发生了变化。&lt;/p>
&lt;p>大部分情况下ABA问题并不会影响并发的正确性.&lt;/p>
&lt;p>如果需要解决ABA问题, 用传统的互斥同步会更好.&lt;/p>
&lt;p>JUC包中提供了一个带有标记的原子引用类AtomicStampedReference来解决ABA问题。&lt;/p>
&lt;p>它可以通过控制变量的版本来保证CAS的正确性。&lt;/p>
&lt;p>Java中有AtomicStampedReference来解决这个问题，他加入了预期标志和更新后标志两个字段，更新时不光检查值，还要检查当前的标志是否等于预期标志，全部相等的话才会更新。&lt;/p>
&lt;h3 id="无同步方案">无同步方案&lt;/h3>
&lt;p>无同步方案是指在多线程环境下，不做任何的同步措施，也不会出现线程安全问题。&lt;/p>
&lt;p>核心是: &lt;strong>不共享数据&lt;/strong>.&lt;/p>
&lt;p>通过将共享数据的访问限制在单线程内部，就可以保证线程安全。&lt;/p>
&lt;p>实现方法有: 栈封闭、线程本地存储(Thread Local Storage, TLS)&lt;/p>
&lt;h4 id="栈封闭">栈封闭&lt;/h4>
&lt;p>多个线程访问同一个方法中的局部变量不会出现线程安全问题。&lt;/p>
&lt;p>局部变量存在虚拟机栈中，属于线程私有的.&lt;/p>
&lt;h4 id="线程本地存储thread-local-storage">线程本地存储(Thread Local Storage)&lt;/h4>
&lt;p>当数据必须被多个线程共享时，看看能否将共享数据的代码封装到一个线程内部，这样就可以保证线程安全。&lt;/p>
&lt;p>例子:&lt;/p>
&lt;ul>
&lt;li>生产者消费者模式中, 每个线程都有自己的队列, 不会出现线程安全问题.&lt;/li>
&lt;li>Web服务器中, 每个请求都会创建一个线程, 也不会出现线程安全问题.&lt;/li>
&lt;/ul>
&lt;p>Java通过ThreadLocal类提供了线程本地存储的支持。&lt;/p>
&lt;p>ThreadLocal类可以让每个线程都有自己的共享变量，从而避免了线程安全问题。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">public class ThreadLocalExample1 {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public static void main(String[] args) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ThreadLocal threadLocal = new ThreadLocal();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Thread thread1 = new Thread(() -&amp;gt; {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> threadLocal1.set(1);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> threadLocal2.set(1);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> });
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Thread thread2 = new Thread(() -&amp;gt; {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> threadLocal1.set(2);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> threadLocal2.set(2);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> });
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> thread1.start();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> thread2.start();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/JUC%28Java%E5%B9%B6%E5%8F%91%29/ThreadLocalExample1%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>每个Thread都有一个ThreadLocalMap对象, 用于存储线程本地变量.&lt;/p>
&lt;p>Thread类中定义了ThreadLocal.ThreadLocalMap 成员。 &lt;code>ThreadLocal.ThreadLocalMap threadLocals = null;&lt;/code>&lt;/p>
&lt;p>当调用get set时,&lt;strong>先获取当前线程的ThreadLocalMap&lt;/strong>, 然后将ThreadLocal对象作为key, value作为value存入.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">public void set(T value) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Thread t = Thread.currentThread();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ThreadLocalMap map = getMap(t);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> if (map != null)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> map.set(this, value);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> else
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> createMap(t, value);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="threadlocal的问题----内存泄漏">ThreadLocal的问题 &amp;ndash; 内存泄漏&lt;/h5>
&lt;p>ThreadLocalMap中的&lt;strong>Entry的key是弱引用&lt;/strong>, value是强引用, 如果key被回收了, value不会被回收, 会导致内存泄漏.&lt;/p>
&lt;p>只要线程还在, ThreadLocalMap中的Entry就不会被回收.&lt;/p>
&lt;p>ThreadLocal 对象可能会被提前回收,导致使用时出现 NullPointerException。因此,开发人员在使用 ThreadLocal 时,需要注意适当的生命周期管理,比如在线程结束时主动调用 remove() 方法清理副本信息。&lt;/p>
&lt;p>解决方法: 在使用完ThreadLocal后, 调用remove方法.&lt;/p>
&lt;h4 id="可重入代码reentrant-code">可重入代码(Reentrant Code)&lt;/h4>
&lt;p>也叫纯代码, 在代码执行的任何时刻, 都可以被中断, 转而执行另一段代码, 然后再回到原来的代码.&lt;/p>
&lt;p>特征: 不依赖于任何共享的变量, 用到的状态变量都有方法的参数传递进来, 不会调用非可重入的方法.&lt;/p>
&lt;p>可重入代码(Reentrant Code)是指一个函数/方法可以被同一线程多次调用而不会产生任何问题的代码。换句话说,在执行该函数/方法的过程中,如果遇到对自身的再次调用,函数能够正确处理这种情况,不会陷入死锁或其他异常状态。&lt;/p>
&lt;p>举几个例子来说明可重入代码:&lt;/p>
&lt;ol>
&lt;li>&lt;strong>synchronized 关键字&lt;/strong>:&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">public class ReentrantExample {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public synchronized void foo() {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // 执行一些操作
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> foo(); // 可以再次调用自身
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在上述代码中,&lt;code>foo()&lt;/code> 方法使用了 &lt;code>synchronized&lt;/code> 关键字来确保线程安全。当一个线程进入 &lt;code>foo()&lt;/code> 方法时,它会获取该对象的锁。即使 &lt;code>foo()&lt;/code> 方法再次调用自身,由于线程已经持有了该对象的锁,所以不会发生死锁。这就是可重入的体现。&lt;/p>
&lt;ol start="2">
&lt;li>&lt;strong>ReentrantLock 类&lt;/strong>:&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">public class ReentrantExample {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> private final ReentrantLock lock = new ReentrantLock();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public void foo() {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> lock.lock();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> try {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // 执行一些操作
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> foo(); // 可以再次调用自身
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> } finally {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> lock.unlock();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在这个例子中,我们使用 &lt;code>ReentrantLock&lt;/code> 来实现可重入的锁定机制。当一个线程进入 &lt;code>foo()&lt;/code> 方法并成功获得锁时,即使方法再次调用自身,由于线程已经持有了该锁,所以不会发生死锁。&lt;/p>
&lt;ol start="3">
&lt;li>&lt;strong>递归算法&lt;/strong>:&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">public int factorial(int n) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> if (n == 0) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> return 1;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> return n * factorial(n - 1); // 可以递归调用自身
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在这个示例中,&lt;code>factorial()&lt;/code> 方法是一个递归算法。它可以在自身内部多次调用自身,而不会产生任何问题。这就是可重入代码的体现。&lt;/p>
&lt;p>总的来说,可重入代码可以让同一个线程多次调用同一个函数/方法,而不会产生死锁或其他异常情况。这在多线程编程中非常重要,可以避免意外的并发问题。&lt;/p>
&lt;h2 id="线程机制">线程机制&lt;/h2>
&lt;h3 id="线程基本机制">线程基本机制&lt;/h3>
&lt;h4 id="executor框架">Executor框架&lt;/h4>
&lt;p>Executor 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。&lt;/p>
&lt;p>三种Executor:&lt;/p>
&lt;ul>
&lt;li>CachedThreadPool：一个任务创建一个线程&lt;/li>
&lt;li>FixedThreadPool：所有任务只能使用固定大小的线程&lt;/li>
&lt;li>SingleThreadExecutor：相当于大小为1的FixedThreadPool&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">public class Main {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public static void main(String[] args) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ExecutorService executorService = Executors.newCachedThreadPool();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> executorService.execute(() -&amp;gt; System.out.println(&amp;#34;CachedThreadPool&amp;#34;));
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> executorService.shutdown();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="daemon线程守护线程">Daemon线程(守护线程)&lt;/h4>
&lt;p>守护线程是一种特殊的线程, 不属于程序中不可或缺的部分，当所有的非守护线程结束时，程序也就终止了，同时会杀死进程中的所有守护线程。&lt;/p>
&lt;p>main不是守护线程.&lt;/p>
&lt;p>使用setDaemon()方法将线程设置为守护线程。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">public class Main {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public static void main(String[] args) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Thread thread = new Thread(() -&amp;gt; {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> while (true) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> System.out.println(&amp;#34;守护线程&amp;#34;);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> });
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> thread.setDaemon(true);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> thread.start();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="sleep方法">sleep()方法&lt;/h4>
&lt;p>sleep()方法是Thread类的静态方法，可以让当前线程休眠一段时间。 以毫秒为单位。&lt;/p>
&lt;p>sleep可能会抛出InterruptedException异常，并且无法跨线程返回给main, 必须在当前线程中处理.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">public class Main {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public static void main(String[] args) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Thread thread = new Thread(() -&amp;gt; {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> try {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Thread.sleep(1000);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> } catch (InterruptedException e) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> e.printStackTrace();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> System.out.println(&amp;#34;sleep&amp;#34;);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> });
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> thread.start();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="yield方法">yield()方法&lt;/h4>
&lt;p>yield()方法是Thread类的静态方法. 表示该线程已经执行完了重要的部分, 可以让当前线程让出CPU，但是不代表当前线程不执行了，只是让出CPU，让CPU重新调度。&lt;/p>
&lt;p>是对线程调度器的一种建议，而不是命令。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">public class Main {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public static void main(String[] args) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Thread thread1 = new Thread(() -&amp;gt; {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> for (int i = 0; i &amp;lt; 100; i++) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> System.out.println(&amp;#34;thread1&amp;#34;);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Thread.yield();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> });
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Thread thread2 = new Thread(() -&amp;gt; {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> for (int i = 0; i &amp;lt; 100; i++) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> System.out.println(&amp;#34;thread2&amp;#34;);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Thread.yield();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> });
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> thread1.start();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> thread2.start();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="线程中断">线程中断&lt;/h3>
&lt;h4 id="interrupt方法">Interrupt()方法&lt;/h4>
&lt;p>InterruptedException是一个检查异常&lt;/p>
&lt;p>当一个线程调用一个阻塞方法时，比如sleep()、wait()、join()等，&lt;/p>
&lt;p>如果其他线程调用了该线程的interrupt()方法，那么该线程会抛出InterruptedException异常。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">public class Main {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public static void main(String[] args) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Thread thread = new Thread(() -&amp;gt; {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> try {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Thread.sleep(1000);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> } catch (InterruptedException e) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> e.printStackTrace();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> });
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> thread.start();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> thread.interrupt();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果一个线程的 run() 方法执行一个无限循环，并且没有执行 sleep() 等会抛出 InterruptedException 的操作，那么调用线程的 interrupt() 方法就无法使线程提前结束&lt;/p>
&lt;p>但调用线程的 interrupt() 方法会设置线程的中断标志，可以通过 Thread.interrupted() 方法来判断线程是否被中断。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">public class Main {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public static void main(String[] args) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Thread thread = new Thread(() -&amp;gt; {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> while (!Thread.interrupted()) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> System.out.println(&amp;#34;running&amp;#34;);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> });
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> thread.start();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> thread.interrupt();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="executor框架中的中断">Executor框架中的中断&lt;/h4>
&lt;p>Executor框架中的线程池提供了shutdown()和shutdownNow()方法来关闭线程池。&lt;/p>
&lt;p>shutdown()会等待所有线程执行完毕后再关闭，而shutdownNow()会立即关闭所有线程(相当于调用每个线程的interrupt()方法)。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">public class Main {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public static void main(String[] args) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ExecutorService executorService = Executors.newCachedThreadPool();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> executorService.execute(() -&amp;gt; {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> while (true) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> System.out.println(&amp;#34;running&amp;#34;);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> });
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> executorService.shutdownNow();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果只是想中断一个线程，可以使用submit()方法提交一个Callable任务，然后调用返回的Future对象的cancel()方法来中断线程。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">public class Main {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public static void main(String[] args) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ExecutorService executorService = Executors.newCachedThreadPool();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Future&amp;lt;?&amp;gt; future = executorService.submit(() -&amp;gt; {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> while (true) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> System.out.println(&amp;#34;running&amp;#34;);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> });
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> future.cancel(true);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="线程之间的协作">线程之间的协作&lt;/h3>
&lt;h4 id="join方法">Join方法&lt;/h4>
&lt;p>join()方法是Thread类的一个实例方法，用于等待调用join()方法的线程执行完毕。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">public class Main {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public static void main(String[] args) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Thread thread = new Thread(() -&amp;gt; {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> System.out.println(&amp;#34;thread&amp;#34;);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> });
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> thread.start();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> try {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> thread.join();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> } catch (InterruptedException e) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> e.printStackTrace();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> System.out.println(&amp;#34;main&amp;#34;);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="查看线程的执行结果怎么拿到">查看线程的执行结果，怎么拿到&lt;/h4>
&lt;p>可以通过线程的join()方法来等待线程执行完毕，并获取线程的执行结果。join()方法会阻塞当前线程，直到被调用的线程执行完毕。&lt;/p>
&lt;p>另外，可以通过线程的返回值来获取线程的执行结果。如果线程需要返回结果，可以在run()方法中返回一个值，然后在调用线程的地方通过&lt;strong>Thread对象的get()方法&lt;/strong>获取返回值。&lt;/p>
&lt;h4 id="wait和notify方法">wait()和notify()方法&lt;/h4>
&lt;p>wait()和notify()方法是Object类的实例方法，用于线程之间的协作。&lt;/p>
&lt;p>wait()方法会使当前线程等待，直到其他线程调用对象的notify()或notifyAll()方法来唤醒该线程。&lt;/p>
&lt;p>只能在同步方法或同步块中调用wait()和notify()方法。&lt;/p>
&lt;p>wait会释放锁&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">public class Main {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public static void main(String[] args) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Object object = new Object();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Thread thread1 = new Thread(() -&amp;gt; {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> synchronized (object) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> try {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> object.wait();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> } catch (InterruptedException e) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> e.printStackTrace();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> System.out.println(&amp;#34;thread1&amp;#34;);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> });
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Thread thread2 = new Thread(() -&amp;gt; {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> synchronized (object) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> object.notify();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> System.out.println(&amp;#34;thread2&amp;#34;);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> });
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> thread1.start();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> thread2.start();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="sleep方法和wait方法">sleep()方法和wait()方法&lt;/h4>
&lt;ul>
&lt;li>sleep()方法
&lt;ul>
&lt;li>Thread类的静态方法，可以让当前线程休眠一段时间&lt;/li>
&lt;li>&lt;strong>不会释放锁&lt;/strong>。&lt;/li>
&lt;li>用于暂停执行&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>wait()方法
&lt;ul>
&lt;li>Object类的方法，可以让当前线程等待&lt;/li>
&lt;li>会释放锁。&lt;/li>
&lt;li>wait()调用后, 线程不会自动唤醒, 需要调用notify()或notifyAll()方法唤醒。
&lt;ul>
&lt;li>或者使用wait(long timeout)方法，指定等待时间后自动唤醒。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>用于线程间的通信&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h5 id="为什么wait不定义在thread类中呢">为什么wait()不定义在Thread类中呢？&lt;/h5>
&lt;p>wait()方法是Object类的方法，是让获得对象锁的线程实现等待，会自动释放当前线程占有的对象锁。&lt;/p>
&lt;p>&lt;strong>每个Object都有对象锁，因此定义在Object类中。&lt;/strong>&lt;/p>
&lt;h5 id="为什么sleep不定义在object类中呢">为什么sleep()不定义在Object类中呢？&lt;/h5>
&lt;p>sleep()方法是Thread类的静态方法，是让当前线程暂停执行，不涉及到对象类，也不需要获得对象锁。&lt;/p>
&lt;h4 id="await和signal方法-condition">await()和signal()方法 (Condition)&lt;/h4>
&lt;p>JUC包中的Condition接口提供了Condition对象来实现线程之间的协作。&lt;/p>
&lt;p>在Condition上调用await()方法会使当前线程等待，直到&lt;strong>其他线程调用Condition的signal()方法 或 signalAll()方法来唤醒该线程&lt;/strong>。&lt;/p>
&lt;p>相比于wait() , await可以指定等待的条件&lt;/p>
&lt;p>使用Lock对象的newCondition()方法来获取Condition对象。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-gdscript3" data-lang="gdscript3">&lt;span class="line">&lt;span class="cl">&lt;span class="n">public&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="n">AwaitSignalExample&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">private&lt;/span> &lt;span class="n">Lock&lt;/span> &lt;span class="n">lock&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">new&lt;/span> &lt;span class="n">ReentrantLock&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">private&lt;/span> &lt;span class="n">Condition&lt;/span> &lt;span class="n">condition&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">lock&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">newCondition&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">public&lt;/span> &lt;span class="n">void&lt;/span> &lt;span class="n">before&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">lock&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">lock&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">try&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;before&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">condition&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">signalAll&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="n">finally&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">lock&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">unlock&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">public&lt;/span> &lt;span class="n">void&lt;/span> &lt;span class="n">after&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">lock&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">lock&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">try&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">condition&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">await&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;after&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="n">catch&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">InterruptedException&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">e&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">printStackTrace&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="n">finally&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">lock&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">unlock&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="可以直接调用run方法吗">可以直接调用run()方法吗？&lt;/h3>
&lt;p>可以直接调用run()方法，但是这样会导致run()方法在当前线程（main线程）中执行，不会创建新的线程。&lt;/p>
&lt;p>正常情况是调用start()方法，然后由JVM来创建新的线程并执行run()方法。&lt;/p>
&lt;p>调用 start() 方法方可启动线程并使线程进入就绪状态，直接执行 run() 方法的话不会以多线程的方式执行。&lt;/p>
&lt;h2 id="锁">锁&lt;/h2>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/JUC%28Java%E5%B9%B6%E5%8F%91%29/Java%E4%B8%BB%E6%B5%81%E9%94%81.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="乐观锁与悲观锁">乐观锁与悲观锁&lt;/h3>
&lt;p>对于同一个数据的并发操作:&lt;/p>
&lt;ul>
&lt;li>悲观锁认为对于同一个数据的并发操作，一定是会发生冲突的，因此在数据被操作时会加锁。
&lt;ul>
&lt;li>synchronized lock&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>乐观锁认为对于同一个数据的并发操作，是不会发生冲突的，所以不会加锁，只是在更新数据时会判断在此期间数据有没有被其他线程更新。
&lt;ul>
&lt;li>CAS&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/JUC%28Java%E5%B9%B6%E5%8F%91%29/%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>悲观锁适用于写操作多的场景，乐观锁适用于读操作多的场景。&lt;/p>
&lt;h3 id="自旋锁与自适应自旋">自旋锁与自适应自旋&lt;/h3>
&lt;p>自旋锁出现的原因: 阻塞或唤醒一个线程都需要从用户态转换到内核态，这个转换过程需要耗费时间, 可能比线程自旋的时间还要长.&lt;/p>
&lt;p>而在很多场景中, 同步资源的锁定时间都是非常短的, 如果线程被阻塞的时间比同步资源的锁定时间还要长, 那么线程就会白白浪费CPU资源.&lt;/p>
&lt;p>所以可以让当前线程&amp;quot;忙等&amp;quot;, 不停地循环等待, 直到获取到锁.&lt;/p>
&lt;p>缺点:&lt;/p>
&lt;ul>
&lt;li>不能代替阻塞,会消耗CPU资源&lt;/li>
&lt;/ul>
&lt;p>因此当自旋时间过长时, 可以将线程挂起, 等待一段时间后再自旋.&lt;/p>
&lt;p>自适应自旋:&lt;/p>
&lt;ul>
&lt;li>自旋的时间不再是固定的, 而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的.&lt;/li>
&lt;li>如果前一次自旋成功, 说明锁的拥有者很快就会释放锁, 那么这一次自旋的时间会更长.&lt;/li>
&lt;li>如果前一次自旋不成功, 说明锁的拥有者不会很快释放锁, 那么这一次自旋的时间会更短.&lt;/li>
&lt;/ul>
&lt;h3 id="无锁-vs-偏向锁-vs-轻量级锁-vs-重量级锁">无锁 vs 偏向锁 vs 轻量级锁 vs 重量级锁&lt;/h3>
&lt;ul>
&lt;li>无锁是指线程间不会争用共享数据，因此无需加锁。&lt;/li>
&lt;li>偏向锁&lt;strong>消除无竞争情况下的同步原语&lt;/strong>,减少不必要的系统调用,从而提高程序的性能。
&lt;ul>
&lt;li>通过对比Mark Word解决加锁问题，避免执行CAS操作。&lt;/li>
&lt;li>Mark Word中存储了偏向线程的ID，当线程访问同步块时，会先检查Mark Word中的线程ID是否为当前线程ID，如果是则直接进入同步块。&lt;/li>
&lt;li>如果不是，则通过CAS操作竞争锁。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。&lt;/li>
&lt;li>重量级锁是将除了拥有锁的线程以外的线程都阻塞。&lt;/li>
&lt;/ul>
&lt;p>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。&lt;/p>
&lt;p>1.为什么引入：在大多数情况下，锁总是由同一线程多次获得，&lt;strong>不存在多线程竞争&lt;/strong>，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。&lt;/p>
&lt;p>2.实现机制：当一个线程访问同步代码块并获取锁时，会在 Mark Word 里存储锁偏向的线程 ID。在线程进入和退出同步块时不再通过 CAS 操作来加锁和解锁，而是检测 Mark Word 里是否存储着指向当前线程的偏向锁。&lt;/p>
&lt;p>Mark Word 是 Java 对象头的一部分,用于存储对象的一些元数据信息&lt;/p>
&lt;p>引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次 CAS 原子指令，而偏向锁只需要在置换 ThreadID 的时候依赖一次 CAS 原子指令即可。&lt;/p>
&lt;h3 id="公平锁和非公平锁">公平锁和非公平锁&lt;/h3>
&lt;p>公平锁是指多个线程按照申请锁的顺序来获取锁。&lt;/p>
&lt;p>非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请锁的线程比先申请锁的线程优先获取锁。&lt;/p>
&lt;p>公平锁的实现成本较高，性能相对非公平锁要低，因为需要先判断队列中是否有其他线程等待，而非公平锁只需要判断锁是否被占用。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/JUC%28Java%E5%B9%B6%E5%8F%91%29/%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="可重入锁-vs-非可重入锁">可重入锁 vs 非可重入锁&lt;/h3>
&lt;p>可重入锁是指同一个线程在外层方法获取锁的时候，内层方法可以直接获取该锁。又叫递归锁。&lt;/p>
&lt;p>非可重入锁是指锁不可以延续使用，不可以重复获取。&lt;/p>
&lt;p>可重入锁可以避免死锁&lt;/p>
&lt;p>Java中的synchronized和ReentrantLock都是可重入锁。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">public class ReentrantLockExample {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> private ReentrantLock lock = new ReentrantLock();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public void func() {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> lock.lock();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> try {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> for (int i = 0; i &amp;lt; 3; i++) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> System.out.println(i);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> if (i == 1) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> func();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> } finally {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> lock.unlock();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/JUC%28Java%E5%B9%B6%E5%8F%91%29/%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/JUC%28Java%E5%B9%B6%E5%8F%91%29/%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/JUC%28Java%E5%B9%B6%E5%8F%91%29/%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E5%92%8C%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E5%8E%9F%E7%90%86.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="共享锁和排他锁">共享锁和排他锁&lt;/h3>
&lt;p>共享锁是读锁，排他锁是写锁。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/JUC%28Java%E5%B9%B6%E5%8F%91%29/ReentrantReadWriteLock.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="todo-synchronized-原理和核心优化">TODO: synchronized 原理和核心优化&lt;/h3>
&lt;p>synchronized 在 JDK 1.5 时性能是比较低的，然而在后续的版本中经过各种优化迭代，它的性能也得到了前所未有的提升&lt;/p>
&lt;p>synchronized 核心优化方案主要包含以下 4 个：&lt;/p>
&lt;ul>
&lt;li>锁膨胀&lt;/li>
&lt;li>锁消除&lt;/li>
&lt;li>锁粗化&lt;/li>
&lt;li>自适应自旋锁&lt;/li>
&lt;/ul>
&lt;p>锁膨胀和自适应自旋锁是 synchronized 关键字自身的优化实现，而锁消除和锁粗化是 JVM 虚拟机对 synchronized 提供的优化方案&lt;/p>
&lt;h4 id="锁膨胀">锁膨胀&lt;/h4>
&lt;p>指 synchronized 从无锁升级到偏向锁，再到轻量级锁，最后到重量级锁的过程，它叫做锁膨胀也叫做锁升级。 JDK 1.6 之前，synchronized 是重量级锁，也就是说 synchronized 在释放和获取锁时都会从用户态转换成内核态，而转换的效率是比较低的。但有了锁膨胀机制之后，synchronized 的状态就多了无锁、偏向锁以及轻量级锁了，这时候在进行并发操作时，大部分的场景都不需要用户态到内核态的转换了，这样就大幅的提升了 synchronized 的性能。&lt;/p>
&lt;p>偏向锁执行流程&lt;/p>
&lt;p>当一个线程访问同步代码块并获取锁时，会在对象头的 Mark Word 里存储锁偏向的线程 ID&lt;/p>
&lt;p>在线程进入和退出同步块时不再通过 CAS 操作来加锁和解锁， 而是检测 Mark Word 里是否存储着指向当前线程的偏向锁&lt;/p>
&lt;ul>
&lt;li>如果 Mark Word 中的线程 ID 和访问的线程 ID 一致，则可以直接进入同步块进行代码执行&lt;/li>
&lt;li>如果线程 ID 不同，则使用 CAS 尝试获取锁，如果获取成功则进入同步块执行代码，否则会将锁的状态升级为轻量级锁。 ​&lt;/li>
&lt;/ul>
&lt;p>轻量级锁 引入轻量级锁的目的是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统 Mutex Lock（互斥锁）产生的性能消耗。&lt;/p>
&lt;p>如果使用 Mutex Lock 每次获取锁和释放锁的操作都会带来用户态和内核态的切换，这样系统的性能开销是很大的。 ​ 当关闭偏向锁或者多个线程竞争偏向锁时就会导致偏向锁升级为轻量级锁，轻量级锁的获取和释放都通过 CAS 完成的，其中锁获取可能会通过一定次数的自旋来完成。 ​&lt;/p>
&lt;p>重量级锁&lt;/p>
&lt;p>依赖监视器 Monitor 实现方法同步或代码块同步的&lt;/p>
&lt;p>代码块同步使用的是 monitorenter 和 monitorexit 指令来实现的&lt;/p>
&lt;p>monitorenter 指令是在编译后插入到同步代码块的开始位置&lt;/p>
&lt;p>monitorexit 是插入到方法结束处和异常处的，任何对象都有一个 Monitor 与之关联，当且一个 Monitor 被持有后，它将处于锁定状态。&lt;/p>
&lt;p>​&lt;/p>
&lt;h4 id="锁消除">锁消除&lt;/h4>
&lt;p>锁消除指的是在某些情况下，JVM 虚拟机如果检测不到某段代码被共享和竞争的可能性，就会将这段代码所属的同步锁消除掉，从而到底提高程序性能的目的。&lt;/p>
&lt;p>锁消除的依据是&lt;strong>逃逸分析&lt;/strong>的数据支持，如 StringBuffer 的 append() 方法，或 Vector 的 add() 方法，在很多情况下是可以进行锁消除的&lt;/p>
&lt;h4 id="锁粗化">锁粗化&lt;/h4>
&lt;p>锁粗化是指，将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。&lt;/p>
&lt;p>我只听说锁“细化”可以提高程序的执行效率，也就是将锁的范围尽可能缩小，这样在锁竞争时，等待获取锁的线程才能更早的获取锁，从而提高程序的运行效率，但锁粗化是如何提高性能的呢？&lt;/p>
&lt;p>没错，锁细化的观点在大多数情况下都是成立了，但是一系列连续加锁和解锁的操作，也会导致不必要的性能开销，从而影响程序的执行效率，比如这段代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">public String method() {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> StringBuilder sb = new StringBuilder();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> for (int i = 0; i &amp;lt; 10; i++) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // 伪代码：加锁操作
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> sb.append(&amp;#34;i:&amp;#34; + i);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // 伪代码：解锁操作
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> return sb.toString();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果我们直接在 for 循环的外层加一把锁，那么对于同一个对象操作这段代码的性能就会提高很多&lt;/p>
&lt;h4 id="自适应自旋锁">自适应自旋锁&lt;/h4>
&lt;p>自适应自旋锁是指，自旋锁在 JDK 1.6 之后，引入了自适应自旋锁的机制，自旋锁的自适应性是指自旋的次数不再是固定的，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的。&lt;/p>
&lt;p>自旋锁优点在于它避免一些线程的挂起和恢复操作，因为挂起线程和恢复线程都需要从用户态转入内核态，这个过程是比较慢的，所以通过自旋的方式可以一定程度上避免线程挂起和恢复所造成的性能开销。&lt;/p>
&lt;p>但是，如果长时间自旋还获取不到锁，那么也会造成一定的资源浪费，所以我们通常会给自旋设置一个固定的值来避免一直自旋的性能开销。然而对于 synchronized 关键字来说，它的自旋锁更加的“智能”，synchronized 中的自旋锁是自适应自旋锁&lt;/p>
&lt;p>线程自旋的次数不再是固定的值，而是一个动态改变的值，这个值会根据前一次自旋获取锁的状态来决定此次自旋的次数。&lt;/p>
&lt;p>如果线程自旋成功了，则下次自旋的次数会增多，如果失败，下次自旋的次数会减少。&lt;/p>
&lt;h2 id="线程池">线程池&lt;/h2>
&lt;h3 id="线程池概念">线程池概念&lt;/h3>
&lt;p>线程池提供了一种限制和管理资源（包括执行一个任务）的方式。 每个线程池还维护一些基本统计信息，例如已完成任务的数量。&lt;/p>
&lt;p>好处:&lt;/p>
&lt;ul>
&lt;li>降低资源消耗: 通过重复利用已创建的线程降低线程创建和销毁造成的消耗。&lt;/li>
&lt;li>提高响应速度: 当任务到达时，任务可以不需要等到线程创建就能立即执行。&lt;/li>
&lt;li>提高线程的可管理性: 线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。&lt;/li>
&lt;/ul>
&lt;h3 id="创建线程池">创建线程池&lt;/h3>
&lt;ol>
&lt;li>通过ThreadPoolExecutor构造函数创建&lt;/li>
&lt;li>通过Executors工厂方法创建&lt;/li>
&lt;/ol>
&lt;h3 id="为什么不推荐使用内置线程池">为什么不推荐使用内置线程池&lt;/h3>
&lt;p>《阿里巴巴 Java 开发手册》中&lt;/p>
&lt;ul>
&lt;li>线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。&lt;/li>
&lt;li>强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 构造函数的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险&lt;/li>
&lt;/ul>
&lt;p>Java是如何实现和管理线程池的?&lt;/p>
&lt;p>从JDK 5开始，把工作单元与执行机制分离开来，工作单元包括Runnable和Callable，而执行机制由Executor框架提供。&lt;/p>
&lt;h4 id="有哪些实现好的线程池既然他们不推荐为什么java官方还要给你">有哪些实现好的线程池，既然他们不推荐，为什么Java官方还要给你&lt;/h4>
&lt;p>Java中提供了多种线程池实现，包括ThreadPoolExecutor、ScheduledThreadPoolExecutor、ForkJoinPool等。这些线程池实现都是经过优化和测试的，可以满足大部分场景的需求。&lt;/p>
&lt;p>虽然Java官方不推荐直接使用这些线程池实现，但是它们提供了一种可靠、高效的线程池实现，可以作为开发者自己实现线程池的参考。&lt;/p>
&lt;h3 id="executors工厂方法创建线程池">Executors工厂方法创建线程池&lt;/h3>
&lt;h4 id="fixedthreadpool">FixedThreadPool&lt;/h4>
&lt;p>该方法返回一个固定数量的线程池，该线程池中的线程数量始终不变。&lt;/p>
&lt;p>当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。&lt;/p>
&lt;p>弊端： 使用的是无界的LinkedBlockingQueue，可能会堆积大量的请求，从而导致OOM。&lt;/p>
&lt;h4 id="singlethreadexecutor">SingleThreadExecutor&lt;/h4>
&lt;p>该方法返回一个只有一个线程的线程池，若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。&lt;/p>
&lt;p>弊端同FixedThreadPool&lt;/p>
&lt;h4 id="cachedthreadpool">CachedThreadPool&lt;/h4>
&lt;p>该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。&lt;/p>
&lt;p>弊端： 使用的是SynchronousQueue，允许创建的线程数量为Integer.MAX_VALUE，可能会创建大量的线程，从而导致OOM。&lt;/p>
&lt;h4 id="scheduledthreadpool">ScheduledThreadPool&lt;/h4>
&lt;p>该方法返回一个固定数量的线程池，而且该线程池可以延迟或定时的执行任务。&lt;/p>
&lt;p>弊端： 使用的是无界的DelayedWorkQueue，队列最大长度为Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM。&lt;/p>
&lt;h3 id="线程池参数">线程池参数**&lt;/h3>
&lt;p>最重要的三个&lt;/p>
&lt;ul>
&lt;li>corePoolSize：核心线程数，即线程池中保留的线程数, 至少的线程数.&lt;/li>
&lt;li>maximumPoolSize：最大线程数，即线程池中允许的最大线程数。&lt;/li>
&lt;li>workQueue：任务队列，用于存储等待执行的任务。&lt;/li>
&lt;li>keepAliveTime：线程空闲时间，即当线程池中的线程空闲时间超过该值时，多余的线程会被销毁。&lt;/li>
&lt;li>unit：时间单位，用于指定keepAliveTime的时间单位。&lt;/li>
&lt;li>threadFactory：线程工厂，用于创建新的线程。&lt;/li>
&lt;li>handler：拒绝策略，用于处理无法处理的任务。&lt;/li>
&lt;/ul>
&lt;h3 id="线程池常用的阻塞队列">线程池常用的阻塞队列&lt;/h3>
&lt;p>新任务到来时，如果线程数量达到了corePoolSize，就将任务加入workQueue中.&lt;/p>
&lt;p>不同的阻塞队列对线程池的运行状态有不同的影响。&lt;/p>
&lt;ul>
&lt;li>ArrayBlockingQueue：基于数组的有界阻塞队列，按FIFO排序任务。&lt;/li>
&lt;li>LinkedBlockingQueue：基于链表的有界阻塞队列，按FIFO排序任务。&lt;/li>
&lt;li>SynchronousQueue：不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态。&lt;/li>
&lt;li>DelayQueue：基于优先级的延迟阻塞队列，按元素的延迟时间排序。&lt;/li>
&lt;/ul>
&lt;h3 id="线程池饱和策略">线程池饱和策略&lt;/h3>
&lt;p>AbortPolicy：直接抛出RejectedExecutionException异常。 CallerRunsPolicy：将任务交给调用线程来执行。 DiscardPolicy：直接丢弃任务，不做任何处理。&lt;/p>
&lt;h3 id="线程池的工作流程">线程池的工作流程&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/JUC%28Java%E5%B9%B6%E5%8F%91%29/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>新任务来了&lt;/p>
&lt;ol>
&lt;li>如果线程池中的线程数量小于corePoolSize，就创建新的线程来执行任务。&lt;/li>
&lt;li>如果线程池中的线程数量等于或大于corePoolSize，且小于maximumPoolSize，就将任务加入workQueue中。&lt;/li>
&lt;li>如果workQueue已满，且线程数量小于maximumPoolSize，就创建新的线程来执行任务。&lt;/li>
&lt;li>如果workQueue已满，且线程数量等于或大于maximumPoolSize，就执行拒绝策略。&lt;/li>
&lt;/ol>
&lt;h3 id="如何动态修改线程池参数">如何动态修改线程池参数&lt;/h3>
&lt;p>对 corePoolSize、maximumPoolSize、keepAliveTime 进行修改，可以通过 ThreadPoolExecutor 的 setCorePoolSize、setMaximumPoolSize、setKeepAliveTime 方法进行修改。&lt;/p>
&lt;p>因为这三个参数基本决定了线程池的基本行为，修改这三个参数后，线程池会重新调整线程数量。&lt;/p>
&lt;p>&lt;a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html" target="_blank" rel="noopener">美团的动态调参&lt;/a>&lt;/p>
&lt;p>从任务的优先级，任务的执行时间长短，任务的性质(CPU密集/ IO密集)，任务的依赖关系这四个角度来分析。&lt;/p>
&lt;p>并且近可能地使用有界的工作队列。性质不同的任务可用使用不同规模的线程池分开处理:&lt;/p>
&lt;p>CPU密集型: 尽可能少的线程，Ncpu+1&lt;/p>
&lt;ul>
&lt;li>保留一个线程用于处理其他辅助工作,如 I/O 操作、垃圾回收等。这样可以确保主要的 CPU 密集型任务有足够的资源,同时不会影响其他必要的工作。&lt;/li>
&lt;/ul>
&lt;p>IO密集型: 尽可能多的线程, Ncpu*2，比如数据库连接池&lt;/p>
&lt;p>混合型: CPU密集型的任务与IO密集型任务的执行时间差别较小，拆分为两个线程池；否则没有必要拆分。&lt;/p>
&lt;h3 id="如何设计根据任务优先级执行的线程池">如何设计根据任务优先级执行的线程池&lt;/h3>
&lt;p>可以使用 PriorityBlockingQueue 来存储任务，然后自定义任务类实现 Comparable 接口，根据优先级来排序。&lt;/p>
&lt;h3 id="如何解决oom">如何解决OOM&lt;/h3>
&lt;p>OOM：OutOfMemoryError 在使用线程池时，可能会因为线程池中的线程数量过多，导致内存溢出。&lt;/p>
&lt;p>解决方法：&lt;/p>
&lt;ul>
&lt;li>通过调整线程池的参数，如 corePoolSize、maximumPoolSize、keepAliveTime 等。&lt;/li>
&lt;li>通过使用有界的阻塞队列，如 ArrayBlockingQueue、LinkedBlockingQueue 等。&lt;/li>
&lt;li>通过使用拒绝策略，如 AbortPolicy、CallerRunsPolicy、DiscardPolicy、DiscardOldestPolicy 等。&lt;/li>
&lt;li>重写入队方法，实现自定义的拒绝策略。&lt;/li>
&lt;/ul>
&lt;h2 id="future">Future&lt;/h2>
&lt;p>Future接口是Java5中引入的，它用来表示异步计算的结果。&lt;/p>
&lt;p>是异步思想的体现，主要用于在一些耗时的操作中，先提交任务，然后去做其他的事情，等到任务完成后再来获取结果。&lt;/p>
&lt;p>Future模式看作是一种特殊的设计模式，思想是异步调用。&lt;/p>
&lt;p>Java中Future类是一个接口，它的实现类是FutureTask。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">// V 代表了Future执行的任务返回值的类型
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">public interface Future&amp;lt;V&amp;gt; {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // 取消任务执行
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // 成功取消返回 true，否则返回 false
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> boolean cancel(boolean mayInterruptIfRunning);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // 判断任务是否被取消
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> boolean isCancelled();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // 判断任务是否已经执行完成
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> boolean isDone();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // 获取任务执行结果
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> V get() throws InterruptedException, ExecutionException;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // 指定时间内没有返回计算结果就抛出 TimeOutException 异常
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> V get(long timeout, TimeUnit unit)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> throws InterruptedException, ExecutionException, TimeoutException;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="futuretask">FutureTask&lt;/h3>
&lt;p>FutureTask是Future的一个实现类，它实现了Runnable接口，所以它可以被线程执行。&lt;/p>
&lt;p>FutureTask可以用来包装Callable或Runnable对象。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">public class FutureTask&amp;lt;V&amp;gt; implements RunnableFuture&amp;lt;V&amp;gt; {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // 有两个构造函数
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // 1. 传入Callable对象
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public FutureTask(Callable&amp;lt;V&amp;gt; callable) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> if (callable == null)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> throw new NullPointerException();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> this.callable = callable;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> this.state = NEW; // ensure visibility of callable
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // 2. 传入Runnable对象和返回值
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public FutureTask(Runnable runnable, V result) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> this.callable = Executors.callable(runnable, result);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> this.state = NEW; // ensure visibility of callable
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>CompletableFuture是Java8中引入的一个类，它实现了Future和CompletionStage接口，可以用来表示一个异步计算的结果。&lt;/p>
&lt;p>解决了Future的局限性: 不支持组合、不支持异常处理、不支持回调机制。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">public class CompletableFuture&amp;lt;T&amp;gt; implements Future&amp;lt;T&amp;gt;, CompletionStage&amp;lt;T&amp;gt; {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="aqsreentrantlock的底层实现框架">AQS（ReentrantLock的底层实现框架）&lt;/h2>
&lt;p>AQS是AbstractQueuedSynchronizer的缩写，它是一个用来构建锁和同步器的框架。&lt;/p>
&lt;p>AQS是JUC包中的一个重要类，它是用来构建锁和同步器的框架。&lt;/p>
&lt;h3 id="aqs的设计思想">AQS的设计思想&lt;/h3>
&lt;p>AQS的设计思想是&lt;/p>
&lt;ul>
&lt;li>如果被请求的资源空闲，那么就将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。&lt;/li>
&lt;li>如果被请求的资源被占用，那么就需要一套&lt;strong>线程阻塞等待以及被唤醒时锁分配&lt;/strong>的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。&lt;/li>
&lt;/ul>
&lt;p>CLH队列是对自旋锁的一种改进，是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系），它将所有申请同步状态的线程封装成一个队列。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/JUC%28Java%E5%B9%B6%E5%8F%91%29/CLH%E9%98%9F%E5%88%97%E7%BB%93%E6%9E%84.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="aqs的实现原理">AQS的实现原理&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/JUC%28Java%E5%B9%B6%E5%8F%91%29/AQS%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>AQS 使用 int 成员变量 state 表示同步状态，通过内置的 FIFO 线程等待/等待队列 来完成获取资源线程的排队工作。&lt;/p>
&lt;p>state 变量由 volatile 修饰，用于展示当前临界资源的获锁情况。 &lt;code>private volatile int state;&lt;/code>&lt;/p>
&lt;h4 id="reentrantlock原理">ReentrantLock原理&lt;/h4>
&lt;p>以可重入的互斥锁 ReentrantLock 为例，它的内部维护了一个 state 变量，用来表示锁的占用状态。&lt;/p>
&lt;ul>
&lt;li>state 的初始值为 0，表示锁处于未锁定状态。当线程 A 调用 lock() 方法时，会尝试通过 tryAcquire() 方法独占该锁，并让 state 的值加 1。&lt;/li>
&lt;li>如果成功了，那么线程 A 就获取到了锁。&lt;/li>
&lt;li>如果失败了，那么线程 A 就会被加入到一个等待队列（CLH 队列）中，直到其他线程释放该锁。&lt;/li>
&lt;li>假设线程 A 获取锁成功了，释放锁之前，**A 线程自己是可以重复获取此锁的（state 会累加）。**这就是可重入性的体现：一个线程可以多次获取同一个锁而不会被阻塞。&lt;/li>
&lt;li>但是，这也意味着，&lt;strong>一个线程必须释放与获取的次数相同的锁&lt;/strong>，才能让 state 的值回到 0，也就是让锁恢复到未锁定状态。只有这样，其他等待的线程才能有机会获取该锁。&lt;/li>
&lt;/ul>
&lt;h2 id="juc工具类">JUC工具类&lt;/h2></description></item><item><title/><link>https://ysyyhhh.github.io/docs/language/java/jvm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/language/java/jvm/</guid><description>&lt;h1 id="jvm">JVM&lt;/h1>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/JVM/%e7%b3%bb%e7%bb%9f%e7%bb%93%e6%9e%84.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h2 id="todo类字节码">TODO:类字节码&lt;/h2>
&lt;p>JVM上运行的是字节码，而不是源代码。
字节码是一种中间代码，它是一种介于源代码和机器码之间的代码。字节码是由Java编译器编译生成的，它是一种与平台无关的代码，可以在任何支持Java虚拟机的平台上运行。&lt;/p>
&lt;p>JVM不仅支持Java语言，还支持其他语言，如Groovy、Kotlin、Scala等。这些语言都可以编译成字节码，然后在JVM上运行。&lt;/p>
&lt;h3 id="字节码文件">字节码文件&lt;/h3>
&lt;p>字节码文件是以.class为扩展名的文件，它包含了Java源代码编译生成的字节码。
字节码文件是一种二进制文件以8位字节为单位存储的，它包含了类的结构信息、字段信息、方法信息、接口信息等。&lt;/p>
&lt;p>class文件采用伪结构来存储, 有两种类型: 无符号数和表。&lt;/p>
&lt;p>无符号数: 占两个字节, 用于描述数字, 例如: u1, u2, u4, u8&lt;/p>
&lt;p>表: 由多个无符号数或其他表构成, 用于描述有层次关系的复合结构, 例如: 字段表, 方法表, 属性表&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/JVM/class%e6%96%87%e4%bb%b6%e7%bb%93%e6%9e%84.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="字节码增强技术">字节码增强技术&lt;/h3>
&lt;p>字节码增强技术是指在编译后的字节码文件中插入新的字节码，从而增强程序的功能。字节码增强技术可以用于实现AOP（Aspect-Oriented Programming）编程、动态代理、代码注入等功能。&lt;/p>
&lt;h2 id="类加载机制">类加载机制&lt;/h2>
&lt;h3 id="类的生命周期">类的生命周期&lt;/h3>
&lt;p>类的生命周期包括：加载、验证、准备、解析、初始化、使用和卸载。&lt;/p>
&lt;p>类加载的过程包括了: 加载、验证、准备、解析、初始化。&lt;/p>
&lt;p>其中解析的过程是可选的，可以在初始化阶段之后再进行。&lt;/p>
&lt;ul>
&lt;li>为了支持动态绑定&lt;/li>
&lt;/ul>
&lt;p>其余阶段按顺序开始,但是不一定按顺序结束.&lt;/p>
&lt;h3 id="类的加载">类的加载&lt;/h3>
&lt;p>类的加载是指将类的字节码文件加载到内存中，并创建一个Class对象，用于表示该类。&lt;/p>
&lt;p>在加载阶段,虚拟机需要完成:&lt;/p>
&lt;ul>
&lt;li>通过类的全限定名获取类的二进制字节流&lt;/li>
&lt;li>将字节流代表的静态存储结构转化为方法区的运行时数据结构&lt;/li>
&lt;li>在内存中生成一个代表这个类的java.lang.Class对象,作为方法区这个类的各种数据的访问入口&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/JVM/%e7%b1%bb%e7%9a%84%e5%8a%a0%e8%bd%bd.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>类加载器不需要等到&amp;quot;首次使用&amp;quot;时才加载类,而是在预料到类会被使用时就加载类. 如果在加载类的过程中遇到了错误,类加载器必须抛出异常,通知调用者类加载失败.&lt;/p>
&lt;p>加载class文件的方式:&lt;/p>
&lt;ul>
&lt;li>从本地系统中直接加载&lt;/li>
&lt;li>通过网络下载.class文件&lt;/li>
&lt;li>从zip,jar等归档文件中加载&lt;/li>
&lt;li>从数据库中读取.class文件&lt;/li>
&lt;li>将Java源文件动态编译为.class文件&lt;/li>
&lt;/ul>
&lt;h3 id="连接">连接&lt;/h3>
&lt;p>连接阶段包括了验证、准备和解析。&lt;/p>
&lt;h4 id="验证">验证&lt;/h4>
&lt;p>验证是确保加载的类符合JVM规范的过程。验证阶段的目的是确保被加载的类是合法、合理的，不会危害虚拟机的安全。&lt;/p>
&lt;p>验证阶段主要包括了四个方面的验证：&lt;/p>
&lt;ul>
&lt;li>文件格式验证：验证字节码文件是否符合JVM规范。&lt;/li>
&lt;li>元数据验证：验证字节码文件中的类、字段、方法等信息是否符合JVM规范。&lt;/li>
&lt;li>字节码验证：验证字节码文件中的字节码是否符合JVM规范。&lt;/li>
&lt;li>符号引用验证：验证字节码文件中的符号引用是否符合JVM规范。&lt;/li>
&lt;/ul>
&lt;h4 id="准备">准备&lt;/h4>
&lt;p>准备阶段是为类的&lt;strong>静态变量分配内存并设置初始值&lt;/strong>的过程。这些变量所使用的内存都将在方法区中进行分配.&lt;/p>
&lt;ul>
&lt;li>不包括实例变量,实例变量会在对象实例化时随着对象一起分配在Java堆中&lt;/li>
&lt;li>初始值是默认的零值,例如: 0, null&lt;/li>
&lt;/ul>
&lt;h4 id="解析">解析&lt;/h4>
&lt;p>解析阶段是将&lt;strong>常量池中的符号引用替换为直接引用&lt;/strong>的过程。&lt;/p>
&lt;p>解析阶段是可选的，可以在初始化阶段之后再进行。&lt;/p>
&lt;p>解析针对类或接口,字段,类方法,接口方法,方法类型,方法句柄,方法调用点限定符,动态调用点限定符这几类符号引用进行.&lt;/p>
&lt;p>符号引用包含了被引用项的名称、描述符以及其所在的类或接口的名称等信息. 但没有直接指向目标的指针, 为了使得方法调用可以实现动态连接,Java编译器会在Class文件中的常量池中留下一些符号引用,以便在运行期间将其解析为直接引用.&lt;/p>
&lt;h3 id="初始化">初始化&lt;/h3>
&lt;p>初始化阶段是执行初始化方法 &lt;clinit> ()方法的过程，是类加载的最后一步，这一步 JVM 才开始真正执行类中定义的 Java 程序代码(字节码)。&lt;/p>
&lt;!--
初始化是为类的静态变量赋予正确的初始值的过程。
对类变量进行初始值设定有两种方式:
- 声明变量时指定初始值
- 使用静态初始化块
JVM初始化步骤
- 如果这个类还没有被加载和连接,则先进行加载和连接
- 如果类的直接父类还没有被初始化,则先初始化其直接父类
- 如果类中有初始化语句,则依次执行这些初始化语句
类的初始化动机: 只有对类的主动使用才会导致类的初始化,主动使用包括:
- 创建类的实例, new
- 访问类的静态变量,或者为静态变量赋值
- 调用类的静态方法
- 反射,例如: Class.forName("com.example.Test")
- 初始化一个类的子类
- Java虚拟机启动时被标明为启动类的类,即main方法所在的类
类初始化的方式
- 构造函数
- 静态代码块 -->
&lt;h3 id="使用">使用&lt;/h3>
&lt;p>类访问方法区的数据,执行程序代码,调用方法等.&lt;/p>
&lt;p>对象是在堆中分配的,对象的实例变量也在堆中分配,但是对象的引用是在栈中分配的.&lt;/p>
&lt;h3 id="卸载">卸载&lt;/h3>
&lt;p>JVM结束声明周期的情况:&lt;/p>
&lt;ul>
&lt;li>执行了System.exit()方法&lt;/li>
&lt;li>程序正常结束&lt;/li>
&lt;li>程序异常结束&lt;/li>
&lt;li>由于操作系统错误导致JVM进程终止&lt;/li>
&lt;/ul>
&lt;h3 id="类加载器">类加载器&lt;/h3>
&lt;p>类加载器是用于加载类的对象，它负责将类的字节码文件加载到内存中，并创建一个Class对象，用于表示该类。&lt;/p>
&lt;p>分为三种:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>启动类&lt;/strong>加载器: Bootstrap ClassLoader
&lt;ul>
&lt;li>负责加载JRE/lib下, 或 -Xbootclasspath选项指定的路径中的核心类库&lt;/li>
&lt;li>由C++实现,不是Java类&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>扩展类&lt;/strong>加载器: Extension ClassLoader
&lt;ul>
&lt;li>负责加载JRE/lib/ext目录下的扩展类库,如javax.*开头的类&lt;/li>
&lt;li>由Java实现,是sun.misc.Launcher$ExtClassLoader类&lt;/li>
&lt;li>开发者可以直接使用扩展类加载器&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>应用程序类&lt;/strong>加载器: Application ClassLoader
&lt;ul>
&lt;li>负责加载用户类路径上的类库&lt;/li>
&lt;li>由Java实现,是sun.misc.Launcher$AppClassLoader类&lt;/li>
&lt;li>开发者可以直接使用应用程序类加载器&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器
因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点:&lt;/p>
&lt;ul>
&lt;li>在执行非置信代码之前，自动验证数字签名。&lt;/li>
&lt;li>动态地创建符合用户特定需要的定制化构建类。&lt;/li>
&lt;li>从特定的场所取得java class，例如数据库中和网络中。&lt;/li>
&lt;/ul>
&lt;h4 id="寻找类加载器">寻找类加载器&lt;/h4>
&lt;p>类加载器的寻找顺序是: 启动类加载器 -&amp;gt; 扩展类加载器 -&amp;gt; 应用程序类加载器&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">package&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">com.pdai.jvm.classloader&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">ClassLoaderTest&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">static&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">args&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">ClassLoader&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">loader&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Thread&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">currentThread&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="na">getContextClassLoader&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">loader&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">loader&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">getParent&lt;/span>&lt;span class="p">());&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">loader&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">getParent&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="na">getParent&lt;/span>&lt;span class="p">());&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="类的加载-1">类的加载&lt;/h3>
&lt;p>类的加载有三种方式:&lt;/p>
&lt;ul>
&lt;li>命令行启动应用时候由JVM初始化加载&lt;/li>
&lt;li>通过Class.forName()方法动态加载&lt;/li>
&lt;li>通过ClassLoader.loadClass()方法动态加载&lt;/li>
&lt;/ul>
&lt;h3 id="jvm类加载机制">JVM类加载机制&lt;/h3>
&lt;p>JVM类加载机制是指JVM在加载类的过程中所采取的策略和步骤。&lt;/p>
&lt;p>全盘负责: 一个类加载器负责加载一个类,如果一个类加载器加载了一个类,那么这个类所依赖的和引用的类也由这个类加载器负责加载.&lt;/p>
&lt;p>父类委托: 一个类加载器在加载类时,先委托给其父类加载器加载,如果父类加载器无法加载,则自己加载.&lt;/p>
&lt;p>缓存机制: 保证所有加载过的类都会被缓存,当程序中需要使用某个类时,类加载器会先从缓存中搜索这个类,只有当缓存中不存在这个类时,类加载器才会去加载这个类.&lt;/p>
&lt;h3 id="类加载器的双亲委派模型">类加载器的双亲委派模型&lt;/h3>
&lt;p>双亲委派模型是指类加载器在加载类时，会先委托给其父类加载器加载，只有在父类加载器无法加载时，才会自己加载。&lt;/p>
&lt;ol>
&lt;li>当AppClassLoader加载一个类时,它首先不会自己去尝试加载这个类,而是把类加载请求委派给父类加载器ExtClassLoader去完成&lt;/li>
&lt;li>当ExtClassLoader加载一个类时,它首先不会自己去尝试加载这个类,而是把类加载请求委派给BootstrapClassLoader去完成&lt;/li>
&lt;li>如果BootstrapClassLoader加载失败(在rt.jar中找不到所需类),会把类加载请求委派给ExtClassLoader&lt;/li>
&lt;li>如果ExtClassLoader加载失败(在jre/lib/ext中找不到所需类),会把类加载请求委派给AppClassLoader&lt;/li>
&lt;li>如果AppClassLoader加载失败(在用户类路径下找不到所需类),会抛出ClassNotFoundException&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Class&lt;/span>&lt;span class="o">&amp;lt;?&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">loadClass&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="kd">throws&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ClassNotFoundException&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">loadClass&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">false&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">protected&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">synchronized&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Class&lt;/span>&lt;span class="o">&amp;lt;?&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">loadClass&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">boolean&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">resolve&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="kd">throws&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ClassNotFoundException&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 首先判断该类型是否已经被加载&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">Class&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">findLoadedClass&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">if&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">==&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">//如果没有被加载，就委托给父类加载或者委派给启动类加载器加载&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">try&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">if&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">parent&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">!=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">//如果存在父类加载器，就委派给父类加载器加载&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">parent&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">loadClass&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">false&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">else&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">//如果不存在父类加载器，就检查是否是由启动类加载器加载的类，通过调用本地方法native Class findBootstrapClass(String name)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">findBootstrapClass0&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">catch&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ClassNotFoundException&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 如果父类加载器和启动类加载器都不能完成加载任务，才调用自身的加载功能&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">findClass&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">if&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">resolve&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">resolveClass&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>优势:&lt;/p>
&lt;ul>
&lt;li>避免类的重复加载, 防止内存中出现多份同样的字节码&lt;/li>
&lt;li>保护程序安全, 防止核心API被随意篡改&lt;/li>
&lt;/ul>
&lt;h3 id="自定义类加载器">自定义类加载器&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">package&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">com.pdai.jvm.classloader&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kn">import&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">java.io.*&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">MyClassLoader&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">extends&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ClassLoader&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">protected&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Class&lt;/span>&lt;span class="o">&amp;lt;?&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">findClass&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">throws&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ClassNotFoundException&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kt">byte&lt;/span>&lt;span class="o">[]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">classData&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">loadClassData&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">if&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">classData&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">==&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">throw&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ClassNotFoundException&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">else&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">defineClass&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">classData&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">classData&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">length&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">byte&lt;/span>&lt;span class="o">[]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">loadClassData&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">className&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">fileName&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">File&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">separatorChar&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">className&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">replace&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sc">&amp;#39;.&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">File&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">separatorChar&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;.class&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">try&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">InputStream&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ins&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">FileInputStream&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">fileName&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">ByteArrayOutputStream&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">baos&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ByteArrayOutputStream&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">bufferSize&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">1024&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kt">byte&lt;/span>&lt;span class="o">[]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">buffer&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">byte&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">bufferSize&lt;/span>&lt;span class="o">]&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">length&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">while&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="n">length&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ins&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">read&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">buffer&lt;/span>&lt;span class="p">))&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">!=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">baos&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">write&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">buffer&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">length&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">baos&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">toByteArray&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">catch&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">IOException&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">printStackTrace&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">getRoot&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">setRoot&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">root&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">static&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">args&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">MyClassLoader&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">classLoader&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">MyClassLoader&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">classLoader&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">setRoot&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;D:\\temp&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">Class&lt;/span>&lt;span class="o">&amp;lt;?&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">testClass&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">try&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">testClass&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">classLoader&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">loadClass&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;com.pdai.jvm.classloader.Test2&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">Object&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">object&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">testClass&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">newInstance&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">object&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">getClass&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="na">getClassLoader&lt;/span>&lt;span class="p">());&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">catch&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ClassNotFoundException&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">printStackTrace&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">catch&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">InstantiationException&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">printStackTrace&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">catch&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">IllegalAccessException&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">printStackTrace&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>自定义类加载器的核心在于对字节码文件的获取，如果是加密的字节码则需要在该类中对文件进行解密。由于这里只是演示，我并未对class文件进行加密，因此没有解密的过程。&lt;/p>
&lt;p>这里有几点需要注意 :
1、这里传递的文件名需要是类的全限定性名称，即com.pdai.jvm.classloader.Test2格式的，因为 defineClass 方法是按这种格式进行处理的。
2、最好不要重写loadClass方法，因为这样容易破坏双亲委托模式。
3、这类Test 类本身可以被 AppClassLoader 类加载，因此我们不能把com/pdai/jvm/classloader/Test2.class 放在类路径下。否则，由于双亲委托机制的存在，会直接导致该类由 AppClassLoader 加载，而不会通过我们自定义类加载器来加载。&lt;/p>
&lt;h2 id="java-内存区域">Java 内存区域&lt;/h2>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/JVM/%e8%bf%90%e8%a1%8c%e6%97%b6%e6%95%b0%e6%8d%ae%e5%8c%ba.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>线程私有的：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>程序计数器&lt;/strong>&lt;/li>
&lt;li>&lt;strong>虚拟机栈&lt;/strong>&lt;/li>
&lt;li>&lt;strong>本地方法栈&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>线程共享的：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>堆&lt;/strong>&lt;/li>
&lt;li>&lt;strong>方法区&lt;/strong>&lt;/li>
&lt;li>直接内存 (非运行时数据区的一部分)&lt;/li>
&lt;/ul>
&lt;p>Java 虚拟机规范对于运行时数据区域的规定是相当宽松的。以堆为例：堆可以是连续空间，也可以不连续。堆的大小可以固定，也可以在运行时按需扩展 。&lt;/p>
&lt;p>虚拟机实现者可以使用任何垃圾回收算法管理堆，甚至完全不进行垃圾收集也是可以的。&lt;/p>
&lt;p>程序计数器的功能是记录当前线程执行的字节码指令的地址，从而实现线程切换和恢复。&lt;/p>
&lt;p>程序计数器是线程私有的，是为了线程切换时能够正确恢复执行现场。&lt;/p>
&lt;p>虚拟机栈：每个线程在创建时都会创建一个虚拟机栈，用于存放线程的方法调用栈、局部变量表、操作数栈等信息。（执行的是Java方法）&lt;/p>
&lt;p>本地方法栈：用于支持本地方法调用，即调用C/C++编写的本地方法。&lt;/p>
&lt;p>为了保证线程的局部变量不被其他线程访问，虚拟机栈和本地方法栈是线程私有的。&lt;/p>
&lt;h3 id="程序计数器">程序计数器&lt;/h3>
&lt;p>程序计数寄存器（Program Counter Register）
JVM 中的 PC 寄存器是对物理 PC 寄存器的一种抽象模拟。&lt;/p>
&lt;p>是一块较小的内存空间，它可以看作是&lt;strong>当前线程所执行的字节码的行号指示器&lt;/strong>。&lt;/p>
&lt;h4 id="作用">作用&lt;/h4>
&lt;ul>
&lt;li>字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令。&lt;/li>
&lt;li>它是线程私有的，每个线程都有一个独立的程序计数器,生命周期与线程的生命周期一致&lt;/li>
&lt;li>任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。
&lt;ul>
&lt;li>如果当前线程正在执行的是 Java 方法，程序计数器记录的是 JVM 字节码指令地址，如果是执行 native 方法，则是未指定值（undefined）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成&lt;/li>
&lt;li>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令&lt;/li>
&lt;li>它是唯一一个在 JVM 规范中没有规定任何 OutOfMemoryError 情况的区域&lt;/li>
&lt;/ul>
&lt;h3 id="java虚拟机栈">Java虚拟机栈&lt;/h3>
&lt;p>Java虚拟机栈内部保存一个个栈帧(Stack Frame),每个栈帧对应一个被调用的方法,每个栈帧包含了局部变量表(Local Variables)、操作数栈(Operand Stack)、动态链接(Dynamic Linking)、方法返回地址和一些额外的附加信息。&lt;/p>
&lt;p>作用: 主管Java方法的运行，它保存方法的局部变量（8种基本数据类型、对象引用）、部分中间运算结果，并参与方法的调用和返回。&lt;/p>
&lt;p>特点&lt;/p>
&lt;ul>
&lt;li>快速有效的分配存储方式, 访问速度快(仅次于程序计数器)&lt;/li>
&lt;li>JVM对虚拟机栈的操作只有两种:
&lt;ul>
&lt;li>每个方法执行时,创建一个栈帧;&lt;/li>
&lt;li>每个方法执行结束时,销毁一个栈帧&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>栈不存在垃圾回收问题&lt;/li>
&lt;/ul>
&lt;p>JVM规范允许虚拟机栈的大小是动态的或者是固定的&lt;/p>
&lt;ul>
&lt;li>固定大小的虚拟机栈在创建时就被确定,不会改变
&lt;ul>
&lt;li>如果线程请求的栈深度大于虚拟机所允许的深度,将抛出StackOverflowError异常&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>动态扩展的虚拟机栈在栈扩展时无法申请到足够的内存,会抛出OutOfMemoryError异常&lt;/li>
&lt;/ul>
&lt;h4 id="栈帧----栈的存储单位">栈帧 &amp;ndash; 栈的存储单位&lt;/h4>
&lt;ul>
&lt;li>每个线程有自己的栈,栈的数据由栈帧组成&lt;/li>
&lt;li>线程中正在执行的每个方法都对应一个栈帧&lt;/li>
&lt;li>栈帧是一个内存区块,是一个数据集,维系着方法的执行状态&lt;/li>
&lt;/ul>
&lt;p>每个栈帧存储着:&lt;/p>
&lt;ul>
&lt;li>局部变量表(Local Variables)&lt;/li>
&lt;li>操作数栈(Operand Stack): 用于存储方法执行过程中的临时数据&lt;/li>
&lt;li>动态链接(Dynamic Linking): 指向运行时常量池中该栈帧所属方法的引用&lt;/li>
&lt;li>方法返回地址(Method Return Address): 指向方法的调用者&lt;/li>
&lt;li>其他信息&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/JVM/%e6%a0%88%e5%b8%a7%e7%9a%84%e7%bb%93%e6%9e%84.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>TODO:详细的栈帧结构&lt;/p>
&lt;h4 id="栈运行原理">栈运行原理&lt;/h4>
&lt;ul>
&lt;li>JVM对栈的操作:
&lt;ul>
&lt;li>每个方法执行时,创建一个栈帧;&lt;/li>
&lt;li>每个方法执行结束时,销毁一个栈帧&lt;/li>
&lt;li>遵循栈的&amp;quot;先进后出&amp;quot;原则&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>在一个活动线程的某一个时间点上,只有一个活动的栈帧,对应着当前正在执行的方法&lt;/li>
&lt;li>所有字节码指令只针对当前栈帧进行操作&lt;/li>
&lt;li>如果调用了其他方法,会创建新的栈帧,并压入栈顶
&lt;ul>
&lt;li>在方法返回之后,栈帧会被销毁,并且栈顶的栈帧会成为当前栈帧&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>有两种返回指令:
&lt;ul>
&lt;li>一种是正常的方法返回指令,&lt;/li>
&lt;li>另一种是异常返回指令&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="本地方法栈">本地方法栈&lt;/h3>
&lt;p>本地方法栈与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的 Native 方法服务。(C实现的)&lt;/p>
&lt;p>本地方法栈也是线程私有的&lt;/p>
&lt;p>允许线程请求本地方法栈的大小是动态的或者固定的&lt;/p>
&lt;p>具体做法:&lt;/p>
&lt;ul>
&lt;li>在&lt;code>Native Method Stack&lt;/code>中登记native方法&lt;/li>
&lt;li>在&lt;code>Execution Engine&lt;/code>执行时,调用&lt;code>Native Method Stack&lt;/code>中的方法&lt;/li>
&lt;li>和虚拟机有同样的权限&lt;/li>
&lt;/ul>
&lt;p>在 Hotspot JVM 中，直接将本地方法栈和虚拟机栈合二为一&lt;/p>
&lt;h3 id="java堆">Java堆&lt;/h3>
&lt;p>Java堆是Java虚拟机所管理的内存中最大的一块，是被所有线程共享的一块内存区域。&lt;/p>
&lt;p>Java堆是垃圾收集器管理的主要区域，也被称为“GC堆”。&lt;/p>
&lt;p>作用: 存放对象实例，几乎所有的对象实例都在这里分配内存。&lt;/p>
&lt;p>为了高效的进行GC, 堆内存&lt;strong>逻辑上&lt;/strong>被划分为:&lt;/p>
&lt;ul>
&lt;li>新生代(年轻代):
&lt;ul>
&lt;li>新对象&lt;/li>
&lt;li>还没到达一定年龄的对象&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>老年代:
&lt;ul>
&lt;li>被长时间使用的对象&lt;/li>
&lt;li>老年代的内存空间一般比新生代大很多&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>元空间:
&lt;ul>
&lt;li>JDK1.8前是永久代, 占用JVM内存&lt;/li>
&lt;li>JDK1.8后是元空间, 占用系统内存&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>Java 虚拟机规范规定，Java 堆可以是处于物理上不连续的内存空间中，只要逻辑上是连续的即可，像磁盘空间一样。实现时，既可以是固定大小，也可以是可扩展的，主流虚拟机都是可扩展的（通过 -Xmx 和 -Xms 控制），如果堆中没有完成实例分配，并且堆无法再扩展时，就会抛出 OutOfMemoryError 异常&lt;/p>
&lt;h4 id="年轻代">年轻代&lt;/h4>
&lt;p>年轻代分为三个部分(分配一般为8:1:1)&lt;/p>
&lt;ul>
&lt;li>Eden区(伊甸园): 存放新创建的对象&lt;/li>
&lt;li>Survivor区(幸存者区): 存放经过一次GC后仍然存活的对象
&lt;ul>
&lt;li>Survivor区一般有两个, 一个是From, 一个是To&lt;/li>
&lt;li>每次GC后, Eden区和From Survivor区中的存活对象会被复制到To Survivor区&lt;/li>
&lt;li>每次GC后, From Survivor区和To Survivor区会交换角色&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>过程&lt;/p>
&lt;ul>
&lt;li>新创建的对象会被分配到Eden区&lt;/li>
&lt;li>当Eden区满时,会触发一次Minor GC,将Eden区中的存活对象复制到Survivor区&lt;/li>
&lt;li>Minor GC检查Survivor区中的存活对象,将存活对象复制到另一个Survivor区, 所以每次都有一个Survivor区是空的&lt;/li>
&lt;li>经过多次Minor GC后,存活时间较长的对象会被移动到老年代, 通过设定年龄阈值来实现.&lt;/li>
&lt;/ul>
&lt;h4 id="老年代">老年代&lt;/h4>
&lt;p>老年代主要存放经过多次GC仍然存活的对象。&lt;/p>
&lt;p>老年代垃圾收集称为主GC&lt;/p>
&lt;p>大对象直接进入老年代, 这样可以避免在Eden区和两个Survivor区之间来回复制大对象&lt;/p>
&lt;h4 id="元空间">元空间&lt;/h4>
&lt;p>可以看作是 Java 虚拟机规范中方法区的实现。&lt;/p>
&lt;p>虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫 Non-Heap（非堆），目的应该是与 Java 堆区分开。&lt;/p>
&lt;h4 id="设置堆大小-和-oom">设置堆大小 和 OOM&lt;/h4>
&lt;p>通过-Xmx 和 -Xms 控制堆的大小&lt;/p>
&lt;ul>
&lt;li>-Xmx: 最大堆大小&lt;/li>
&lt;li>-Xms: 初始堆大小&lt;/li>
&lt;/ul>
&lt;p>如果堆中没有完成实例分配，并且堆无法再扩展时，就会抛出 OutOfMemoryError 异常&lt;/p>
&lt;p>通常这两个参数设置成一样的值，可以减少堆大小调整的次数，从而提高性能。&lt;/p>
&lt;p>默认情况下，Xmx是物理内存的1/4，Xms是1/64&lt;/p>
&lt;p>堆内存的分配:&lt;/p>
&lt;ul>
&lt;li>新生代:老年代 = 1:2, 通过-XX:NewRatio设置&lt;/li>
&lt;li>新生代中的Eden:From:To = 8:1:1, 通过-XX:SurvivorRatio设置&lt;/li>
&lt;/ul>
&lt;p>每次GC后会重新计算Eden区和Survivor区的大小
计算依据是GC过程中统计的GC时间、吞吐量、内存占用量&lt;/p>
&lt;h4 id="对象在堆的声明周期">对象在堆的声明周期&lt;/h4>
&lt;ul>
&lt;li>对象的创建&lt;/li>
&lt;li>对象被定义了一个 年轻对象计数器&lt;/li>
&lt;li>当Eden空间不足时, Minor GC
&lt;ul>
&lt;li>Eden移动到Survivor区&lt;/li>
&lt;li>所有对象年龄+1&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>如果超过了-XX:PetenureSizeThreshold(默认15次), 分配到老年区&lt;/li>
&lt;/ul>
&lt;h4 id="对象的分配过程">对象的分配过程&lt;/h4>
&lt;ul>
&lt;li>老年区内存不足时, 触发Major GC&lt;/li>
&lt;li>如果Major GC后, 仍然没有足够的内存, 抛出OOM异常&lt;/li>
&lt;/ul>
&lt;h4 id="minor-gcmajor-gcfull-gc">Minor GC、Major GC、Full GC&lt;/h4>
&lt;p>见&lt;a href="###%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e4%b8%8e%e5%9b%9e%e6%94%b6%e7%ad%96%e7%95%a5">内存分配与回收&lt;/a>&lt;/p>
&lt;h4 id="tlabthread-local-allocation-buffer">TLAB(Thread Local Allocation Buffer)&lt;/h4>
&lt;p>从内存模型角度, 对Eden区继续划分, 为每个线程分配一个私有的缓冲区, 在TLAB中分配对象, 减少线程间的竞争
这种内存分配方式称为快速分配策略&lt;/p>
&lt;p>TLAB的意义&lt;/p>
&lt;ul>
&lt;li>堆是线程共享的, 多线程并发分配对象时, 会出现竞争&lt;/li>
&lt;li>对象实例的创建非常频繁, 因此在并发环境下从堆区中划分内存空间是线程不安全的&lt;/li>
&lt;li>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度&lt;/li>
&lt;/ul>
&lt;p>尽管不是所有的对象实例都能够在 TLAB 中成功分配内存，但 JVM 确实是将 TLAB 作为内存分配的首选。&lt;/p>
&lt;h4 id="堆是分配对象的唯一选择吗逃逸分析">堆是分配对象的唯一选择吗？(逃逸分析)&lt;/h4>
&lt;p>不是, 有些对象不会分配到堆中.&lt;/p>
&lt;p>逃逸分析(Escape Analysis)是可以有效减少 Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法.&lt;/p>
&lt;p>通过逃逸分析, 可以分析出一个新的对象的引用的使用范围, 如果发现一个对象的引用并没有逃逸出方法的话, 那么就可以将这个对象在栈上分配, 而不是在堆上分配.&lt;/p>
&lt;p>基本行为, 分析对象动态作用域:&lt;/p>
&lt;ul>
&lt;li>只在方法内部使用, 没有发生逃逸&lt;/li>
&lt;li>被外部方法引用, 发生逃逸
&lt;ul>
&lt;li>如返回值, 赋值给全局变量等&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">static&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">StringBuffer&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">craeteStringBuffer&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s2&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">StringBuffer&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">sb&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">StringBuffer&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">sb&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s1&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">sb&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s2&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">sb&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样是发生逃逸的, 虽然它是一个局部变量,但还有可能被其他方法引用,所以会分配到堆上.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">static&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">createStringBuffer&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s2&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">StringBuffer&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">sb&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">StringBuffer&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">sb&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s1&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">sb&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s2&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">sb&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">toString&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>不直接返回StringBuffer, 而是返回String, 这样就不会发生逃逸, 可以分配到栈上.&lt;/p>
&lt;p>在 JDK 6u23 版本之后，HotSpot 中默认就已经开启了逃逸分析&lt;/p>
&lt;p>编译器可以对代码做优化：&lt;/p>
&lt;ul>
&lt;li>栈上分配：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配&lt;/li>
&lt;li>同步省略：如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步分离对象或&lt;/li>
&lt;li>标量替换：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而存储在 CPU 寄存器&lt;/li>
&lt;/ul>
&lt;h3 id="方法区">方法区&lt;/h3>
&lt;p>方法区(Method Area)是各个线程共享的内存区域，它用于存储&lt;strong>已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码&lt;/strong>等数据。&lt;/p>
&lt;p>Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是方法区有一个别名叫 Non-Heap（非堆），目的应该是与 Java 堆区分开。&lt;/p>
&lt;p>常量池是方法区的一部分，用于存放编译期生成的各种字面量和符号引用。&lt;/p>
&lt;p>方法区的大小可以固定也可以扩展&lt;/p>
&lt;p>方法区（method area）只是 JVM 规范中定义的一个概念，用于存储类信息、常量池、静态变量、JIT编译后的代码等数据，并没有规定如何去实现它，不同的厂商有不同的实现。而永久代（PermGen）是 Hotspot 虚拟机特有的概念， Java8 的时候又被元空间取代了，永久代和元空间都可以理解为方法区的落地实现。&lt;/p>
&lt;p>永久代物理是堆的一部分，和新生代，老年代地址是连续的（受垃圾回收器管理），而元空间存在于本地内存（我们常说的堆外内存，不受垃圾回收器管理），这样就不受 JVM 限制了，也比较难发生OOM（都会有溢出异常）&lt;/p>
&lt;h4 id="方法区的内部结构">方法区的内部结构&lt;/h4>
&lt;p>方法区用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。&lt;/p>
&lt;p>类型信息: 类型的全限定名、字段、方法、接口等信息&lt;/p>
&lt;p>域信息: 域的名称、类型、修饰符等信息&lt;/p>
&lt;p>方法信息: 方法的名称、参数、返回值、修饰符等信息&lt;/p>
&lt;h4 id="运行时常量池">运行时常量池&lt;/h4>
&lt;p>JVM 为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的&lt;/p>
&lt;h4 id="todo-方法区的垃圾回收">TODO: 方法区的垃圾回收&lt;/h4>
&lt;h3 id="java对象在内存中的布局">Java对象在内存中的布局&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/JVM/Java%e5%af%b9%e8%b1%a1%e5%9c%a8%e5%86%85%e5%ad%98%e4%b8%ad%e7%9a%84%e5%b8%83%e5%b1%80.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;ul>
&lt;li>对象头(Header)
&lt;ul>
&lt;li>Mark Word: 存储对象的hashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等信息&lt;/li>
&lt;li>Class Metadata Address: 类型指针指向对象的类元数据，JVM通过这个指针确定该对象是哪个类的实例&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>实例数据(Instance Data)
&lt;ul>
&lt;li>存储对象真正有效的数据信息&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>对齐填充(Padding)
&lt;ul>
&lt;li>由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，填充数据不是必然存在的，仅仅是为了字节对齐&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="jvm垃圾回收机制">JVM垃圾回收机制&lt;/h2>
&lt;h3 id="判断一个对象是否可被回收">判断一个对象是否可被回收&lt;/h3>
&lt;h4 id="引用计数法">引用计数法&lt;/h4>
&lt;p>引用计数法是一种最直观的判断对象是否可被回收的方法，它的基本思想是通过引用计数来判断一个对象是否可袝回收。&lt;/p>
&lt;p>但由于循环引用的存在，这种方法并不可靠,JVM不使用&lt;/p>
&lt;h4 id="可达性分析法">可达性分析法&lt;/h4>
&lt;p>通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/JVM/GC%20Roots.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>GC Roots 一般包括:&lt;/p>
&lt;ul>
&lt;li>虚拟机栈中引用的对象&lt;/li>
&lt;li>本地方法栈中引用的对象&lt;/li>
&lt;li>方法区中类静态属性引用的对象&lt;/li>
&lt;li>方法区中常量引用的对象&lt;/li>
&lt;/ul>
&lt;h4 id="方法区的回收">方法区的回收&lt;/h4>
&lt;p>因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，因此在方法区上进行回收性价比不高。&lt;/p>
&lt;p>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型。&lt;/p>
&lt;p>在大量使用反射、动态代理、CGLib 等 ByteCode 框架、动态生成 JSP 以及 OSGi 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载功能，以保证不会出现内存溢出。&lt;/p>
&lt;p>方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近 Java 语言层次的常量概念，如文本字符串、被声明为 final 的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：类和接口的全限定名字段的名称和描述符方法的名称和描述符&lt;/p>
&lt;p>HotSpot 虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收&lt;/p>
&lt;p>判定一个类型是否属于“不再被使用的类”，需要同时满足三个条件：&lt;/p>
&lt;ul>
&lt;li>该类所有的实例都已经被回收，也就是堆中不存在该类的任何实例。&lt;/li>
&lt;li>加载该类的 ClassLoader 已经被回收。&lt;/li>
&lt;li>该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。&lt;/li>
&lt;/ul>
&lt;h4 id="finalize方法">finalize()方法&lt;/h4>
&lt;p>finalize() 类似于 C++中的析构函数，用于对象在被垃圾收集器回收之前调用。&lt;/p>
&lt;p>当一个对象可被回收时，垃圾收集器会调用该对象的 finalize() 方法，然后回收该对象。&lt;/p>
&lt;p>通过finalize()方法，可以使对象在被回收之前进行一些清理工作，比如关闭文件、释放资源等。(自救,但只能进行一次)&lt;/p>
&lt;h3 id="引用类型">引用类型&lt;/h3>
&lt;h4 id="强引用">强引用&lt;/h4>
&lt;p>强引用是指在程序代码之中普遍存在的，类似“Object obj = new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收被引用的对象。&lt;/p>
&lt;h4 id="软引用">软引用&lt;/h4>
&lt;p>被软引用关联的对象，只有在内存不足的时候才会被回收。&lt;/p>
&lt;p>通过 SoftReference 类来实现软引用。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="n">SoftReference&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Object&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">softRef&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">SoftReference&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Object&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Object&lt;/span>&lt;span class="p">());&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="弱引用">弱引用&lt;/h4>
&lt;p>被弱引用关联的对象，只能生存到下一次垃圾收集发生之前。&lt;/p>
&lt;p>通过 WeakReference 类来实现弱引用。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="n">WeakReference&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Object&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">weakRef&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">WeakReference&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Object&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Object&lt;/span>&lt;span class="p">());&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="虚引用">虚引用&lt;/h4>
&lt;p>虚引用是最弱的一种引用关系，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获取一个对象实例。&lt;/p>
&lt;p>为一个对象设置虚引用的唯一目的是能在这个对象被收集器回收时收到一个系统通知。&lt;/p>
&lt;p>通过 PhantomReference 类来实现虚引用。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="n">ReferenceQueue&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Object&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">rq&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ReferenceQueue&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Object&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">PhantomReference&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Object&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">pr&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">PhantomReference&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Object&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Object&lt;/span>&lt;span class="p">(),&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">rq&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="垃圾收集算法">垃圾收集算法&lt;/h3>
&lt;h4 id="标记-清除算法">标记-清除算法&lt;/h4>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/JVM/%e6%a0%87%e8%ae%b0%e6%b8%85%e9%99%a4.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>将所有存活的对象标记，然后清除所有未标记的对象。&lt;/p>
&lt;p>缺点:&lt;/p>
&lt;ul>
&lt;li>标记和清除的效率都不高&lt;/li>
&lt;li>标记清除之后会产生大量不连续的内存碎片&lt;/li>
&lt;/ul>
&lt;h4 id="标记-整理算法">标记-整理算法&lt;/h4>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/JVM/%e6%a0%87%e8%ae%b0%e6%95%b4%e7%90%86.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>标记-整理算法是标记-清除算法的升级版，它在标记阶段完成后，会将存活的对象向一端移动，然后直接清理掉边界外的内存。&lt;/p>
&lt;h4 id="复制算法">复制算法&lt;/h4>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/JVM/%e5%a4%8d%e5%88%b6.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>将内存分为两块，每次只使用其中一块，当这一块内存用完了，就将还存活的对象复制到另一块内存上，然后清理掉原来的内存。&lt;/p>
&lt;p>缺点:&lt;/p>
&lt;ul>
&lt;li>内存使用率低&lt;/li>
&lt;li>适用于新生代&lt;/li>
&lt;/ul>
&lt;h4 id="分代收集算法">分代收集算法&lt;/h4>
&lt;p>根据对象存活周期的不同将内存划分为几块，一般是把堆分为新生代和老年代，根据各个年代的特点采用最适当的收集算法。&lt;/p>
&lt;h3 id="垃圾收集器">垃圾收集器&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/JVM/HotSpot%e7%9a%84%e4%b8%83%e4%b8%aa%e5%9e%83%e5%9c%be%e6%94%b6%e9%9b%86%e5%99%a8.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>可以从两个维度来划分：&lt;/p>
&lt;ul>
&lt;li>单线程和多线程: 单线程收集器只会使用一个线程进行垃圾回收，而多线程收集器则会使用多个线程进行垃圾回收。&lt;/li>
&lt;li>串行和并行: 串行收集器是指在垃圾回收时只使用一个线程，而并行收集器则是指在垃圾回收时使用多个线程。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。&lt;/li>
&lt;/ul>
&lt;h4 id="serial收集器">Serial收集器&lt;/h4>
&lt;p>单线程、串行、Client模型的默认新生代收集器&lt;/p>
&lt;p>优点：简单高效，对于单个CPU环境来说，没有线程交互的开销，可以获得最高的单线程收集效率。&lt;/p>
&lt;h4 id="parnew收集器">ParNew收集器&lt;/h4>
&lt;p>Serial收集器的多线程版本，Server模式下的默认新生代收集器&lt;/p>
&lt;p>除了Serial外，只有它能和CMS收集器配合工作&lt;/p>
&lt;h4 id="parallel-scavenge收集器">Parallel Scavenge收集器&lt;/h4>
&lt;p>其它收集器关注点是尽可能&lt;strong>缩短垃圾收集时用户线程的停顿时间&lt;/strong>，而它的目标是达到一个&lt;strong>可控制的吞吐量&lt;/strong>，它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户代码的时间占总时间的比值。&lt;/p>
&lt;p>缩短停顿时间是以牺牲吞吐量和新生代空间来换取的: 新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。&lt;/p>
&lt;p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。&lt;/p>
&lt;h4 id="serial-old收集器">Serial Old收集器&lt;/h4>
&lt;p>Serial收集器的老年代版本，使用单线程进行垃圾回收&lt;/p>
&lt;h4 id="parallel-old收集器">Parallel Old收集器&lt;/h4>
&lt;p>Parallel Scavenge收集器的老年代版本，使用多线程进行垃圾回收&lt;/p>
&lt;h4 id="cms收集器">CMS收集器&lt;/h4>
&lt;p>CMS（Concurrent Mark-Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，它非常符合那些集中在互联网站或者 B/S 系统的服务端上的 Java 应用，这些应用都非常重视服务的响应速度。&lt;/p>
&lt;p>Mark-Sweep（标记-清除）算法是 CMS 收集器的核心，它是一种获取最短回收停顿时间为目标的收集算法。&lt;/p>
&lt;p>流程：&lt;/p>
&lt;ul>
&lt;li>初始标记: 仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿&lt;/li>
&lt;li>并发标记: 进行 GC Roots Tracing 的过程， 耗时最长，不需要停顿&lt;/li>
&lt;li>重新标记: 为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，需要停顿&lt;/li>
&lt;li>并发清除: 与标记过程并发执行，不需要停顿&lt;/li>
&lt;/ul>
&lt;p>缺点&lt;/p>
&lt;ul>
&lt;li>吞吐量低&lt;/li>
&lt;li>无法处理浮动垃圾&lt;/li>
&lt;li>由于 CMS 收集器是基于标记-清除算法实现的，所以在清除阶段会产生大量的空间碎片&lt;/li>
&lt;/ul>
&lt;h4 id="g1收集器">G1收集器&lt;/h4>
&lt;p>G1（Garbage-First）收集器是一种面向服务端应用的垃圾收集器，适用于多核处理器和大容量内存的环境。&lt;/p>
&lt;p>G1 收集器的设计目标是取代 CMS 收集器，它同样是一种并发并行的垃圾收集器。&lt;/p>
&lt;p>堆被分为新生代和老年代，G1引入了Region的概念，将堆内存分为多个大小相等的Region，每个Region都有一个分代的角色，新生代和老年代不再是物理隔离的，而是逻辑上的概念。&lt;/p>
&lt;p>G1 收集器的运作大致可划分为以下几个步骤:&lt;/p>
&lt;ul>
&lt;li>初始标记&lt;/li>
&lt;li>并发标记&lt;/li>
&lt;li>最终标记: 为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。&lt;/li>
&lt;li>筛选回收: 首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。&lt;/li>
&lt;/ul>
&lt;p>具备如下特点:&lt;/p>
&lt;ul>
&lt;li>空间整合: 整体来看是基于“&lt;strong>标记-整理&lt;/strong>”算法实现的收集器，从局部(两个 Region 之间)上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。&lt;/li>
&lt;li>可预测的停顿: 能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。&lt;/li>
&lt;/ul>
&lt;p>CMS更适合低延迟、对停顿时间敏感的应用,如web服务器、交易系统等。
G1更适合中大型堆、需要良好的吞吐量和可预测停顿时间的应用,如大数据处理系统、游戏服务器等。&lt;/p>
&lt;h3 id="内存分配与回收策略">内存分配与回收策略&lt;/h3>
&lt;p>针对HotSpot虚拟机,按照回收区域分为两大类:&lt;/p>
&lt;ul>
&lt;li>部分收集
&lt;ul>
&lt;li>Minor GC/Young GC: 新生代的GC&lt;/li>
&lt;li>Major GC/Old GC: 老年代的GC
&lt;ul>
&lt;li>目前,只有CMS GC会有单独的Major GC&lt;/li>
&lt;li>很多时候, Major GC会和Full GC混在一起&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Mixed GC: 混合收集, 收集整个新生代和部分老年代
&lt;ul>
&lt;li>目前只有G1收集器会有Mixed GC&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>整堆收集
&lt;ul>
&lt;li>Full GC: 整堆收集,整个Java堆和方法区的垃圾&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>Major GC（Major Garbage Collection）和Mixed GC（Mixed Garbage Collection）是两种不同的垃圾回收机制，它们在执行时的行为和目标有所不同。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-md" data-lang="md">&lt;span class="line">&lt;span class="cl"> Major GC（也称为Full GC）是一种针对整个堆内存执行的垃圾回收操作。它的目标是清理整个堆内存，并回收无用对象。Major GC通常在堆内存空间不足或触发显式的垃圾回收请求时执行。它会停止应用程序的执行，并对整个堆内存进行标记和清理。Major GC的过程包括标记阶段和清理阶段，通过标记可达对象和清理未标记的对象来回收内存空间。
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Mixed GC（也称为Incremental GC）是一种结合了部分收集和全收集的垃圾回收操作。它的目标是在不完全停止应用程序的情况下，尽可能回收垃圾对象。Mixed GC通过将堆内存划分为多个区域（如年轻代和老年代的不同区域）来实现增量的回收。它会在应用程序执行的同时，对某些区域进行标记和清理操作。这样可以减少垃圾回收的停顿时间，提高应用程序的响应性能。
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 区别总结如下：
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 范围：Major GC是对整个堆内存执行的垃圾回收操作，而Mixed GC是对部分堆内存区域执行的垃圾回收操作。
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 目标：Major GC的目标是清理整个堆内存，并回收无用对象；Mixed GC的目标是在不完全停止应用程序的情况下，尽可能回收垃圾对象。
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 执行方式：Major GC会停止应用程序的执行，执行全面的标记和清理操作；Mixed GC会在应用程序执行的同时，对某些区域进行增量式的标记和清理操作。
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 停顿时间：Major GC的停顿时间较长，会导致应用程序的暂停；Mixed GC采用增量式的回收，可以减少垃圾回收的停顿时间，提高应用程序的响应性能。
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Java虚拟机和垃圾收集器的实现可以根据具体的需求和性能目标选择使用Major GC、Mixed GC或它们的组合来进行垃圾回收操作。
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="内存分配策略">内存分配策略&lt;/h4>
&lt;ul>
&lt;li>对象优先在Eden区分配&lt;/li>
&lt;li>大对象直接进入老年代&lt;/li>
&lt;li>长期存活的对象进入老年代&lt;/li>
&lt;li>动态对象年龄判定
&lt;ul>
&lt;li>如果在Eden区中经过一次Minor GC后,存活对象会被移动到Survivor区&lt;/li>
&lt;li>经过多次Minor GC后,存活时间较长的对象会被移动到老年代, 通过设定年龄阈值来实现.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>空间分配担保
&lt;ul>
&lt;li>在发生Minor GC之前,虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间&lt;/li>
&lt;li>如果条件成立,则Minor GC可以确保是安全的&lt;/li>
&lt;li>如果不成立,则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败
&lt;ul>
&lt;li>如果允许,则进行一次Full GC&lt;/li>
&lt;li>如果不允许,则改为进行一次Full GC&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="full-gc-的触发条件">Full GC 的触发条件&lt;/h4>
&lt;ul>
&lt;li>调用 System.gc() 方法&lt;/li>
&lt;li>老年代空间不足&lt;/li>
&lt;li>空间分配担保失败&lt;/li>
&lt;li>CMS GC时出现Promotion Failure&lt;/li>
&lt;/ul>
&lt;h2 id="jvm的内存模型">jvm的内存模型&lt;/h2>
&lt;h3 id="什么叫零拷贝">什么叫零拷贝&lt;/h3>
&lt;p>零拷贝（Zero Copy）是一种数据传输技术，它可以在不需要将数据从一个缓冲区复制到另一个缓冲区的情况下，将数据从一个地方传输到另一个地方。在零拷贝技术中，数据可以直接从磁盘、网络或其他设备中读取，然后通过DMA（Direct Memory Access）技术直接写入内存中，从而避免了数据的多次复制，提高了数据传输的效率。&lt;/p>
&lt;p>在Java中，零拷贝技术可以通过NIO（New I/O）来实现。NIO提供了一种基于通道（Channel）和缓冲区（Buffer）的I/O模型，可以直接将数据从通道中读取到缓冲区中，或者将缓冲区中的数据直接写入通道中，从而避免了数据的多次复制。&lt;/p>
&lt;h3 id="为什么用常量池有哪些常量池">为什么用常量池，有哪些常量池&lt;/h3>
&lt;p>&lt;a href="https://blog.csdn.net/qq_41376740/article/details/80338158" target="_blank" rel="noopener">https://blog.csdn.net/qq_41376740/article/details/80338158&lt;/a>&lt;/p>
&lt;p>常量池是Java中的一种特殊的内存区域，用于存储常量和符号引用。在Java中，常量池主要有以下几种：&lt;/p>
&lt;ol>
&lt;li>字面量常量池：用于存储字符串、数字等字面量常量。&lt;/li>
&lt;li>符号引用常量池：用于存储类、方法、字段等符号引用。&lt;/li>
&lt;li>运行时常量池：用于存储在类加载时解析的常量池信息，包括字面量常量池和符号引用常量池中的内容。&lt;/li>
&lt;/ol>
&lt;p>使用常量池的主要目的是为了提高程序的性能和减少内存的占用。由于常量池中的常量是唯一的，因此可以避免重复创建相同的常量对象，从而减少内存的占用。同时，由于常量池中的常量是在编译期间就确定的，因此可以在运行时直接使用，避免了重复计算和创建对象的开销，提高了程序的性能。&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/language/java/spring/3.18%E5%89%8D/code%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/language/java/spring/3.18%E5%89%8D/code%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</guid><description>&lt;h5 id="service层的返回值">Service层的返回值&lt;/h5>
&lt;p>service 做校验，如果非法，直接抛异常 + 全局异常处理&lt;/p>
&lt;p>controller 正常就是组合 service ，返回前端需要的数据。&lt;/p>
&lt;p>java异常效率低下是因为抛出异常会遍历所有涉及堆栈，具体代码在基类Throwable的fillInStackTrace()方法里。但其实可以通过在自定义异常中重写fillInStackTrace()来大幅度提高异常效率。&lt;/p>
&lt;p>&lt;a href="https://segmentfault.com/q/1010000020840854" target="_blank" rel="noopener">https://segmentfault.com/q/1010000020840854&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://blog.csdn.net/qq_41107231/article/details/115874974" target="_blank" rel="noopener">https://blog.csdn.net/qq_41107231/article/details/115874974&lt;/a>&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/language/java/spring/3.18%E5%89%8D/spring-cloud-alibaba/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/language/java/spring/3.18%E5%89%8D/spring-cloud-alibaba/</guid><description>&lt;h1 id="微服务">微服务&lt;/h1>
&lt;p>各个springboot&lt;/p>
&lt;h1 id="nacos注册中心">Nacos注册中心&lt;/h1>
&lt;h4 id="核心功能">核心功能&lt;/h4>
&lt;p>服务注册：&lt;/p>
&lt;p>服务心跳：&lt;/p>
&lt;p>服务同步：&lt;/p>
&lt;p>服务发现：拿到微服务地址&lt;/p>
&lt;p>服务调用：&lt;/p>
&lt;p>服务健康检查：&lt;/p>
&lt;h2 id="ribbon-负载均衡">Ribbon 负载均衡&lt;/h2>
&lt;h2 id="feign-优雅地调用远程服务">feign 优雅地调用远程服务&lt;/h2>
&lt;p>解决的是微服务之间调用问题&lt;/p>
&lt;h2 id="sentinel-服务容错">sentinel 服务容错&lt;/h2>
&lt;p>解决服务雪崩等问题&lt;/p>
&lt;h2 id="服务网关">服务网关&lt;/h2>
&lt;h3 id="解决的问题">解决的问题&lt;/h3>
&lt;p>解决客户端访问微服务的问题：&lt;/p>
&lt;ol>
&lt;li>维护微服务的多个地址&lt;/li>
&lt;li>认证 鉴权复杂&lt;/li>
&lt;li>跨域问题&lt;/li>
&lt;/ol>
&lt;p>所谓的API网关，就是指系统的统一入口。对于客服端来说，它封装了应用程序的内部结构，为客户端提供统一服务，一些&lt;strong>与业务本身功能无关&lt;/strong>的&lt;strong>公共逻辑&lt;/strong>可以在这里实现，诸如&lt;strong>认证、鉴权、监控、路由转发&lt;/strong>等等。&lt;/p>
&lt;h3 id="目前主流的解决方案">目前主流的解决方案&lt;/h3>
&lt;ul>
&lt;li>Ngnix+lua&lt;/li>
&lt;/ul>
&lt;p>使用nginx的&lt;strong>反向代理和负载均衡&lt;/strong>可实现对api服务器的负载均衡及高可用&lt;/p>
&lt;p>lua是一种脚本语言,可以来编写一些简单的逻辑, nginx支持lua脚本&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Kong&lt;/p>
&lt;p>基于Nginx+Lua开发，性能高，稳定，有多个可用的插件(限流、鉴权等等)可以开箱即用。 问题：&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>只支持Http协议；二次开发，自由扩展困难；提供管理API，缺乏更易用的管控、配置方式。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Zuul&lt;/p>
&lt;p>springboot1系列用的，Netflix开源的网关，功能丰富，使用JAVA开发，易于二次开发。Zuul 1.0 有问题：缺乏管控，无法动态配置；依赖组件较多；处理Http请求依赖的是Web容器，性能不如Nginx。&lt;/p>
&lt;p>Zuul有2.0&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Spring Cloud Gateway&lt;/p>
&lt;p>Spring公司为了替换Zuul而开发的网关服务，将在下面具体介绍。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Gateway&lt;/p>
&lt;p>缺点：&lt;/p>
&lt;ul>
&lt;li>其实现依赖Netty与WebFlux，不是传统的Servlet编程模型，学习成本高&lt;/li>
&lt;li>不能将其部署在Tomcat、Jetty等Servlet容器里，只能打成jar包执行&lt;/li>
&lt;li>需要Spring Boot 2.0及以上的版本，才支持&lt;/li>
&lt;/ul>
&lt;h3 id="路由-route">路由 route&lt;/h3>
&lt;p>路由(Route) 是 gateway 中最基本的组件之一，表示一个具体的路由信息载体。主要定义了下面的几个信息:&lt;/p>
&lt;p>id，路由标识符，区别于其他 Route，默认是一个随机的UID，最好自己起一个###&lt;/p>
&lt;p>uri，路由指向的目的地 uri，即客户端请求最终被转发到的微服务。&lt;/p>
&lt;p>order，用于多个 Route 之间的排序，数值越小排序越靠前，匹配优先级越高。&lt;/p>
&lt;p>predicate，断言的作用是进行条件判断，只有断言都返回真，才会真正的执行路由。&lt;/p>
&lt;p>filter，过滤器用于修改请求和响应信息。&lt;/p>
&lt;h3 id="断言">断言&lt;/h3>
&lt;p>predicate 用于条件判断，只有全部的断言为真，才实现路由转发。&lt;/p>
&lt;p>4.5.1 内置路由断言工厂&lt;/p>
&lt;p>可以自定义断言&lt;/p>
&lt;h3 id="过滤器">过滤器&lt;/h3>
&lt;ol>
&lt;li>作用：在请求过程中，对请求和响应做手脚&lt;/li>
&lt;li>生命周期：PRE 和 POST&lt;/li>
&lt;li>分类：局部过滤器（作用在一个路由上），全局过滤器（全部路由是）&lt;/li>
&lt;/ol>
&lt;p>PRE生命周期：在被路由之前调用，跨域实现验证身份，集群。&lt;/p>
&lt;p>POST生命周期：可以添加标准的Header，收集统计信息。&lt;/p>
&lt;h4 id="局部过滤器-gateaway">局部过滤器 GateAway&lt;/h4>
&lt;p>内置有很多，可以自定义&lt;/p>
&lt;h4 id="全局过滤器">全局过滤器&lt;/h4>
&lt;h4 id="网关限流">网关限流&lt;/h4>
&lt;p>用sentinel&lt;/p>
&lt;h2 id="mq消息队列">MQ消息队列&lt;/h2>
&lt;p>一般用于请求加快&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/language/java/spring/3.18%E5%89%8D/spring%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/language/java/spring/3.18%E5%89%8D/spring%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81/</guid><description>&lt;h5 id="jpa注解">JPA注解&lt;/h5>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">https://www.jianshu.com/p/38d247f02724
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="安全">安全&lt;/h5>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">https://blog.csdn.net/qq_37023928/article/details/116777630
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="解决前后端分离的跨域问题">解决前后端分离的跨域问题&lt;/h5>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">https://www.yisu.com/zixun/606000.html
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="创建test类注解">创建Test类注解&lt;/h5>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">@RunWith(SpringJUnit4ClassRunner.class)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">@SpringBootTest
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">依赖
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;lt;dependency&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;lt;artifactId&amp;gt;spring-boot-test&amp;lt;/artifactId&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;lt;/dependency&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;lt;dependency&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;lt;artifactId&amp;gt;spring-test&amp;lt;/artifactId&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;lt;/dependency&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="开启services">开启services&lt;/h5>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">Views -&amp;gt; Tool Windows -&amp;gt; Services
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="spring容器中找不到servletwebserverfactory类出现的异常">&lt;strong>Spring容器中找不到ServletWebServerFactory类出现的异常&lt;/strong>&lt;/h5>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">https://cloud.tencent.com/developer/article/1893349
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title/><link>https://ysyyhhh.github.io/docs/language/java/spring/3.18%E5%89%8D/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/language/java/spring/3.18%E5%89%8D/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/</guid><description>&lt;h2 id="实体类命名">实体类命名&lt;/h2>
&lt;p>1.分层领域模型规约：&lt;/p>
&lt;pre>&lt;code>• DO（ Data Object）：与数据库表结构一一对应，通过DAO层向上传输数据源对象。
• DTO（ Data Transfer Object）：数据传输对象，Service或Manager向外传输的对象。
• BO（ Business Object）：业务对象。 由Service层输出的封装业务逻辑的对象。
• AO（ Application Object）：应用对象。 在Web层与Service层之间抽象的复用对象模型，极为贴近展示层，复用度不高。
• VO（ View Object）：显示层对象，通常是Web向模板渲染引擎层传输的对象。
• POJO（ Plain Ordinary Java Object）：在本手册中， POJO专指只有setter/getter/toString的简单类，包括DO/DTO/BO/VO等。
• Query：数据查询对象，各层接收上层的查询请求。 注意超过2个参数的查询封装，禁止使用Map类来传输。
&lt;/code>&lt;/pre>
&lt;p>2.领域模型命名规约：&lt;/p>
&lt;pre>&lt;code>• 数据对象：xxxDO，xxx即为数据表名。
• 数据传输对象：xxxDTO，xxx为业务领域相关的名称。
• 展示对象：xxxVO，xxx一般为网页名称。 • POJO是DO/DTO/BO/VO的统称，禁止命名成xxxPOJO。
&lt;/code>&lt;/pre>
&lt;h1 id="restful-接口风格">Restful 接口风格&lt;/h1></description></item><item><title/><link>https://ysyyhhh.github.io/docs/language/java/spring/3.18%E5%89%8D/%E6%9C%8D%E5%8A%A1%E7%AB%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/language/java/spring/3.18%E5%89%8D/%E6%9C%8D%E5%8A%A1%E7%AB%AF/</guid><description>&lt;p>jar包启动&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">nohup java -jar -Xms128M -Xmx128M -XX:PermSize=128M -XX:MaxPermSize=128M jar包名.jar
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>nacos启动&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">sh /home/tmp/nacos/bin/startup.sh -m standalone
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>服务器启动&lt;/p>
&lt;p>输出到各自的日志文件&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">cd /home/mind_wings
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">nohup java -jar -Xms128M -Xmx128M -XX:PermSize=128M -XX:MaxPermSize=128M service-user-1.0-SNAPSHOT.jar &amp;gt; service-user.log 2&amp;gt;&amp;amp;1 &amp;amp;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">nohup java -jar -Xms128M -Xmx128M -XX:PermSize=128M -XX:MaxPermSize=128M service-timetable-1.0-SNAPSHOT.jar &amp;gt; service-timetable.log 2&amp;gt;&amp;amp;1 &amp;amp;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">nohup java -jar -Xms128M -Xmx128M -XX:PermSize=128M -XX:MaxPermSize=128M -noverify api-gateway-1.0-SNAPSHOT.jar &amp;gt; api-gateway.log 2&amp;gt;&amp;amp;1 &amp;amp;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>出现过的问题&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">api-gateway 启动失败
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">https://blog.csdn.net/crxk_/article/details/103196146
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title/><link>https://ysyyhhh.github.io/docs/language/java/spring/mybatis/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/language/java/spring/mybatis/</guid><description>&lt;h1 id="mybatis">MyBatis&lt;/h1>
&lt;h2 id="mybatis-概念">MyBatis 概念&lt;/h2>
&lt;p>MyBatis 是一个优秀的持久层框架，它对 JDBC 的操作数据库的过程进行封装，使开发者只需要关注 SQL 本身，而不需要花费精力去处理例如注册驱动、创建连接、创建 Statement、手动设置参数、结果集检索等JDBC繁杂的过程代码。&lt;/p>
&lt;p>与 MyBatis Plus 的区别：&lt;/p>
&lt;ul>
&lt;li>MyBatis 是一个持久层框架，它是对 JDBC 的封装，它的目的是为了简化 JDBC 的操作。&lt;/li>
&lt;li>MyBatis Plus 是在 MyBatis 的基础上进行了功能的增强，它是一个持久层框架，它的目的是为了简化开发。&lt;/li>
&lt;li>MyBatis Plus 多了一些功能，例如：分页、逻辑删除、性能分析等。&lt;/li>
&lt;/ul>
&lt;h2 id="语法">语法&lt;/h2>
&lt;h3 id="-与--的区别">#{} 与 ${} 的区别&lt;/h3>
&lt;ul>
&lt;li>#{} 是预编译处理，${} 是字符串替换。&lt;/li>
&lt;li>#{} 是将传入的数据当做一个字符串，会在#{}所在的位置加一个占位符?，然后使用 PreparedStatement 的 setString() 方法来设置?的值。&lt;/li>
&lt;li>${} 是将传入的数据直接拼接在 SQL 中，会导致 SQL 注入的问题。&lt;/li>
&lt;/ul>
&lt;h2 id="mybatis-的执行流程">MyBatis 的执行流程&lt;/h2>
&lt;ol>
&lt;li>加载配置文件&lt;/li>
&lt;li>创建 SqlSessionFactory 工厂&lt;/li>
&lt;li>创建 SqlSession&lt;/li>
&lt;li>执行 SQL&lt;/li>
&lt;li>关闭 SqlSession&lt;/li>
&lt;li>关闭 SqlSessionFactory&lt;/li>
&lt;li>释放资源&lt;/li>
&lt;/ol>
&lt;h2 id="xml中的标签">xml中的标签&lt;/h2>
&lt;p>sql相关: insert 、 update delete、select
参数相关: parameterMap、parameterType、resultMap、resultType
其他: sql、include、trim、where、set、foreach、if、choose、when、otherwise&lt;/p>
&lt;h2 id="dao接口的工作原理">Dao接口的工作原理&lt;/h2>
&lt;p>Dao 接口的工作原理是动态代理，MyBatis 会根据 Dao 接口的方法名和参数类型来生成一个代理对象，代理对象会调用 SqlSession 的方法来执行 SQL 语句。&lt;/p>
&lt;p>Mapper接口没有实现类， 调用接口方法时，接口全限定名+方法名就是对应的SQL语句的ID，可唯一定位一个MappedStatement对象。&lt;/p>
&lt;p>Dao接口里的方法可以重载，但Mybatis xml里的ID不允许重复
重载需要满足的条件：&lt;/p>
&lt;ul>
&lt;li>仅有一个无参 和 有参&lt;/li>
&lt;li>或者， 多个有参方法，但参数数量必须一一对应，使用相同的@Param注解&lt;/li>
&lt;/ul>
&lt;p>xml中id，在namespace下唯一，不同namespace下可以有相同的id&lt;/p>
&lt;h2 id="mybatis-的延迟加载">MyBatis 的延迟加载&lt;/h2>
&lt;p>MyBatis 的延迟加载是指在需要使用数据时才去查询数据库，而不是在一开始就把所有数据都查询出来。&lt;/p>
&lt;p>原理是（和Hibernate的延迟加载原理一致）
使用 CGLIB 创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用 a.getB().getName() ，拦截器 invoke() 方法发现 a.getB() 是 null 值，那么就会单独发送事先保存好的查询关联 B 对象的 sql，把 B 查询上来，然后调用 a.setB(b)，于是 a 的对象 b 属性就有值了，接着完成 a.getB().getName() 方法的调用。这就是延迟加载的基本原理。&lt;/p>
&lt;h2 id="批处理">批处理&lt;/h2>
&lt;p>使用 BatchExecutor 批处理器，可以将多个 SQL 语句一次性发送到数据库执行，减少网络开销。&lt;/p>
&lt;h2 id="executor">Executor&lt;/h2>
&lt;p>Executor 是 MyBatis 的执行器，它负责执行 MyBatis 的 SQL 语句，它有三种实现：&lt;/p>
&lt;ul>
&lt;li>SimpleExecutor：每执行一次 update 或 select 都会开启一个 Statement 对象，用完立刻关闭 Statement 对象。&lt;/li>
&lt;li>ReuseExecutor：执行 update 或 select 时，会创建 Statement 对象，用完后不会关闭 Statement 对象，而是放置于 Map&amp;lt;String, Statement&amp;gt; 中，供下一次使用。&lt;/li>
&lt;li>BatchExecutor：执行 update（没有 select，JDBC 批处理不支持 select），将所有 SQL 都添加到批处理中（addBatch()），等待统一执行（executeBatch()）。&lt;/li>
&lt;/ul>
&lt;p>如何选择 Executor：&lt;/p>
&lt;ul>
&lt;li>默认情况下，MyBatis 使用 SimpleExecutor。&lt;/li>
&lt;li>在 MyBatis 的配置文件中可以配置使用哪种 Executor。&lt;/li>
&lt;li>一般情况下，如果是单线程环境，使用 SimpleExecutor 就可以了。&lt;/li>
&lt;li>如果是多线程环境，使用 ReuseExecutor。&lt;/li>
&lt;li>如果是批处理，使用 BatchExecutor。&lt;/li>
&lt;/ul>
&lt;h2 id="mybatis-映射枚举类">MyBatis 映射枚举类&lt;/h2>
&lt;p>MyBatis 3.4.5 之后，MyBatis 支持枚举类型的映射。&lt;/p>
&lt;h2 id="mybatis-xml文件中-a-include了bb能否定义在a的后面">MyBatis xml文件中 A include了B，B能否定义在A的后面&lt;/h2>
&lt;p>可以，MyBatis 会先解析所有的 sql 语句，然后再解析所有的 include 标签。&lt;/p>
&lt;h2 id="mybatis-的一级缓存和二级缓存">MyBatis 的一级缓存和二级缓存&lt;/h2>
&lt;p>一级缓存是 SqlSession 级别的缓存，当调用 SqlSession 的修改、添加、删除、commit()、close()等方法时，就会清空一级缓存。&lt;/p>
&lt;p>二级缓存是 Mapper 级别的缓存，多个 SqlSession 可以共用二级缓存，二级缓存是跨 SqlSession 的。&lt;/p>
&lt;h2 id="mybatis-的缓存机制">MyBatis 的缓存机制&lt;/h2>
&lt;p>MyBatis 的缓存机制是通过 Cache 接口来实现的，MyBatis 默认使用 PerpetualCache 作为一级缓存，使用 LruCache 作为二级缓存。&lt;/p>
&lt;h2 id="orm">ORM&lt;/h2>
&lt;p>ORM（Object-Relational Mapping）对象关系映射，是一种程序设计技术，用于实现面向对象编程语言里不同类型系统的数据之间的转换。&lt;/p>
&lt;p>MyBatis 是一种半自动化的 ORM 框架，它需要程序员手动编写 SQL 语句，但是不需要程序员手动处理结果集。&lt;/p>
&lt;p>Hibernate 是一种全自动化的 ORM 框架，它不需要程序员手动编写 SQL 语句，也不需要程序员手动处理结果集。&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/language/java/spring/netty/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/language/java/spring/netty/</guid><description>&lt;h1 id="netty">Netty&lt;/h1>
&lt;p>Netty是一个异步的、事件驱动的网络应用框架，用于快速开发高性能、高可靠性的网络服务器和客户端程序。&lt;/p>
&lt;h2 id="io模型">I/O模型&lt;/h2>
&lt;p>Netty的I/O模型是Reactor模型，Reactor模型是一种事件驱动模型，当有事件发生时，会调用相应的事件处理器进行处理。&lt;/p>
&lt;p>BIO (Blocking I/O)：同步阻塞I/O模型，一个连接一个线程，即客户端有连接请求时服务端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销。&lt;/p>
&lt;p>NIO (Non-blocking I/O)：同步非阻塞I/O模型，一个线程处理多个连接，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求就进行处理。&lt;/p>
&lt;p>AIO (Asynchronous I/O)：异步非阻塞I/O模型，AIO引入异步通道的概念，采用了Proactor模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端启动线程去处理，一般适用于连接数较多且连接时间较长的应用。&lt;/p>
&lt;h2 id="netty的介绍">Netty的介绍&lt;/h2>
&lt;p>Netty是一个基于NIO的客户、服务器端编程框架，使用Netty可以快速开发网络应用，例如实现一个高性能的协议服务器/客户端。&lt;/p>
&lt;p>NIO的缺点 &amp;amp;&amp;amp; Netty的价值&lt;/p>
&lt;p>NIO的编程模型相对底层，对开发人员的要求较高，需要了解Selector、Channel、Buffer等概念，开发工作量和难度较大。
NIO在面对复杂的网络应用时，容易出现Reactor模型中的两个重要问题：粘包和拆包。&lt;/p>
&lt;p>粘包和拆包&lt;/p>
&lt;ul>
&lt;li>粘包：多个小的包粘在一起发送，接收端无法区分&lt;/li>
&lt;li>拆包：一个大的包被拆分成多个小的包发送，接收端无法区分&lt;/li>
&lt;/ul>
&lt;p>Netty优点&lt;/p>
&lt;ul>
&lt;li>API使用简单，开发工作量小&lt;/li>
&lt;li>自带的编解码器，可以很好的解决粘包和拆包问题&lt;/li>
&lt;li>简单的线程模型，可以处理成千上万的连接&lt;/li>
&lt;li>自带各种协议栈&lt;/li>
&lt;li>真正的无连接，无状态，高性能&lt;/li>
&lt;/ul>
&lt;p>Netty的应用场景&lt;/p>
&lt;ul>
&lt;li>作为RPC框架的网络通信模块&lt;/li>
&lt;li>实现HTTP服务器，功能包括处理常见的HTTP请求、响应、编解码、文件服务等&lt;/li>
&lt;li>实现自定义的协议服务器，例如实现一个简单的聊天服务器&lt;/li>
&lt;li>实现消息推送服务器，例如实现一个简单的即时通讯服务器&lt;/li>
&lt;/ul>
&lt;p>使用了Netty的开源项目&lt;/p>
&lt;ul>
&lt;li>Dubbo&lt;/li>
&lt;li>RocketMQ&lt;/li>
&lt;li>Elasticsearch&lt;/li>
&lt;li>Zookeeper&lt;/li>
&lt;li>gRPC&lt;/li>
&lt;/ul>
&lt;h2 id="netty的核心组件">Netty的核心组件&lt;/h2>
&lt;p>Channel：通道，Java NIO中的基础概念，代表一个打开的连接，可执行读取/写入操作。Netty对Channel的所有操作都是非阻塞的。&lt;/p>
&lt;p>ChannelFuture：Java的Future接口的扩展，代表一个还没有发生的I/O操作。&lt;/p>
&lt;p>EventLoop：事件循环，一个线程，一个EventLoop可以处理多个Channel，一个Channel只对应一个EventLoop。&lt;/p>
&lt;p>ChannelHandler：事件处理器，处理I/O事件或者拦截I/O操作，并将其转发到其ChannelPipeline(业务逻辑处理链)中的下一个处理器。&lt;/p>
&lt;p>ChannelPipeline：事件处理链，负责ChannelHandler的调度和执行。&lt;/p>
&lt;p>ByteBuf：一个字节容器，Netty对ByteBuffer进行了封装，提供了更加强大和灵活的功能。&lt;/p>
&lt;h2 id="netty的使用">Netty的使用&lt;/h2>
&lt;p>Netty的使用主要分为两个部分：服务端和客户端。&lt;/p>
&lt;h2 id="reactor线程模型">Reactor线程模型&lt;/h2>
&lt;p>Reactor线程模型是Netty的核心，它是Netty高性能的关键。&lt;/p>
&lt;p>Reactor线程模型是一种基于事件驱动的设计模式，主要用于处理并发I/O操作。&lt;/p>
&lt;p>单线程Reactor模型&lt;/p>
&lt;ul>
&lt;li>一个线程处理所有的I/O事件，包括接收客户端的连接、读取数据、发送数据等。&lt;/li>
&lt;li>优点：编程简单，没有线程切换的开销&lt;/li>
&lt;li>缺点：性能瓶颈，无法充分利用多核CPU&lt;/li>
&lt;/ul>
&lt;p>多线程Reactor模型&lt;/p>
&lt;ul>
&lt;li>一个线程负责接收客户端的连接，多个线程负责处理I/O事件&lt;/li>
&lt;li>优点：充分利用多核CPU&lt;/li>
&lt;li>缺点：编程复杂，需要处理线程同步和数据共享问题
&lt;ul>
&lt;li>并发连接数多时存在性能问题&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>主从Reactor模型&lt;/p>
&lt;ul>
&lt;li>一组线程负责接收客户端的连接，一组线程负责处理I/O事件&lt;/li>
&lt;/ul></description></item><item><title/><link>https://ysyyhhh.github.io/docs/language/java/spring/springaop/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/language/java/spring/springaop/</guid><description>&lt;h1 id="spring-aop">Spring AOP&lt;/h1>
&lt;h2 id="什么是aop">什么是AOP&lt;/h2>
&lt;p>AOP（Aspect-Oriented Programming）&lt;strong>面向切面编程&lt;/strong>，是一种编程范式，它的主要目的是&lt;strong>提高代码的模块化程度&lt;/strong>，使得代码更加易于维护和扩展。&lt;/p>
&lt;p>将那些与业务无关，却为业务模块&lt;strong>所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来&lt;/strong>，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。&lt;/p>
&lt;p>Manager层的&lt;strong>事务管理、日志管理、权限控制&lt;/strong>等功能，都是与业务逻辑无关的，但是却是业务逻辑所必须的，这些功能可以通过AOP来实现。&lt;/p>
&lt;h2 id="aop的核心概念">AOP的核心概念&lt;/h2>
&lt;ul>
&lt;li>Aspect（切面）：横切关注点，即模块化横切关注点的行为。比如日志、事务、权限等 = Advice + Pointcut&lt;/li>
&lt;li>JoinPoint（连接点）：程序执行的某个特定的点，比如方法的调用、异常的处理等&lt;/li>
&lt;li>PointCut（切入点）：匹配连接点的断言，AOP通过切入点定位到连接点&lt;/li>
&lt;li>Advice（通知）：切面在连接点上执行的动作，分为前置通知、后置通知、环绕通知、异常通知、最终通知&lt;/li>
&lt;li>Introduction（引介）：在不修改类代码的前提下，为类添加新的方法和属性&lt;/li>
&lt;li>Target（目标对象）：被代理的对象&lt;/li>
&lt;li>Weaving（织入）：将切面应用到目标对象并创建新的代理对象的过程&lt;/li>
&lt;li>Proxy（代理）：被AOP框架创建的对象，用来替换原始对象&lt;/li>
&lt;/ul>
&lt;h2 id="aop的实现方法">AOP的实现方法&lt;/h2>
&lt;p>AOP的实现方式有两种：动态代理和CGLIB字节码增强。&lt;/p>
&lt;ul>
&lt;li>如果目标对象实现了接口，Spring就会使用JDK的动态代理&lt;/li>
&lt;li>如果目标对象没有实现接口，Spring就会使用CGLIB字节码增强&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/SpringAOP/AOP%20Process.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>Spring AOP也集成了AspectJ，可以使用AspectJ的注解来实现AOP。&lt;/p>
&lt;p>Spring AOP 和 AspectJ&lt;/p>
&lt;ul>
&lt;li>Spring AOP：基于代理的AOP实现，只支持方法级别的连接点&lt;/li>
&lt;li>AspectJ：基于字节码的AOP实现，支持方法级别和字段级别的连接点&lt;/li>
&lt;li>Spring AOP 属于运行时增强，AspectJ 属于编译时增强&lt;/li>
&lt;/ul>
&lt;p>AspectJ的通知类型:&lt;/p>
&lt;ul>
&lt;li>Before：前置通知&lt;/li>
&lt;li>After：后置通知&lt;/li>
&lt;li>AfterReturning：返回通知, 在方法返回结果后执行&lt;/li>
&lt;li>AfterThrowing：异常通知, 在方法抛出异常后执行&lt;/li>
&lt;li>Around：环绕通知, 在方法执行前后执行&lt;/li>
&lt;/ul>
&lt;h2 id="aop实战">AOP实战&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 日志注解&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nd">@Target&lt;/span>&lt;span class="p">({&lt;/span>&lt;span class="n">ElementType&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">PARAMETER&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">ElementType&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">METHOD&lt;/span>&lt;span class="p">})&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nd">@Retention&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">RetentionPolicy&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">RUNTIME&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nd">@Documented&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nd">@interface&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Log&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="cm">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * 描述
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> */&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">description&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">default&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="cm">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * 方法类型 INSERT DELETE UPDATE OTHER
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> */&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">MethodType&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">methodType&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">default&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">MethodType&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">OTHER&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c1">// 日志切面&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nd">@Component&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nd">@Aspect&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">LogAspect&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 切入点，所有被 Log 注解标注的方法&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nd">@Pointcut&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;@annotation(cn.javaguide.annotation.Log)&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">webLog&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="cm">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * 环绕通知
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> */&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nd">@Around&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;webLog()&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Object&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">doAround&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ProceedingJoinPoint&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">joinPoint&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">throws&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Throwable&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 省略具体的处理逻辑&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 省略其他代码&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="nd">@Log&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">description&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;method1&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">methodType&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">MethodType&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">INSERT&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">CommonResponse&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Object&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">method1&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 业务逻辑&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">xxService&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">method1&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 省略具体的业务处理逻辑&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">CommonResponse&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">success&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="aop的应用场景">AOP的应用场景&lt;/h2>
&lt;ul>
&lt;li>日志记录: 自定义日志记录注解&lt;/li>
&lt;li>性能统计: 利用AOP统计方法的执行时间&lt;/li>
&lt;li>事务管理: @Transactional注解就是基于AOP实现的&lt;/li>
&lt;li>权限控制: 利用注解在目标方法前判断用户所需的权限
&lt;ul>
&lt;li>Spring Security中的@PreAuthorize注解&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="多个切面的执行顺序">多个切面的执行顺序&lt;/h2>
&lt;ol>
&lt;li>使用@Order注解, 数值越小优先级越高&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="nd">@Aspect&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nd">@Component&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nd">@Order&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">LogAspect&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// ...&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="2">
&lt;li>实现Ordered接口, 重写getOrder()方法&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="nd">@Aspect&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nd">@Component&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">LogAspect&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">implements&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Ordered&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nd">@Override&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">getOrder&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="切面filterinterceptor">切面、Filter、Interceptor&lt;/h2>
&lt;ul>
&lt;li>Filter是Servlet规范中的一部分，是基于URL的，只能在Servlet规范中使用
&lt;ul>
&lt;li>作用是对请求进行过滤，可以在请求到达Servlet之前或者响应到达客户端之前进行一些处理&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Interceptor的作用是在请求到达Controller之前或者响应到达客户端之前进行一些处理&lt;/li>
&lt;li>aspect是AOP的一部分，是基于Java的，可以在任何地方使用
&lt;ul>
&lt;li>作用是对方法进行增强，比如事务、日志、权限等&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>执行顺序：过滤器-&amp;gt;拦截器-&amp;gt;切面
过滤器、拦截器属于请求层面的拦截；切面属于方法层面的拦截&lt;/p>
&lt;p>实现原理不同&lt;/p>
&lt;ul>
&lt;li>Filter是基于函数回调的，依赖于Servlet容器&lt;/li>
&lt;li>Interceptor是基于反射的，依赖于Spring容器&lt;/li>
&lt;li>Aspect是基于代理的，依赖于Spring容器&lt;/li>
&lt;/ul>
&lt;p>使用范围不同&lt;/p>
&lt;ul>
&lt;li>Filter是基于URL的，依赖Tomcat容器&lt;/li>
&lt;li>Interceptor是基于方法的，是Spring组件，不依赖Tomcat容器，&lt;/li>
&lt;/ul>
&lt;p>触发时间不同
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/SpringAOP/%e8%a7%a6%e5%8f%91%e6%97%b6%e9%97%b4.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
请求进入容器后，但在进入servlet之前进行预处理，请求结束是在servlet处理完以后。&lt;/p>
&lt;p>拦截器 Interceptor 是在请求进入servlet后，在进入Controller之前进行预处理的，Controller 中渲染了对应的视图之后请求结束。&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/language/java/spring/springcloud/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/language/java/spring/springcloud/</guid><description>&lt;h1 id="springcloud">SpringCloud&lt;/h1>
&lt;h2 id="springcloud-alibaba特点">SpringCloud Alibaba特点&lt;/h2>
&lt;p>SpringCloud 和 SpringCloud Alibaba的区别&lt;/p>
&lt;ul>
&lt;li>SpringCloud 是基于 Netflix 的一系列组件构建的微服务架构&lt;/li>
&lt;li>SpringCloud Alibaba 是阿里巴巴基于 SpringCloud 的一系列组件构建的微服务架构&lt;/li>
&lt;li>SpringCloud Alibaba 是 SpringCloud 的补充，提供了一些 SpringCloud 没有的组件
&lt;ul>
&lt;li>Nacos&lt;/li>
&lt;li>Sentinel&lt;/li>
&lt;li>Dubbo&lt;/li>
&lt;li>RocketMQ&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title/><link>https://ysyyhhh.github.io/docs/language/java/spring/springioc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/language/java/spring/springioc/</guid><description>&lt;h1 id="spring-ioc">Spring IOC&lt;/h1>
&lt;p>什么是IOC&lt;/p>
&lt;ul>
&lt;li>Inversion of Control 控制反转&lt;/li>
&lt;li>&lt;strong>控制权由程序员转交给了Spring容器&lt;/strong>，&lt;strong>由Spring容器来实例化对象&lt;/strong>，而不是由程序员来实例化对象&lt;/li>
&lt;/ul>
&lt;p>控制：对象创建（实例化、管理）的控制权
反转：由程序员转交给了外部环境（Spring，IOC容器）&lt;/p>
&lt;p>当我们&lt;strong>需要创建一个对象时，只需要配置好配置文件/注解&lt;/strong>&lt;/p>
&lt;h2 id="spring-ioc容器">Spring IOC容器&lt;/h2>
&lt;p>IOC容器是&lt;strong>Map类型的对象&lt;/strong>，存储了所有的bean对象，key是bean的id，value是bean对象&lt;/p>
&lt;p>两种配置Bean的方式：&lt;/p>
&lt;ul>
&lt;li>XML配置&lt;/li>
&lt;li>注解配置&lt;/li>
&lt;/ul>
&lt;h2 id="spring-bean">Spring Bean&lt;/h2>
&lt;p>Bean是被IoC容器管理的对象，Bean是一个Java对象，由Spring容器实例化、装配、管理&lt;/p>
&lt;h2 id="声明为bean的注解">声明为Bean的注解&lt;/h2>
&lt;p>@Component&lt;/p>
&lt;ul>
&lt;li>用于标注一个普通的bean&lt;/li>
&lt;li>不区分是哪个层的&lt;/li>
&lt;/ul>
&lt;p>@Repository&lt;/p>
&lt;ul>
&lt;li>用于标注一个DAO层的bean&lt;/li>
&lt;li>但很多时候都不用这种方式&lt;/li>
&lt;li>一般直接通过MapperScan注解扫描mapper接口（在mybatis中）&lt;/li>
&lt;/ul>
&lt;p>@Service&lt;/p>
&lt;ul>
&lt;li>用于标注一个Service层的bean&lt;/li>
&lt;/ul>
&lt;p>@Controller&lt;/p>
&lt;ul>
&lt;li>用于标注一个Controller层的bean&lt;/li>
&lt;/ul>
&lt;p>@Component和@Bean的区别&lt;/p>
&lt;ul>
&lt;li>@Component是用于标注一个普通的bean，作用于&lt;strong>类&lt;/strong>；而@Bean是用于标注一个方法，作用于&lt;strong>方法&lt;/strong>&lt;/li>
&lt;li>@Component是被Spring扫描到之后（@ComponentScan），&lt;strong>自动注册&lt;/strong>到Spring容器中；而@Bean是在配置类中，&lt;strong>手动注册&lt;/strong>到Spring容器中&lt;/li>
&lt;li>@Bean自定义性强，比如在引用第三方库的时候，可以使用@Bean注解，将第三方库的对象注册到Spring容器中&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-Java" data-lang="Java">&lt;span class="line">&lt;span class="cl">&lt;span class="nd">@Configuration&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">AppConfig&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nd">@Bean&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">TransferService&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">transferService&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">TransferServiceImpl&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-xml" data-lang="xml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;bean&lt;/span> &lt;span class="na">id=&lt;/span>&lt;span class="s">&amp;#34;transferService&amp;#34;&lt;/span> &lt;span class="na">class=&lt;/span>&lt;span class="s">&amp;#34;com.example.TransferServiceImpl&amp;#34;&lt;/span>&lt;span class="nt">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>不能通过@Component实现的例子&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-Java" data-lang="Java">&lt;span class="line">&lt;span class="cl">&lt;span class="nd">@Configuration&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">AppConfig&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nd">@Bean&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">TransferService&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">transferService&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">TransferServiceImpl&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nd">@Bean&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">TransferService&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">transferService2&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">TransferServiceImpl&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>为什么不能使用@Component&lt;/p>
&lt;ul>
&lt;li>因为@Component是用于标注一个普通的bean，作用于类；而@Bean是用于标注一个方法，作用于方法&lt;/li>
&lt;/ul>
&lt;h2 id="注入bean的注解">注入Bean的注解&lt;/h2>
&lt;p>Spring内置的@Autowired注解
JDK内置的@Resource注解和@Inject注解&lt;/p>
&lt;p>@Autowired和@Resource的区别&lt;/p>
&lt;ul>
&lt;li>AutoWired的默认是&lt;strong>按照类型注入&lt;/strong>
&lt;ul>
&lt;li>如果有多个类型一样的bean，会变成按照名称注入&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Resource默认是按照名称注入，如果没有指定name属性，会按照类型注入&lt;/li>
&lt;li>如果存在多个实现类, Autowired需要@Qualifier指定具体的实现类，而Resource需要name指定具体的实现类&lt;/li>
&lt;li>@Autowired 支持在构造函数、方法、字段和参数上使用。&lt;/li>
&lt;li>@Resource 主要用于字段和方法上的注入，&lt;strong>不支持在构造函数或参数上使用&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>SmsService 接口有两个实现类: SmsServiceImpl1和 SmsServiceImpl2，且它们都已经被 Spring 容器所管理&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 报错，byName 和 byType 都无法匹配到 bean&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nd">@Autowired&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">SmsService&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">smsService&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c1">// 正确注入 SmsServiceImpl1 对象对应的 bean&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nd">@Autowired&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">SmsService&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">smsServiceImpl1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c1">// 正确注入 SmsServiceImpl1 对象对应的 bean&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c1">// smsServiceImpl1 就是我们上面所说的名称&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nd">@Autowired&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nd">@Qualifier&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;smsServiceImpl1&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">SmsService&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">smsService&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-Java" data-lang="Java">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 报错，byName 和 byType 都无法匹配到 bean&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nd">@Resource&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">SmsService&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">smsService&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c1">// 正确注入 SmsServiceImpl1 对象对应的 bean&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nd">@Resource&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">SmsService&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">smsServiceImpl1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c1">// 正确注入 SmsServiceImpl1 对象对应的 bean（比较推荐这种方式）&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nd">@Resource&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;smsServiceImpl1&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">SmsService&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">smsService&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="注入bean冲突时的问题">注入Bean冲突时的问题&lt;/h2>
&lt;p>当我们从 Spring 容器中“拉”取一个 Bean 回来的时候，可以按照名字去拉取，也可以按照类型去拉取，按照 BeanName 拉取的话，一般来说只要 BeanName 书写没有问题，都是没问题的。但是如果是按照类型去拉取，则可能会因为 Bean 存在多个实例从而导致失败。&lt;/p>
&lt;p>使用@Resource&lt;/p>
&lt;p>@Qualifier 指定 name&lt;/p>
&lt;p>另外还有一种方案，就是在注册 Bean 的时候，告诉 Spring 容器，这个 Bean 在通过 type 进行注入的时候，不作为候选 Bean。&lt;/p>
&lt;h2 id="怎么动态获取spring容器里面的bean从哪个类中获取">怎么动态获取spring容器里面的bean，从哪个类中获取&lt;/h2>
&lt;p>从ApplicationContext中获取Bean&lt;/p>
&lt;h2 id="bean的作用域">Bean的作用域&lt;/h2>
&lt;ul>
&lt;li>singleton：单例模式，一个Spring容器中只有一个bean实例，默认值&lt;/li>
&lt;li>prototype：原型模式，每次从容器中获取bean时，都会创建一个新的实例&lt;/li>
&lt;li>request：每次HTTP请求都会创建一个新的bean，该bean仅在当前HTTP request内有效&lt;/li>
&lt;li>session：每次HTTP请求都会创建一个新的bean，该bean仅在当前HTTP session内有效&lt;/li>
&lt;li>global session：全局session作用域，仅在基于portlet的Web应用中才有意义，Spring5废弃&lt;/li>
&lt;li>application：全局作用域，Spring5废弃&lt;/li>
&lt;li>websocket：全局作用域，Spring5废弃&lt;/li>
&lt;/ul>
&lt;p>配置Bean的作用域&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-xml" data-lang="xml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;bean&lt;/span> &lt;span class="na">id=&lt;/span>&lt;span class="s">&amp;#34;user&amp;#34;&lt;/span> &lt;span class="na">class=&lt;/span>&lt;span class="s">&amp;#34;com.example.User&amp;#34;&lt;/span> &lt;span class="na">scope=&lt;/span>&lt;span class="s">&amp;#34;prototype&amp;#34;&lt;/span>&lt;span class="nt">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-Java" data-lang="Java">&lt;span class="line">&lt;span class="cl">&lt;span class="nd">@Component&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nd">@Scope&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;prototype&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">User&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="bean的线程安全问题">Bean的线程安全问题&lt;/h2>
&lt;p>与作用域有关&lt;/p>
&lt;ul>
&lt;li>singleton：线程不安全, IoC容器中只有一个bean实例，多个线程共享一个bean实例, 如果bean中有状态，会出现线程安全问题&lt;/li>
&lt;li>prototype：线程安全, 每次从容器中获取bean时，都会创建一个新的实例&lt;/li>
&lt;li>其他的都是线程安全的&lt;/li>
&lt;/ul>
&lt;p>解决办法:&lt;/p>
&lt;ul>
&lt;li>不要在bean中定义状态&lt;/li>
&lt;li>使用ThreadLocal(推荐)&lt;/li>
&lt;/ul>
&lt;h2 id="bean的生命周期">Bean的生命周期&lt;/h2>
&lt;p>Bean的生命周期包括初始化和销毁两个阶段&lt;/p>
&lt;p>Bean的初始化&lt;/p>
&lt;ul>
&lt;li>通过构造方法创建bean&lt;/li>
&lt;li>为bean的属性设置值 set()&lt;/li>
&lt;li>如果实现了*.Aware接口，调用相应的方法
&lt;ul>
&lt;li>BeanNameAware&lt;/li>
&lt;li>BeanFactoryAware&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>如果有相应的初始化方法就调用
&lt;ul>
&lt;li>如果有Spring 容器相关BeanPostProcessor，调用postProcessBeforeInitialization方法&lt;/li>
&lt;li>如果有InitializingBean，调用afterPropertiesSet方法&lt;/li>
&lt;li>如果有init-method属性，调用init-method方法&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>bean初始化完成&lt;/li>
&lt;/ul>
&lt;p>Bean的销毁&lt;/p>
&lt;ul>
&lt;li>调用bean的销毁方法
&lt;ul>
&lt;li>如果实现了 DisposableBean 接口，调用destroy方法&lt;/li>
&lt;li>如果有destroy-method属性，调用destroy-method方法&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>bean销毁完成&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/SpringIOC/Bean%e7%9a%84%e5%a3%b0%e6%98%8e%e5%91%a8%e6%9c%9f.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/language/java/spring/springmvc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/language/java/spring/springmvc/</guid><description>&lt;h1 id="springmvc">SpringMVC&lt;/h1>
&lt;h2 id="1-springmvc简介">1. SpringMVC简介&lt;/h2>
&lt;p>MVC是Model-View-Controller的缩写，是一种设计模式，用于开发Web应用程序。SpringMVC是Spring框架的一个模块，用于开发Web应用程序。&lt;/p>
&lt;p>Model1时代&lt;/p>
&lt;p>这个模式下 JSP 即是控制层（Controller）又是表现层（View）。显而易见，这种模式存在很多问题。比如控制逻辑和表现逻辑混杂在一起，导致代码重用率极低；再比如前端和后端相互依赖，难以进行测试维护并且开发效率极低。
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/SpringMVC/Model1.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>Model2时代&lt;/p>
&lt;p>早期MVC
Model:系统涉及的数据，也就是 dao 和 bean。
View：展示模型中的数据，只是用来展示。
Controller：接受用户请求，并将请求发送至 Model，最后返回数据给 JSP 并展示给用户
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/SpringMVC/Model2.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>存在的问题有:&lt;/p>
&lt;ul>
&lt;li>代码耦合度高, 代码重用率低&lt;/li>
&lt;/ul>
&lt;p>SpringMVC&lt;/p>
&lt;p>MVC 是一种设计模式，Spring MVC 是一款很优秀的 MVC 框架。Spring MVC 可以帮助我们进行更简洁的 Web 层的开发，并且它天生与 Spring 框架集成。Spring MVC 下我们一般把后端项目分为 Service 层（处理业务）、Dao 层（数据库操作）、Entity 层（实体类）、Controller 层(控制层，返回数据给前台页面)。&lt;/p>
&lt;h2 id="springmvc核心组件">SpringMVC核心组件&lt;/h2>
&lt;p>SpringMVC的核心组件有：&lt;/p>
&lt;ul>
&lt;li>DispatcherServlet: 核心的Servlet，用于接收请求并分发请求&lt;/li>
&lt;li>HandlerMapping: 处理器映射器，用于查找处理器&lt;/li>
&lt;li>HandlerAdapter: 处理器适配器，用于执行处理器&lt;/li>
&lt;li>Handler: 处理器，用于处理请求&lt;/li>
&lt;li>ViewResolver: 视图解析器，用于解析视图&lt;/li>
&lt;/ul>
&lt;h2 id="springmvc的工作流程mvc的dispatcherservlet的分派原理">SpringMVC的工作流程(mvc的dispatcherservlet的分派原理)&lt;/h2>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/SpringMVC/SpringMVC%e5%b7%a5%e4%bd%9c%e6%b5%81%e7%a8%8b.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;ol>
&lt;li>客户端发送请求到前端控制器 &lt;code>DispatcherServlet&lt;/code>。&lt;/li>
&lt;li>获得Controller
&lt;ol>
&lt;li>&lt;code>DispatcherServlet&lt;/code> 根据请求信息 (URI 等)，决定使用哪个 &lt;code>HandlerMapping&lt;/code> 来映射 Controller。&lt;/li>
&lt;li>&lt;code>HandlerMapping&lt;/code> 获取到对应的 &lt;code>Controller&lt;/code> 后,返回给 &lt;code>DispatcherServlet&lt;/code>&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>调用Controller的方法
&lt;ol>
&lt;li>&lt;code>DispatcherServlet&lt;/code> 根据获得的 &lt;code>Controller&lt;/code> 来调用对应的方法。&lt;/li>
&lt;li>&lt;code>Controller&lt;/code> 执行相应的业务逻辑,处理完后返回一个 &lt;code>ModelAndView&lt;/code> 对象给 &lt;code>DispatcherServlet&lt;/code>。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>根据&lt;code>ModelAndView&lt;/code>找到&lt;code>View&lt;/code>
&lt;ol>
&lt;li>&lt;code>DispatcherServlet&lt;/code> 将获得的 &lt;code>ModelAndView&lt;/code> 对象传递给 &lt;code>ViewResolver&lt;/code>。
&lt;code>ViewResolver&lt;/code> 根据之前配置好的规则,解析&lt;code>ModelAndView&lt;/code>对象中的视图名,找到真正的视图对象View。&lt;/li>
&lt;li>&lt;code>DispatcherServlet&lt;/code> 调用 View 对象进行视图渲染,得到最终的视图。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>最终的视图通过响应对象返回给客户端。&lt;/li>
&lt;/ol>
&lt;h2 id="restful风格在mvc的分派如何解析参数这个我不知道瞎答的">restful风格在mvc的分派，如何解析参数（这个我不知道瞎答的）&lt;/h2>
&lt;p>restful 即 URL表示资源， + GET POST PUT DELETE 表示行为&lt;/p>
&lt;p>Restful风格的请求是使用 &lt;strong>url+请求方式&lt;/strong> 表示一次请求目的的，并且规范了一些的状态码，使得看到接口就知道请求要干嘛。&lt;/p>
&lt;p>RequestMappingURL&lt;/p>
&lt;p>PathVariable 获取参数&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>@Controller&lt;/code>声名一个处理请求的控制器&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>@RequestMapping&lt;/code>请求映射地址，它存在几个子注解对于实现&lt;code>REST&lt;/code>风格来说更加具有语义性&lt;/p>
&lt;/li>
&lt;li>
&lt;ul>
&lt;li>&lt;code>GETMapping&lt;/code> GET请求&lt;/li>
&lt;li>&lt;code>PUTMapping&lt;/code> PUT请求&lt;/li>
&lt;li>&lt;code>POSTMapping&lt;/code> POST请求&lt;/li>
&lt;li>&lt;code>DELETEMapping&lt;/code> DELETE请求&lt;code>sponseBody&lt;/code> 将响应内容转换为&lt;code>JSON&lt;/code>格式&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;code>@RequestBody&lt;/code> 请求内容转换为&lt;code>JSON&lt;/code>格式&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>@PathVariable(&amp;quot;id&amp;quot;)&lt;/code>用于绑定一个参数&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>@RESTController&lt;/code> 等同于&lt;code>@Controller&lt;/code>+&lt;code>@ResponseBody&lt;/code>在类上写了这个注解，标识这个类的所有方法只返回数据，而不进行视图跳转&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="统一异常处理">统一异常处理&lt;/h2>
&lt;p>SpringMVC提供了&lt;code>@ControllerAdvice&lt;/code>注解，用于统一处理异常。&lt;code>@ControllerAdvice&lt;/code>注解可以用于定义一个全局的异常处理类，用于处理所有Controller中抛出的异常。&lt;/p>
&lt;p>还会用到&lt;code>@ExceptionHandler&lt;/code>注解，用于定义一个方法，用于处理指定类型的异常。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="nd">@ControllerAdvice&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nd">@ResponseBody&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">GlobalExceptionHandler&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nd">@ExceptionHandler&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Exception&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Result&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">handleException&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Exception&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Result&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;500&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">getMessage&lt;/span>&lt;span class="p">());&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这种方式可以统一处理异常，避免在每个Controller中都写异常处理代码。&lt;/p>
&lt;p>如果需要对不同的异常做不同的处理，可以定义多个&lt;code>@ExceptionHandler&lt;/code>方法&lt;/p>
&lt;p>ExceptionHandlerMethodResolver 中 getMappedMethod 方法，根据异常类型找到对应的方法，然后执行。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="nd">@Nullable&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Method&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">getMappedMethod&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Class&lt;/span>&lt;span class="o">&amp;lt;?&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">extends&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Throwable&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">exceptionType&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">List&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Class&lt;/span>&lt;span class="o">&amp;lt;?&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">extends&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Throwable&lt;/span>&lt;span class="o">&amp;gt;&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">matches&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ArrayList&lt;/span>&lt;span class="o">&amp;lt;&amp;gt;&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">//找到可以处理的所有异常信息。mappedMethods 中存放了异常和处理异常的方法的对应关系&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">for&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Class&lt;/span>&lt;span class="o">&amp;lt;?&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">extends&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Throwable&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">mappedException&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">mappedMethods&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">keySet&lt;/span>&lt;span class="p">())&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">if&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mappedException&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">isAssignableFrom&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">exceptionType&lt;/span>&lt;span class="p">))&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">matches&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mappedException&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 不为空说明有方法处理异常&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">if&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">matches&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">isEmpty&lt;/span>&lt;span class="p">())&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 按照匹配程度从小到大排序&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">matches&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">sort&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ExceptionDepthComparator&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">exceptionType&lt;/span>&lt;span class="p">));&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 返回处理异常的方法&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">mappedMethods&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">get&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">matches&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">get&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="p">));&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">else&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>getMappedMethod() 会首先找到所有可以处理的异常信息，然后按照匹配程度从小到大排序，最后返回处理异常的方法。&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/language/java/spring/spring%E4%BA%8B%E5%8A%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/language/java/spring/spring%E4%BA%8B%E5%8A%A1/</guid><description>&lt;h1 id="spring事务">Spring事务&lt;/h1>
&lt;h2 id="事务的特性">事务的特性&lt;/h2>
&lt;ul>
&lt;li>原子性(Atomicity): 事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。&lt;/li>
&lt;li>一致性(Consistency): 事务必须使数据库从一个一致性状态变换到另一个一致性状态。&lt;/li>
&lt;li>隔离性(Isolation): 一个事务的执行不能被其他事务干扰。&lt;/li>
&lt;li>持久性(Durability): 事务一旦提交，它对数据库中数据的改变是永久性的。&lt;/li>
&lt;/ul>
&lt;p>保证AID,C才能被满足&lt;/p>
&lt;h2 id="为什么要有事务">为什么要有事务&lt;/h2>
&lt;p>系统中的业务方法可能包括了多个原子性的数据库操作&lt;/p>
&lt;p>如:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">savePerson&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">personDao&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">save&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">person&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">personDetailDao&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">save&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">personDetail&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这些操作需要保证原子性，要么都成功，要么都失败&lt;/p>
&lt;p>事务能否生效, 取决于数据库引擎的支持, 需要是innodb引擎&lt;/p>
&lt;h2 id="spring事务管理">Spring事务管理&lt;/h2>
&lt;p>MySQL保证原子性是通过回滚日志(undo log) 实现的.
如果执行遇到异常, 会回滚到事务开始前的状态. 且回滚日志先于数据的持久化.&lt;/p>
&lt;p>Spring事务管理的方式有两种：&lt;/p>
&lt;ul>
&lt;li>编程式事务管理&lt;/li>
&lt;li>声明式事务管理&lt;/li>
&lt;/ul>
&lt;h3 id="编程式事务管理">编程式事务管理&lt;/h3>
&lt;p>编程式事务管理是通过编程的方式来管理事务。&lt;/p>
&lt;p>在编程式事务管理中，需要在代码中显式的调用事务管理的API来管理事务&lt;/p>
&lt;p>会导致业务代码和事务管理代码耦合在一起，不利于事务管理逻辑的重用, 很少用&lt;/p>
&lt;p>通过&lt;code>TransactionTemplate&lt;/code> 或者 &lt;code>PlatformTransactionManager&lt;/code> 来管理事务&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">AccountService&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">JdbcTemplate&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">jdbcTemplate&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">TransactionTemplate&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">transactionTemplate&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">setJdbcTemplate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">JdbcTemplate&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">jdbcTemplate&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">jdbcTemplate&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">jdbcTemplate&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">setTransactionTemplate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">TransactionTemplate&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">transactionTemplate&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">transactionTemplate&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">transactionTemplate&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">transfer&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">final&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">outUser&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">final&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">inUser&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">final&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Double&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">money&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">transactionTemplate&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">execute&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">TransactionCallbackWithoutResult&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nd">@Override&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">protected&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">doInTransactionWithoutResult&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">TransactionStatus&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">transactionStatus&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">jdbcTemplate&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">update&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;update account set money = money - ? where username = ?&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">money&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">outUser&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">jdbcTemplate&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">update&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;update account set money = money + ? where username = ?&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">money&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">inUser&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">});&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="声明式事务管理">声明式事务管理&lt;/h3>
&lt;p>声明式事务管理是通过配置的方式来管理事务。&lt;/p>
&lt;p>在声明式事务管理中，只需要在配置文件中声明事务管理的相关属性，就可以在业务代码中实现事务管理，而不需要在业务代码中负责事务管理的代码。&lt;/p>
&lt;p>实际基于 AOP 实现（基于&lt;code>@Transactional&lt;/code> 的全注解方式使用最多）&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="nd">@Service&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">AccountService&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nd">@Autowired&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">JdbcTemplate&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">jdbcTemplate&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nd">@Transactional&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">transfer&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">outUser&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">inUser&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Double&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">money&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">jdbcTemplate&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">update&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;update account set money = money - ? where username = ?&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">money&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">outUser&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">jdbcTemplate&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">update&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;update account set money = money + ? where username = ?&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">money&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">inUser&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="spring事务的传播行为">Spring事务的传播行为&lt;/h2>
&lt;p>事务的传播行为是指在&lt;strong>多个事务方法相互调用的情况下，事务管理器如何管理事务的传播行为&lt;/strong>。&lt;/p>
&lt;p>当事务方法A调用事务方法B时，Spring事务管理器会根据&lt;strong>事务方法B的传播行为&lt;/strong>来决定事务方法B是否加入事务方法A的事务。&lt;/p>
&lt;p>我们在 A 类的aMethod()方法中调用了 B 类的 bMethod() 方法。这个时候就涉及到业务层方法之间互相调用的事务问题。如果我们的 &lt;strong>bMethod()如果发生异常需要回滚&lt;/strong>，如何配置事务传播行为才能&lt;strong>让 aMethod()也跟着回滚&lt;/strong>呢？&lt;/p>
&lt;p>Spring事务的传播行为有以下几种：&lt;/p>
&lt;h3 id="会发生回滚的四种情况">会发生回滚的四种情况&lt;/h3>
&lt;h4 id="required">REQUIRED&lt;/h4>
&lt;p>默认且最常见的传播行为，如果当前没有事务，就新建一个事务，如果当前存在事务，就加入该事务。&lt;/p>
&lt;ul>
&lt;li>如果外部方法没有开启事务, REQUIRED修饰的内部方法会开启一个新的事务.&lt;/li>
&lt;li>如果外部方法开启了事务, REQUIRED修饰的内部方法会加入到外部方法的事务中, 即属于同一个事务.&lt;/li>
&lt;/ul>
&lt;p>其中一个方法回滚,就都回滚&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="nd">@Service&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">Class&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">A&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nd">@Autowired&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">B&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nd">@Transactional&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">propagation&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Propagation&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">REQUIRED&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">aMethod&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">//do something&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">bMethod&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nd">@Service&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">Class&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">B&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nd">@Transactional&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">propagation&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Propagation&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">REQUIRED&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">bMethod&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">//do something&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="requires_new">REQUIRES_NEW&lt;/h4>
&lt;p>新建一个事务，如果当前存在事务，就把当前事务挂起。&lt;/p>
&lt;p>也就是说&lt;strong>不管外部方法是否开启事务&lt;/strong>，Propagation.REQUIRES_NEW修饰的内部方法会&lt;strong>新开启自己的事务&lt;/strong>，且开启的&lt;strong>事务相互独立，互不干扰&lt;/strong>。&lt;/p>
&lt;p>即,一般情况下, ab回滚互不影响.&lt;/p>
&lt;p>但如果b方法&lt;strong>抛出了未被捕获的异常&lt;/strong>, 且这个异常满足a的回滚规则,a才会跟着回滚.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="nd">@Service&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">Class&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">A&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nd">@Autowired&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">B&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nd">@Transactional&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">propagation&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Propagation&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">REQUIRED&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">aMethod&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">//do something&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">bMethod&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nd">@Service&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">Class&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">B&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nd">@Transactional&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">propagation&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Propagation&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">REQUIRES_NEW&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">bMethod&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">//do something&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="nested">NESTED&lt;/h4>
&lt;p>如果当前存在事务，则在嵌套事务内执行，如果当前没有事务，则新建一个事务。&lt;/p>
&lt;ul>
&lt;li>在外部方法开启事务的情况下，在&lt;strong>内部开启一个新的事务，作为嵌套事务存在&lt;/strong>。&lt;/li>
&lt;li>如果外部方法无事务，则单独开启一个事务，与 PROPAGATION_REQUIRED 类似。&lt;/li>
&lt;/ul>
&lt;p>即,
a回滚, b一定回滚
b回滚,a不会滚&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="nd">@Service&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">Class&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">A&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nd">@Autowired&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">B&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nd">@Transactional&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">propagation&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Propagation&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">REQUIRED&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">aMethod&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">//do something&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">bMethod&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nd">@Service&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">Class&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">B&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nd">@Transactional&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">propagation&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Propagation&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">NESTED&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">bMethod&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">//do something&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="mandatory">MANDATORY&lt;/h4>
&lt;p>如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）&lt;/p>
&lt;ul>
&lt;li>如果外部方法没有开启事务, MANDATORY修饰的内部方法会抛出异常.&lt;/li>
&lt;li>如果外部方法开启了事务, MANDATORY修饰的内部方法会加入到外部方法的事务中, 即属于同一个事务.&lt;/li>
&lt;/ul>
&lt;h4 id="不会发生回滚的情况">不会发生回滚的情况&lt;/h4>
&lt;ul>
&lt;li>PROPAGATION_SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行。&lt;/li>
&lt;li>PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。&lt;/li>
&lt;li>PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。&lt;/li>
&lt;/ul>
&lt;h2 id="spring事务的隔离级别">Spring事务的隔离级别&lt;/h2>
&lt;p>事务的隔离级别是指多个事务之间的隔离程度，事务的隔离级别有以下几种：&lt;/p>
&lt;ul>
&lt;li>DEFAULT：使用数据库默认的隔离级别。
&lt;ul>
&lt;li>MySQL 默认的隔离级别是 REPEATABLE_READ&lt;/li>
&lt;li>Oracle 默认的隔离级别是 READ_COMMITTED&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>READ_UNCOMMITTED：允许脏读、不可重复读和幻读
&lt;ul>
&lt;li>允许一个事务读取另一个事务未提交的数据&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>READ_COMMITTED：禁止脏读，但是允许不可重复读和幻读。
&lt;ul>
&lt;li>允许一个事务读取另一个事务已提交的数据&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>REPEATABLE_READ：禁止脏读和不可重复读，但是允许幻读。
&lt;ul>
&lt;li>对同一字段的多次读取结果是一致的&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>SERIALIZABLE：禁止脏读、不可重复读和幻读。
&lt;ul>
&lt;li>最高的隔离级别，会导致性能下降&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="事务超时">事务超时&lt;/h2>
&lt;p>是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务.&lt;/p>
&lt;h2 id="事务只读">事务只读&lt;/h2>
&lt;p>对于只有读取数据查询的事务，可以指定事务类型为 readonly，即只读事务。&lt;/p>
&lt;p>这是一种声明, 用于优化事务性能, 通常用于查询操作, 但不是必须的.&lt;/p>
&lt;p>原因:
给方法加上了Transactional注解的话，这个方法执行的所有sql会被放在一个事务中。如果声明了只读事务的话，数据库就会去优化它的执行.&lt;/p>
&lt;p>比如:&lt;/p>
&lt;ul>
&lt;li>一次执行单条查询, 数据库没必要使用事务支持, 因为默认支持了.&lt;/li>
&lt;li>一次执行大量的查询, 数据库会使用事务支持, 保证数据的一致性.&lt;/li>
&lt;/ul>
&lt;h2 id="spring事务的回滚规则">Spring事务的回滚规则&lt;/h2>
&lt;p>Spring事务的回滚规则有以下几种：&lt;/p>
&lt;ul>
&lt;li>默认情况下，只有遇到运行期异常(RuntimeException 的子类）时才会回滚，Error 也会导致事务回滚，但是，在遇到检查型（Checked）异常时不会回滚。&lt;/li>
&lt;li>通过&lt;code>@Transactional&lt;/code>注解的&lt;code>rollbackFor&lt;/code>属性可以指定哪些异常需要回滚。&lt;/li>
&lt;li>通过&lt;code>@Transactional&lt;/code>注解的&lt;code>noRollbackFor&lt;/code>属性可以指定哪些异常不需要回滚。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="nd">@Transactional&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">rollbackFor&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="n">Exception&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="p">})&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">transfer&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">outUser&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">inUser&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Double&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">money&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">jdbcTemplate&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">update&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;update account set money = money - ? where username = ?&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">money&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">outUser&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">jdbcTemplate&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">update&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;update account set money = money + ? where username = ?&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">money&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">inUser&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="transactional注解使用">@Transactional注解使用&lt;/h2>
&lt;h3 id="作用范围">作用范围&lt;/h3>
&lt;ul>
&lt;li>方法: 推荐用于方法, 但智能用于public方法, 否则不生效.&lt;/li>
&lt;li>类: 用于类上, 会应用到所有的public方法上.&lt;/li>
&lt;li>接口: 不推荐在接口上使用.&lt;/li>
&lt;/ul>
&lt;h3 id="常用配置参数">常用配置参数&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="nd">@Target&lt;/span>&lt;span class="p">({&lt;/span>&lt;span class="n">ElementType&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">TYPE&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ElementType&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">METHOD&lt;/span>&lt;span class="p">})&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nd">@Retention&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">RetentionPolicy&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">RUNTIME&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nd">@Inherited&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nd">@Documented&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nd">@interface&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Transactional&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nd">@AliasFor&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;transactionManager&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">value&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">default&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nd">@AliasFor&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;value&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">transactionManager&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">default&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">Propagation&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">propagation&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">default&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Propagation&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">REQUIRED&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">Isolation&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">isolation&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">default&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Isolation&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">DEFAULT&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">timeout&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">default&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">TransactionDefinition&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">TIMEOUT_DEFAULT&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kt">boolean&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">readOnly&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">default&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">false&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">Class&lt;/span>&lt;span class="o">&amp;lt;?&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">extends&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Throwable&lt;/span>&lt;span class="o">&amp;gt;[]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">rollbackFor&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">default&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{};&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">rollbackForClassName&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">default&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{};&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">Class&lt;/span>&lt;span class="o">&amp;lt;?&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">extends&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Throwable&lt;/span>&lt;span class="o">&amp;gt;[]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">noRollbackFor&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">default&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{};&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">noRollbackForClassName&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">default&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{};&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>五个常用配置参数&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>属性名&lt;/th>
&lt;th>默认值&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>propagation&lt;/td>
&lt;td>Propagation.REQUIRED&lt;/td>
&lt;td>事务的传播行为&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>isolation&lt;/td>
&lt;td>Isolation.DEFAULT&lt;/td>
&lt;td>事务的隔离级别&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>timeout&lt;/td>
&lt;td>TransactionDefinition.TIMEOUT_DEFAULT(-1)&lt;/td>
&lt;td>事务的超时时间&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>readOnly&lt;/td>
&lt;td>false&lt;/td>
&lt;td>事务的只读属性&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>rollbackFor&lt;/td>
&lt;td>{}&lt;/td>
&lt;td>导致事务回滚的异常类数组&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="transactional注解的实现原理">@Transactional注解的实现原理&lt;/h3>
&lt;p>&lt;code>@Transactional&lt;/code>注解的实现原理是基于AOP实现的。&lt;/p>
&lt;p>AOP 又是使用动态代理实现的。如果目标对象实现了接口，默认情况下会采用 JDK 的动态代理，如果目标对象没有实现了接口,会使用 CGLIB 动态代理。&lt;/p>
&lt;h2 id="spring-aop-自调用问题">Spring AOP 自调用问题&lt;/h2>
&lt;p>当一个方法被标记了@Transactional 注解的时候，Spring 事务管理器只会在&lt;strong>被其他类方法调用的时候生效&lt;/strong>，而不会在同一个类中方法调用生效。&lt;/p>
&lt;p>Spring AOP 工作原理决定的。&lt;/p>
&lt;p>因为 Spring AOP 使用动态代理来实现事务的管理，它会在运行的时候为带有 @Transactional 注解的方法生成代理对象，并在方法调用的前后应用事物逻辑。如果该方法被其他类调用我们的代理对象就会拦截方法调用并处理事务。&lt;/p>
&lt;p>但是在&lt;strong>一个类中的其他方法内部调用的时候，我们代理对象就无法拦截到这个内部调用&lt;/strong>，因此事务也就失效了。&lt;/p>
&lt;p>MyService 类中的method1()调用method2()就会导致method2()的事务失效。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="nd">@Service&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">MyService&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">method1&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">method2&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">//......&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nd">@Transactional&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">method2&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">//......&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>解决方法:&lt;/p>
&lt;ul>
&lt;li>避免同一个类内部调用&lt;/li>
&lt;li>使用AspectJ取代Spring AOP(因为AspectJ是编译时织入，Spring AOP是运行时织入)&lt;/li>
&lt;/ul></description></item><item><title/><link>https://ysyyhhh.github.io/docs/language/java/spring/spring%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/language/java/spring/spring%E5%9F%BA%E7%A1%80/</guid><description>&lt;h1 id="spring-基础">Spring 基础&lt;/h1>
&lt;h2 id="spring-概念">Spring 概念&lt;/h2>
&lt;p>Spring 是重量级企业开发框架 Enterprise JavaBean(EJB)的替代品，Spring 为企业级 Java 开发提供了一种相对简单的方法，通过 依赖注入 和 面向切面编程，用简单的 Java 对象(Plain Old Java Object，PoJ0)实现了 EJB 的功能&lt;/p>
&lt;p>缺点:
Spring的组件代码是轻量级,但是Spring的配置文件却是重量级的&lt;/p>
&lt;p>Spring 2.5 引入了注解驱动的开发模式，消除了大量的XML配置&lt;/p>
&lt;p>Spring 3.0 引入了Java配置的方式，可以完全不使用XML配置&lt;/p>
&lt;p>但在使用某些特性时,仍然要配置
如:&lt;/p>
&lt;ul>
&lt;li>事务管理&lt;/li>
&lt;li>SpringMVC&lt;/li>
&lt;/ul>
&lt;h3 id="spring声明周期">Spring声明周期&lt;/h3>
&lt;ul>
&lt;li>Spring容器的生命周期
&lt;ul>
&lt;li>创建容器&lt;/li>
&lt;li>初始化容器&lt;/li>
&lt;li>使用容器&lt;/li>
&lt;li>销毁容器&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="常见的一些模块">常见的一些模块&lt;/h3>
&lt;p>Spring 支持&lt;/p>
&lt;ul>
&lt;li>IoC（Inversion of Control:控制反转）&lt;/li>
&lt;li>AOP(Aspect-Oriented Programming:面向切面编程)&lt;/li>
&lt;/ul>
&lt;p>Spring模块：&lt;/p>
&lt;ul>
&lt;li>Spring Core Container：核心容器， 提供IoC容器的基本功能
&lt;ul>
&lt;li>spring-core：Spring 框架基本的核心工具类。&lt;/li>
&lt;li>spring-beans：提供对 bean 的创建、配置和管理等功能的支持。&lt;/li>
&lt;li>spring-context：提供对国际化、事件传播、资源加载等功能的支持。&lt;/li>
&lt;li>spring-expression：提供对表达式语言（Spring Expression Language） SpEL 的支持，只依赖于 core 模块，不依赖于其他模块，可以单独使用。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Spring AOP：提供面向切面编程的功能
&lt;ul>
&lt;li>spring-aop：提供对 AOP 的支持。&lt;/li>
&lt;li>spring-aspects：提供对 AspectJ 的支持。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Spring Data Access/Integration：提供对数据库操作、事务管理、消息处理等功能的支持
&lt;ul>
&lt;li>spring-jdbc：提供对 JDBC 的支持。&lt;/li>
&lt;li>spring-tx：提供对事务管理的支持。&lt;/li>
&lt;li>spring-orm：提供对 ORM 工具的支持。&lt;/li>
&lt;li>spring-oxm：提供对 Object/XML 映射的支持。&lt;/li>
&lt;li>spring-jms：提供对 JMS 的支持。&lt;/li>
&lt;li>spring-web：提供对 Web 应用的支持。&lt;/li>
&lt;li>spring-webmvc：提供对 Web MVC 的支持。&lt;/li>
&lt;li>spring-websocket：提供对 Web Socket 的支持。&lt;/li>
&lt;li>spring-webflux：提供对 Web Flux 的支持。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Spring Web：提供对 Web 应用的支持
&lt;ul>
&lt;li>spring-web：提供对 Web 应用的支持。&lt;/li>
&lt;li>spring-webmvc：提供对 Web MVC 的支持。&lt;/li>
&lt;li>spring-websocket：提供对 Web Socket 的支持。&lt;/li>
&lt;li>spring-webflux：提供对 Web Flux 的支持。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Spring Test：提供对单元测试和集成测试的支持
&lt;ul>
&lt;li>spring-test：提供对测试的支持。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="spring-spring-mvc-spring-boot的关系">Spring Spring MVC Spring Boot的关系&lt;/h2>
&lt;p>Spring是一个开源框架
Spring MVC是Spring框架的一个模块
Spring Boot是Spring框架的一个子项目。&lt;/p>
&lt;ul>
&lt;li>简化了Spring MVC的配置&lt;/li>
&lt;/ul>
&lt;h3 id="springboot">springboot&lt;/h3>
&lt;p>为了简化spring应用的创建及部署&lt;/p>
&lt;p>SpringBoot优点:&lt;/p>
&lt;p>Spring Boot通过自动配置功能，降低了复杂性，同时支持基于JVM的多种开源框架，可以缩短开发时间，使开发更加简单和高效。&lt;/p>
&lt;p>Spring Boot 遵循“约定优于配置”的原则，提供了一种快速构建Spring应用的方式。(默认配置可以修改)&lt;/p>
&lt;p>提供了嵌入式的Tomcat、Jetty、Undertow等容器，可以通过main方法直接运行。&lt;/p>
&lt;h4 id="spring-boot-starter">Spring Boot Starter&lt;/h4>
&lt;p>Spring Boot Starter 是 Spring Boot 的一个重要特性，它是一种特殊的依赖，可以简化 Maven 或 Gradle 的配置，使得构建 Spring Boot 应用更加简单。
spring-boot-starter-web：提供对 Web 应用的支持。&lt;/p>
&lt;h3 id="spring-boot的特性">Spring Boot的特性&lt;/h3>
&lt;p>支持的Servlet容器:&lt;/p>
&lt;ul>
&lt;li>Tomcat&lt;/li>
&lt;li>Jetty&lt;/li>
&lt;li>Undertow&lt;/li>
&lt;/ul>
&lt;p>如何在Spring Boot中使用Jetty&lt;/p>
&lt;ul>
&lt;li>在pom.xml中排除Tomcat&lt;/li>
&lt;li>添加Jetty的依赖&lt;/li>
&lt;/ul>
&lt;h3 id="springbootapplication注解">SpringBootApplication注解&lt;/h3>
&lt;p>SpringBootApplication注解是Spring Boot的核心注解，它是一个组合注解，包括了@Configuration、@EnableAutoConfiguration、@ComponentScan等注解。&lt;/p>
&lt;p>这三个注解的功能:&lt;/p>
&lt;ul>
&lt;li>@Configuration：表明该类是一个配置类，它会被Spring容器扫描并且用于构建Bean定义，这些Bean定义将被用于构建Spring应用上下文。&lt;/li>
&lt;li>@ComponentScan：自动扫描并加载符合条件的组件或者bean。&lt;/li>
&lt;li>@EnableAutoConfiguration：开启Spring Boot的自动配置功能。&lt;/li>
&lt;/ul>
&lt;h3 id="springboot的自动配置">SpringBoot的自动配置&lt;/h3>
&lt;p>Spring Boot 的自动配置功能是 Spring Boot 的一个重要特性，它可以根据应用的依赖和配置自动配置 Spring 应用。&lt;/p>
&lt;p>Spring Boot 的自动配置功能是通过 @EnableAutoConfiguration 注解实现的，它会根据应用的依赖和配置自动配置 Spring 应用。&lt;/p>
&lt;p>自动装配核心功能的实现实际是通过 AutoConfigurationImportSelector类&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="nd">@Target&lt;/span>&lt;span class="p">({&lt;/span>&lt;span class="n">ElementType&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">TYPE&lt;/span>&lt;span class="p">})&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nd">@Retention&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">RetentionPolicy&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">RUNTIME&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nd">@Documented&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nd">@Inherited&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nd">@AutoConfigurationPackage&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//作用：将main包下的所有组件注册到容器中&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nd">@Import&lt;/span>&lt;span class="p">({&lt;/span>&lt;span class="n">AutoConfigurationImportSelector&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="p">})&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//加载自动装配类 xxxAutoconfiguration&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nd">@interface&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">EnableAutoConfiguration&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ENABLED_OVERRIDE_PROPERTY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;spring.boot.enableautoconfiguration&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">Class&lt;/span>&lt;span class="o">&amp;lt;?&amp;gt;[]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">exclude&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">default&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{};&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">excludeName&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">default&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{};&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>AutoConfigurationImportSelector 类实现了 ImportSelector接口，也就实现了这个接口中的 selectImports方法，该方法主要用于获取所有符合条件的类的全限定类名，这些类需要被加载到 IoC 容器中。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">static&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">final&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">NO_IMPORTS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="o">]&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">selectImports&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">AnnotationMetadata&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">annotationMetadata&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// &amp;lt;1&amp;gt;.判断自动装配开关是否打开&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">if&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">isEnabled&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">annotationMetadata&lt;/span>&lt;span class="p">))&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">NO_IMPORTS&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">else&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">//&amp;lt;2&amp;gt;.获取所有需要装配的bean&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">AutoConfigurationMetadata&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">autoConfigurationMetadata&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">AutoConfigurationMetadataLoader&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">loadMetadata&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">beanClassLoader&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">AutoConfigurationImportSelector&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">AutoConfigurationEntry&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">autoConfigurationEntry&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">getAutoConfigurationEntry&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">autoConfigurationMetadata&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">annotationMetadata&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">StringUtils&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">toStringArray&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">autoConfigurationEntry&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">getConfigurations&lt;/span>&lt;span class="p">());&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="开发restful-web的注解有哪些">开发RESTful Web的注解有哪些&lt;/h3>
&lt;p>RESTful是一种软件架构风格，它是一种设计风格而不是标准，它是一种针对网络应用的设计和开发方式，可以降低开发的复杂性，提高系统的可伸缩性。&lt;/p>
&lt;p>Spring MVC 提供了一些注解来简化 RESTful Web 的开发，这些注解包括：&lt;/p>
&lt;ul>
&lt;li>@RestController：用于定义 RESTful Web 服务。
&lt;ul>
&lt;li>是@Controller和@ResponseBody的组合注解&lt;/li>
&lt;li>表示这是个控制器，并且是一个RESTful的控制器&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>@Component、@Service、@Repository：用于定义组件。&lt;/li>
&lt;li>@GetMapping、@PostMapping、@PutMapping、@DeleteMapping：用于定义 GET、POST、PUT、DELETE 请求。&lt;/li>
&lt;li>@RequestParam、@PathVariable、@RequestBody：分别在处理方法的参数上使用，用于获取请求参数、路径参数、请求体。&lt;/li>
&lt;/ul>
&lt;h3 id="spring-boot的配置文件">Spring Boot的配置文件&lt;/h3>
&lt;p>Spring Boot 的配置文件有两种格式：properties 和 YAML。&lt;/p>
&lt;p>Spring Boot 的配置文件有以下几种位置，对应的优先级从高到低：&lt;/p>
&lt;ul>
&lt;li>当前目录下的 config 目录&lt;/li>
&lt;li>当前目录&lt;/li>
&lt;li>classpath 下的 config 目录&lt;/li>
&lt;li>classpath 根目录&lt;/li>
&lt;li>开发时 resources 目录&lt;/li>
&lt;li>以上位置的 application-{profile}.properties 或 application-{profile}.yml&lt;/li>
&lt;/ul>
&lt;p>读取配置文件&lt;/p>
&lt;p>@Value注解&lt;/p>
&lt;ul>
&lt;li>用于读取配置文件中的属性值&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="nd">@Value&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;${name}&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>@ConfigurationProperties注解&lt;/p>
&lt;ul>
&lt;li>读取并绑定配置文件中的属性值&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="nd">@ConfigurationProperties&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">prefix&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;person&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">Person&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Integer&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">age&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="spring-中的设计模式">Spring 中的设计模式&lt;/h2>
&lt;ul>
&lt;li>工厂模式
&lt;ul>
&lt;li>BeanFactory&lt;/li>
&lt;li>ApplicationContext&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>单例模式
&lt;ul>
&lt;li>Bean的作用域&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>代理模式
&lt;ul>
&lt;li>AOP&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>观察者模式
&lt;ul>
&lt;li>Spring事件驱动模型&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>适配器模式
&lt;ul>
&lt;li>HandlerAdapter&lt;/li>
&lt;li>HandlerMapping&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>模板方法模式
&lt;ul>
&lt;li>JdbcTemplate&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="spring-data-jpa">Spring Data JPA&lt;/h2>
&lt;p>Spring Data JPA 是 Spring 基于 ORM 框架 JPA 封装的一个子项目，用于简化 JPA 的使用。&lt;/p>
&lt;p>Spring Data JPA 提供了一种新的方法来定义仓库接口，通过定义仓库接口来自动生成仓库实现。&lt;/p>
&lt;p>Spring Data JPA 通过解析方法名来自动生成 SQL 语句，从而简化了开发。&lt;/p>
&lt;h3 id="实战">实战&lt;/h3>
&lt;h4 id="创建实体类">创建实体类&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="nd">@Entity&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nd">@Table&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;t_user&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">User&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nd">@Id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nd">@GeneratedValue&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">strategy&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">GenerationType&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">IDENTITY&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Long&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">username&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">password&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">email&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">phone&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Date&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">created&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Date&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">updated&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 省略 getter 和 setter&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使某个字段不参与持久化&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="nd">@Transient&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">code&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="jpa的审计功能">JPA的审计功能&lt;/h3>
&lt;p>JPA提供了审计功能，可以自动记录实体的创建时间和更新时间。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="nd">@EntityListeners&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">AuditingEntityListener&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nd">@MappedSuperclass&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">BaseEntity&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nd">@CreatedDate&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Date&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">created&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nd">@LastModifiedDate&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Date&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">updated&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 省略 getter 和 setter&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>需要在启动类上添加&lt;code>@EnableJpaAuditing&lt;/code>注解&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="nd">@Configuration&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nd">@EnableJpaAuditing&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">JpaConfig&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="hibernate">Hibernate&lt;/h2>
&lt;p>Hibernate 是一个开源的对象关系映射框架，它是一个优秀的ORM（Object-Relational Mapping）框架，它对 JDBC 进行了封装，提供了对象关系映射的功能，可以将 Java 对象映射到数据库表中。&lt;/p>
&lt;h2 id="spring-security">Spring Security&lt;/h2>
&lt;p>Spring Security 是 Spring 提供的一个安全框架，用于对 Java 应用程序进行安全认证和授权。&lt;/p>
&lt;p>hasRole和hasAuthority的区别&lt;/p>
&lt;ul>
&lt;li>hasRole：会在参数上加上ROLE_前缀(所以数据库中的角色名要加上ROLE_前缀)&lt;/li>
&lt;li>hasAuthority：不会在参数上加上ROLE_前缀&lt;/li>
&lt;/ul>
&lt;p>加密&lt;/p>
&lt;ul>
&lt;li>BCryptPasswordEncoder&lt;/li>
&lt;/ul></description></item><item><title/><link>https://ysyyhhh.github.io/docs/language/java/%E5%AE%9E%E6%88%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/language/java/%E5%AE%9E%E6%88%98/</guid><description>&lt;h2 id="线上机器突然cpu暴增有什么可能的原因">线上机器突然cpu暴增，有什么可能的原因&lt;/h2>
&lt;p>&lt;a href="https://www.cnblogs.com/dennyzhangdd/p/11585971.html" target="_blank" rel="noopener">https://www.cnblogs.com/dennyzhangdd/p/11585971.html&lt;/a>
&lt;a href="https://www.cnblogs.com/dennyzhangdd/p/11585971.html" target="_blank" rel="noopener">https://www.cnblogs.com/dennyzhangdd/p/11585971.html&lt;/a>
&lt;a href="https://www.cnblogs.com/huyangshu-fs/p/16718553.html" target="_blank" rel="noopener">https://www.cnblogs.com/huyangshu-fs/p/16718553.html&lt;/a>
&lt;a href="https://cloud.tencent.com/developer/article/1650717" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1650717&lt;/a>&lt;/p>
&lt;p>并发量提升&lt;/p>
&lt;p>内存不足 full GC&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/tips/docker/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/tips/docker/</guid><description>&lt;h1 id="docker相关技巧">docker相关技巧&lt;/h1>
&lt;h2 id="记把深度学习项目装入docker">记把深度学习项目装入docker&lt;/h2>
&lt;p>安装时出现选项&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-Dockerfile" data-lang="Dockerfile">&lt;span class="line">&lt;span class="cl">&lt;span class="c"># RUN apt-get install libglib2.0-dev -y&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 由于安装libglib2.0-dev的时候，bash会有交互操作叫你选择对应的时区，在docker build的时候没有交互的，所以需要加上DEBIAN_FRONTEND=&amp;#34;noninteractive&amp;#34;&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> &lt;span class="nv">DEBIAN_FRONTEND&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;noninteractive&amp;#34;&lt;/span> apt -y install libglib2.0-dev&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="docker清理">docker清理&lt;/h2>
&lt;p>在win10下，docker是基于wsl2的，所以docker的镜像和容器都是在wsl2的文件系统中。
所以在清理完docker的镜像和容器后，需要对wsl的盘进行压缩。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 停止所有的容器&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker stop &lt;span class="k">$(&lt;/span>docker ps -aq&lt;span class="k">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 删除所有未使用的容器&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker volume prune
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 删除所有未使用的镜像&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker image prune -a
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 删除缓存&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker builder prune
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看当前占用的空间&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker system df
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>对wsl2的盘进行压缩&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">wsl --shutdown
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看wsl2的盘&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">wsl --list -v
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 使用diskpart压缩&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">diskpart
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># open window Diskpart&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">select&lt;/span> vdisk &lt;span class="nv">file&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;D:\ubuntu\wsl\docker-desktop-data\ext4.vhdx&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">attach vdisk &lt;span class="nb">readonly&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">compact vdisk
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">detach vdisk
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">exit&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="docker中安装conda">docker中安装conda&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-Dockerfile" data-lang="Dockerfile">&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 安装conda&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> apt-get install -y wget&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># yhyu13 : donwload anaconda package &amp;amp; install&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> wget &lt;span class="s2">&amp;#34;https://repo.anaconda.com/archive/Anaconda3-2023.03-1-Linux-x86_64.sh&amp;#34;&lt;/span> &lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> sh Anaconda3-2023.03-1-Linux-x86_64.sh -b -p /opt/conda&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># RUN rm /anaconda.sh &lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> ln -s /opt/conda/etc/profile.d/conda.sh /etc/profile.d/conda.sh&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;. /opt/conda/etc/profile.d/conda.sh&amp;#34;&lt;/span> &amp;gt;&amp;gt; ~/.bashrc&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># yhyu13 : add conda to path &lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">ENV&lt;/span> PATH /opt/conda/bin:/opt/conda/condabin:&lt;span class="nv">$PATH&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="docker-compose-使用gpu">docker-compose 使用gpu&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">version&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;3.7&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">services&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">pytorch&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">build&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">runtime&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">nvidia&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">environment&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="l">NVIDIA_VISIBLE_DEVICES=all&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="l">NVIDIA_DRIVER_CAPABILITIES=all&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">volumes&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="l">.:/workspace&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">ports&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="s2">&amp;#34;8888:8888&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="s2">&amp;#34;6006:6006&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">command&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">bash -c &amp;#34;jupyter notebook --ip&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="wsl-盘迁移到非系统盘">wsl 盘迁移到非系统盘&lt;/h2>
&lt;p>一般情况下 wsl盘的位置在
&lt;code>C:\Users\&amp;lt;用户名&amp;gt;\AppData\Local\Docker\wsl&lt;/code>&lt;/p>
&lt;p>docker的盘在
&lt;code>C:\Users\&amp;lt;用户名&amp;gt;\AppData\Local\Docker\wsl\data&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 1. 停止wsl&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">wsl --shutdown
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 2. 查看wsl状态&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">wsl --list -v
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 可以看到docker有两个wsl，一个是docker-desktop-data，一个是docker-desktop&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 只需要迁移docker-desktop-data即可,另一个很小&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 3. 迁移wsl&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">wsl --export Ubuntu-20.04 D:&lt;span class="se">\u&lt;/span>buntu&lt;span class="se">\w&lt;/span>sl&lt;span class="se">\U&lt;/span>buntu-20.04.tar
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 4. 删除wsl&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">wsl --unregister Ubuntu-20.04
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 5. 查看是否删除成功&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">wsl --list -v
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 6. 导入wsl&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">wsl --import Ubuntu-20.04 D:&lt;span class="se">\u&lt;/span>buntu&lt;span class="se">\w&lt;/span>sl&lt;span class="se">\U&lt;/span>buntu-20.04 D:&lt;span class="se">\u&lt;/span>buntu&lt;span class="se">\w&lt;/span>sl&lt;span class="se">\U&lt;/span>buntu-20.04.tar --version &lt;span class="m">2&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 7. 查看是否导入成功&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">wsl --list -v
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="docker-中设置特定版本的python">docker 中设置特定版本的python&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 创建一个基础镜像 &lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">FROM ubuntu:20.04
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 重置apt-get&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">RUN rm -rf /etc/apt/sources.list
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 安装conda&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># yhyu13 : install additional packages&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 设置apt的源为tsinghua镜像源&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">RUN sed -i &lt;span class="s1">&amp;#39;s/archive.ubuntu.com/mirrors.tuna.tsinghua.edu.cn/g&amp;#39;&lt;/span> /etc/apt/sources.list
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">RUN apt-get update &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> apt-get install -y curl wget
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 安装conda&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">RUN curl -O https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> bash Miniconda3-latest-Linux-x86_64.sh -b -p /opt/conda &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> rm Miniconda3-latest-Linux-x86_64.sh
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 创建conda环境并安装python&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">RUN /opt/conda/bin/conda create -n py38 &lt;span class="nv">python&lt;/span>&lt;span class="o">=&lt;/span>3.8.5
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ENV PATH /opt/conda/envs/py38/bin:&lt;span class="nv">$PATH&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="docker中使用display">docker中使用display&lt;/h2>
&lt;p>在启动时需要设置环境变量DISPLAY&lt;/p>
&lt;h3 id="win下的情况">win下的情况&lt;/h3>
&lt;p>参考&lt;a href="https://www.cnblogs.com/larva-zhh/p/10531824.html" target="_blank" rel="noopener">在Docker for Windows中运行GUI程序&lt;/a>&lt;/p>
&lt;p>报错：
libGL error: No matching fbConfigs or visuals found&lt;/p>
&lt;p>libGL error: failed to load driver: swrast&lt;/p>
&lt;p>解决办法：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://bbs.huaweicloud.com/blogs/281862" target="_blank" rel="noopener">https://bbs.huaweicloud.com/blogs/281862&lt;/a>&lt;/li>
&lt;li>或取消勾选 native opengl&lt;/li>
&lt;/ul>
&lt;h3 id="ubuntu下的情况">ubuntu下的情况&lt;/h3>
&lt;p>安装虚拟显示屏
&lt;a href="https://blog.csdn.net/Ber_Bai/article/details/127768374" target="_blank" rel="noopener">https://blog.csdn.net/Ber_Bai/article/details/127768374&lt;/a>&lt;/p>
&lt;p>挂载卷传入 /tmp/.X11-unix
DISPLAY一般是:1.0&lt;/p>
&lt;p>在宿主机上
xhost +&lt;/p>
&lt;h2 id="前后端项目静态资源转发">前后端项目静态资源转发&lt;/h2>
&lt;p>后端 springboot时：
把静态资源放在static目录下，然后在application中配置&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">spring&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">mvc&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">static-path-pattern&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/static/**&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">resources&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">static-locations&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">classpath:/static/&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果设置了拦截器，需要在拦截器上加入&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="nd">@Configuration&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">WebMvcConfig&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">implements&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">WebMvcConfigurer&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nd">@Bean&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">CorsInterceptor&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">corsInterceptor&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">CorsInterceptor&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nd">@Override&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">addInterceptors&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">InterceptorRegistry&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">registry&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">registry&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">addInterceptor&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">corsInterceptor&lt;/span>&lt;span class="p">())&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">addPathPatterns&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/**&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nd">@Override&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">addResourceHandlers&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ResourceHandlerRegistry&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">registry&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">registry&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">addResourceHandler&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/static/**&amp;#34;&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="na">addResourceLocations&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;classpath:/static/&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;file:static/&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>jar 包和静态路径关系&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-md" data-lang="md">&lt;span class="line">&lt;span class="cl">&lt;span class="k">-&lt;/span> .jar
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">-&lt;/span> static
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>前端，需要在nginx上加入转发后访问静态路径后缀。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-nginx" data-lang="nginx">&lt;span class="line">&lt;span class="cl"> &lt;span class="k">location&lt;/span> &lt;span class="s">/api&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">rewrite&lt;/span> &lt;span class="s">^/api(.*)&lt;/span> &lt;span class="nv">$1&lt;/span> &lt;span class="s">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">proxy_pass&lt;/span> &lt;span class="nv">$SERVER_URL&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">proxy_set_header&lt;/span> &lt;span class="s">Host&lt;/span> &lt;span class="nv">$host&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">proxy_set_header&lt;/span> &lt;span class="s">X-Real-IP&lt;/span> &lt;span class="nv">$remote_addr&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">proxy_set_header&lt;/span> &lt;span class="s">X-Forwarded-For&lt;/span> &lt;span class="nv">$proxy_add_x_forwarded_for&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">proxy_set_header&lt;/span> &lt;span class="s">X-Forwarded-Photo&lt;/span> &lt;span class="nv">$scheme&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">location&lt;/span> &lt;span class="p">~&lt;/span>&lt;span class="sr">*.+\.(jpg|jpeg|gif|png|ico|css|js|pdf|txt|swf|xml|woff|woff2|ttf|eot|svg)$&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">rewrite&lt;/span> &lt;span class="s">^/api(.*)&lt;/span> &lt;span class="nv">$1&lt;/span> &lt;span class="s">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">proxy_pass&lt;/span> &lt;span class="nv">$SERVER_URL&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">proxy_redirect&lt;/span> &lt;span class="no">off&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="启动docker时使用环境变量的注意事项">启动docker时使用环境变量的注意事项&lt;/h2>
&lt;p>可以通过编写sh文件来载入环境变量
要注意centos 是source，ubuntu 直接 . 就行&lt;/p>
&lt;p>通用docker&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-gdscript3" data-lang="gdscript3">&lt;span class="line">&lt;span class="cl">&lt;span class="n">version&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s1">&amp;#39;3.8&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">services&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">client&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">image&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="o">$&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="n">IMAGE_PREFIX&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="o">/$&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="n">PROJECT_NAME&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="n">_client&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="mf">1.1&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># build: ./client&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ports&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">-&lt;/span> &lt;span class="o">$&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="n">CLIENT_PORT&lt;/span>&lt;span class="p">}:&lt;/span>&lt;span class="o">$&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="n">CLIENT_PORT&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">environment&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">-&lt;/span> &lt;span class="n">BASE_API&lt;/span>&lt;span class="o">=/&lt;/span>&lt;span class="n">api&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">-&lt;/span> &lt;span class="n">SERVER_URL&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">http&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="o">//&lt;/span>&lt;span class="n">server&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="o">$&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="n">SERVER_PORT&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">-&lt;/span> &lt;span class="n">CLIENT_PORT&lt;/span>&lt;span class="o">=$&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="n">CLIENT_PORT&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">admin&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">image&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="o">$&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="n">IMAGE_PREFIX&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="o">/$&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="n">PROJECT_NAME&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="n">_admin&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="mf">1.0&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># build: ./adminr&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">environment&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># - NODE_ENV=production&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># - VITE_APP_TITLE=数据资源管理平台&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># - VITE_APP_BASE_API=/api&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># - VITE_SERVE=http://server:${SERVER_PORT}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">-&lt;/span> &lt;span class="n">BASE_API&lt;/span>&lt;span class="o">=/&lt;/span>&lt;span class="n">api&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">-&lt;/span> &lt;span class="n">SERVER_URL&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">http&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="o">//&lt;/span>&lt;span class="n">server&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="o">$&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="n">SERVER_PORT&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">-&lt;/span> &lt;span class="n">ADMIN_PORT&lt;/span>&lt;span class="o">=$&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="n">ADMIN_PORT&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ports&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">-&lt;/span> &lt;span class="o">$&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="n">ADMIN_PORT&lt;/span>&lt;span class="p">}:&lt;/span>&lt;span class="o">$&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="n">ADMIN_PORT&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">server&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">image&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="o">$&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="n">IMAGE_PREFIX&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="o">/$&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="n">PROJECT_NAME&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="n">_server&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="mf">1.0&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># build: ./server&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ports&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">-&lt;/span> &lt;span class="o">$&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="n">SERVER_PORT&lt;/span>&lt;span class="p">}:&lt;/span>&lt;span class="o">$&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="n">SERVER_PORT&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">environment&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">-&lt;/span> &lt;span class="n">MYSQL_URL&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">jdbc&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">mysql&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="o">//&lt;/span>&lt;span class="n">mysql&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="mi">3306&lt;/span>&lt;span class="o">/$&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="n">MYSQL_DATABASE&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="err">?&lt;/span>&lt;span class="n">useUnicode&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="bp">true&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">characterEncoding&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">utf&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">8&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">serverTimezone&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">Asia&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">Shanghai&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">-&lt;/span> &lt;span class="n">MYSQL_USER&lt;/span>&lt;span class="o">=$&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="n">MYSQL_USER&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">-&lt;/span> &lt;span class="n">MYSQL_PASSWORD&lt;/span>&lt;span class="o">=$&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="n">MYSQL_PASSWORD&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">-&lt;/span> &lt;span class="n">MINIO_ENDPOINT&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">http&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="o">//&lt;/span>&lt;span class="n">minio&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="o">$&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="n">MINIO_PORT&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">-&lt;/span> &lt;span class="n">MINIO_BUCKET_NAME&lt;/span>&lt;span class="o">=$&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="n">MINIO_BUCKET_NAME&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">-&lt;/span> &lt;span class="n">MINIO_ACCESS_KEY&lt;/span>&lt;span class="o">=$&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="n">MINIO_ACCESS_KEY&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">-&lt;/span> &lt;span class="n">MINIO_SECRET_KEY&lt;/span>&lt;span class="o">=$&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="n">MINIO_SECRET_KEY&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">depends_on&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">-&lt;/span> &lt;span class="n">mysql&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">-&lt;/span> &lt;span class="n">minio&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">mysql&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">image&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">mysql&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="mf">5.7&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ports&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">-&lt;/span> &lt;span class="o">$&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="n">MYSQL_PORT&lt;/span>&lt;span class="p">}:&lt;/span>&lt;span class="mi">3306&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">volumes&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">-&lt;/span> &lt;span class="o">$&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="n">DATA_PATH&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">mysql&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">logs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="k">var&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="nb">log&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">mysql&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">-&lt;/span> &lt;span class="o">$&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="n">DATA_PATH&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">mysql&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="k">var&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">lib&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">mysql&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">environment&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">-&lt;/span> &lt;span class="n">MYSQL_ROOT_PASSWORD&lt;/span>&lt;span class="o">=$&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="n">MYSQL_ROOT_PASSWORD&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">-&lt;/span> &lt;span class="n">TZ&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">Asia&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">Shanghai&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">command&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="o">--&lt;/span>&lt;span class="n">character&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">set&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">server&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">utf8mb4&lt;/span> &lt;span class="o">--&lt;/span>&lt;span class="n">collation&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">server&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">utf8mb4_unicode_ci&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">minio&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">image&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">bitnami&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">minio&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">latest&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ports&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">-&lt;/span> &lt;span class="o">$&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="n">MINIO_PORT&lt;/span>&lt;span class="p">}:&lt;/span>&lt;span class="mi">9000&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">-&lt;/span> &lt;span class="o">$&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="n">MINIO_MANAGE_PORT&lt;/span>&lt;span class="p">}:&lt;/span>&lt;span class="mi">9001&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">volumes&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">-&lt;/span> &lt;span class="o">$&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="n">DATA_PATH&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">minio&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">data&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">environment&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">-&lt;/span> &lt;span class="n">MINIO_ROOT_USER&lt;/span>&lt;span class="o">=$&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="n">MINIO_ROOT_USER&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">-&lt;/span> &lt;span class="n">MINIO_ROOT_PASSWORD&lt;/span>&lt;span class="o">=$&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="n">MINIO_ROOT_PASSWORD&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">-&lt;/span> &lt;span class="n">TZ&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">Asia&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">Shanghai&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title/><link>https://ysyyhhh.github.io/docs/tips/linux/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/tips/linux/</guid><description>&lt;h1 id="linux">Linux&lt;/h1>
&lt;h2 id="系统资源相关">系统资源相关&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看内存&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">free -h
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看cpu&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cat /proc/cpuinfo
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看cpu使用情况&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">top
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看GPU使用情况&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">nvidia-smi
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看磁盘&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">df -h
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看系统版本&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cat /etc/os-release
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看系统信息&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">uname -a
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 列出所有文件夹和文件 显示占用空间&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">du -sh *
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看文件夹大小&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">du -sh folder_name
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看文件大小&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">du -sh file_name
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="用户相关">用户相关&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 创建用户&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">useradd -m -s /bin/bash -d /home/username username
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">## 解释: -m 创建用户目录, -s 指定shell, -d 指定用户目录&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 设置密码&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">passwd username
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 删除用户&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">userdel -r username
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 添加用户的sudo权限&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">## 编辑sudoers文件&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">vi /etc/sudoers
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">## 在root ALL=(ALL) ALL下面添加&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">username &lt;span class="nv">ALL&lt;/span>&lt;span class="o">=(&lt;/span>ALL&lt;span class="o">)&lt;/span> ALL
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看用户组&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">groups username
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 修改用户组&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">usermod -g groupname username
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看所有用户&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cat /etc/passwd
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 切换用户&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">su username
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="目录挂载">目录挂载&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看挂载&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">df -h
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 挂载目录&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">mount /dev/sdb1 /home/username/data
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 卸载目录&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">umount /home/username/data
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 挂载硬盘&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">## 查看硬盘&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">fdisk -l
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">## 格式化硬盘&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">fdisk /dev/sdb
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">## 格式化为ext4&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">mkfs.ext4 /dev/sdb1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>挂载目录并立即生效&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 挂载目录&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">mount /dev/sdb1 /home/username/data
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 立即生效&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">mount -a
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="文件">文件&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 带权限复制&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cp -rp &lt;span class="nb">source&lt;/span> dest
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 远程连接复制文件&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">scp -r username@ip:/home/username/data /home/username/data
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 权限设置&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">chmod &lt;span class="m">777&lt;/span> filename
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 参数解释&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 7: 111 读写执行&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 6: 110 读写&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 5: 101 读执行&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 三位数分别代表所有者、所属组、其他用户的权限&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 读、写、执行分别用4、2、1表示&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="进程">进程&lt;/h2>
&lt;p>查看端口占用&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">netstat -tunlp
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>查看进程状态&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">ps -ef
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="工具">工具&lt;/h2>
&lt;h3 id="压缩解压缩">压缩解压缩&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 压缩&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">tar -czvf filename.tar.gz foldername
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 解压&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">tar -xzvf filename.tar.gz
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">### 定时脚本
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">```shell
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 查看定时脚本
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">crontab -l
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="curl">curl&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 下载文件&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">curl -o filename url
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="系统路径变量">系统路径/变量&lt;/h2>
&lt;p>持久化添加/改变系统路径/变量&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 添加到系统路径&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">echo&lt;/span> &lt;span class="s1">&amp;#39;export PATH=$PATH:/home/username/bin&amp;#39;&lt;/span> &amp;gt;&amp;gt; /etc/profile
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 立即生效&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">source&lt;/span> /etc/profile
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="tool">tool&lt;/h2>
&lt;h3 id="ssh">ssh&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 生成密钥&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ssh-keygen -t rsa -C &lt;span class="s2">&amp;#34;{email}&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看密钥&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cat ~/.ssh/id_rsa.pub
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="apt">apt&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 设置tsinghua源&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo sed -i &lt;span class="s1">&amp;#39;s/archive.ubuntu.com/mirrors.tuna.tsinghua.edu.cn/g&amp;#39;&lt;/span> /etc/apt/sources.list
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title/><link>https://ysyyhhh.github.io/docs/tips/piplineaction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/tips/piplineaction/</guid><description>&lt;p>&lt;a href="https://docs.github.com/en/actions/migrating-to-github-actions/manual-migrations/migrating-from-gitlab-cicd-to-github-actions" target="_blank" rel="noopener">github action&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://docs.gitlab.com/ee/ci/" target="_blank" rel="noopener">gitlab pipline&lt;/a>&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/tips/server/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/tips/server/</guid><description>&lt;h1 id="服务器">服务器&lt;/h1>
&lt;h2 id="scp传输文件">scp传输文件&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 本地到远程&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">scp -r /home/username/data username@ip:/home/username/data
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title/><link>https://ysyyhhh.github.io/docs/tips/windows%E4%B8%8B%E7%9A%84%E5%AD%90%E7%B3%BB%E7%BB%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/tips/windows%E4%B8%8B%E7%9A%84%E5%AD%90%E7%B3%BB%E7%BB%9F/</guid><description>&lt;h1 id="windows-下的子系统">windows 下的子系统&lt;/h1>
&lt;h2 id="wsl">wsl&lt;/h2>
&lt;p>pass&lt;/p>
&lt;h2 id="适用于android的windows子系统">适用于Android的Windows子系统&lt;/h2>
&lt;p>安装apk&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">adb install xxx.apk
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title/><link>https://ysyyhhh.github.io/docs/tool/docker/docker/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/tool/docker/docker/</guid><description>&lt;h1 id="docker-usage">docker Usage&lt;/h1>
&lt;h2 id="多阶段构建docker镜像">多阶段构建docker镜像&lt;/h2>
&lt;p>多阶段构建的修改不会保留到下一阶段，只有COPY和ADD命令会保留到下一阶段&lt;/p>
&lt;p>usages：&lt;/p>
&lt;ul>
&lt;li>第一阶段：编译/打包程序依赖&lt;/li>
&lt;/ul>
&lt;p>多阶段用途：&lt;/p>
&lt;ul>
&lt;li>缩小镜像体积&lt;/li>
&lt;li>&lt;/li>
&lt;/ul>
&lt;h2 id="新系统build时出现cannot-autolaunch-d-bus-without-x11-display">新系统build时出现&lt;code>Cannot autolaunch D-Bus without X11 $DISPLAY&lt;/code>&lt;/h2>
&lt;p>docker 拉取包时需要登录.&lt;/p>
&lt;p>问题出在Linux缺少一个密码管理包gnupg，它用于加密，我们在登录时需要这个包将密码加密后才能完成，因此直接安装&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">sudo apt install gnupg2 pass
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title/><link>https://ysyyhhh.github.io/docs/tool/docker/docker%E5%91%BD%E4%BB%A4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/tool/docker/docker%E5%91%BD%E4%BB%A4/</guid><description>&lt;h1 id="docker命令">Docker命令&lt;/h1>
&lt;h2 id="安装docker">安装docker&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">sudo apt -y update
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo apt -y upgrade
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo apt -y full-upgrade
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 安装依赖&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo apt install -y apt-transport-https ca-certificates curl software-properties-common gnupg lsb-release
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 添加官方GPG密钥&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">curl -fsSL https://download.docker.com/linux/ubuntu/gpg &lt;span class="p">|&lt;/span> sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">#添加仓库&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;deb [arch=&lt;/span>&lt;span class="k">$(&lt;/span>dpkg --print-architecture&lt;span class="k">)&lt;/span>&lt;span class="s2"> signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu &lt;/span>&lt;span class="k">$(&lt;/span>lsb_release -cs&lt;span class="k">)&lt;/span>&lt;span class="s2"> stable&amp;#34;&lt;/span> &lt;span class="p">|&lt;/span> sudo tee /etc/apt/sources.list.d/docker.list &amp;gt; /dev/null
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 更新apt&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo apt -y update
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 安装docker&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo apt install -y docker-ce docker-ce-cli containerd.io docker-compose-plugin
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 安装docker-compose&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo apt install -y docker-compose
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>centos 6.9 下安装docker&lt;/p>
&lt;p>&lt;a href="https://medium.com/@zihansyu/centos-6-x-%E5%AE%89%E8%A3%9Ddocker-9e61354fd2ae" target="_blank" rel="noopener">https://medium.com/@zihansyu/centos-6-x-%E5%AE%89%E8%A3%9Ddocker-9e61354fd2ae&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://blog.csdn.net/kinginblue/article/details/73527832" target="_blank" rel="noopener">https://blog.csdn.net/kinginblue/article/details/73527832&lt;/a>&lt;/p>
&lt;h2 id="1镜像相关">1.镜像相关&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 构建镜像&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker build &lt;span class="o">[&lt;/span>选项&lt;span class="o">]&lt;/span> &amp;lt;上下文路径/URL/-&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 选项: -f, --file=&amp;#34;&amp;#34; # 指定要使用的Dockerfile路径（默认为./Dockerfile）&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># --force-rm=false # 在构建过程中删除中间容器&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># --no-cache=false # 始终使用缓存&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># --pull=false # 在构建过程中尝试去更新镜像的新版本&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># --quiet=false # 安静模式，成功后只输出镜像ID&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># --rm=true # 在构建成功后删除临时容器&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># -t, --tag=[] # 镜像名称（默认值：&amp;lt;上下文路径&amp;gt;的基本名称）&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># --ulimit=[] # Ulimit配置&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 拉取镜像&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker pull &lt;span class="o">[&lt;/span>选项&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>Docker Registry 地址&lt;span class="o">[&lt;/span>:端口号&lt;span class="o">]&lt;/span>/&lt;span class="o">]&lt;/span>仓库名&lt;span class="o">[&lt;/span>:标签&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看镜像&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker images &lt;span class="o">[&lt;/span>选项&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>仓库名&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 删除镜像&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker rmi &lt;span class="o">[&lt;/span>选项&lt;span class="o">]&lt;/span> &amp;lt;镜像1&amp;gt; &lt;span class="o">[&lt;/span>&amp;lt;镜像2&amp;gt; ...&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看镜像历史&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker &lt;span class="nb">history&lt;/span> &lt;span class="o">[&lt;/span>选项&lt;span class="o">]&lt;/span> &amp;lt;镜像名&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看镜像详细信息&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker inspect &lt;span class="o">[&lt;/span>选项&lt;span class="o">]&lt;/span> &amp;lt;镜像名&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="2容器相关">2.容器相关&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 创建容器&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker run &lt;span class="o">[&lt;/span>选项&lt;span class="o">]&lt;/span> &amp;lt;镜像名&amp;gt; &lt;span class="o">[&lt;/span>命令&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">#eg: docker run -d -p 8080:8080 --name tomcat tomcat:8.5.51&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">#选项&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># -d 后台运行容器，并返回容器ID&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># -i 以交互模式运行容器，通常与 -t 同时使用&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># -t 为容器重新分配一个伪输入终端，通常与 -i 同时使用&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># -P 随机端口映射&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># -p 指定端口映射，格式为：主机(宿主)端口:容器端口&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># --name 指定容器名字&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># --link 连接到其它容器&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># --rm 容器退出后自动删除容器文件&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># --volumes-from 从其它容器或数据卷挂载一些配置或其它文件&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># --volume 挂载宿主机目录或文件，格式为：主机目录:容器目录&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># --privileged=true 给容器内的root用户赋予最高权限，容器内的root用户就拥有了真正的root权限&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># --restart&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># no 容器退出时不重启&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># on-failure[:max-retries] 容器故障退出（返回值非零）时重启，最多重启max-retries次&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># always 容器退出时总是重启&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># unless-stopped 容器退出时总是重启，但是不考虑在Docker守护进程启动时就已经停止了的容器&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># --env-file 从指定文件读入环境变量&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># eg:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># docker run -d -p 8080:8080 --name tomcat tomcat:8.5.51 --env-file ./env.list&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看容器&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker ps &lt;span class="o">[&lt;/span>选项&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 删除容器&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker rm &lt;span class="o">[&lt;/span>选项&lt;span class="o">]&lt;/span> &amp;lt;容器名&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 启动容器&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 启动和创建容器的区别在于，启动容器是针对已经创建好的容器进行启动，而创建容器则是针对镜像进行的操作&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker start &lt;span class="o">[&lt;/span>选项&lt;span class="o">]&lt;/span> &amp;lt;容器名&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 停止容器&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker stop &lt;span class="o">[&lt;/span>选项&lt;span class="o">]&lt;/span> &amp;lt;容器名&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看容器日志&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker logs &lt;span class="o">[&lt;/span>选项&lt;span class="o">]&lt;/span> &amp;lt;容器名&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看容器内进程&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker top &lt;span class="o">[&lt;/span>选项&lt;span class="o">]&lt;/span> &amp;lt;容器名&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看容器详细信息&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker inspect &lt;span class="o">[&lt;/span>选项&lt;span class="o">]&lt;/span> &amp;lt;容器名&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 进入容器&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker &lt;span class="nb">exec&lt;/span> &lt;span class="o">[&lt;/span>选项&lt;span class="o">]&lt;/span> &amp;lt;容器名&amp;gt; &lt;span class="o">[&lt;/span>命令&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 导出容器&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker &lt;span class="nb">export&lt;/span> &lt;span class="o">[&lt;/span>选项&lt;span class="o">]&lt;/span> &amp;lt;容器名&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 导入容器&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker import &lt;span class="o">[&lt;/span>选项&lt;span class="o">]&lt;/span> &amp;lt;容器名&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 重命名容器&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker rename &lt;span class="o">[&lt;/span>选项&lt;span class="o">]&lt;/span> &amp;lt;容器名&amp;gt; &amp;lt;新容器名&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看容器使用的资源&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker stats &lt;span class="o">[&lt;/span>选项&lt;span class="o">]&lt;/span> &amp;lt;容器名&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看容器端口映射&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker port &lt;span class="o">[&lt;/span>选项&lt;span class="o">]&lt;/span> &amp;lt;容器名&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 导出容器中的文件&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker cp &lt;span class="o">[&lt;/span>选项&lt;span class="o">]&lt;/span> &amp;lt;容器名&amp;gt;:&amp;lt;容器内路径&amp;gt; &amp;lt;宿主机路径&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 选项: -a, --archive=false # 归档模式(默认)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># -L, --follow-link=false # 总是解析符号链接&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># -d, --device=false # 复制字符和块设备&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># -r, --recursive=false # 递归复制整个目录&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># -p, --pause=true # 暂停容器中的所有进程&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="docker-检查与排错">docker 检查与排错&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">docker logs &lt;span class="o">[&lt;/span>选项&lt;span class="o">]&lt;/span> &amp;lt;容器名&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 选项: -f, --follow=false # 跟踪日志输出&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># --since=&amp;#34;&amp;#34; # 显示自某个timestamp之后的日志，或相对时间，如42m（即42分钟）&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># --tail=&amp;#34;all&amp;#34; # 从日志末尾显示多少行日志， 默认是all&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># -t, --timestamps=false # 显示时间戳&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># --until=&amp;#34;&amp;#34; # 显示自某个timestamp之前的日志，或相对时间，如42m（即42分钟）&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看容器占用&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker stats &lt;span class="o">[&lt;/span>选项&lt;span class="o">]&lt;/span> &amp;lt;容器名&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 选项: --all=false # 显示所有容器（默认显示运行中的容器）&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># --format=&amp;#34;&amp;#34; # 使用Go模板显示&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># --no-stream=false # 不显示实时流容器的统计信息&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># --no-trunc=false # 不截断输出&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 停止所有容器&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker stop &lt;span class="k">$(&lt;/span>docker ps -a -q&lt;span class="k">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 移除所有容器&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker rm &lt;span class="k">$(&lt;/span>docker ps -a -q&lt;span class="k">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 移除所有镜像&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker image rmi &lt;span class="k">$(&lt;/span>docker images -q&lt;span class="k">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 清空docker中所有的东西&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker system prune -a
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 清空缓存&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker system prune -f
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 清空未使用的镜像&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker image prune -a
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 清空未使用的容器&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker container prune
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 清空未使用的卷&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker volume prune
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 清空未使用的网络&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker network prune
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 清空未使用的构建缓存&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker builder prune
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 清空未使用的数据&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker system prune -a --volumes
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 清空所有未使用的数据&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker system prune -a --volumes --force
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="3容器日志">3.容器日志&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看容器日志&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker logs &lt;span class="o">[&lt;/span>选项&lt;span class="o">]&lt;/span> &amp;lt;容器名&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 选项: -f, --follow=false # 跟踪日志输出&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># --since=&amp;#34;&amp;#34; # 显示自某个timestamp之后的日志，或相对时间，如42m（即42分钟）&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># --tail=&amp;#34;all&amp;#34; # 从日志末尾显示多少行日志， 默认是all&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># -t, --timestamps=false # 显示时间戳&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># --until=&amp;#34;&amp;#34; # 显示自某个timestamp之前的日志，或相对时间，如42m（即42分钟）&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="docker-submodule">docker submodule&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 获取子模块&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git submodule update --init --recursive
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="docker-compose">docker-compose&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 启动命令&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker-compose up &lt;span class="o">[&lt;/span>选项&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>服务名&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 选项&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># -d 后台运行&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># --build 构建镜像&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 删除容器&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker-compose rm &lt;span class="o">[&lt;/span>选项&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>服务名&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 删除镜像&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker-compose down &lt;span class="o">[&lt;/span>选项&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>服务名&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="docker私服的相关命令">docker私服的相关命令&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 登录&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker login
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 上传&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker push &amp;lt;镜像名&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title/><link>https://ysyyhhh.github.io/docs/tool/git/git/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/tool/git/git/</guid><description>&lt;h1 id="git">git&lt;/h1>
&lt;h2 id="git-常用命令">git 常用命令&lt;/h2>
&lt;h3 id="git-基本配置">git 基本配置&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">git config --global user.name &lt;span class="s2">&amp;#34;your name&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git config --global user.email &lt;span class="s2">&amp;#34;your email&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="git-基本操作">git 基本操作&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">git init &lt;span class="c1"># 初始化仓库&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git add . &lt;span class="c1"># 添加所有文件到暂存区&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git commit -m &lt;span class="s2">&amp;#34;commit message&amp;#34;&lt;/span> &lt;span class="c1"># 提交到本地仓库&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git remote add origin
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git push -u origin master &lt;span class="c1"># 推送到远程仓库&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git pull origin master &lt;span class="c1"># 拉取远程仓库&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git clone &lt;span class="c1"># 克隆远程仓库&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git status &lt;span class="c1"># 查看当前状态&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git log &lt;span class="c1"># 查看提交日志&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git diff &lt;span class="c1"># 查看修改内容&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git branch &lt;span class="c1"># 查看分支&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git checkout -b branch_name &lt;span class="c1"># 创建并切换到新分支&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git checkout branch_name &lt;span class="c1"># 切换分支&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git merge branch_name &lt;span class="c1"># 合并分支&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git branch -d branch_name &lt;span class="c1"># 删除分支&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git reset --hard HEAD^ &lt;span class="c1"># 回退到上一个版本&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git reset --hard commit_id &lt;span class="c1"># 回退到指定版本&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git reflog &lt;span class="c1"># 查看命令历史&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git rm file_name &lt;span class="c1"># 删除文件&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git stash &lt;span class="c1"># 暂存当前修改&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git stash list &lt;span class="c1"># 查看暂存列表&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git stash apply &lt;span class="c1"># 恢复暂存&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git stash drop &lt;span class="c1"># 删除暂存&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git stash pop &lt;span class="c1"># 恢复并删除暂存&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git remote -v &lt;span class="c1"># 查看远程仓库地址&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git remote set-url origin new_url &lt;span class="c1"># 修改远程仓库地址&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git push origin --delete branch_name &lt;span class="c1"># 删除远程分支&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git push origin :branch_name &lt;span class="c1"># 删除远程分支&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git tag &lt;span class="c1"># 查看标签&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git tag tag_name &lt;span class="c1"># 创建标签&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git tag tag_name commit_id &lt;span class="c1"># 指定提交创建标签&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git tag -a tag_name -m &lt;span class="s2">&amp;#34;tag message&amp;#34;&lt;/span> &lt;span class="c1"># 创建带有说明的标签&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git tag -d tag_name &lt;span class="c1"># 删除标签&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git push origin tag_name &lt;span class="c1"># 推送标签到远程&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git push origin --tags &lt;span class="c1"># 推送所有标签到远程&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git push origin :refs/tags/tag_name &lt;span class="c1"># 删除远程标签&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git push origin --delete tag tag_name &lt;span class="c1"># 删除远程标签&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git checkout -- file_name &lt;span class="c1"># 撤销工作区修改&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git reset HEAD file_name &lt;span class="c1"># 撤销暂存区修改&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git reset --hard HEAD^ &lt;span class="c1"># 撤销本地提交&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git reset --hard commit_id &lt;span class="c1"># 撤销本地提交&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git config --global alias.st status &lt;span class="c1"># 设置别名&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git config --global alias.co checkout &lt;span class="c1"># 设置别名&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git config --global alias.ci commit &lt;span class="c1"># 设置别名&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git config --global alias.br branch &lt;span class="c1"># 设置别名&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git config --global alias.unstage &lt;span class="s1">&amp;#39;reset HEAD&amp;#39;&lt;/span> &lt;span class="c1"># 设置别名&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git config --global alias.last &lt;span class="s1">&amp;#39;log -1&amp;#39;&lt;/span> &lt;span class="c1"># 设置别名&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git config --global alias.lg &lt;span class="s2">&amp;#34;log --color --graph --pretty=format:&amp;#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&amp;lt;%an&amp;gt;%Creset&amp;#39; --abbrev-commit&amp;#34;&lt;/span> &lt;span class="c1"># 设置别名&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="git-子模块">git 子模块&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看子模块&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git submodule
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git submodule add &lt;span class="c1"># 添加子模块&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 添加子模块并自定义子模块目录名称和分支&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git submodule add &amp;lt;repository&amp;gt; &lt;span class="o">[&lt;/span>&amp;lt;path&amp;gt;&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git submodule init &lt;span class="c1"># 初始化子模块&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git submodule update &lt;span class="c1"># 更新子模块&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git submodule foreach git pull &lt;span class="c1"># 更新所有子模块&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 删除子模块&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 1. 删除.gitmodules中对应子模块的条目&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 2. 删除.git/config中对应子模块的条目&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 3. 执行git rm --cached path/to/submodule&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 4. 执行rm -rf .git/modules/path/to/submodule&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 5. 执行rm -rf path/to/submodule&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="gitignore">gitignore&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">在已忽略文件夹中不忽略指定文件夹：
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">/libs/*
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">!/libs/extend/
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title/><link>https://ysyyhhh.github.io/docs/tool/git/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/tool/git/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</guid><description>&lt;p>多个笔记之间存在关联, 可以先在mind-wings内笔记搜索, 再搜索百度.&lt;/p>
&lt;p>笔记格式为&lt;/p>
&lt;ul>
&lt;li>指令集&lt;/li>
&lt;li>名称解释&lt;/li>
&lt;li>学习步骤&lt;/li>
&lt;/ul>
&lt;p>其中指令集和名称解释是将学习步骤的内容做一个简要整理, 即备忘录. 目的是方便快速搜索.&lt;/p>
&lt;p>如果是初学者,直接跳过指令集和名词解释.&lt;/p>
&lt;h1 id="指令集">指令集&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">git init # 初始化本地git仓库（创建新仓库）
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git config --global user.name &amp;#34;xxx&amp;#34; # 配置用户名
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git config --global user.email &amp;#34;xxx@xxx.com&amp;#34; # 配置邮件
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git config --global color.ui true # git status等命令自动着色
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git config --global color.status auto
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git config --global color.diff auto
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git config --global color.branch auto
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git config --global color.interactive auto
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git config --global --unset http.proxy # remove proxy configuration on git
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git clone git+ssh://git@192.168.53.168/VT.git # clone远程仓库
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git status # 查看当前版本状态（是否修改）
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git add xyz # 添加xyz文件至index
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git add . # 增加当前子目录下所有更改过的文件至index
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git commit -m &amp;#39;xxx&amp;#39; # 提交
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git commit --amend -m &amp;#39;xxx&amp;#39; # 合并上一次提交（用于反复修改）
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git commit -am &amp;#39;xxx&amp;#39; # 将add和commit合为一步
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git rm xxx # 删除index中的文件
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git rm -r * # 递归删除
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git log # 显示提交日志
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git log -1 # 显示1行日志 -n为n行
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git log -5
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git log --stat # 显示提交日志及相关变动文件
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git log -p -m
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git show dfb02e6e4f2f7b573337763e5c0013802e392818 # 显示某个提交的详细内容
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git show dfb02 # 可只用commitid的前几位
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git show HEAD # 显示HEAD提交日志
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git show HEAD^ # 显示HEAD的父（上一个版本）的提交日志 ^^为上两个版本 ^5为上5个版本
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git tag # 显示已存在的tag
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git tag -a v2.0 -m &amp;#39;xxx&amp;#39; # 增加v2.0的tag
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git show v2.0 # 显示v2.0的日志及详细内容
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git log v2.0 # 显示v2.0的日志
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git diff # 显示所有未添加至index的变更
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git diff --cached # 显示所有已添加index但还未commit的变更
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git diff HEAD^ # 比较与上一个版本的差异
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git diff HEAD -- ./lib # 比较与HEAD版本lib目录的差异
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git diff origin/master..master # 比较远程分支master上有本地分支master上没有的
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git diff origin/master..master --stat # 只显示差异的文件，不显示具体内容
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git remote add origin git+ssh://git@192.168.53.168/VT.git # 增加远程定义（用于push/pull/fetch）
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git branch # 显示本地分支
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git branch --contains 50089 # 显示包含提交50089的分支
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git branch -a # 显示所有分支
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git branch -r # 显示所有原创分支
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git branch --merged # 显示所有已合并到当前分支的分支
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git branch --no-merged # 显示所有未合并到当前分支的分支
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git branch -m master master_copy # 本地分支改名
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git checkout -b master_copy # 从当前分支创建新分支master_copy并检出
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git checkout -b master master_copy # 上面的完整版
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git checkout features/performance # 检出已存在的features/performance分支
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git checkout --track hotfixes/BJVEP933 # 检出远程分支hotfixes/BJVEP933并创建本地跟踪分支
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git checkout v2.0 # 检出版本v2.0
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git checkout -b devel origin/develop # 从远程分支develop创建新本地分支devel并检出
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git checkout -- README # 检出head版本的README文件（可用于修改错误回退）
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git merge origin/master # 合并远程master分支至当前分支
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git cherry-pick ff44785404a8e # 合并提交ff44785404a8e的修改
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git push origin master # 将当前分支push到远程master分支
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git push origin :hotfixes/BJVEP933 # 删除远程仓库的hotfixes/BJVEP933分支
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git push --tags # 把所有tag推送到远程仓库
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git fetch # 获取所有远程分支（不更新本地分支，另需merge）
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git fetch --prune # 获取所有原创分支并清除服务器上已删掉的分支
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git pull origin master # 获取远程分支master并merge到当前分支
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git mv README README2 # 重命名文件README为README2
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git reset --hard HEAD # 将当前版本重置为HEAD（通常用于merge失败回退）
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git rebase
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git branch -d hotfixes/BJVEP933 # 删除分支hotfixes/BJVEP933（本分支修改已合并到其他分支）
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git branch -D hotfixes/BJVEP933 # 强制删除分支hotfixes/BJVEP933
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git ls-files # 列出git index包含的文件
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git show-branch # 图示当前分支历史
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git show-branch --all # 图示所有分支历史
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git whatchanged # 显示提交历史对应的文件修改
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git revert dfb02e6e4f2f7b573337763e5c0013802e392818 # 撤销提交dfb02e6e4f2f7b573337763e5c0013802e392818
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git ls-tree HEAD # 内部命令：显示某个git对象
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git rev-parse v2.0 # 内部命令：显示某个ref对于的SHA1 HASH
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git reflog # 显示所有提交，包括孤立节点
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git show HEAD@{5}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git show master@{yesterday} # 显示master分支昨天的状态
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git log --pretty=format:&amp;#39;%h %s&amp;#39; --graph # 图示提交日志
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git show HEAD~3
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git show -s --pretty=raw 2be7fcb476
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git stash # 暂存当前修改，将所有至为HEAD状态
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git stash list # 查看所有暂存
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git stash show -p stash@{0} # 参考第一次暂存
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git stash apply stash@{0} # 应用第一次暂存
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git grep &amp;#34;delete from&amp;#34; # 文件中搜索文本“delete from”
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git grep -e &amp;#39;#define&amp;#39; --and -e SORT_DIRENT
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git gc
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git fsck
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="名词解释">名词解释&lt;/h1>
&lt;p>repo&lt;/p>
&lt;h1 id="git概述">Git概述&lt;/h1>
&lt;h2 id="简要介绍">简要介绍&lt;/h2>
&lt;h2 id="安装与检查">安装与检查&lt;/h2>
&lt;p>安装命令&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">sudo apt-get install git #Ubuntu
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo yum install git #Centos
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>检查安装是否成功&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">git --version #检查版本号
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="配置">配置&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">git config --global user.name &amp;#34;username&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git config --global user.email &amp;#34;xxx@example.com&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title/><link>https://ysyyhhh.github.io/docs/tool/ide/vscode%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%85%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/tool/ide/vscode%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%85%A8/</guid><description>&lt;h1 id="工作学习流vscode快捷键">工作学习流(vscode快捷键)&lt;/h1>
&lt;h2 id="markdown-快捷键">markdown 快捷键&lt;/h2>
&lt;p>删除线: &lt;code>alt + s&lt;/code>&lt;/p>
&lt;p>待办事项勾选/取消勾选: &lt;code>alt + c&lt;/code>&lt;/p>
&lt;h2 id="terminal">terminal&lt;/h2>
&lt;p>命令行创建: &lt;code>Ctrl + Shift + ~&lt;/code>&lt;/p>
&lt;p>命令行切换: &lt;code>Ctrl + fn + upArrow/downArrow&lt;/code>&lt;/p>
&lt;h2 id="view">view&lt;/h2>
&lt;h2 id="run">Run&lt;/h2>
&lt;p>Run python file in terminal: &lt;code>Ctrl + F5&lt;/code>&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/tool/k8s/k8s/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/tool/k8s/k8s/</guid><description>&lt;h1 id="k8s">k8s&lt;/h1>
&lt;p>&lt;strong>&lt;a href="https://kubernetes.io/zh-cn/docs/reference/kubectl/" target="_blank" rel="noopener">kubectl&lt;/a> 命令行工具&lt;/strong>&lt;/p>
&lt;p>kubectl [command] [TYPE] [NAME] [flags]&lt;/p>
&lt;p>- &lt;code>command&lt;/code>：指定要对一个或多个资源执行的操作，例如 &lt;code>create&lt;/code>、&lt;code>get&lt;/code>、&lt;code>describe&lt;/code>、&lt;code>delete&lt;/code>。&lt;/p>
&lt;p>- &lt;code>TYPE&lt;/code>：指定&lt;a href="https://kubernetes.io/zh-cn/docs/reference/kubectl/#resource-types" target="_blank" rel="noopener">资源类型&lt;/a>。资源类型不区分大小写， 可以指定单数、复数或缩写形式。&lt;/p>
&lt;p>- &lt;code>NAME&lt;/code>：指定资源的名称。名称区分大小写。 如果省略名称，则显示所有资源的详细信息。例如：&lt;/p>
&lt;p>命令大全&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">- kubectl get:列出资源,比如 pod、deployment、service 等
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">- kubectl describe:显示资源的详细信息
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">- kubectl create:创建资源,比如 pod、deployment、service 等
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">- kubectl delete:删除资源
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">- kubectl apply:对资源进行配置更改
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">- kubectl rollout:管理资源的发布,比如 deployment 的发布
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">- kubectl scale:扩缩 pod 副本数
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">- kubectl expose:暴露资源为 service
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">- kubectl logs:打印 pod 的日志
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">- kubectl exec:在 pod 内执行命令
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">- kubectl cp:在 pod 之间 copy 文件
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">- kubectl port-forward:将 pod 的端口转发到本地
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">- kubectl label:给资源加标签
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">- kubectl annotate:给资源加注释
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">- kubectl config:管理 kubeconfig 文件
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">- kubectl cluster-info:显示集群信息
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">- kubectl version:显示 CLI 版本和服务端版本
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">- kubectl api-versions:显示所支持的 API 版本
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">- kubectl api-resources:显示每个API group下的资源列表
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>常用命令&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kubectl get 资源类型
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kubectl get pod
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kubectl get pod -o wide
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kubectl get deployment
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kubectl get deployment -o wide
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kubectl get namespace
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 指定查看某个命名空间下的pod
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kubectl get pod -n kube-system
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 查看所有命名空间下的pod
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kubectl get pod -A -o wide
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kubectl describe 资源类型
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kubectl describe pod
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kubectl describe pod web-nginx-dep2-5f4fbd5bfb-jqw9z
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kubectl describe pod -o wide
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kubectl describe deployment
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kubectl describe deployment -o wide
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kubectl describe namespace
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 指定查看某个命名空间下的pod
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kubectl describe pod -n kube-system
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 查看所有命名空间下的pod
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kubectl describe pod -A -o wide
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kubectl logs 显示pod中的容器中运行过程中产生的日志信息
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kubectl logs ngx-dep3-64cfcc9ddc-92x9s
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kubectl logs injoi-5c9b8f98bd-trm95 | grep &amp;#34;capturing the emotions&amp;#34; -A 100 -B 100 搜索并查看上下文
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kubectl run bx --image=busybox
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kubectl exec -it nginx-dep1-6dd5d75f8b-mgndd /bin/bash
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kubectl exec -it pod对象 /bin/bash
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://kubernetes.io/zh-cn/docs/" target="_blank" rel="noopener">https://kubernetes.io/zh-cn/docs/&lt;/a>&lt;/p>
&lt;h1 id="container">container&lt;/h1>
&lt;h1 id="pod">pod&lt;/h1>
&lt;p>Pod 类似于共享名字空间并共享文件系统卷的一组容器。&lt;/p>
&lt;h1 id="deployment">deployment&lt;/h1>
&lt;h2 id="depploymentyaml">depployment.yaml&lt;/h2>
&lt;p>① &lt;code>apiVersion&lt;/code> 是当前配置格式的版本。&lt;br>
② &lt;code>kind&lt;/code> 是要创建的资源类型，这里是 &lt;code>Deployment&lt;/code>。&lt;br>
③ &lt;code>metadata&lt;/code> 是该资源的元数据，&lt;code>name&lt;/code> 是必需的元数据项。&lt;br>
④ &lt;code>spec&lt;/code> 部分是该 &lt;code>Deployment&lt;/code> 的规格说明。&lt;br>
⑤ &lt;code>replicas&lt;/code> 指明副本数量，默认为 1。&lt;br>
⑥ &lt;code>template&lt;/code> 定义 Pod 的模板，这是配置文件的重要部分。&lt;br>
⑦ &lt;code>metadata&lt;/code> 定义 Pod 的元数据，至少要定义一个 label。label 的 key 和 value 可以任意指定。&lt;br>
⑧ &lt;code>spec&lt;/code> 描述 Pod 的规格，此部分定义 Pod 中每一个容器的属性，&lt;code>name&lt;/code> 和 &lt;code>image&lt;/code> 是必需的。&lt;/p>
&lt;h1 id="secret">secret&lt;/h1>
&lt;p>Secret 是 Kubernetes 中的一种资源,用于存储敏感信息,比如密码、OAuth 令牌、SSH 密钥等。Secret 的数据是 base64 编码并存储在 etcd 中。Secret 有三种类型:1. Opaque:任意数据,用于存储密码、密钥等;base64 编码后存储。&lt;br>
2. &lt;a href="http://kubernetes.io/service-account-token:%E6%9C%8D%E5%8A%A1%E8%B4%A6%E5%8F%B7%E4%BB%A4%E7%89%8C,%E7%94%B1" target="_blank" rel="noopener">kubernetes.io/service-account-token:服务账号令牌,由&lt;/a> Kubernetes 自动创建和更新。&lt;br>
3. &lt;a href="http://kubernetes.io/dockercfg:Docker" target="_blank" rel="noopener">kubernetes.io/dockercfg:Docker&lt;/a> 配置文件,用来存储私有 Docker Registry 的认证信息。主要用途是:- 存储敏感数据,比如密码、密钥、认证信息等&lt;br>
- 在 Pod 中设置环境变量&lt;br>
- 用于拉取私有镜像仓库的镜像创建 Secret 有三种方式:1. 从文件中创建:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">bash
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kubectl create secret generic &amp;lt;secret-name&amp;gt; --from-file=path/to/file
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>2. 从字串中创建:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">bash
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kubectl create secret generic &amp;lt;secret-name&amp;gt; --from-literal=&amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>3. 编写 YAML 文件创建:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">yaml
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">apiVersion: v1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kind: Secret
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">metadata:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> name: mysecret
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">type: Opaque
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">data:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> username: YWRtaW4= # base64 编码后的密码或密钥
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> password: MWYyZDFlMmU2N2Rm # base64 编码后的密码或密钥
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在 Pod 中可以以三种方式使用 Secret:1. 设置环境变量的值 &lt;code>env&lt;/code>&lt;br>
2. 以 Volume 文件的形式挂载,然后在 Volume 中访问&lt;br>
3. 使用 kubectl 在本地执行工具中设置 Secret总的来说,Secret 用于在 Kubernetes 集群中存储敏感信息,有以下主要用途:- 存储密码、密钥、认证信息等敏感数据&lt;br>
- 用于在 Pod 中设置环境变量的值&lt;br>
- 用于在 Volume 中创建 config 文件&lt;br>
- 拉取私有 Docker Registry 的镜像&lt;/p>
&lt;h1 id="namespace">namespace&lt;/h1></description></item><item><title/><link>https://ysyyhhh.github.io/docs/tool/k8s/minikube/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/tool/k8s/minikube/</guid><description>&lt;h1 id="minikube">minikube&lt;/h1>
&lt;p>使用&lt;/p>
&lt;p>进入pods的容器&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">kubectl &lt;span class="nb">exec&lt;/span> -it &amp;lt;pod-name&amp;gt; -c &amp;lt;container-name&amp;gt; -- /bin/bash
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看对应容器的日志&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kubectl logs -f &amp;lt;pod-name&amp;gt; -c &amp;lt;container-name&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="错误和解决方案">错误和解决方案&lt;/h2>
&lt;h3 id="minikube-挂载-本地目录进minikube时作为mysql的数据目录但是mysql无法启动">minikube 挂载 本地目录进minikube时,作为mysql的数据目录,但是mysql无法启动&lt;/h3>
&lt;p>挂载方式:
在minikube正常启动后, 使用&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">minikube mount &amp;lt;本地目录&amp;gt;:&amp;lt;minikube目录&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>进行挂载&lt;/p>
&lt;p>检查问题&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 进入pod 的 db容器内查看日志 &lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kubectl logs -f &amp;lt;pod-name&amp;gt; -c &amp;lt;container-name&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>输出为&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">find: File system loop detected&lt;span class="p">;&lt;/span> &lt;span class="s1">&amp;#39;/var/lib/mysql/test&amp;#39;&lt;/span> is part of the same file system loop as &lt;span class="s1">&amp;#39;/var/lib/mysql/&amp;#39;&lt;/span>.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>原因是挂载时发现循环&lt;/p>
&lt;p>解决方案:&lt;/p>
&lt;ol>
&lt;li>关闭并&lt;strong>删除&lt;/strong>minikube&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">minikube stop
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">minikube delete
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="2">
&lt;li>在minikube启动时就挂载&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">minikube start --mount --mount-string&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;&amp;lt;本地目录&amp;gt;:&amp;lt;minikube目录&amp;gt;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>问题解决&lt;/p>
&lt;h3 id="minikube-中-设置ingress未转发的问题">minikube 中 设置ingress未转发的问题&lt;/h3>
&lt;p>参考&lt;a href="https://stackoverflow.com/questions/66275458/could-not-access-kubernetes-ingress-in-browser-on-windows-home-with-minikube" target="_blank" rel="noopener">Could not access Kubernetes Ingress in Browser on Windows Home with Minikube?&lt;/a>&lt;/p>
&lt;p>问题1：
当使用minikube时，设置ingress后，minikube ssh 内部可以通过ingress转发的服务端口访问。
但127.0.0.1 或 minikube ip 在主机上无法访问。&lt;/p>
&lt;p>解决方法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-md" data-lang="md">&lt;span class="line">&lt;span class="cl">Set custom domain IP to 127.0.01 in %WINDIR%\System32\drivers\etc\hosts file, i.e. by adding line 127.0.0.1 my-k8s.com
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Get ingress pod name: kubectl get pods -n ingress-nginx
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Start port forwarding: kubectl -n ingress-nginx port-forward pod/ingress-nginx-controller-5d88495688-dxxgw --address 0.0.0.0 80:80 443:443, where you should replace ingress-nginx-controller-5d88495688-dxxgw with your ingress pod name.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Enjoy using ingress on custom domain in any browser (but only when port forwarding is active)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>问题2:
ingress中使用prefix的转发规则时,无法获取路径中的query&lt;/p>
&lt;p>解决方法:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">networking.k8s.io/v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Ingress&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">minimal-ingress&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">annotations&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">nginx.ingress.kubernetes.io/use-regex&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;true&amp;#34;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># 需要添加这个&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">nginx.ingress.kubernetes.io/rewrite-target&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/$2&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">defaultBackend&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">service&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">default-http-backend&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">port&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">number&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">80&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">rules&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">host&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">fuzzs-scene-sim-test.localhost&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">http&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">paths&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">path&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/FuzzsSceneSimTest(/|$)(.*)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># 后缀加上(/|$)(.*) 用于获取query&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">pathType&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ImplementationSpecific &lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">backend&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">service&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">fuzzs-scene-sim-test&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">port&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">number&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">8089&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title/><link>https://ysyyhhh.github.io/docs/tool/maven/maven/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/tool/maven/maven/</guid><description>&lt;h1 id="maven">maven&lt;/h1>
&lt;h2 id="打包">打包&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">mvn clean package -Dmaven.test.skip&lt;span class="o">=&lt;/span>&lt;span class="nb">true&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="常见问题">常见问题&lt;/h2>
&lt;h3 id="找不到主类">找不到主类&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">Error: Could not find or load main class com.xxx.xxx.xxx
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Caused by: java.lang.ClassNotFoundException: com.xxx.xxx.xxx
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>解决方法：在pom.xml中添加如下配置&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-xml" data-lang="xml">&lt;/code>&lt;/pre>&lt;/div></description></item><item><title/><link>https://ysyyhhh.github.io/docs/tool/nginx/nginx/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/tool/nginx/nginx/</guid><description>&lt;h1 id="nginx">nginx&lt;/h1>
&lt;h2 id="nginx安装">nginx安装&lt;/h2>
&lt;h3 id="1-安装依赖">1. 安装依赖&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">yum install -y gcc gcc-c++ autoconf automake make
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">yum install -y pcre pcre-devel
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">yum install -y zlib zlib-devel
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">yum install -y openssl openssl-devel
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="2-转发后端图片">2. 转发后端图片&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 1. 创建目录&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">mkdir -p /data/nginx/cache
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 2. 修改目录权限&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">chown -R nginx:nginx /data/nginx/cache
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="nginx-命令">nginx 命令&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 启动&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">nginx
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 重启, 重新加载配置文件&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">nginx -s reload
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 停止&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">nginx -s stop
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 测试配置文件是否正确&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">nginx -t
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="nginx-配置">nginx 配置&lt;/h2>
&lt;p>加权轮询&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/tool/npm/npm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/tool/npm/npm/</guid><description>&lt;h1 id="npm">npm&lt;/h1>
&lt;h2 id="docker中的npm">docker中的npm&lt;/h2>
&lt;p>&lt;a href="https://blog.csdn.net/wenxuankeji/article/details/135658361" target="_blank" rel="noopener">解决npm慢&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 设置npm源&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">npm config &lt;span class="nb">set&lt;/span> registry https://registry.npmmirror.com
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 原有域名弃用了&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">## https://npm.taobao.org =&amp;gt; https://npmmirror.com&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># https://registry.npm.taobao.org =&amp;gt; https://registry.npmmirror.com&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># npm install 时查看详细信息&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">npm install --verbose
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title/><link>https://ysyyhhh.github.io/docs/tool/python/conda/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/tool/python/conda/</guid><description>&lt;h1 id="conda">conda&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看环境&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">conda env list
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 创建环境&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">conda create -n py3 &lt;span class="nv">python&lt;/span>&lt;span class="o">=&lt;/span>3.6
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 通过yml文件创建环境&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">conda env create -f environment.yml
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 激活环境&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">conda activate py3
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 退出环境&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">conda deactivate
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 删除环境&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">conda remove -n py3 --all
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 导出环境为.tar&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">conda pack -n &amp;lt;env_name&amp;gt; -o &amp;lt;env_name&amp;gt;.tar.gz
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="迁移时可能会出现pip问题">迁移时可能会出现pip问题&lt;/h2>
&lt;p>可以在yml的pip:上面加上pip&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yml" data-lang="yml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">py3&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">channels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="l">defaults&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">dependencies&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="l">python=3.6&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="l">pip&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">pip&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- -&lt;span class="l">r requirements.txt&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title/><link>https://ysyyhhh.github.io/docs/tool/python/poetry/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/tool/python/poetry/</guid><description>&lt;h1 id="poetry">poetry&lt;/h1>
&lt;h2 id="poetry-出现的错误及解决方法">poetry 出现的错误及解决方法&lt;/h2>
&lt;h3 id="poetry-install-时failed-to-create-the-collection-prompt-dismissed">poetry install 时Failed to create the collection: Prompt dismissed&lt;/h3>
&lt;p>解决方案: 关闭keyring&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">python3 -m keyring --disable
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>原因:
&lt;a href="https://github.com/python-poetry/poetry/issues/1917" target="_blank" rel="noopener">https://github.com/python-poetry/poetry/issues/1917&lt;/a>&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/tool/sql/mongodb/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/tool/sql/mongodb/</guid><description>&lt;h1 id="mongodb">mongoDB&lt;/h1>
&lt;h2 id="常用命令">常用命令&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 连接&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">mongosh ip&lt;span class="o">[&lt;/span>:port&lt;span class="o">]&lt;/span>/database -u username -p password
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看数据库&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">show dbs
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 切换数据库&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">use database
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看集合&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">show collections
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># file&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看集合数据&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">db.&lt;span class="o">{&lt;/span>collection&lt;span class="o">}&lt;/span>.find&lt;span class="o">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 按条件查看集合数据&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">## pid=1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">db.&lt;span class="o">{&lt;/span>collection&lt;span class="o">}&lt;/span>.find&lt;span class="o">({&lt;/span>pid:1&lt;span class="o">})&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">## 限制4条&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">db.&lt;span class="o">{&lt;/span>collection&lt;span class="o">}&lt;/span>.find&lt;span class="o">()&lt;/span>.limit&lt;span class="o">(&lt;/span>4&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">## 只显示其中一个字段&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">db.&lt;span class="o">{&lt;/span>collection&lt;span class="o">}&lt;/span>.find&lt;span class="o">({}&lt;/span>, &lt;span class="o">{&lt;/span>name:1&lt;span class="o">})&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">## 统计数量&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">db.&lt;span class="o">{&lt;/span>collection&lt;span class="o">}&lt;/span>.find&lt;span class="o">()&lt;/span>.count&lt;span class="o">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">## 全部删除&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">db.&lt;span class="o">{&lt;/span>collection&lt;span class="o">}&lt;/span>.remove&lt;span class="o">({})&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">## 插入或更新数据&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title/><link>https://ysyyhhh.github.io/docs/tool/sql/mysql/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/tool/sql/mysql/</guid><description>&lt;h1 id="mysql">MySQL&lt;/h1>
&lt;h2 id="mysql常用命令">MySql常用命令&lt;/h2>
&lt;p>查看所有用户和host&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">select user,host from mysql.user;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="修改用户">修改用户&lt;/h5>
&lt;p>修改密码&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">alter user &amp;#39;root&amp;#39;@&amp;#39;localhost&amp;#39; identified with mysql_native_password by &amp;#39;123456&amp;#39;;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">alter user &amp;#39;digitalmap&amp;#39;@&amp;#39;%&amp;#39; identified with mysql_native_password by &amp;#39;digitalmap&amp;#39;;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>修改用户host&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">update&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">mysql&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">user&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">set&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">host&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;%&amp;#39;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">where&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">user&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;root
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="刷新权限">刷新权限&lt;/h5>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">flush privileges;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="添加一个远程用户">添加一个远程用户&lt;/h5>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">create user &amp;#39;remote&amp;#39;@&amp;#39;%&amp;#39; identified by &amp;#39;password&amp;#39;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">create user &amp;#39;digitalmap&amp;#39;@&amp;#39;localhost&amp;#39; identified by &amp;#39;digitalmap_root&amp;#39;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">GRANT all ON *.* TO &amp;#39;remote&amp;#39;@&amp;#39;%&amp;#39;;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">GRANT all ON digitalmap.* TO &amp;#39;digitalmap&amp;#39;@&amp;#39;%&amp;#39;;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">grant all privileges on *.* to &amp;#39;remote&amp;#39;@&amp;#39;%&amp;#39; with grant option;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">grant all privileges on digitalmap.* to &amp;#39;digitalmap&amp;#39;@&amp;#39;%&amp;#39; with grant option;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">*.*所有数据库下的所有表
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="删除用户">删除用户&lt;/h5>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">drop user &amp;#39;remote&amp;#39;@&amp;#39;%&amp;#39;;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="创建数据库并设定中文编码">创建数据库并设定中文编码&lt;/h5>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-mysql" data-lang="mysql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">CREATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">DATABASE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="n">db_name&lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">DEFAULT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">CHARACTER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">SET&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">utf8&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">COLLATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">utf8_general_ci&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="登录格式">登录格式&lt;/h5>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">mysql -h #{数据库IP} -P 3306 -u #{用户名} -p -D #{数据库名}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="自增id-不连续时">自增id 不连续时&lt;/h5>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SET @auto_id = 0;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">UPDATE 表名 SET 自增字段名 = (@auto_id := @auto_id + 1);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ALTER TABLE 表名 AUTO_INCREMENT = 1;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="文件">文件&lt;/h4>
&lt;p>读取sql&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">source
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>导出为sql&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">mysqldump -u root -p 数据库名 &amp;gt; 文件名.sql
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="数据库">数据库&lt;/h4>
&lt;p>设置数据库的字符集&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">alter&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">database&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">数据库名&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">character&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">set&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">utf8&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="表">表&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="o">#&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">添加一列&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">alter&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">table&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">表名&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">add&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">column&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">列名&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">类型&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="数据">数据&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="o">#&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">插入数据&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">insert&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">into&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">表名&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="err">字段&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="err">字段&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">values&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="err">值&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="err">值&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="o">#&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">更新数据&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">update&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">表名&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">set&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">字段&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="err">值&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="err">字段&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="err">值&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">where&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">条件&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="o">#&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">删除数据&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">delete&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">from&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">表名&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">where&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">条件&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="时间处理">时间处理&lt;/h3>
&lt;p>Date&lt;/p>
&lt;h3 id="条件语句">条件语句&lt;/h3>
&lt;p>CASE&lt;/p>
&lt;p>强制转换&lt;/p>
&lt;p>CAST&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/tool/sql/redis/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/tool/sql/redis/</guid><description>&lt;h1 id="redis">redis&lt;/h1>
&lt;p>flushall 清空&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/tool/terminal/grep/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/tool/terminal/grep/</guid><description>&lt;h1 id="grep">grep&lt;/h1>
&lt;p>grep工具&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/tool/terminal/%E5%91%BD%E4%BB%A4%E8%A1%8C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/tool/terminal/%E5%91%BD%E4%BB%A4%E8%A1%8C/</guid><description>&lt;h1 id="命令行">命令行&lt;/h1>
&lt;h2 id="cmd">cmd&lt;/h2>
&lt;p>后缀 &lt;code>.bat&lt;/code> 或 &lt;code>.cmd&lt;/code> 的批处理文件&lt;/p>
&lt;h2 id="powershell">powershell&lt;/h2>
&lt;p>后缀 &lt;code>.ps1&lt;/code> 的脚本文件&lt;/p>
&lt;h2 id="bash">bash&lt;/h2>
&lt;h2 id="zsh">zsh&lt;/h2>
&lt;h2 id="fish">fish&lt;/h2></description></item><item><title/><link>https://ysyyhhh.github.io/docs/tool/terminal/%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/tool/terminal/%E5%B7%A5%E5%85%B7/</guid><description>&lt;h1 id="命令行工具">命令行工具&lt;/h1>
&lt;h2 id="查看文件">查看文件&lt;/h2>
&lt;h3 id="cat">cat&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">cat 文件名
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="heading">&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">more 文件名
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="下载文件">下载文件&lt;/h2>
&lt;h3 id="wget">wget&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">wget -c -t &lt;span class="m">0&lt;/span> -T &lt;span class="m">60&lt;/span> -O 文件名 下载地址
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># -c 断点续传&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># -t 0 重试次数&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># -T 60 超时时间&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># -O 文件名 保存文件名&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="tree指令在windows下">tree指令在windows下&lt;/h2>
&lt;p>&lt;a href="https://blog.csdn.net/pyufftj/article/details/83102530" target="_blank" rel="noopener">https://blog.csdn.net/pyufftj/article/details/83102530&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://blog.csdn.net/fragrant_no1/article/details/85986511" target="_blank" rel="noopener">https://blog.csdn.net/fragrant_no1/article/details/85986511&lt;/a>&lt;/p>
&lt;p>nohup&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">nohup python3 -u tcp_client.py &amp;gt; tcp.log 2&amp;gt;&amp;amp;1 &amp;amp;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">nuhup : 不挂起的意思
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">python3 tcp_client.py : 使用python3环境运行 tcp_client.py文件
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">-u : 代表程序不启用缓存，也就是把输出直接放到log中，没这个参数的话，log文件的生成会有延迟
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&amp;gt; tcp.log : 把程序输出日志保存到tcp.log文件中
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">2&amp;gt;&amp;amp;1 : 换成2&amp;gt;&amp;amp;1，&amp;amp;与1结合就代表标准输出了，就变成错误重定向到标准输出
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&amp;amp; : 最后一个&amp;amp; ，代表该命令在后台执行
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">nohup python3 -u main.py &amp;gt; chatbot.log 2&amp;gt;&amp;amp;1 &amp;amp;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">nohup ./go-cqhttp &amp;gt; go-cq.log 2&amp;gt;&amp;amp;1 &amp;amp;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="网络">网络&lt;/h1>
&lt;p>nc -v -z 172.29.4.47 19530&lt;/p>
&lt;p>telnet 172.29.4.47 19530&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/tool/vim/%E6%8C%87%E4%BB%A4%E6%89%8B%E5%86%8C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/tool/vim/%E6%8C%87%E4%BB%A4%E6%89%8B%E5%86%8C/</guid><description>&lt;h1 id="vim的使用">vim的使用&lt;/h1>
&lt;h2 id="光标移动">光标移动&lt;/h2>
&lt;p>h: 左移一个字符
j: 下移一行
k: 上移一行
l: 右移一个字符&lt;/p>
&lt;p>w: 移动到下一个单词的开头
e: 移动到当前单词末尾
b: 移动到上一个单词的开头&lt;/p>
&lt;p>0: 移动到行首
$: 移动到行尾&lt;/p>
&lt;p>n + 上面的命令: 移动n次&lt;/p>
&lt;p>gg: 移动到文件开头
G: 移动到文件末尾&lt;/p>
&lt;p>上面所有命令构成了一个移动命令，可以和d命令组合使用，删除从当前光标到移动命令所指的位置的内容&lt;/p>
&lt;p>ctrl + f: 下翻一页
ctrl + b: 上翻一页
ctrl + G: 显示当前光标所在行的行号&lt;/p>
&lt;p>ctrl + i: 跳转到上次位置·
ctrl + o: 跳转到下次位置&lt;/p>
&lt;p>G + n: 移动到第n行&lt;/p>
&lt;h2 id="插入">插入&lt;/h2>
&lt;p>i: 在当前光标处插入
I: 在当前行首插入&lt;/p>
&lt;p>a: 在当前光标后插入
A: 在当前行尾插入&lt;/p>
&lt;p>o: 在当前行下方插入一行
O: 在当前行上方插入一行&lt;/p>
&lt;h2 id="删除">删除&lt;/h2>
&lt;p>x: 删除当前光标所在的字符
X: 删除当前光标所在的前一个字符&lt;/p>
&lt;p>dd: 删除当前行
D: 删除当前光标所在位置到行尾的内容&lt;/p>
&lt;p>d + 移动命令: 删除从当前光标到移动命令所指的位置的内容&lt;/p>
&lt;p>如:
dw: 删除当前光标所在的单词
db: 删除当前光标所在的单词
d$: 删除当前光标所在位置到行尾的内容
dnG: 删除当前光标所在行到第n行的内容
dG: 删除当前光标所在行到文件末尾的内容&lt;/p>
&lt;h2 id="剪切">剪切&lt;/h2>
&lt;p>上面删除的内容都会被保存到剪切板中&lt;/p>
&lt;h2 id="删除并进入插入模式">删除并进入插入模式&lt;/h2>
&lt;p>s: 删除当前光标所在的字符并进入插入模式
S: 删除当前行并进入插入模式&lt;/p>
&lt;p>c + 移动命令: 删除从当前光标到移动命令所指的位置的内容并进入插入模式&lt;/p>
&lt;p>如:
cw: 删除当前光标所在的单词并进入插入模式
c$: 删除当前光标所在位置到行尾的内容并进入插入模式
cnG: 删除当前光标所在行到第n行的内容并进入插入模式&lt;/p>
&lt;h2 id="复制">复制&lt;/h2>
&lt;p>y + 移动命令: 复制从当前光标到移动命令所指的位置的内容&lt;/p>
&lt;p>如:
yw: 复制当前光标所在的单词
yb: 复制当前光标所在的单词
y$: 复制当前光标所在位置到行尾的内容
ynG: 复制当前光标所在行到第n行的内容&lt;/p>
&lt;h2 id="粘贴">粘贴&lt;/h2>
&lt;p>所有删除的内容都会被保存到剪切板中，可以使用p命令将剪切板中的内容粘贴到当前光标所在位置
p: 将剪切板中的内容粘贴到当前光标所在位置的后面
P: 将剪切板中的内容粘贴到当前光标所在位置的前面&lt;/p>
&lt;h2 id="替换">替换&lt;/h2>
&lt;p>r + 字符: 将当前光标所在的字符替换为指定的字符&lt;/p>
&lt;p>R + 字符串: 将当前光标所在位置开始的字符串替换为指定的字符串&lt;/p>
&lt;h2 id="撤销">撤销&lt;/h2>
&lt;p>u: 撤销上一次操作
U: 撤销当前行的所有操作&lt;/p>
&lt;p>ctrl + r: 恢复上一次撤销的操作&lt;/p>
&lt;h2 id="重复">重复&lt;/h2>
&lt;p>. : 重复上一次操作&lt;/p>
&lt;h2 id="查找">查找&lt;/h2>
&lt;p>/ + 关键字: 从当前光标开始向下查找关键字
? + 关键字: 从当前光标开始向上查找关键字&lt;/p>
&lt;p>输完后按回车，会跳转到第一个匹配的位置.&lt;/p>
&lt;p>n: 跳转到下一个匹配的位置
N: 跳转到上一个匹配的位置&lt;/p>
&lt;h2 id="-进阶命令">: 进阶命令&lt;/h2>
&lt;p>:w 保存文件
:q 退出
:q! 强制退出，不保存
:wq 保存并退出
:wq! 强制保存并退出&lt;/p>
&lt;p>上面的命令 + 文件名: 保存文件到指定的文件名&lt;/p>
&lt;p>:help 命令名: 查看命令的帮助文档&lt;/p>
&lt;h3 id="替换-1">替换&lt;/h3>
&lt;p>:%s/old/new/g 将所有的old替换为new
:%s/old/new/gc 将所有的old替换为new，替换前询问是否替换&lt;/p>
&lt;p>:#,#s/old/new/g 将第#行到第#行的old替换为new&lt;/p>
&lt;h3 id="外部命令">外部命令&lt;/h3>
&lt;p>:! + 命令: 执行外部命令&lt;/p>
&lt;p>如:
:!ls 执行ls命令
:!dir 执行dir命令&lt;/p></description></item></channel></rss>