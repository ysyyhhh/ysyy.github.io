<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Home | Ysyy's</title><link>https://ysyyhhh.github.io/</link><atom:link href="https://ysyyhhh.github.io/index.xml" rel="self" type="application/rss+xml"/><description>Home</description><generator>Hugo Blox Builder (https://hugoblox.com)</generator><language>en-us</language><lastBuildDate>Tue, 24 Oct 2023 00:00:00 +0000</lastBuildDate><image><url>https://ysyyhhh.github.io/media/logo.svg</url><title>Home</title><link>https://ysyyhhh.github.io/</link></image><item><title>rpc框架</title><link>https://ysyyhhh.github.io/blog/rpc%E6%A1%86%E6%9E%B6/</link><pubDate>Wed, 06 Mar 2024 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/blog/rpc%E6%A1%86%E6%9E%B6/</guid><description/></item><item><title>大文件上传</title><link>https://ysyyhhh.github.io/blog/%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</link><pubDate>Wed, 06 Mar 2024 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/blog/%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</guid><description/></item><item><title>密码安全</title><link>https://ysyyhhh.github.io/blog/%E5%AF%86%E7%A0%81%E5%AE%89%E5%85%A8/</link><pubDate>Wed, 06 Mar 2024 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/blog/%E5%AF%86%E7%A0%81%E5%AE%89%E5%85%A8/</guid><description/></item><item><title>短链系统</title><link>https://ysyyhhh.github.io/blog/%E7%9F%AD%E9%93%BE%E7%B3%BB%E7%BB%9F/</link><pubDate>Wed, 06 Mar 2024 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/blog/%E7%9F%AD%E9%93%BE%E7%B3%BB%E7%BB%9F/</guid><description/></item><item><title>秒杀系统</title><link>https://ysyyhhh.github.io/blog/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/</link><pubDate>Wed, 06 Mar 2024 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/blog/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/</guid><description/></item><item><title>6.5840 Lab 1: MapReduce</title><link>https://ysyyhhh.github.io/blog/6.5840-lab-1-mapreduce/</link><pubDate>Tue, 05 Mar 2024 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/blog/6.5840-lab-1-mapreduce/</guid><description>&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;p>在这个实验中，你将构建一个 MapReduce 系统。你将实现一个工作节点进程，调用应用程序的 Map 和 Reduce 函数，处理文件的读写，以及一个协调器进程，向工作节点分发任务，并处理失败的工作节点。你将构建类似于 &lt;a href="https://pdos.csail.mit.edu/6.824/labs/lab-mr.html" target="_blank" rel="noopener">MapReduce 论文&lt;/a>中描述的系统。（注意：&lt;strong>这个实验使用“协调器”而不是论文中的“主节点”。&lt;/strong>）&lt;/p>
&lt;h2 id="getting-started">Getting started&lt;/h2>
&lt;p>准备工作:
&lt;a href="https://pdos.csail.mit.edu/6.824/labs/go.html" target="_blank" rel="noopener">安装Go&lt;/a>
&lt;a href="https://git-scm.com/" target="_blank" rel="noopener">安装Git&lt;/a>&lt;/p>
&lt;p>获取项目:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">git clone git://g.csail.mit.edu/6.5840-golabs-2024 6.5840
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">cd&lt;/span> 6.824
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ls
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 输出为 Makefile src&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们为你提供了一个简单的顺序 MapReduce 实现，位于 src/main/mrsequential.go 中。
它一次只在单个进程中运行一个 Map 和一个 Reduce。&lt;/p>
&lt;p>我们还为你提供了几个 MapReduce 应用程序：在 &lt;code>mrapps/wc.go&lt;/code> 中是单词计数，而在 &lt;code>mrapps/indexer.go&lt;/code> 中是文本索引器。你可以按顺序运行单词计数如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 生成 wc.so 文件&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">go build -buildmode&lt;span class="o">=&lt;/span>plugin ../mrapps/wc.go
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 删除 mr-out* 文件 这是输出文件&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">rm mr-out*
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 运行 mrsequential.go 使用 wc.so 插件处理 pg*.txt 文件, 这是提供的线性处理程序&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># pg*.txt 是输入文件, 包含了一些文本&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">go run mrsequential.go wc.so pg*.txt
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看输出文件 mr-out-0 的内容&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">more mr-out-0
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Go 将其输出保留在文件 mr- out-0中，输入来自名为 pg-xxx.txt 的文本文件。&lt;/p>
&lt;p>可以随意借用 mrSequential.go 的代码。您还应该查看 mrapps/wc.go，看看 MapReduce 应用程序代码是什么样的。&lt;/p>
&lt;h2 id="任务">任务&lt;/h2>
&lt;p>你的任务是实现一个分布式的 MapReduce，包括两个程序，协调器和工作节点。将只有一个协调器进程，以及一个或多个并行执行的工作节点进程。在一个真实的系统中，工作节点可能会在一堆不同的机器上运行，但是对于这个实验，你会将它们全部运行在单个机器上。工作节点将通过 RPC 与协调器通信。&lt;/p>
&lt;p>每个工作节点进程都会循环询问协调器要一个任务，从一个或多个文件中读取任务的输入，执行任务，将任务的输出写入一个或多个文件，然后再次向协调器请求一个新的任务。&lt;/p>
&lt;p>如果一个工作节点在合理的时间内（在这个实验中，使用十秒）没有完成它的任务，协调器应该注意到，并将相同的任务分配给另一个工作节点。&lt;/p>
&lt;p>协调器和 worker 的“ main”例程位于 main/mrCollaborator.go 和 main/mrworker.go 中; 不要更改这些文件。&lt;/p>
&lt;p>只修改mr/coordinator.go, mr/worker.go, and mr/rpc.go&lt;/p>
&lt;h3 id="示例">示例&lt;/h3>
&lt;p>下面是如何在单词计数 MapReduce 应用程序上运行代码的方法。首先，确保单词计数插件是新构建的:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">go build -buildmode&lt;span class="o">=&lt;/span>plugin ../mrapps/wc.go
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">rm mr-out*
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">go run mrcoordinator.go pg-*.txt
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中 pg-.txt 参数是输入文件；每个文件对应一个“分片”，是一个 Map 任务的输入。&lt;/p>
&lt;p>然后,在一个或多个其他窗口中，运行一些工作节点：
&lt;code>go run mrworker.go wc.so&lt;/code>&lt;/p>
&lt;p>在&lt;code>mr-out-*&lt;/code>文件中，可以单词计数的输出。&lt;/p>
&lt;p>当coordinator完成所有任务后, 会输出如下内容:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">cat mr-out-* &lt;span class="p">|&lt;/span> sort &lt;span class="p">|&lt;/span> more
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="测试">测试&lt;/h3>
&lt;p>我们在 main/test-mr.sh 中为你提供了一个测试脚本。
这些测试检查当给定 pg-xxx.txt 文件作为输入时，wc 和 indexer MapReduce 应用程序是否产生正确的输出。
测试还会检查你的实现是否并行运行 Map 和 Reduce 任务，并且你的实现是否能够从在运行任务时崩溃的工作节点中恢复。&lt;/p>
&lt;p>运行测试脚本的方法如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">bash test-mr.sh
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>tips:&lt;/p>
&lt;blockquote>
&lt;p>如果现在直接执行mrcoordinator会一直卡在那, 因为&lt;code>mr/coordinator.go&lt;/code>中的Done函数没有被实现.
一直返回false, 无法结束任务.
如果想先测试一下流程,直接把&lt;code>mr/coordinator.go&lt;/code>中的&lt;code>Done&lt;/code>函数改成&lt;code>return true&lt;/code>就可以了.&lt;/p>
&lt;/blockquote>
&lt;p>这个测试脚本会输出到 &lt;code>mr-out-X&lt;/code>中&lt;/p>
&lt;p>如果全部完成了,可以看到输出的内容:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">*** Starting wc test.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">--- wc test: PASS
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">*** Starting indexer test.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">--- indexer test: PASS
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">*** Starting map parallelism test.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">--- map parallelism test: PASS
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">*** Starting reduce parallelism test.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">--- reduce parallelism test: PASS
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">*** Starting job count test.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">--- job count test: PASS
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">*** Starting early &lt;span class="nb">exit&lt;/span> test.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">--- early &lt;span class="nb">exit&lt;/span> test: PASS
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">*** Starting crash test.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">--- crash test: PASS
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">*** PASSED ALL TESTS
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="一些可以忽略的问题">一些可以忽略的问题&lt;/h3>
&lt;p>&lt;code>rpc.Register: method &amp;quot;Done&amp;quot; has 1 input parameters; needs exactly three&lt;/code>
这个
将协调器注册为 RPC 服务器检查它的所有方法是否适合 RPC (有3个输入) ;
我们知道RPC并没有调用 Done。&lt;/p>
&lt;p>另外，根据你终止工作进程的策略，你可能会看到一些形式的错误。
&lt;code> dialing:dial unix /var/tmp/5840-mr-501: connect: connection refused&lt;/code>
每个测试可以看到一些这样的消息; 当协调器退出后，工作者无法与协调器 RPC 服务器联系时，就会出现这些消息。&lt;/p>
&lt;h2 id="a-few-rules">A few rules&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>Map 阶段应该将中间键分成 nReduce 个 reduce 任务的桶，其中 nReduce 是 reduce 任务的数量 &amp;ndash; 这是 main/mrcoordinator.go 传递给 MakeCoordinator() 的参数。每个 Mapper 应该为 Reduce 任务创建 nReduce 个中间文件以供使用。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Worker 的实现应该将第 X 个 reduce 任务的输出放入文件 mr-out-X 中。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>mr-out-X 文件应该包含一个 Reduce 函数输出的行。这一行应该用 Go 的 &amp;ldquo;%v %v&amp;rdquo; 格式生成，调用时传入键和值。在 main/mrsequential.go 中找到被注释为 &amp;ldquo;这是正确的格式&amp;rdquo; 的行。如果你的实现与这个格式相差太远，测试脚本会失败。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>你可以修改 mr/worker.go、mr/coordinator.go 和 mr/rpc.go。你可以临时修改其他文件进行测试，但确保你的代码与原始版本一起工作；我们将使用原始版本进行测试。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Worker 应该将中间 Map 输出放在当前目录中的文件中，以便稍后的 Reduce 任务读取它们作为输入。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>main/mrcoordinator.go 期望 mr/coordinator.go 实现一个 Done() 方法，在 MapReduce 作业完全完成时返回 true；此时，mrcoordinator.go 将退出。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当作业完全完成时，工作进程应该退出。实现这一点的一个简单方法是使用 call() 的返回值：如果工作节点无法联系到协调器，它可以假设协调器已经退出，因为作业已经完成，所以工作节点也可以终止。根据你的设计，你可能还会发现有一个“请退出”的伪任务对协调器给工作节点很有帮助。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="hints">Hints&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://pdos.csail.mit.edu/6.824/labs/guidance.html" target="_blank" rel="noopener">指南页面&lt;/a>上有一些关于开发和调试的提示。&lt;/li>
&lt;li>开始的一种方法是修改 mr/worker.go 中的 Worker()，向协调器发送一个 RPC 请求任务。然后修改协调器以响应一个尚未启动的 Map 任务的文件名。然后修改工作节点以读取该文件并调用应用程序的 Map 函数，就像在 mrsequential.go 中一样。&lt;/li>
&lt;li>应用程序的 Map 和 Reduce 函数是在运行时使用 Go 插件包加载的，文件的名称以 .so 结尾。&lt;/li>
&lt;li>如果你改变了 mr/ 目录中的任何内容，你可能需要重新构建你使用的任何 MapReduce 插件，例如使用 go build -buildmode=plugin ../mrapps/wc.go。&lt;/li>
&lt;li>这个实验依赖于&lt;strong>工作节点共享文件系统&lt;/strong>。当所有工作节点运行在同一台机器上时，这很简单，但如果工作节点在不同的机器上运行，则需要像 GFS 这样的全局文件系统。&lt;/li>
&lt;li>中间文件的一个合理命名约定是 mr-X-Y，其中 X 是 Map 任务编号，Y 是 reduce 任务编号。&lt;/li>
&lt;li>工作节点的 Map 任务代码将需要一种方法来将&lt;strong>中间键/值对存储在文件中&lt;/strong>，以便在 reduce 任务期间正确读取回来。一种可能性是使用 Go 的 encoding/json 包。要将键/值对以 JSON 格式写入到打开的文件中：
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">enc&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">json&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">NewEncoder&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">file&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="nx">_&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">kv&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="o">...&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">enc&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Encode&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">kv&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>并读取回来：
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">dec&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">json&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">NewDecoder&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">file&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">var&lt;/span> &lt;span class="nx">kv&lt;/span> &lt;span class="nx">KeyValue&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">dec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Decode&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">kv&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">break&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">kva&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nb">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">kva&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">kv&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>你的工作节点的 Map 部分可以使用 ihash(key) 函数（在 worker.go 中）来选择给定键的 reduce 任务。&lt;/li>
&lt;li>你可以从 mrsequential.go 中偷一些代码来读取 Map 输入文件，对 Map 和 Reduce 之间的中间键/值对进行排序，并将 Reduce 输出存储在文件中。&lt;/li>
&lt;li>作为一个 RPC 服务器的协调器将是并发的；不要忘记锁定共享数据。&lt;/li>
&lt;li>使用 Go 的竞争检测器，使用 go run -race。test-mr.sh 在开头有一条注释，告诉你如何用 -race 运行它。当我们评估你的实验时，我们不会使用竞争检测器。&lt;strong>尽管如此，如果你的代码有竞争条件，即使没有竞争检测器，也有很大可能会在我们测试时失败&lt;/strong>。&lt;/li>
&lt;li>工作节点有时需要等待，例如在最后一个 Map 完成之前不能开始 Reduce。一种可能性是让工作节点定期向协调器请求工作，在每个请求之间使用 time.Sleep() 进行睡眠。另一种可能性是让协调器中相应的 RPC 处理程序具有等待循环，可以使用 time.Sleep() 或 sync.Cond 进行等待。Go 在自己的线程中运行每个 RPC 的处理程序，因此一个处理程序在等待时不会阻止协调器处理其他 RPC。&lt;/li>
&lt;li>协调器不能可靠地区分崩溃的工作节点、仍然存活但由于某种原因停滞不前的工作节点以及执行但速度太慢以至于无用的工作节点。你能做的最好的事情是让协调器等待一段时间，然后放弃并将任务重新分配给另一个工作节点。对于这个实验，让协调器等待十秒；之后，&lt;strong>协调器应该假设工作节点已经死亡&lt;/strong>（当然，它可能没有）。&lt;/li>
&lt;li>如果选择实现备份任务（第 3.6 节），请注意我们测试你的代码在工作节点执行任务而不崩溃时不安排多余的任务。备份任务应该只在一段相对较长的时间（例如，10 秒）之后才被安排。&lt;/li>
&lt;li>为了测试崩溃恢复，你可以使用 mrapps/crash.go 应用程序插件。它会在 Map 和 Reduce 函数中随机退出。&lt;/li>
&lt;li>为了确保在崩溃的情况下没有人观察到部分写入的文件，MapReduce 论文提到了使用临时文件并在完全写入后以原子方式重命名它的技巧。你可以使用 ioutil.TempFile（或者如果你正在运行 Go 1.17 或更高版本，则可以使用 os.CreateTemp）来创建临时文件，并使用 os.Rename 来原子地重命名它。&lt;/li>
&lt;li>test-mr.sh 在子目录 mr-tmp 中运行所有进程，所以如果出了问题，你想查看中间文件或输出文件，请查看那里。可以随意暂时修改 test-mr.sh，在失败的测试后退出，这样脚本就不会继续测试（并覆盖输出文件）。&lt;/li>
&lt;li>test-mr-many.sh 连续多次运行 test-mr.sh，这样做可以帮助你发现低概率的错误。它接受一个参数，指定运行测试的次数。你不应该并行运行多个 test-mr.sh 实例，因为协调器会重用相同的套接字，导致冲突。&lt;/li>
&lt;li>Go RPC 只发送字段名称以大写字母开头的结构字段。子结构体也必须具有大写的字段名称。&lt;/li>
&lt;li>在调用 RPC 的 call() 函数时，应答结构体应包含所有默认值。RPC 调用应该像这样：
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">reply&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">SomeType&lt;/span>&lt;span class="p">{}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">call&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">...&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">reply&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>在调用之前不设置任何 reply 字段。如果传递具有非默认字段的 reply 结构体，则 RPC 系统可能会静默返回不正确的值。&lt;/li>
&lt;/ul>
&lt;h2 id="挑战">挑战&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>实现你自己的 MapReduce 应用程序（参见 mrapps/* 中的示例），例如，分布式 Grep（MapReduce 论文第 2.3 节）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>让你的 MapReduce 协调器和工作节点在不同的机器上运行，就像在实际中一样。你需要设置你的 RPC 以通过 TCP/IP 进行通信，而不是 Unix 套接字（参见 Coordinator.server() 中的注释行），并使用共享文件系统进行文件读写。例如，你可以 ssh 进入麻省理工学院的多个 Athena 集群机器，它们使用 AFS 共享文件；或者你可以租用几个 AWS 实例，并使用 S3 进行存储。&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>lab2 key value server</title><link>https://ysyyhhh.github.io/blog/lab2-key-value-server/</link><pubDate>Tue, 05 Mar 2024 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/blog/lab2-key-value-server/</guid><description/></item><item><title>MapReduce: Simplified Data Processing on Large Clusters</title><link>https://ysyyhhh.github.io/blog/mapreduce-simplified-data-processing-on-large-clusters/</link><pubDate>Tue, 05 Mar 2024 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/blog/mapreduce-simplified-data-processing-on-large-clusters/</guid><description>&lt;p>MapReduce: 一种用于大规模数据处理的简化并行计算模型&lt;/p>
&lt;p>引用: Jeffrey Dean and Sanjay Ghemawat. 2008. MapReduce: simplified data processing on large clusters. Commun. ACM 51, 1 (January 2008), 107–113. &lt;a href="https://doi.org/10.1145/1327452.1327492" target="_blank" rel="noopener">https://doi.org/10.1145/1327452.1327492&lt;/a>&lt;/p>
&lt;p>论文: [MapReduce: Simplified Data Processing on Large Clusters](&lt;a href="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/mapreduce-osdi04.pdf" target="_blank" rel="noopener">https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/mapreduce-osdi04.pdf&lt;/a>&lt;/p>
&lt;h2 id="摘要">摘要&lt;/h2>
&lt;p>MapReduce 是一个用于处理和生成大数据集的编程模型和相关实现。&lt;/p>
&lt;p>用户需要指定一个 map 函数来处理键/值对，生成一组中间键/值对，还有一个 reduce 函数来合并与同一个中间键相关联的所有中间值。&lt;/p>
&lt;p>许多现实世界的任务都可以用这个模型来表达，就像论文中所示的那样。以&lt;strong>这种函数式风格编写的程序会自动并行化&lt;/strong>，并在一大群廉价机器上执行。运行时系统负责处理输入数据的分区细节，调度程序在一组机器上的执行，处理机器故障，并管理所需的机器间通信。&lt;/p>
&lt;p>这使得没有任何并行和分布式系统经验的程序员可以轻松利用大型分布式系统的资源。&lt;/p>
&lt;p>我们的 MapReduce 实现运行在一大群廉价机器上，而且具有高度可扩展性：典型的 MapReduce 计算在成千上万台机器上处理着数百 TB 的数据。程序员发现这个系统易于使用：已经实现了数百个 MapReduce 程序，并且每天有上千个 MapReduce 作业在 Google 的集群上执行。&lt;/p>
&lt;h2 id="1-介绍">1. 介绍&lt;/h2>
&lt;p>在过去的五年里，作者和谷歌的许多其他人实现了数百种专用计算，处理大量原始数据，例如爬取的文档、网页请求日志等，以计算各种派生数据，例如倒排索引、网页文档的图结构的各种表示、每个主机爬取的页面数量摘要，给定日中最常见的查询集等等。大多数&lt;strong>这样的计算在概念上都很简单&lt;/strong>。但是，输入数据通常很大，计算必须分布在数百甚至数千台机器上才能在合理的时间内完成。&lt;strong>如何并行化计算、分布数据以及处理故障等问题，使原本简单的计算变得复杂&lt;/strong>，需要大量的复杂代码来解决这些问题。&lt;/p>
&lt;p>针对这种复杂性，我们设计了一个新的抽象，&lt;strong>允许我们表达我们试图执行的简单计算，但隐藏了并行化、容错、数据分布和负载平衡等混乱的细节在一个库&lt;/strong>中。我们的抽象受到Lisp和许多其他函数式语言中存在的map和reduce原语的启发。&lt;/p>
&lt;p>我们意识到，我们的大多数计算涉及将map操作应用于输入中的每个逻辑“记录”，以计算一组中间键/值对，然后将reduce操作应用于所有共享相同键的值，以适当地组合派生数据。我们使用具有&lt;strong>用户指定的map和reduce操作的函数模型，可以轻松地并行化大型计算，并使用重新执行作为容错的主要机制&lt;/strong>。&lt;/p>
&lt;p>这项工作的主要贡献是一个简单而强大的接口，可以实现大规模计算的自动并行化和分发，结合了该接口的一个实现，在大规模PC集群上实现了高性能。&lt;/p>
&lt;ul>
&lt;li>第2节描述了基本编程模型并给出了几个示例。&lt;/li>
&lt;li>第3节描述了针对我们基于集群的计算环境定制的MapReduce接口的实现。&lt;/li>
&lt;li>第4节描述了我们发现有用的编程模型的几个细化。&lt;/li>
&lt;li>第5节对我们的实现在各种任务中的性能进行了测量。&lt;/li>
&lt;li>第6节探讨了在谷歌内部使用MapReduce的情况，包括我们将其用作重写生产索引系统的基础的经验。&lt;/li>
&lt;li>第7节讨论了相关和未来的工作。&lt;/li>
&lt;/ul>
&lt;h2 id="2-编程模型">2. 编程模型&lt;/h2>
&lt;p>编程模型计算接受一组输入键/值对，并产生一组输出键/值对。MapReduce库的用户将计算表示为两个函数：Map和Reduce。&lt;/p>
&lt;p>用户编写的Map函数接受一个输入对，并生成一组中间键/值对。MapReduce库将所有与相同中间键I关联的中间值组合在一起，并将它们传递给Reduce函数。&lt;/p>
&lt;p>Reduce函数也由用户编写，接受一个中间键I和该键的一组值。它将这些值合并在一起，形成可能更小的一组值。通常，每次调用Reduce都只产生零个或一个输出值。中间值通过迭代器提供给用户的reduce函数。这使我们能够处理太大而无法放入内存的值列表。&lt;/p>
&lt;h3 id="21-示例">2.1 示例&lt;/h3>
&lt;p>下面考虑在大量文档集合中计算每个单词出现次数的问题。用户将编写类似以下伪代码的代码:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">map&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">String&lt;/span> &lt;span class="n">key&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">//&lt;/span> &lt;span class="n">key&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">文档名&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">//&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">文档内容&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">each&lt;/span> &lt;span class="n">word&lt;/span> &lt;span class="n">w&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">EmitIntermediate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">w&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;1&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">reduce&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">String&lt;/span> &lt;span class="n">key&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">Iterator&lt;/span> &lt;span class="n">values&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">//&lt;/span> &lt;span class="n">key&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">单词&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">//&lt;/span> &lt;span class="n">values&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">与key关联的值的迭代器&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">int&lt;/span> &lt;span class="n">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">each&lt;/span> &lt;span class="n">v&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">values&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">result&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">ParseInt&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">v&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Emit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">AsString&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">result&lt;/span>&lt;span class="p">));&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Map函数将文档名和内容作为输入，并为每个单词w生成一组中间键/值对。对于每个单词，我们发出一个中间键/值对，其中键是单词，值是字符串“1”。&lt;/p>
&lt;p>reduce函数将为特定单词发出的所有计数相加在一起。&lt;/p>
&lt;p>此外，用户编写代码来填写一个mapreduce规范对象，其中包含输入和输出文件的名称，以及可选的调优参数。&lt;/p>
&lt;p>然后，用户调用MapReduce函数，将规范对象传递给它。用户的代码与MapReduce库（用C++实现）链接在一起。&lt;/p>
&lt;p>此示例的完整程序文本:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 本节包含一个程序，用于统计命令行指定的一组输入文件中每个唯一单词的出现次数。
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;#34;mapreduce/mapreduce.h&amp;#34;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 用户的map函数
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">class&lt;/span> &lt;span class="nc">WordCounter&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="k">public&lt;/span> &lt;span class="n">Mapper&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">public&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">virtual&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="n">Map&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="n">MapInput&lt;/span>&lt;span class="o">&amp;amp;&lt;/span> &lt;span class="n">input&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">const&lt;/span> &lt;span class="n">string&lt;/span>&lt;span class="o">&amp;amp;&lt;/span> &lt;span class="n">text&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">input&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">const&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">n&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">text&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">size&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 跳过前导空白
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">isspace&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">text&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 寻找单词结尾
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">start&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="o">!&lt;/span>&lt;span class="n">isspace&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">text&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">start&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Emit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">text&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">substr&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">start&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">start&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="s">&amp;#34;1&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">REGISTER_MAPPER&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">WordCounter&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 用户的reduce函数
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">class&lt;/span> &lt;span class="nc">Adder&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="k">public&lt;/span> &lt;span class="n">Reducer&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">virtual&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">Reduce&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ReduceInput&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">input&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 遍历所有具有相同键的条目，并将值相加
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">int64&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">input&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">done&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">value&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">StringToInt&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">input&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="p">());&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">input&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">NextValue&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 发出输入键（input-&amp;gt;key()）的总和
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">Emit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">IntToString&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="p">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">REGISTER_REDUCER&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Adder&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">argc&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">char&lt;/span>&lt;span class="o">**&lt;/span> &lt;span class="n">argv&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ParseCommandLineFlags&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">argc&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">argv&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">MapReduceSpecification&lt;/span> &lt;span class="n">spec&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 将输入文件列表存储到 &amp;#34;spec&amp;#34; 中
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">argc&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">MapReduceInput&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">input&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">spec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">add_input&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">input&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">set_format&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;text&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">input&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">set_filepattern&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">argv&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">input&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">set_mapper_class&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;WordCounter&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 指定输出文件:
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// /gfs/test/freq-00000-of-00100
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// /gfs/test/freq-00001-of-00100
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">MapReduceOutput&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">out&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">spec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">output&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">out&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">set_filebase&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/gfs/test/freq&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">out&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">set_num_tasks&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">100&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">out&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">set_format&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;text&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">out&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">set_reducer_class&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Adder&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 可选: 在map任务中执行部分求和以节省网络带宽
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 组合器函数
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">out&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">set_combiner_class&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Adder&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 调优参数: 最多使用2000台机器和每个任务100 MB的内存
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">spec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">set_machines&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2000&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">spec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">set_map_megabytes&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">100&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">spec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">set_reduce_megabytes&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">100&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 现在运行它
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">MapReduceResult&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">MapReduce&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">spec&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">result&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">abort&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 完成: &amp;#39;result&amp;#39; 结构包含有关计数器、花费时间、使用的机器数量等的信息
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="22-类型">2.2 类型&lt;/h3>
&lt;p>即使先前的伪代码是以字符串输入和输出为基础编写的，从概念上讲，用户提供的Map和Reduce函数具有关联的类型：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">map&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">k1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">v1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="nb">list&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">k2&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">v2&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">reduce&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">k2&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nb">list&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">v2&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="nb">list&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">v2&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>也就是说，输入的键和值和输出的键和值来自不同的领域。此外，&lt;strong>中间键和值来自与输出键和值&lt;/strong>相同的领域。&lt;/p>
&lt;p>我们的 C++ 实现将字符串传递给用户定义的函数，并将其留给用户代码在字符串和适当类型之间进行转换。&lt;/p>
&lt;h3 id="23-更多示例">2.3 更多示例&lt;/h3>
&lt;p>以下是几个简单的有趣程序的示例，可以很容易地表达为 MapReduce 计算。&lt;/p>
&lt;p>分布式 Grep：如果匹配提供的模式，则Map函数发出一行。Reduce函数是一个恒等函数，只是将提供的中间数据复制到输出。&lt;/p>
&lt;p>URL 访问频率计数：Map函数处理 Web 页面请求的日志并输出 〈URL，1〉。Reduce函数将同一 URL 的所有值相加，并发出一个 〈URL，总计数〉 对。&lt;/p>
&lt;p>反向 Web-Link 图：Map函数为在名为源的页面中找到的指向目标 URL 的每个链接输出 〈目标，源〉 对。Reduce函数将与给定目标 URL 关联的所有源 URL 的列表串联在一起，并发出：〈目标，列表（源）〉&lt;/p>
&lt;p>每个主机的术语向量：术语向量汇总了出现在文档或一组文档中的最重要的单词，作为 〈word，frequency〉 对的列表。Map函数为每个输入文档（其中主机名从文档的 URL 中提取）发出一个 〈主机名，术语向量〉 对。Reduce函数为给定主机传递了所有每文档术语向量。它将这些术语向量相加，丢弃不经常出现的术语，然后发出一个最终的 〈主机名，术语向量〉 对。&lt;/p>
&lt;p>倒排索引：Map函数解析每个文档，并发出一系列 〈单词，文档 ID〉 对。Reduce函数接受给定单词的所有对，对相应的文档 ID 进行排序，并发出一个 〈单词，文档 ID 列表〉 对。所有输出对的集合形成一个简单的倒排索引。很容易扩展这个计算以跟踪单词位置。&lt;/p>
&lt;p>分布式排序：Map函数从每个记录中提取键，并发出一个 〈键，记录〉 对。Reduce函数保持所有对不变地发出。此计算依赖于第 4.1 节描述的分区设施和第 4.2 节描述的排序属性。&lt;/p>
&lt;h2 id="3-实施">3 实施&lt;/h2>
&lt;p>MapReduce 接口的许多不同实现是可能的。正确的选择取决于环境。例如，一个实现可能适用于小型共享内存机器，另一个适用于大型 NUMA 多处理器，还有一个适用于更大的网络机器集合。&lt;/p>
&lt;p>本节描述了一个针对谷歌广泛使用的计算环境的实现：大量使用廉价个人计算机连接在一起，采用交换式以太网 [4]。在我们的环境中：&lt;/p>
&lt;ol>
&lt;li>机器通常是运行 Linux 的双处理器 x86 处理器，每台机器配备 2-4GB 内存。&lt;/li>
&lt;li>采用廉价的网络硬件 - 通常是 100 兆位/秒或 1 千兆位/秒的机器级别，但总体双向分割带宽要低得多。&lt;/li>
&lt;li>一个集群由数百或数千台机器组成，因此机器故障很常见。&lt;/li>
&lt;li>存储由廉价的 IDE 硬盘直接连接到个别机器上提供。内部开发的分布式文件系统 [8] 用于管理存储在这些硬盘上的数据。文件系统使用复制在不可靠的硬件上提供可用性和可靠性。&lt;/li>
&lt;li>用户向调度系统提交作业。每个作业由一组任务组成，并由调度程序Map到集群中的一组可用机器。&lt;/li>
&lt;/ol>
&lt;h3 id="31-执行概述">3.1 执行概述&lt;/h3>
&lt;p>Map 调用通过自动分区输入数据到一组 M 个分片的方式分布在多台机器上。输入分片可以由不同的机器并行处理。Reduce 调用通过使用分区函数（例如，hash(key) mod R）将中间键空间分成 R 个部分进行分区。分区数量（R）和分区函数由用户指定。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/mapreduce-simplified-data-processing-on-large-clusters/img/2024-03-05-19-02-07_huc63602efe41666f6224ca8061e20c955_107810_b3d405394d84175d8e9509595bbf7ce1.webp 400w,
/blog/mapreduce-simplified-data-processing-on-large-clusters/img/2024-03-05-19-02-07_huc63602efe41666f6224ca8061e20c955_107810_2746d748292773c2f94329f8af4cc75d.webp 760w,
/blog/mapreduce-simplified-data-processing-on-large-clusters/img/2024-03-05-19-02-07_huc63602efe41666f6224ca8061e20c955_107810_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/mapreduce-simplified-data-processing-on-large-clusters/img/2024-03-05-19-02-07_huc63602efe41666f6224ca8061e20c955_107810_b3d405394d84175d8e9509595bbf7ce1.webp"
width="760"
height="512"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
上图显示了我们实现的 MapReduce 操作的整体流程。当用户程序调用 MapReduce 函数时，将发生以下动作序列（图中的编号标签对应下面列表中的编号）：&lt;/p>
&lt;ol>
&lt;li>用户程序中的 MapReduce 库首先将输入文件分成 M 个片段，通常每个片段为 16 MB 到 64 MB（用户可以通过可选参数控制）。然后，在一组机器上启动许多程序副本。&lt;/li>
&lt;li>程序的其中一个副本是特殊的 - &lt;strong>主节点。其余的是工作节点，由主节点分配工作。有&lt;/strong> M 个Map任务和 R 个Reduce任务要分配。主节点选择空闲的工作节点，并为每个分配一个Map任务或Reduce任务。&lt;/li>
&lt;li>被分配Map任务的工作节点读取相应输入分片的内容。它&lt;strong>从输入数据中解析出键/值对，并将每对传递给用户定义的 Map 函数&lt;/strong>。由 Map 函数产生的中间键/值对在内存中进行缓冲。&lt;/li>
&lt;li>&lt;strong>定期&lt;/strong>，缓冲的对会被写入本地磁盘，并由分区函数分成 R 个区域。这些缓冲对的位置被传回给主节点，负责将这些位置转发给Reduce工作节点。&lt;/li>
&lt;li>当Reduce工作节点收到主节点关于这些位置的通知时，它&lt;strong>使用RPC从Map工作节点的本地磁盘读取缓冲数据&lt;/strong>。当Reduce工作节点读取了所有中间数据时，它会根据中间键对数据进行排序，以便将相同键的所有出现组合在一起。**排序是必要的，因为通常许多不同的键Map到同一个Reduce任务。**如果中间数据量太大无法放入内存，则使用外部排序。&lt;/li>
&lt;li>Reduce工作节点遍历排序后的中间数据，并对每个唯一的中间键进行处理，&lt;strong>将键和相应的中间值集合传递给用户的 Reduce 函数&lt;/strong>。Reduce函数的输出附加到此Reduce分区的最终输出文件中。&lt;/li>
&lt;li>当所有Map任务和Reduce任务完成时，主节点唤醒用户程序。此时，用户程序中的 MapReduce 调用返回给用户代码。&lt;/li>
&lt;/ol>
&lt;p>成功完成后，mapreduce 执行的输出可用于 R 个输出文件中（&lt;strong>每个Reduce任务一个文件&lt;/strong>，文件名由用户指定）。&lt;/p>
&lt;p>通常，&lt;strong>用户不需要将这些 R 个输出文件合并为一个文件&lt;/strong> - 他们通常将这些文件作为另一个 MapReduce 调用的输入，或者从另一个能够处理被分成多个文件的输入的分布式应用程序中使用它们。&lt;/p>
&lt;h3 id="32-主数据结构">3.2 主数据结构&lt;/h3>
&lt;p>主节点保持着几个数据结构。对于每个Map任务和Reduce任务，它存储状态（空闲、进行中或已完成），以及工作机器的标识（对于非空闲任务）。&lt;/p>
&lt;p>主节点是中间文件区域的位置从Map任务传播到Reduce任务的通道。&lt;/p>
&lt;p>因此，对于每个已完成的Map任务，主节点存储由该Map任务产生的 R 个中间文件区域的位置和大小。&lt;/p>
&lt;p>当Map任务完成时，会接收到此位置和大小信息的更新。这些信息被逐步推送给具有正在进行的Reduce任务的工作节点。&lt;/p>
&lt;h3 id="33-容错性">3.3 容错性&lt;/h3>
&lt;p>由于 MapReduce 库旨在使用数百或数千台机器处理大量数据，因此该库必须能够优雅地容忍机器故障。&lt;/p>
&lt;h4 id="工作节点故障">工作节点故障&lt;/h4>
&lt;p>主节点&lt;strong>定期对每个工作节点进行 ping&lt;/strong>。如果一段时间内没有从工作节点接收到响应，主节点将该工作节点标记为失败。&lt;/p>
&lt;blockquote>
&lt;p>任何状态的Map任务被重置
由该工作节点完成的&lt;strong>任何Map任务&lt;/strong>都将被重置回初始空闲状态，因此可以被重新调度到其他工作节点上。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>进行中的Reduce被重置
类似地，由失败的工作节点&lt;strong>进行中&lt;/strong>的任何Map任务或Reduce任务也将被重置为空闲状态，并且有资格重新调度。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>已完成的Reduce任务不需要被重置&lt;/p>
&lt;/blockquote>
&lt;p>由于其输出存储在失败机器的本地磁盘上，因此&lt;strong>已完成的Map任务在失败时会被重新执行&lt;/strong>，并且因此无法访问。
&lt;strong>已完成的Reduce任务无需重新执行&lt;/strong>，因为其输出存储在全局文件系统中。&lt;/p>
&lt;p>当工作节点 A 首先执行Map任务，然后稍后由工作节点 B（因为 A 失败）执行时，&lt;strong>执行Reduce任务的所有工作节点&lt;/strong>都会收到重新执行的通知。
尚未从工作节点 A 读取数据的任何Reduce任务将从工作节点 B 读取数据。&lt;/p>
&lt;p>MapReduce 对大规模工作节点故障具有弹性。
例如，在一个 MapReduce 操作期间，运行中的集群上进行网络维护导致每次有 80 台机器成为几分钟内无法访问。MapReduce &lt;strong>主节点简单地重新执行了不可访问的工作节点机器完成的工作&lt;/strong>，并继续向前推进，最终完成了 MapReduce 操作。&lt;/p>
&lt;h4 id="主节点故障">主节点故障&lt;/h4>
&lt;p>主节点定期写入上述主数据结构的周期性检查点是很简单的。如果主任务死亡，则可以从最后一个检查点状态启动新的副本。&lt;/p>
&lt;p>然而，考虑到只有一个主节点，它的故障是不太可能的；因此，我们当前的实现在主节点故障时会中止 MapReduce 计算。客户端可以检查此条件，并在需要时重试 MapReduce 操作。&lt;/p>
&lt;h4 id="故障存在时的语义">故障存在时的语义&lt;/h4>
&lt;p>当用户提供的Map和Reduce运算符是其输入值的确定性函数时，我们的分布式实现产生的输出与整个程序的非故障顺序执行所产生的输出相同。&lt;/p>
&lt;p>我们依赖于Map和Reduce任务输出的原子提交来实现此属性。每个进行中的任务&lt;strong>将其输出写入私有临时文件&lt;/strong>。&lt;/p>
&lt;p>一个Reduce任务产生一个这样的文件，而&lt;strong>一个Map任务产生 R 个这样的文件（每个Reduce任务一个）&lt;/strong>。&lt;/p>
&lt;p>当Map任务完成时，工作节点向主节点发送一条消息，并在消息中包含 R 个临时文件的名称。如果主节点收到已经完成的Map任务的完成消息，则会忽略该消息。否则，它会将 R 个文件的名称记录在主数据结构中。&lt;/p>
&lt;p>当Reduce任务完成时，Reduce工作节点&lt;strong>将其临时输出文件原子地重命名为最终输出文件&lt;/strong>。如果相同的Reduce任务在多个机器上执行，则&lt;strong>对同一最终输出文件将执行多个重命名调用&lt;/strong>。我们依赖底层文件系统提供的原子重命名操作来保证最终的文件系统状态仅包含由Reduce任务的一次执行产生的数据。&lt;/p>
&lt;p>我们的大多数Map和Reduce运算符是确定性的，而我们的语义在这种情况下等同于顺序执行，这使得程序员很容易理解其程序的行为。当Map或Reduce运算符是非确定性的时，我们提供了更弱但仍合理的语义。&lt;/p>
&lt;p>在非确定性运算符存在的情况下，特定Reduce任务 R1 的输出等同于顺序执行非确定性程序产生的 R1 的输出。然而，不同Reduce任务 R2 的输出可能对应于&lt;strong>由不同顺序执行非确定性程序产生的 R2 的输出&lt;/strong>。&lt;/p>
&lt;p>考虑Map任务 M 和Reduce任务 R1 和 R2。设 e(Ri) 是执行 Ri 的已提交的执行（正好有一个这样的执行）。较弱的语义出现是因为 e(R1) 可能已读取由 M 的一个执行产生的输出，而 e(R2) 可能已读取由 M 的不同执行产生的输出。&lt;/p>
&lt;h3 id="34-本地性">3.4 本地性&lt;/h3>
&lt;p>在我们的计算环境中，网络带宽是相对稀缺的资源。我们通过利用输入数据（由 GFS [8] 管理）存储在构成我们集群的机器的本地磁盘上的事实来节省网络带宽。&lt;/p>
&lt;p>GFS 将每个文件划分为 64 MB 的块，并在不同的机器上存储每个块的多个副本（通常为 3 个副本）。&lt;/p>
&lt;p>MapReduce 主节点考虑输入文件的位置信息，并尝试在包含相应输入数据副本的机器上安排Map任务。如果失败，它将尝试在靠近该任务输入数据副本的地方安排Map任务（例如，在与包含数据的机器相同网络交换机上的工作机器）。
当在集群中的大部分工作节点上运行大型 MapReduce 操作时，大多数输入数据都是本地读取的，不会消耗网络带宽。&lt;/p>
&lt;h3 id="35-任务粒度">3.5 任务粒度&lt;/h3>
&lt;p>我们将映射阶段细分为 M 个部分，将Reduce阶段细分为 R 个部分，如上所述。&lt;/p>
&lt;p>理想情况下，M 和 R 应远大于工作节点的数量。让每个工作节点执行许多不同的任务可以改善动态负载平衡，并且在工作节点失败时加快恢复速度：它已完成的许多Map任务可以分散到所有其他工作节点上。&lt;/p>
&lt;p>在我们的实现中，M 和 R 的大小存在实际的限制，因为主节点必须根据上述描述做出 O(M + R) 的调度决策，并在内存中保持 O(M * R) 的状态。（然而，内存使用的常数因子很小：状态的 O(M * R) 部分大约包含每个Map任务/Reduce任务对的一个字节的数据。）&lt;/p>
&lt;p>此外，R 通常受用户约束，因为每个Reduce任务的输出最终都会在单独的输出文件中结束。&lt;/p>
&lt;p>在实践中，我们倾向于选择 M，使每个单独的任务大约为 16 MB 到 64 MB 的输入数据（这样上面描述的本地性优化效果最佳），并且我们将 R 设为我们预期使用的工作节点数量的小倍数。&lt;/p>
&lt;p>我们经常使用 M = 200,000 和 R = 5,000 来执行 MapReduce 计算，使用 2,000 个工作节点。&lt;/p>
&lt;h3 id="36-备用任务">3.6 备用任务&lt;/h3>
&lt;p>延长 MapReduce 操作总时间的常见原因之一是“拖延者”：一个机器在计算中完成 &lt;strong>最后几个映射或Reduce任务中的一个&lt;/strong> 时花费异常长的时间。&lt;/p>
&lt;p>拖延者可能出现的原因很多。&lt;/p>
&lt;ul>
&lt;li>一个有坏硬盘的机器可能会经常发生可纠正错误，从而将其读取性能从 30 MB/s 减慢到 1 MB/s。&lt;/li>
&lt;li>集群调度系统可能已将其他任务调度到该机器上，导致由于竞争 CPU、内存、本地磁盘或网络带宽而更慢地执行 MapReduce 代码。&lt;/li>
&lt;li>我们最近遇到的一个问题是机器初始化代码中的一个错误导致处理器缓存被禁用：受影响的机器上的计算速度下降了一百多倍。&lt;/li>
&lt;/ul>
&lt;p>我们有一个通用机制来缓解拖延者的问题。&lt;/p>
&lt;ul>
&lt;li>当 MapReduce 操作&lt;strong>即将完成时&lt;/strong>，主节点会&lt;strong>安排剩余正在进行的任务的备用执行&lt;/strong>。&lt;/li>
&lt;li>只要&lt;strong>主要执行或备用执行完成&lt;/strong>，任务就被标记为已完成。&lt;/li>
&lt;li>我们已经调整了这个机制，使其通常将操作使用的&lt;strong>计算资源增加不超过几个百分点&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>我们发现这显著缩短了完成大型 MapReduce 操作所需的时间。例如，第 5.3 节中描述的排序程序在禁用备用任务机制时需要花费的时间要长 44%。&lt;/p>
&lt;h2 id="4优化">4.优化&lt;/h2>
&lt;p>虽然简单地编写映射和Reduce函数提供的基本功能对大多数需求已足够，但我们发现一些扩展很有用。这些在本节中描述。&lt;/p>
&lt;h3 id="41-分区函数">4.1 分区函数&lt;/h3>
&lt;p>MapReduce 的用户指定他们希望的Reduce任务/输出文件数量（R）。使用中间键上的分区函数将数据分区到这些任务中。&lt;/p>
&lt;p>提供了一个默认的分区函数，使用哈希（例如“hash(key) mod R”）。这往往会产生相当均衡的分区。&lt;/p>
&lt;p>但是，在某些情况下，通过键的某些其他函数对数据进行分区是有用的。例如，有时输出键是 URL，我们希望所有单个主机的条目都最终出现在同一个输出文件中。&lt;/p>
&lt;p>为了支持这种情况，MapReduce 库的用户可以提供一个特殊的分区函数。例如，使用“hash(Hostname(urlkey)) mod R”作为分区函数将导致同一主机的所有 URL 最终出现在同一个输出文件中。&lt;/p>
&lt;h3 id="42-排序保证">4.2 排序保证&lt;/h3>
&lt;p>我们保证在给定分区内，中间键/值对按照递增的键顺序处理。&lt;/p>
&lt;p>这个排序保证使得生成每个分区的排序输出文件变得容易，当输出文件格式需要支持通过键进行高效的随机访问查找，或者输出的用户发现按排序数据很方便时，这是很有用的。&lt;/p>
&lt;h3 id="43-组合器功能">4.3 组合器功能&lt;/h3>
&lt;p>在某些情况下，每个Map任务产生的&lt;strong>中间键中存在重复&lt;/strong>，并且用户指定的Reduce函数是&lt;strong>可交换和可结合&lt;/strong>的。&lt;/p>
&lt;p>这种情况的一个很好的例子是第 2.1 节中的单词计数示例。由于单词频率往往遵循 Zipf 分布，每个Map任务将产生数百或数千个形式为 &amp;lt;the, 1&amp;gt; 的记录。&lt;/p>
&lt;p>所有这些计数都将通过网络发送到单个Reduce任务，然后由Reduce函数相加以产生一个数字。我们&lt;strong>允许用户指定一个可选的组合器函数&lt;/strong>，在将数据发送到网络之前对其进行部分合并。&lt;/p>
&lt;p>组合器函数在执行Map任务的每台机器上执行。通常情况下，相同的代码用于实现组合器和Reduce函数。&lt;/p>
&lt;p>Reduce函数和组合器函数之间唯一的区别是 MapReduce 库如何处理函数的输出。Reduce函数的输出写入最终输出文件。组合器函数的输出写入一个&lt;strong>中间文件&lt;/strong>，该文件将被发送到Reduce任务。&lt;/p>
&lt;p>部分合并显着加速了某些类别的 MapReduce 操作。
2.1示例中使用了组合器函数&lt;/p>
&lt;h3 id="44-输入和输出类型">4.4 输入和输出类型&lt;/h3>
&lt;p>MapReduce 库提供了对几种不同格式的输入数据进行读取的支持。&lt;/p>
&lt;p>例如，“文本”模式输入将每一行视为一个键/值对：键是文件中的偏移量，值是行的内容。另一个常见的支持格式存储按键排序的键/值对序列。&lt;/p>
&lt;p>每种输入类型的实现都知道如何将自己分割成适当的范围以作为单独的Map任务进行处理（例如，文本模式的范围分割确保范围分割仅发生在行边界处）。&lt;/p>
&lt;p>用户可以通过&lt;strong>提供简单的读取器接口的实现来添加对新输入类型的支持&lt;/strong>，尽管大多数用户只使用少量预定义的输入类型之一。&lt;/p>
&lt;p>读取器不一定需要提供从文件读取的数据。例如，可以轻松定义一个从数据库或内存中映射的数据结构中读取记录的读取器。&lt;/p>
&lt;p>类似地，我们&lt;strong>支持一组输出类型&lt;/strong>，以产生不同格式的数据，用户代码可以轻松地添加对新输出类型的支持。&lt;/p>
&lt;h3 id="45-副作用">4.5 副作用&lt;/h3>
&lt;p>在某些情况下，MapReduce 的用户发现从他们的Map和/或Reduce操作中&lt;strong>产生辅助文件作为附加输出&lt;/strong>是很方便的。&lt;/p>
&lt;p>我们&lt;strong>依赖于应用程序编写者使这些副作用具有原子性和幂等性&lt;/strong>。通常，应用程序将写入临时文件，&lt;strong>并在完全生成后原子地&lt;/strong>将此文件重命名。&lt;/p>
&lt;p>我们&lt;strong>不支持由单个任务产生的多个输出文件的原子两阶段提交&lt;/strong>。因此，产生具有跨文件一致性要求的多个输出文件的任务应该是确定性的。在实践中，这种限制从未成为问题。&lt;/p>
&lt;h3 id="46-跳过错误记录">4.6 跳过错误记录&lt;/h3>
&lt;p>有时用户代码中存在错误，导致 Map 或 Reduce 函数在某些记录上出现确定性崩溃。这种错误会阻止 MapReduce 操作完成。&lt;/p>
&lt;p>通常的做法是修复错误，但有时这是不可行的；也许错误是由于不可用的第三方库中的 bug。&lt;/p>
&lt;p>此外，有时可以忽略一些记录，例如在大型数据集上进行统计分析时。我们提供了一种可选的执行模式，其中 MapReduce 库会&lt;strong>检测哪些记录导致确定性崩溃，并跳过这些记录以继续向前推进&lt;/strong>。&lt;/p>
&lt;p>每个工作进程都安装了一个信号处理程序，用于捕获段错误和总线错误。在调用用户的 Map 或 Reduce 操作之前，MapReduce 库会将参数的序列号存储在一个全局变量中。如果用户代码生成信号，信号处理程序会发送一个“最后一口气”的 UDP 数据包，其中包含序列号到 MapReduce 主节点。&lt;/p>
&lt;p>当主节点在特定记录上看到多次失败时，它表示应该在下一个重新执行相应的 Map 或 Reduce 任务时跳过该记录。&lt;/p>
&lt;h3 id="47-本地执行">4.7 本地执行&lt;/h3>
&lt;p>调试 Map 或 Reduce 函数中的问题可能会很棘手，因为实际的计算发生在一个分布式系统中，通常在数千台机器上进行，并由主节点动态地进行工作分配决策。&lt;/p>
&lt;p>为了帮助进行调试、分析和小规模测试，我们开发了 MapReduce 库的替代实现，它在本地机器上顺序执行 MapReduce 操作的所有工作。为用户提供了控制，以便计算可以限制在特定的Map任务上。&lt;/p>
&lt;p>用户使用特殊标志调用其程序，然后可以轻松地使用任何有用的调试或测试工具（例如 gdb）。&lt;/p>
&lt;h3 id="48-状态信息">4.8 状态信息&lt;/h3>
&lt;p>主节点运行一个内部 HTTP 服务器，并为人类消费者导出一组状态页面。&lt;/p>
&lt;p>状态页面显示计算的进度，例如已完成多少任务、正在进行多少任务、输入字节数、中间数据字节数、输出字节数、处理速率等。&lt;/p>
&lt;p>页面还包含每个任务生成的标准错误和标准输出文件的链接。用户可以使用这些数据来预测计算需要多长时间，以及是否应该向计算中添加更多资源。这些页面还可以用于确定计算是否比预期的慢得多。&lt;/p>
&lt;p>此外，顶级状态页面显示了哪些工作节点失败，以及它们在失败时正在处理哪些映射和缩减任务。在尝试诊断用户代码中的错误时，这些信息非常有用。&lt;/p>
&lt;h3 id="49-计数器">4.9 计数器&lt;/h3>
&lt;p>MapReduce 库提供了一个计数器功能，用于&lt;strong>计算各种事件的发生次数&lt;/strong>。&lt;/p>
&lt;p>例如，用户代码可能希望计算处理的总单词数或索引的德语文档数等。&lt;/p>
&lt;p>要使用此功能，用户代码创建一个命名计数器对象，然后在 Map 和/或 Reduce 函数中适当地递增计数器。例如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="n">Counter&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">uppercase&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">uppercase&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">GetCounter&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;uppercase&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">map&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">String&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="n">contents&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">each&lt;/span> &lt;span class="n">word&lt;/span> &lt;span class="n">w&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">contents&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">IsCapitalized&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">w&lt;/span>&lt;span class="p">)):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">uppercase&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">Increment&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">EmitIntermediate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">w&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;1&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>来自各个工作机器的计数器值会&lt;strong>定期传播到主节点（通过 ping 响应搭载）&lt;/strong>。&lt;/p>
&lt;p>主节点汇总成功的映射和缩减任务的计数器值，并在 MapReduce 操作完成时将它们返回给用户代码。
当前的计数器值也显示在主节点状态页面上，以便人类观察实时计算的进度。&lt;/p>
&lt;p>在聚合计数器值时，&lt;strong>主节点消除相同映射或缩减任务的重复执行的影响&lt;/strong>，以避免重复计数。（重复执行可能源自我们对备用任务的使用以及由于失败而重新执行任务。）&lt;/p>
&lt;p>MapReduce 库自动维护了一些计数器值，例如处理的输入键/值对数和生成的输出键/值对数。&lt;/p>
&lt;p>用户发现计数器功能对于检查 MapReduce 操作的行为非常有用。例如，在某些 MapReduce 操作中，用户代码可能希望确保生成的输出对数恰好等于处理的输入对数，或者处理的德语文档的比例在总处理的文档数中的可容忍比例内。&lt;/p>
&lt;h2 id="5-性能">5 性能&lt;/h2>
&lt;p>在这一部分，我们将衡量在一个大型机群上运行的两个计算的MapReduce性能。&lt;/p>
&lt;ul>
&lt;li>一个计算搜索大约1TB的数据，寻找特定的模式。&lt;/li>
&lt;li>另一个计算对大约1TB的数据进行排序。&lt;/li>
&lt;/ul>
&lt;p>这两个程序代表了MapReduce用户编写的真实程序的一个大的子集 - 一个类别的程序将数据从一种表示形式转换为另一种表示形式，另一个类别从大数据集中提取少量有趣的数据。&lt;/p>
&lt;h3 id="51-机群配置">5.1 机群配置&lt;/h3>
&lt;p>所有程序都在一个包含大约1800台机器的机群上执行。每台机器配备两个2GHz的Intel Xeon处理器，并启用超线程技术，4GB内存，两个160GB IDE硬盘，以及一个千兆以太网连接。这些机器排列成一个两级树形交换网络，根节点拥有约100-200 Gbps的聚合带宽。所有机器都位于同一个托管设施，因此任何一对机器之间的往返时间都不到一毫秒。&lt;/p>
&lt;p>在4GB内存中，大约有1-1.5GB被集群上运行的其他任务所占用。这些程序是在一个周末下午执行的，当时CPU、磁盘和网络大部分时间都是空闲的。&lt;/p>
&lt;h3 id="52-grep">5.2 Grep&lt;/h3>
&lt;p>grep程序扫描10^10个100字节的记录，搜索一个相对罕见的三字符模式（该模式在92337条记录中出现）。输入被分成大约64MB的片段（M = 15000），整个输出放在一个文件中（R = 1）。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/mapreduce-simplified-data-processing-on-large-clusters/img/2024-03-05-20-59-39_hu032a4766b39d1ed5906607200701ac36_91532_c03a4a786a830643a05ed96ec4f9e640.webp 400w,
/blog/mapreduce-simplified-data-processing-on-large-clusters/img/2024-03-05-20-59-39_hu032a4766b39d1ed5906607200701ac36_91532_e9b9befc2f9010c298cf44bbeb5b236e.webp 760w,
/blog/mapreduce-simplified-data-processing-on-large-clusters/img/2024-03-05-20-59-39_hu032a4766b39d1ed5906607200701ac36_91532_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/mapreduce-simplified-data-processing-on-large-clusters/img/2024-03-05-20-59-39_hu032a4766b39d1ed5906607200701ac36_91532_c03a4a786a830643a05ed96ec4f9e640.webp"
width="760"
height="458"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
上图显示了随时间推移计算的进展情况。&lt;/p>
&lt;p>Y轴显示了扫描输入数据的速率。随着越来越多的机器被分配给这个MapReduce计算，速率逐渐提高，当分配了1764个工作节点时，达到了30GB/s以上的峰值。随着映射任务的完成，速率开始下降，并且在计算进行到大约80秒时降为零。整个计算大约需要150秒完成。这包括约一分钟的启动开销。这种开销是由于将程序传播到所有工作机器，以及与GFS交互以打开1000个输入文件集并获取所需信息以进行位置优化而造成的延迟。&lt;/p>
&lt;h3 id="53-排序">5.3 排序&lt;/h3>
&lt;p>sort程序对1010个100字节的记录进行排序（约1TB的数据）。该程序是模仿TeraSort基准测试[10]设计的。&lt;/p>
&lt;p>排序程序由不到50行的用户代码组成。三行Map函数从文本行中提取一个10字节的排序键并发出键和原始文本行作为中间键/值对。我们使用内置的Identity函数作为Reduce运算符。这个函数将中间键/值对不改变地作为输出键/值对。最终排序后的输出被写入一组2路复制的GFS文件（即，程序的输出为2TB）。与之前一样，输入数据被分割成64MB的片段（M = 15000）。我们将排序后的输出分成4000个文件（R = 4000）。分区函数使用键的初始字节将其分隔成R个片段之一。我们的分区函数对这个基准测试具有键的分布的内置知识。在一般的排序程序中，我们会添加一个预处理的MapReduce操作，该操作将收集键的样本并使用样本键的分布来计算最终排序传递的分割点。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/mapreduce-simplified-data-processing-on-large-clusters/img/2024-03-05-21-02-00_hua9a2c4f15df4d7b2d5e5e79a577d399a_87031_b345b946d5f65308bb9774bf3ec996ad.webp 400w,
/blog/mapreduce-simplified-data-processing-on-large-clusters/img/2024-03-05-21-02-00_hua9a2c4f15df4d7b2d5e5e79a577d399a_87031_624bd2ed20c3165d08c15caec5bdeeeb.webp 760w,
/blog/mapreduce-simplified-data-processing-on-large-clusters/img/2024-03-05-21-02-00_hua9a2c4f15df4d7b2d5e5e79a577d399a_87031_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/mapreduce-simplified-data-processing-on-large-clusters/img/2024-03-05-21-02-00_hua9a2c4f15df4d7b2d5e5e79a577d399a_87031_b345b946d5f65308bb9774bf3ec996ad.webp"
width="760"
height="441"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
图显示了排序程序正常执行的进度。左上角的图表显示了读取输入的速率。速率峰值约为13 GB/s，并在大约200秒内迅速下降，因为所有的映射任务在200秒之前都已完成。请注意，输入速率小于grep。这是因为排序映射任务将大约一半的时间和I/O带宽用于将中间输出写入其本地磁盘。相应的grep的中间输出尺寸可以忽略不计。
左中的图表显示了数据从映射任务发送到减少任务的网络速率。这种洗牌在第一个映射任务完成后立即开始。图表中的第一个驼峰是约为1700个减少任务的第一批（整个MapReduce分配了约1700台机器，并且每台机器最多执行一个减少任务）。计算约300秒后，这些第一批减少任务中的一些完成，我们开始为剩余的减少任务洗牌数据。所有的洗牌在计算约600秒后完成。
左下的图表显示了排序数据由减少任务写入最终输出文件的速率。在第一个洗牌周期结束和写入周期开始之间有一个延迟，因为机器正在忙于排序中间数据。一段时间后，写入速率维持在约2-4 GB/s。所有写入在计算约850秒后完成。
包括启动开销，整个计算需要891秒。这与TeraSort基准测试[18]的当前最佳报告结果1057秒相似。
需要注意的几点：输入速率高于洗牌速率和输出速率，因为我们的局部性优化 - 大多数数据从本地磁盘读取，绕过了我们相对带宽受限的网络。洗牌速率高于输出速率，因为输出阶段写入了排序数据的两个副本（我们为了可靠性和可用性原因制作了输出的两个副本）。我们写入两个副本，因为这是我们底层文件系统提供的可靠性和可用性机制。如果底层文件系统使用纠删码[14]而不是复制，那么写入数据的网络带宽要求将会降低。&lt;/p>
&lt;h3 id="54-备份任务的影响">5.4 备份任务的影响&lt;/h3>
&lt;p>在图(b)中，我们展示了禁用备份任务的排序程序执行。执行流程与图3(a)中显示的类似，唯一不同的是存在一个非常长的尾部，在那里几乎没有任何写入活动发生。
在960秒后，除了5个减少任务外，所有任务都已完成。然而，这最后几个慢性病者直到300秒后才完成。整个计算需要1283秒，比经过的时间增加了44%。&lt;/p>
&lt;h3 id="55-机器故障">5.5 机器故障&lt;/h3>
&lt;p>在图(c)中，我们展示了排序程序的执行，我们在计算几分钟后故意杀死了1746个工作进程中的200个。底层集群调度程序立即在这些机器上重新启动了新的工作进程（因为只有进程被杀死，机器仍然正常运行）。&lt;/p>
&lt;p>工作进程的死亡表现为负的输入速率，因为一些之前完成的映射工作消失了（因为对应的映射工作者被杀死了），需要重新做。这个映射工作的重新执行发生得相对迅速。整个计算包括启动开销在内在933秒内完成（仅比正常执行时间增加了5%）。&lt;/p>
&lt;h2 id="6-经验">6 经验&lt;/h2>
&lt;p>我们在2003年2月编写了MapReduce库的第一个版本，并在2003年8月进行了重大改进，包括局部性优化、动态负载平衡跨工作机器的任务执行等。自那时起，我们惊讶地发现MapReduce库在我们处理的问题类型上具有广泛的适用性。&lt;/p>
&lt;p>它已经在Google内部的各个领域广泛应用，包括：&lt;/p>
&lt;ul>
&lt;li>大规模机器学习问题，&lt;/li>
&lt;li>Google新闻和Froogle产品的聚类问题，&lt;/li>
&lt;li>提取用于生成流行查询报告（例如Google Zeitgeist）的数据，&lt;/li>
&lt;li>为新实验和产品从网页中提取属性（例如从大量网页中提取地理位置以进行本地化搜索），&lt;/li>
&lt;li>大规模图计算。&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/mapreduce-simplified-data-processing-on-large-clusters/img/2024-03-05-21-04-13_hucc00e8da7fd183260595548f1e4310d8_37077_582c034a0e3d7541c732ff88c0362386.webp 400w,
/blog/mapreduce-simplified-data-processing-on-large-clusters/img/2024-03-05-21-04-13_hucc00e8da7fd183260595548f1e4310d8_37077_565a7eef56928718c1cf63e51b77c64d.webp 760w,
/blog/mapreduce-simplified-data-processing-on-large-clusters/img/2024-03-05-21-04-13_hucc00e8da7fd183260595548f1e4310d8_37077_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/mapreduce-simplified-data-processing-on-large-clusters/img/2024-03-05-21-04-13_hucc00e8da7fd183260595548f1e4310d8_37077_582c034a0e3d7541c732ff88c0362386.webp"
width="760"
height="757"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
图4显示了随着时间的推移，我们在主要源代码管理系统中检入的单独MapReduce程序数量的显著增长，从2003年初的0增加到截至2004年9月底近900个独立实例。MapReduce之所以如此成功，是因为它使得编写一个简单的程序，并在半个小时内在一千台机器上高效运行成为可能，极大地加快了开发和原型周期。此外，它允许没有分布式和/或并行系统经验的程序员轻松利用大量资源。在每个作业结束时，MapReduce库记录了作业使用的计算资源的统计信息。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/mapreduce-simplified-data-processing-on-large-clusters/img/2024-03-05-21-04-28_hu5da7b1e3ce81d76e0bf52bfacb097572_100682_f294739f123f28d60ee7efda1461d269.webp 400w,
/blog/mapreduce-simplified-data-processing-on-large-clusters/img/2024-03-05-21-04-28_hu5da7b1e3ce81d76e0bf52bfacb097572_100682_290401552d51776df516abea43bd083c.webp 760w,
/blog/mapreduce-simplified-data-processing-on-large-clusters/img/2024-03-05-21-04-28_hu5da7b1e3ce81d76e0bf52bfacb097572_100682_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/mapreduce-simplified-data-processing-on-large-clusters/img/2024-03-05-21-04-28_hu5da7b1e3ce81d76e0bf52bfacb097572_100682_f294739f123f28d60ee7efda1461d269.webp"
width="760"
height="596"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
在表1中，我们展示了Google在2004年8月运行的一些MapReduce作业的统计信息子集。&lt;/p>
&lt;h3 id="61-大规模索引">6.1 大规模索引&lt;/h3>
&lt;p>迄今为止，我们对MapReduce的最重要的使用之一是完全重写了用于Google网页搜索服务的生产索引系统。索引系统将由我们的爬取系统检索到的大量文档作为输入，存储为一组GFS文件。这些文档的原始内容超过20TB的数据。索引过程作为五到十个MapReduce操作的序列运行。使用MapReduce（而不是之前版本索引系统中的特定分布式操作）带来了几个好处：&lt;/p>
&lt;ul>
&lt;li>索引代码更简单、更小、更容易理解，因为处理容错、分布和并行化的代码被隐藏在MapReduce库中。例如，计算的一个阶段的代码量从约3800行C++代码减少到使用MapReduce表达时约为700行。&lt;/li>
&lt;li>MapReduce库的性能足够好，我们可以将概念上无关的计算分开，而不是将它们混合在一起以避免对数据的额外传递。这使得改变索引过程变得容易。例如，在旧的索引系统中需要几个月的变更，在新系统中只需要几天就能实现。&lt;/li>
&lt;li>索引过程的操作变得更加容易，因为大部分由机器故障、慢机器和网络故障引起的问题都由MapReduce库自动处理，无需操作员干预。此外，通过向索引集群添加新机器来改进索引过程的性能也很容易。&lt;/li>
&lt;/ul>
&lt;h2 id="7-相关工作">7 相关工作&lt;/h2>
&lt;p>许多系统提供了受限制的编程模型，并利用这些限制自动并行化计算。例如，可以使用并行前缀计算在N个处理器上以log N时间计算N个元素数组的所有前缀[6, 9, 13]。根据我们在大型现实世界计算中的经验，MapReduce可以被视为对其中一些模型的简化和提炼。更重要的是，我们提供了一个可容忍故障的实现，可以扩展到数千个处理器。相比之下，大多数并行处理系统只在较小的规模上实现，并将处理机器故障的细节留给程序员。&lt;/p>
&lt;p>批量同步编程[17]和一些MPI原语[11]提供了更高级别的抽象，使程序员更容易编写并行程序。这些系统与MapReduce之间的一个关键区别在于，MapReduce利用受限编程模型来自动并行化用户程序，并提供透明的容错机制。&lt;/p>
&lt;p>我们的局部性优化受到了诸如主动磁盘[12, 15]等技术的启发，其中计算被推送到靠近本地磁盘的处理元素，以减少跨I/O子系统或网络发送的数据量。我们在普通处理器上运行，其中直接连接了少量磁盘，而不是直接在磁盘控制器处理器上运行，但总体方法是相似的。&lt;/p>
&lt;p>我们的备份任务机制类似于Charlotte系统[3]中采用的急切调度机制。简单的急切调度的一个缺点是，如果一个给定的任务导致重复的故障，整个计算将无法完成。我们通过跳过错误记录的机制来解决一些这样的问题。&lt;/p>
&lt;p>MapReduce实现依赖于一种内部集群管理系统，该系统负责在大量共享机器上分发和运行用户任务。尽管本文的重点不在此，但集群管理系统在精神上与其他系统如Condor [16]类似。&lt;/p>
&lt;p>MapReduce库中的排序设施与NOW-Sort [1]的操作类似。源机器（映射工作器）对要排序的数据进行分区，并将其发送到R个减少工作者之一。每个减少工作者在本地排序其数据（如果可能的话在内存中）。当然，NOW-Sort没有用户可定义的Map和Reduce函数，这使得我们的库具有广泛的适用性。&lt;/p>
&lt;p>River [2]提供了一个编程模型，其中进程通过在分布式队列上发送数据进行通信。与MapReduce类似，River系统试图在异构硬件或系统扰动引入的非均匀性的情况下提供良好的平均性能。River通过仔细调度磁盘和网络传输来实现平衡的完成时间。MapReduce采用了一种不同的方法。通过限制编程模型，MapReduce框架能够将问题划分为大量的细粒度任务。这些任务动态地调度在可用工作者上，以便更快的工作者处理更多的任务。受限编程模型还允许我们在作业结束时调度任务的冗余执行，这在存在非均匀性（例如慢速或卡住的工作者）时极大地减少了完成时间。&lt;/p>
&lt;p>BAD-FS [5]与MapReduce有着非常不同的编程模型，与MapReduce不同，它的目标是跨广域网络执行作业。然而，它们有两个基本的相似之处。一是这两个系统都使用冗余执行来从故障引起的数据丢失中恢复。二是它们都使用了局部感知调度来减少在拥塞的网络链路上传输的数据量。&lt;/p>
&lt;p>TACC [7]是一个旨在简化高可用网络服务构建的系统。与MapReduce类似，它依赖于重新执行作为实现容错的机制。&lt;/p>
&lt;h2 id="8-结论">8 结论&lt;/h2>
&lt;p>MapReduce编程模型在Google被成功地用于许多不同的目的。我们将这一成功归因于几个原因。&lt;/p>
&lt;ul>
&lt;li>首先，该模型易于使用，即使是对于没有并行和分布式系统经验的程序员，因为它隐藏了并行化、容错、局部优化和负载平衡的细节。&lt;/li>
&lt;li>其次，大量的问题都可以很容易地表达为MapReduce计算。例如，MapReduce用于生成Google生产的网络搜索服务的数据，用于排序，数据挖掘，机器学习以及许多其他系统。&lt;/li>
&lt;li>第三，我们开发了一个MapReduce的实现，可以扩展到包含数千台机器的大型集群。该实现有效地利用了这些机器资源，因此适用于Google遇到的许多大型计算问题。&lt;/li>
&lt;/ul>
&lt;p>我们从这项工作中学到了几件事情。&lt;/p>
&lt;ul>
&lt;li>首先，限制编程模型使得并行化和分布计算变得容易，并使得这样的计算具有容错性。&lt;/li>
&lt;li>其次，网络带宽是一种稀缺资源。因此，我们系统中的许多优化都旨在减少在网络上传输的数据量：局部优化允许我们从本地磁盘读取数据，将中间数据写入本地磁盘的单个副本可以节省网络带宽。&lt;/li>
&lt;li>第三，冗余执行可以减少慢速机器的影响，并处理机器故障和数据丢失。&lt;/li>
&lt;/ul></description></item><item><title>Abstraction vs implementation</title><link>https://ysyyhhh.github.io/blog/abstraction-vs-implementation/</link><pubDate>Fri, 01 Mar 2024 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/blog/abstraction-vs-implementation/</guid><description>&lt;h2 id="ispc-language">ISPC language&lt;/h2>
&lt;p>SPMD: Single Program Multiple Data
一种花哨的方式来说，就是一种并行编程的范式，它的特点是：在编程时，我们只需要写一个程序，然后在运行时，这个程序会被复制多份，每一份都会被分配到不同的处理器上去执行，这样就实现了并行。&lt;/p>
&lt;p>用ISPC实现sinx&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="n">export&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">sinx&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">uniform&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">uniform&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">terms&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">uniform&lt;/span> &lt;span class="kt">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">uniform&lt;/span> &lt;span class="kt">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//assume N % programCount == 0
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">uniform&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">programCount&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">idx&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">programIndex&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">float&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">idx&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">float&lt;/span> &lt;span class="n">number&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">uniform&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">denom&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">6&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">uniform&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">sign&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">uniform&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">terms&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">j&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">value&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">sign&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">number&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="n">denom&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">number&lt;/span> &lt;span class="o">*=&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">denom&lt;/span> &lt;span class="o">*=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">sign&lt;/span> &lt;span class="o">*=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">result&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">idx&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用C++来调用
调用ISPC的东西是个程序实例的集合, gang.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c++" data-lang="c++">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;#34;sinx.ispc.h&amp;#34;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="n">N&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1000000&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="n">terms&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="kt">float&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">N&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="kt">float&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">N&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//init x
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//execute
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">ispc&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">sinx&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">N&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">terms&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">result&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/abstraction-vs-implementation/img/2023-10-07-21-12-02_huf0efc3661c3a8dbb19222d4c78427dcd_64558_6645a5b3ae3ddd05822a97581964c7a1.webp 400w,
/blog/abstraction-vs-implementation/img/2023-10-07-21-12-02_huf0efc3661c3a8dbb19222d4c78427dcd_64558_a5fc4d7e11a6077f1c92e8e21cf17691.webp 760w,
/blog/abstraction-vs-implementation/img/2023-10-07-21-12-02_huf0efc3661c3a8dbb19222d4c78427dcd_64558_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/abstraction-vs-implementation/img/2023-10-07-21-12-02_huf0efc3661c3a8dbb19222d4c78427dcd_64558_6645a5b3ae3ddd05822a97581964c7a1.webp"
width="377"
height="390"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>ispc中不需要手动设置programCount,programIndex&lt;/p>
&lt;p>programCount: &lt;strong>number of simultaneous program&lt;/strong> instances in the gang (uniform value)&lt;/p>
&lt;p>programIndex: &lt;strong>id of the current program&lt;/strong> instance in the gang(a non-uniform value)&lt;/p>
&lt;p>uniform value: 一个值在gang中的所有实例中都是一样的&lt;/p>
&lt;p>如果在ispc中直接使用sinx 并不会更快.&lt;/p>
&lt;p>因为有一些相同的工作会被重复做很多次.
通过分离他们,可以减少重复计算的次数,从而提高效率.&lt;/p>
&lt;p>一个设想的实现方法如下:
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/abstraction-vs-implementation/img/2023-10-07-21-20-55_hu8ffcb6cb31f8f6bbebe6700f4e47b705_244038_6c839c2c7db48b5c09baf72171af45ca.webp 400w,
/blog/abstraction-vs-implementation/img/2023-10-07-21-20-55_hu8ffcb6cb31f8f6bbebe6700f4e47b705_244038_c5c93d956e779e277324ce9a6f829f09.webp 760w,
/blog/abstraction-vs-implementation/img/2023-10-07-21-20-55_hu8ffcb6cb31f8f6bbebe6700f4e47b705_244038_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/abstraction-vs-implementation/img/2023-10-07-21-20-55_hu8ffcb6cb31f8f6bbebe6700f4e47b705_244038_6c839c2c7db48b5c09baf72171af45ca.webp"
width="728"
height="526"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>ISPC是为了更容易编写SIMD代码而设计的, 只需要通过特殊的宏或编译指示就可以使用SIMD指令.&lt;/p>
&lt;p>programCount 就是 向量宽度&lt;/p>
&lt;p>SPMD programming &lt;strong>abstraction&lt;/strong>&lt;/p>
&lt;p>ISPC compiler generates SIMD &lt;strong>implementation&lt;/strong>&lt;/p>
&lt;p>version2版本的代码,这是分块进行而不是交错的.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="n">export&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">sinx&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">uniform&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">uniform&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">terms&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">uniform&lt;/span> &lt;span class="kt">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">uniform&lt;/span> &lt;span class="kt">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">uniform&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">count&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">N&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="n">programCount&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">start&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">programIndex&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">count&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//assume N % programCount == 0
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">uniform&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">count&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">idx&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">start&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">float&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">idx&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">float&lt;/span> &lt;span class="n">number&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">uniform&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">denom&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">6&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">uniform&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">sign&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">uniform&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">terms&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">j&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">value&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">sign&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">number&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="n">denom&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">number&lt;/span> &lt;span class="o">*=&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">denom&lt;/span> &lt;span class="o">*=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">sign&lt;/span> &lt;span class="o">*=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">result&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">idx&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/abstraction-vs-implementation/img/2023-10-07-21-26-19_hu7938bd2c1271d40663fbfcd32562e0ce_196751_489fcd0f2eb24701e06c213cf432a3a7.webp 400w,
/blog/abstraction-vs-implementation/img/2023-10-07-21-26-19_hu7938bd2c1271d40663fbfcd32562e0ce_196751_58e4e2bf0e53ad2ba318e1a2ae95c491.webp 760w,
/blog/abstraction-vs-implementation/img/2023-10-07-21-26-19_hu7938bd2c1271d40663fbfcd32562e0ce_196751_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/abstraction-vs-implementation/img/2023-10-07-21-26-19_hu7938bd2c1271d40663fbfcd32562e0ce_196751_489fcd0f2eb24701e06c213cf432a3a7.webp"
width="723"
height="530"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>交错通常比分块更好,因为分块会导致数据的访问不连续. 当计算量不均匀时,分块会导致一些处理器的负载过重,而另一些处理器的负载过轻.&lt;/p>
&lt;p>并且因为是同时进行的, 交错可以访问邻近的数据,这样可以增加cache的命中率.&lt;/p>
&lt;p>根本原因:
矢量加载指令(寄存器)是一次加载多个数据,如果在很短的时间内,要加载的数据是连续的,那么就可以一次加载多个数据,如果数据是不连续的,那么就需要多次加载,这样就会降低效率.
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/abstraction-vs-implementation/img/2023-10-07-21-30-56_hu772df7a64f68035bf40a24f2e3f74143_347068_3384da9ebeed146a97cfc55595a67d0b.webp 400w,
/blog/abstraction-vs-implementation/img/2023-10-07-21-30-56_hu772df7a64f68035bf40a24f2e3f74143_347068_1575106681211a7a5c741cec621dd52d.webp 760w,
/blog/abstraction-vs-implementation/img/2023-10-07-21-30-56_hu772df7a64f68035bf40a24f2e3f74143_347068_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/abstraction-vs-implementation/img/2023-10-07-21-30-56_hu772df7a64f68035bf40a24f2e3f74143_347068_3384da9ebeed146a97cfc55595a67d0b.webp"
width="760"
height="562"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>如果有个聪明的编译器,它可以自动将分块的代码转换为交错的代码,这样就可以兼顾两者的优点.&lt;/p>
&lt;p>foreach就可以实现这个功能,让程序员不需要关心这些细节.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="n">export&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">sinx&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">uniform&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">uniform&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">terms&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">uniform&lt;/span> &lt;span class="kt">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">uniform&lt;/span> &lt;span class="kt">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">foreach&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="p">...&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">float&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">float&lt;/span> &lt;span class="n">number&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">uniform&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">denom&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">6&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">uniform&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">sign&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">uniform&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">terms&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">j&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">value&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">sign&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">number&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="n">denom&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">number&lt;/span> &lt;span class="o">*=&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">denom&lt;/span> &lt;span class="o">*=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">sign&lt;/span> &lt;span class="o">*=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">result&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ISPC的错误例子:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="n">export&lt;/span> &lt;span class="n">uniform&lt;/span> &lt;span class="kt">float&lt;/span> &lt;span class="nf">sumall&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">uniform&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">uniform&lt;/span> &lt;span class="kt">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">uniform&lt;/span> &lt;span class="kt">float&lt;/span> &lt;span class="n">sum&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">foreach&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="p">...&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">sum&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">sum&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>错误:编译器会报错,因为sum是一个uniform value,它在所有的实例中都是一样的,但是在foreach中,每个实例都会对sum进行修改,这样就会导致错误.&lt;/p>
&lt;p>修正这个错误:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="n">export&lt;/span> &lt;span class="n">uniform&lt;/span> &lt;span class="kt">float&lt;/span> &lt;span class="nf">sumall&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">uniform&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">uniform&lt;/span> &lt;span class="kt">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">uniform&lt;/span> &lt;span class="kt">float&lt;/span> &lt;span class="n">sum&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">float&lt;/span> &lt;span class="n">partial_sum&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">foreach&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="p">...&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">partial_sum&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">sum&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nf">reduce_add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">partial_sum&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">sum&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>reduce_add原语: 允许将一组不同的值合并为一个值,这个值在所有的实例中都是一样的.&lt;/p>
&lt;p>编译后的细节
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/abstraction-vs-implementation/img/2023-10-07-21-41-11_hu30d7f4b1ac4472348ddd5783aa0a2e21_362539_c0b3c7b02a87cd0eafa04c9f4beee5c6.webp 400w,
/blog/abstraction-vs-implementation/img/2023-10-07-21-41-11_hu30d7f4b1ac4472348ddd5783aa0a2e21_362539_55edfb833370beeedb04607514558ee7.webp 760w,
/blog/abstraction-vs-implementation/img/2023-10-07-21-41-11_hu30d7f4b1ac4472348ddd5783aa0a2e21_362539_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/abstraction-vs-implementation/img/2023-10-07-21-41-11_hu30d7f4b1ac4472348ddd5783aa0a2e21_362539_c0b3c7b02a87cd0eafa04c9f4beee5c6.webp"
width="741"
height="536"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>ISPC tasks: 基本上就是一个线程,但是它可以被分配到不同的处理器上去执行.&lt;/p>
&lt;h2 id="三种并行编程范式-和-三种-machine-architecture">三种并行编程范式 和 三种 machine architecture&lt;/h2>
&lt;p>聚焦于 communication 和 cooperation&lt;/p>
&lt;p>使用pthread时要call operate system
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/abstraction-vs-implementation/img/2023-10-07-21-46-12_hu424ec0e5f725e78cd54c25ee6a2805b4_197701_83380472fb20f875d83bf8891c0f6c14.webp 400w,
/blog/abstraction-vs-implementation/img/2023-10-07-21-46-12_hu424ec0e5f725e78cd54c25ee6a2805b4_197701_ed04f98ce04c7e8e1fd1bf25ece5ef46.webp 760w,
/blog/abstraction-vs-implementation/img/2023-10-07-21-46-12_hu424ec0e5f725e78cd54c25ee6a2805b4_197701_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/abstraction-vs-implementation/img/2023-10-07-21-46-12_hu424ec0e5f725e78cd54c25ee6a2805b4_197701_83380472fb20f875d83bf8891c0f6c14.webp"
width="737"
height="539"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>而在ISPC中,只需要call compiler&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/abstraction-vs-implementation/img/2023-10-07-21-46-25_hu743500d3f46eda111182bb13825ddd61_215881_52792a10df8d3bb4c80ec3a9d0e8c19a.webp 400w,
/blog/abstraction-vs-implementation/img/2023-10-07-21-46-25_hu743500d3f46eda111182bb13825ddd61_215881_030e1987c8ce29fd60d9d581425c576f.webp 760w,
/blog/abstraction-vs-implementation/img/2023-10-07-21-46-25_hu743500d3f46eda111182bb13825ddd61_215881_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/abstraction-vs-implementation/img/2023-10-07-21-46-25_hu743500d3f46eda111182bb13825ddd61_215881_52792a10df8d3bb4c80ec3a9d0e8c19a.webp"
width="727"
height="516"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="three-models-of-communicationabstraction">Three models of communication(abstraction)&lt;/h3>
&lt;h4 id="1shared-address-space">1.Shared address space&lt;/h4>
&lt;p>asst3中会用到&lt;/p>
&lt;p>多个线程之间通过互斥锁来进行通信&lt;/p>
&lt;p>在硬件中, Dance-hall model
所有处理器在同一侧.&lt;/p>
&lt;p>Symmetric Multiprocessor(SMP) system 就是如此&lt;/p>
&lt;p>最简单的方式是总线, 但这样无法扩展,因为总线的带宽是有限的.
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/abstraction-vs-implementation/img/2023-10-07-21-53-08_hub47389cf4f6ee62c3a24da3ed64647bd_284773_83f92147b67d52d347c9e764be414a7b.webp 400w,
/blog/abstraction-vs-implementation/img/2023-10-07-21-53-08_hub47389cf4f6ee62c3a24da3ed64647bd_284773_cc407f2eb03a52fbae43d3cfe589a807.webp 760w,
/blog/abstraction-vs-implementation/img/2023-10-07-21-53-08_hub47389cf4f6ee62c3a24da3ed64647bd_284773_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/abstraction-vs-implementation/img/2023-10-07-21-53-08_hub47389cf4f6ee62c3a24da3ed64647bd_284773_83f92147b67d52d347c9e764be414a7b.webp"
width="719"
height="515"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
但实际中:
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/abstraction-vs-implementation/img/2023-10-07-21-55-16_huf5246cd0b880f843a34d54e8a9ceaf60_364206_72f74a1364f215b213f08c01860aa3b0.webp 400w,
/blog/abstraction-vs-implementation/img/2023-10-07-21-55-16_huf5246cd0b880f843a34d54e8a9ceaf60_364206_edb55a08e1aefae545f268c2c8d26a2d.webp 760w,
/blog/abstraction-vs-implementation/img/2023-10-07-21-55-16_huf5246cd0b880f843a34d54e8a9ceaf60_364206_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/abstraction-vs-implementation/img/2023-10-07-21-55-16_huf5246cd0b880f843a34d54e8a9ceaf60_364206_72f74a1364f215b213f08c01860aa3b0.webp"
width="700"
height="525"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/abstraction-vs-implementation/img/2023-10-07-21-55-34_hua87b13fdf1ea4f4894dd6309e2108996_336002_c2b29e4255b71be3da91f5e5bf6035ad.webp 400w,
/blog/abstraction-vs-implementation/img/2023-10-07-21-55-34_hua87b13fdf1ea4f4894dd6309e2108996_336002_62a5aae783f2810b1b06c98e682c54c6.webp 760w,
/blog/abstraction-vs-implementation/img/2023-10-07-21-55-34_hua87b13fdf1ea4f4894dd6309e2108996_336002_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/abstraction-vs-implementation/img/2023-10-07-21-55-34_hua87b13fdf1ea4f4894dd6309e2108996_336002_c2b29e4255b71be3da91f5e5bf6035ad.webp"
width="713"
height="527"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>还有一种访问本地内存的方式,就是通过cache,这样就可以减少对总线的访问,从而提高效率.
Non-Uniform Memory Access(NUMA) system
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/abstraction-vs-implementation/img/2023-10-14-14-14-34_hud613f70bd8ccce87e35300c481917997_435369_f41680dad25a8c31bbd97860f05c5172.webp 400w,
/blog/abstraction-vs-implementation/img/2023-10-14-14-14-34_hud613f70bd8ccce87e35300c481917997_435369_fb2fbd3e109a81339371b7401c85f29f.webp 760w,
/blog/abstraction-vs-implementation/img/2023-10-14-14-14-34_hud613f70bd8ccce87e35300c481917997_435369_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/abstraction-vs-implementation/img/2023-10-14-14-14-34_hud613f70bd8ccce87e35300c481917997_435369_f41680dad25a8c31bbd97860f05c5172.webp"
width="760"
height="410"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>但它为程序员引入的复杂性是很大的,因为程序员需要手动的将数据放到本地内存中,这样才能提高效率.&lt;/p>
&lt;p>shared address space的优点:&lt;/p>
&lt;ol>
&lt;li>程序员不需要关心数据的传输&lt;/li>
&lt;li>程序员不需要关心数据的分布&lt;/li>
&lt;/ol>
&lt;h4 id="2message-passing">2.Message passing&lt;/h4>
&lt;p>aasst4中会用到&lt;/p>
&lt;p>由于实现缓存一致性需要额外的成本，因此在大型系统中，共享内存的实现是不可行的。在这种情况下，消息传递是一种更好的选择。&lt;/p>
&lt;p>在消息传递中，每个处理器都有自己的私有内存，而且没有共享内存。要在处理器之间传递数据，必须使用显式的消息传递原语。&lt;/p>
&lt;p>不需要任何硬件支持，因此可以在任何系统上实现。只需要网络。&lt;/p>
&lt;p>可以构建大型系统，因为没有共享内存的限制。&lt;/p>
&lt;p>这些原语允许程序员在处理器之间传递数据，但是程序员必须显式地指定数据的传输。这种方式的缺点是，程序员需要关心数据的传输，这样就会增加程序员的负担。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/abstraction-vs-implementation/img/2023-10-14-14-18-37_hu42065f6b748829e4ad2ed8749e657be7_703756_ddc00b5301d4dc84d1e271fe7930a3e9.webp 400w,
/blog/abstraction-vs-implementation/img/2023-10-14-14-18-37_hu42065f6b748829e4ad2ed8749e657be7_703756_d491feaa04b414c21f714294089e1a0f.webp 760w,
/blog/abstraction-vs-implementation/img/2023-10-14-14-18-37_hu42065f6b748829e4ad2ed8749e657be7_703756_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/abstraction-vs-implementation/img/2023-10-14-14-18-37_hu42065f6b748829e4ad2ed8749e657be7_703756_ddc00b5301d4dc84d1e271fe7930a3e9.webp"
width="760"
height="513"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h4 id="3data-parallel">3.Data parallel&lt;/h4>
&lt;p>asst2中会用到&lt;/p>
&lt;p>上面两种方式可以在任何硬件上实现。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/abstraction-vs-implementation/img/2023-10-14-14-22-41_hu29009ffeff66b4988989ee35eddf94af_620179_c09df96c7d1eb7e807d4e08bd88b7d7a.webp 400w,
/blog/abstraction-vs-implementation/img/2023-10-14-14-22-41_hu29009ffeff66b4988989ee35eddf94af_620179_45b583dd334a3ef06cb1eba15c98eb10.webp 760w,
/blog/abstraction-vs-implementation/img/2023-10-14-14-22-41_hu29009ffeff66b4988989ee35eddf94af_620179_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/abstraction-vs-implementation/img/2023-10-14-14-22-41_hu29009ffeff66b4988989ee35eddf94af_620179_c09df96c7d1eb7e807d4e08bd88b7d7a.webp"
width="760"
height="440"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>Data parallel对程序员来说是最简单的，因为程序员不需要关心数据的传输，也不需要关心数据的分布。但是，它只能在特定的硬件上实现，因为它需要硬件支持。&lt;/p>
&lt;p>过去我们使用SIMD，现在使用SPMD。&lt;/p>
&lt;p>并行程序的问题&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/abstraction-vs-implementation/img/2023-10-14-14-28-16_hu69dfe58954025daef8c252774f7a0fae_426166_3f56fdd1ed92ca29942ada1ecd451f8a.webp 400w,
/blog/abstraction-vs-implementation/img/2023-10-14-14-28-16_hu69dfe58954025daef8c252774f7a0fae_426166_35f3911aeb8171c6b3bb3b1641022573.webp 760w,
/blog/abstraction-vs-implementation/img/2023-10-14-14-28-16_hu69dfe58954025daef8c252774f7a0fae_426166_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/abstraction-vs-implementation/img/2023-10-14-14-28-16_hu69dfe58954025daef8c252774f7a0fae_426166_3f56fdd1ed92ca29942ada1ecd451f8a.webp"
width="760"
height="562"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>这样的并行会得到不确定的结果。&lt;/p>
&lt;p>那么如何有原则性地使用并行呢？&lt;/p>
&lt;p>有一个抽象概念是stream，可以避免并行竞争问题。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/abstraction-vs-implementation/img/2023-10-14-14-30-44_hu3d9b4b708f4c384b1f7b7d012771095e_675645_3c7739822199ef3aa5013f2a499cb65b.webp 400w,
/blog/abstraction-vs-implementation/img/2023-10-14-14-30-44_hu3d9b4b708f4c384b1f7b7d012771095e_675645_2e3d9be1885abeb0b8a5ba073e2faa56.webp 760w,
/blog/abstraction-vs-implementation/img/2023-10-14-14-30-44_hu3d9b4b708f4c384b1f7b7d012771095e_675645_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/abstraction-vs-implementation/img/2023-10-14-14-30-44_hu3d9b4b708f4c384b1f7b7d012771095e_675645_3c7739822199ef3aa5013f2a499cb65b.webp"
width="760"
height="519"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>两个函数间的用法：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/abstraction-vs-implementation/img/2023-10-14-14-31-24_hu7ad04064968c85894cc57d0d9c48a049_715623_64ef6cbf5a00d5a6bf1599d935d086d9.webp 400w,
/blog/abstraction-vs-implementation/img/2023-10-14-14-31-24_hu7ad04064968c85894cc57d0d9c48a049_715623_48da98c2f403b1682277c9fc2c8145bc.webp 760w,
/blog/abstraction-vs-implementation/img/2023-10-14-14-31-24_hu7ad04064968c85894cc57d0d9c48a049_715623_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/abstraction-vs-implementation/img/2023-10-14-14-31-24_hu7ad04064968c85894cc57d0d9c48a049_715623_64ef6cbf5a00d5a6bf1599d935d086d9.webp"
width="760"
height="559"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>当如果使用stream，就必须创建tmp。不得不把临时数据写入浪费的带宽中。&lt;/p>
&lt;p>所以我们希望也许有一些新的运算符可以做更加高级的操作。&lt;/p>
&lt;p>gather: 将数据从不同的stream中收集到一个stream中。
scatter: 将数据从一个stream中分散到不同的stream中。&lt;/p>
&lt;p>intel包括了gather，但不包括scatter。
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/abstraction-vs-implementation/img/2023-10-14-14-39-33_huac084b4facbe1a325680980b61a6f2eb_748223_5e0630b9c73daaa7936463d125ffd07c.webp 400w,
/blog/abstraction-vs-implementation/img/2023-10-14-14-39-33_huac084b4facbe1a325680980b61a6f2eb_748223_88196d1ffbb5e688aa133fefcc71da82.webp 760w,
/blog/abstraction-vs-implementation/img/2023-10-14-14-39-33_huac084b4facbe1a325680980b61a6f2eb_748223_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/abstraction-vs-implementation/img/2023-10-14-14-39-33_huac084b4facbe1a325680980b61a6f2eb_748223_5e0630b9c73daaa7936463d125ffd07c.webp"
width="760"
height="568"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/abstraction-vs-implementation/img/2023-10-14-14-42-00_hu1e128ac41b625201ee01db386b0f9bf6_668641_08b839ae4cc614773c96da758214b653.webp 400w,
/blog/abstraction-vs-implementation/img/2023-10-14-14-42-00_hu1e128ac41b625201ee01db386b0f9bf6_668641_fd727307d9b3eec91fb5789f8d13a106.webp 760w,
/blog/abstraction-vs-implementation/img/2023-10-14-14-42-00_hu1e128ac41b625201ee01db386b0f9bf6_668641_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/abstraction-vs-implementation/img/2023-10-14-14-42-00_hu1e128ac41b625201ee01db386b0f9bf6_668641_08b839ae4cc614773c96da758214b653.webp"
width="760"
height="557"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h4 id="总结">总结&lt;/h4>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/abstraction-vs-implementation/img/2023-10-14-14-44-11_hu191eb3d20f4c2a32765dba803ce24f69_671529_e7cdb83e3678f5e26c23091fd4def508.webp 400w,
/blog/abstraction-vs-implementation/img/2023-10-14-14-44-11_hu191eb3d20f4c2a32765dba803ce24f69_671529_7c9a647964f71be563c9183aefe4e725.webp 760w,
/blog/abstraction-vs-implementation/img/2023-10-14-14-44-11_hu191eb3d20f4c2a32765dba803ce24f69_671529_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/abstraction-vs-implementation/img/2023-10-14-14-44-11_hu191eb3d20f4c2a32765dba803ce24f69_671529_e7cdb83e3678f5e26c23091fd4def508.webp"
width="760"
height="512"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>这些并不是完全独立的，而是可以组合使用的。&lt;/p>
&lt;p>通常在实践中为了得到最好的性能，会使用以上所有的方式。&lt;/p>
&lt;p>多核芯片内部通常是shared address space，但小规模情况下使用message passing。&lt;/p></description></item><item><title>asst1</title><link>https://ysyyhhh.github.io/blog/asst1/</link><pubDate>Fri, 01 Mar 2024 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/blog/asst1/</guid><description>&lt;p>&lt;a href="https://www.cnblogs.com/kalicener/p/16824312.html" target="_blank" rel="noopener">参考&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://github.com/stanford-cs149/asst1" target="_blank" rel="noopener">任务&lt;/a>&lt;/p>
&lt;h2 id="program-1-parallel-fractal-generation-using-threads-20-pointshttpsgithubcomstanford-cs149asst1program-1-parallel-fractal-generation-using-threads-20-points">&lt;a href="https://github.com/stanford-cs149/asst1#program-1-parallel-fractal-generation-using-threads-20-points" target="_blank" rel="noopener">Program 1: Parallel Fractal Generation Using Threads (20 points)&lt;/a>&lt;/h2>
&lt;p>提示:
需要先看CMU15-418/CS149的L2再完成Pro1&lt;/p>
&lt;p>任务描述:
用多线程画mandelbrot fractal.&lt;/p>
&lt;p>代码中给出了串行的实现, 你需要实现多线程的版本.&lt;/p>
&lt;p>多线程版本中只需要修改 &lt;code>workerThreadStart&lt;/code>函数.
不需要手动创建线程, 也不需要手动join线程.
直接调用mandelbrotThread().&lt;/p>
&lt;h3 id="11--12-计算在23456781632个线程下的加速比">1.1 &amp;amp; 1.2, 计算在2,3,4,5,6,7,8,16,32个线程下的加速比&lt;/h3>
&lt;h4 id="编写并观察">编写并观察&lt;/h4>
&lt;p>workerThreadStart函数的实现:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="mi">345&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">workerThreadStart&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">WorkerArgs&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// TODO FOR CS149 STUDENTS: Implement the body of the worker
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// thread here. Each thread should make a call to mandelbrotSerial()
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// to compute a part of the output image. For example, in a
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// program that uses two threads, thread 0 could compute the top
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// half of the image and thread 1 could compute the bottom half.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// printf(&amp;#34;Hello world from thread %d\n&amp;#34;, args-&amp;gt;threadId);
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">double&lt;/span> &lt;span class="n">startTime&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">CycleTimer&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">currentSeconds&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 每个线程负责的行数(除不尽的部分由最后一个线程负责)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">height&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">height&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">numThreads&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">startRow&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">threadId&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">height&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">numRows&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">height&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">threadId&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">numThreads&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 如果是最后一个线程，那么就要把除不尽的部分也算上
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">numRows&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">height&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">height&lt;/span> &lt;span class="o">%&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">numThreads&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Thread %d startRow: %d, numRows: %d&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">threadId&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">startRow&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">numRows&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">mandelbrotSerial&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">x0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">y0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">x1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">y1&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">width&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">height&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">startRow&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">numRows&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">maxIterations&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">output&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">double&lt;/span> &lt;span class="n">endTime&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">CycleTimer&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">currentSeconds&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Thread %d time: %.3f ms&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">threadId&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">endTime&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">startTime&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="mi">1000&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>结果:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>线程数&lt;/th>
&lt;th>加速比&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>2&lt;/td>
&lt;td>1.97&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>3&lt;/td>
&lt;td>1.63&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>4&lt;/td>
&lt;td>2.31&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>5&lt;/td>
&lt;td>2.37&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>6&lt;/td>
&lt;td>3.08&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>7&lt;/td>
&lt;td>3.15&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>8&lt;/td>
&lt;td>3.74&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>16&lt;/td>
&lt;td>5.14&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>可以观察到，加速比和线程数并不是线性相关.&lt;/p>
&lt;h4 id="猜测原因">猜测原因&lt;/h4>
&lt;p>猜测可能的原因有:&lt;/p>
&lt;ul>
&lt;li>线程通信的开销&lt;/li>
&lt;li>每个线程分配的任务不均匀&lt;/li>
&lt;/ul>
&lt;h3 id="13-查看每个线程的执行时间验证猜想">1.3 查看每个线程的执行时间,验证猜想&lt;/h3>
&lt;p>当线程数为4时, 每个线程的执行时间如下:
Thread 0 time: 63.974 ms
Thread 3 time: 65.563 ms
Thread 2 time: 259.972 ms
Thread 1 time: 260.669 ms&lt;/p>
&lt;p>当线程数为8时, 每个线程的执行时间如下:
Thread 0 time: 13.702 ms
Thread 7 time: 16.831 ms
Thread 1 time: 57.324 ms
Thread 6 time: 61.069 ms
Thread 5 time: 113.431 ms
Thread 2 time: 115.753 ms
Thread 4 time: 164.736 ms
Thread 3 time: 166.306 ms&lt;/p>
&lt;p>可以看到,中间线程分配的任务更多,执行时间更长.
因此在增加线程数时,加速比并不是线性增加的.&lt;/p>
&lt;h3 id="14">1.4&lt;/h3>
&lt;p>任务描述:&lt;/p>
&lt;ul>
&lt;li>解决上面的问题,使得加速比更接近线性.
&lt;ul>
&lt;li>如: 8线程时的加速比需要在7~8之间.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>解决方法需要具有适用性, 适用所有的线程数.&lt;/li>
&lt;/ul>
&lt;p>tips:
有一个非常简单的静态赋值可以实现这个目标，并且线程之间不需要通信/同步.&lt;/p>
&lt;h4 id="解决方案">解决方案&lt;/h4>
&lt;p>思路:
根据代码可知, 每行的计算是独立的, 因此可以将每行分配给不同的线程.
但由上面的实验可知,中间行的计算量比较大.&lt;/p>
&lt;p>因此我们不应该直接平均切分行, 而是以线程数量为步长,线程交叉依次分配行.
即 第i个线程分配k*n+i行.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">workerThreadStart&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">WorkerArgs&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// TODO FOR CS149 STUDENTS: Implement the body of the worker
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// thread here. Each thread should make a call to mandelbrotSerial()
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// to compute a part of the output image. For example, in a
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// program that uses two threads, thread 0 could compute the top
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// half of the image and thread 1 could compute the bottom half.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// printf(&amp;#34;Hello world from thread %d\n&amp;#34;, args-&amp;gt;threadId);
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">double&lt;/span> &lt;span class="n">startTime&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">CycleTimer&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">currentSeconds&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cm">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> 方案1
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> // 每个线程负责的行数(除不尽的部分由最后一个线程负责)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> int baseHeight = args-&amp;gt;height / args-&amp;gt;numThreads;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> int startRow = args-&amp;gt;threadId * baseHeight;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> int numRows = baseHeight;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> int yu = args-&amp;gt;height % args-&amp;gt;numThreads;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> // 均匀分配剩余行
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> if (args-&amp;gt;threadId &amp;lt; yu)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> {
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> numRows++;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> }
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> startRow += std::min(args-&amp;gt;threadId, yu);
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> printf(&amp;#34;Thread %d startRow: %d, numRows: %d\n&amp;#34;, args-&amp;gt;threadId, startRow, numRows);
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> mandelbrotSerial(args-&amp;gt;x0, args-&amp;gt;y0, args-&amp;gt;x1, args-&amp;gt;y1,
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> args-&amp;gt;width, args-&amp;gt;height,
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> startRow, numRows,
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> args-&amp;gt;maxIterations, args-&amp;gt;output);
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 方案2, 依次分配行
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">height&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">height&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">threadId&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">height&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">numThreads&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">mandelbrotSerial&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">x0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">y0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">x1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">y1&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">width&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">height&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">maxIterations&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">output&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">double&lt;/span> &lt;span class="n">endTime&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">CycleTimer&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">currentSeconds&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Thread %d time: %.3f ms&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">threadId&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">endTime&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">startTime&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="mi">1000&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>输出结果:&lt;/p>
&lt;p>Thread 3 time: 88.842 ms
Thread 1 time: 89.680 ms
Thread 0 time: 89.717 ms
Thread 7 time: 90.280 ms
Thread 5 time: 90.715 ms
Thread 6 time: 90.743 ms
Thread 2 time: 91.049 ms
Thread 4 time: 92.982 ms
[mandelbrot thread]: [93.318] ms
Wrote image file mandelbrot-thread.ppm
(7.10x speedup from 8 threads)&lt;/p>
&lt;p>上面的解决方案使得每个线程的执行时间基本相同,因此加速比接近线性.
在8线程时,加速比为7.1.&lt;/p>
&lt;h3 id="15-16线程和8线程的加速比">1.5 16线程和8线程的加速比&lt;/h3>
&lt;p>现在16线程是否明显优于8线程? 给出是或否的原因.
(6.45x speedup from 16 threads)
16线程并没有明显由于8线程,反而还更慢.
原因:&lt;/p>
&lt;ul>
&lt;li>电脑本身是4核, 超线程后是8线程.&lt;/li>
&lt;li>16线程时线程切换反而导致开销增加.&lt;/li>
&lt;/ul>
&lt;h3 id="总结">总结&lt;/h3>
&lt;p>pro1的目的是为了认识到并行计算的overhead, 以及多线程在计算上也应该是依次交替分配的. 不能简单的平均分配.&lt;/p>
&lt;p>pro1是通过垂直分割来实现并行计算.
而向量化是通过水平分割来实现并行计算.&lt;/p>
&lt;h2 id="program-2-vectorizing-code-using-simd-intrinsics">program-2-vectorizing-code-using-simd-intrinsics&lt;/h2>
&lt;p>前提: L2
任务描述：
使用SIMD指令(CS149intrin.h提供的),来实现clampedExpVector函数.&lt;/p>
&lt;p>示例函数:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">absVector&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">values&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">output&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">__cs149_vec_float&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">__cs149_vec_float&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">__cs149_vec_float&lt;/span> &lt;span class="n">zero&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">_cs149_vset_float&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mf">0.f&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">__cs149_mask&lt;/span> &lt;span class="n">maskAll&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">maskIsNegative&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">maskIsNotNegative&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// Note: Take a careful look at this loop indexing. This example
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// code is not guaranteed to work when (N % VECTOR_WIDTH) != 0.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// Why is that the case?
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">N&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">+=&lt;/span>&lt;span class="n">VECTOR_WIDTH&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// All ones
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">maskAll&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">_cs149_init_ones&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// All zeros
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">maskIsNegative&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">_cs149_init_ones&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Load vector of values from contiguous memory addresses
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">_cs149_vload_float&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">values&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">maskAll&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// x = values[i];
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Set mask according to predicate
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">_cs149_vlt_float&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">maskIsNegative&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">zero&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">maskAll&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// if (x &amp;lt; 0) {
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Execute instruction using mask (&amp;#34;if&amp;#34; clause)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">_cs149_vsub_float&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">result&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">zero&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">maskIsNegative&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// output[i] = -x;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Inverse maskIsNegative to generate &amp;#34;else&amp;#34; mask
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">maskIsNotNegative&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">_cs149_mask_not&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">maskIsNegative&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// } else {
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Execute instruction (&amp;#34;else&amp;#34; clause)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">_cs149_vload_float&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">result&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">values&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">maskIsNotNegative&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// output[i] = x; }
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Write results back to memory
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">_cs149_vstore_float&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">output&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">maskAll&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>示例函数absVector并不能适用于所有情况,原因如下:
当n%VECTOR_WIDTH != 0时, 会越界.&lt;/p>
&lt;h3 id="12-实现clampedexpvector函数">1&amp;amp;2 实现clampedExpVector函数&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">clampedExpVector&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">float&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">values&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">exponents&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">float&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">output&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// CS149 STUDENTS TODO: Implement your vectorized version of
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// clampedExpSerial() here.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// Your solution should work for any value of
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// N and VECTOR_WIDTH, not just when VECTOR_WIDTH divides N
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">__cs149_vec_float&lt;/span> &lt;span class="n">one&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">nine&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">__cs149_vec_int&lt;/span> &lt;span class="n">zeroInt&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">oneInt&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">oneInt&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">_cs149_vset_int&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">zeroInt&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">_cs149_vset_int&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">one&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">_cs149_vset_float&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mf">1.f&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">nine&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">_cs149_vset_float&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mf">9.999999f&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">VECTOR_WIDTH&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">__cs149_mask&lt;/span> &lt;span class="n">maskAll&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">maskIsZero&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">maskIsNotZero&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">__cs149_vec_float&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">__cs149_vec_int&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// All ones
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">maskAll&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">_cs149_init_ones&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// All zeros
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">maskIsZero&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">_cs149_init_ones&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 防止在最后一次循环时，i+VECTOR_WIDTH超出N
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">VECTOR_WIDTH&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">maskAll&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">_cs149_init_ones&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">N&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// float x = values[i];
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">_cs149_vload_float&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">values&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">maskAll&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// int y = exponents[i];
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">_cs149_vload_int&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">exponents&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">maskAll&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// if (y == 0)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">_cs149_veq_int&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">maskIsZero&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">zeroInt&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">maskAll&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// {
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// output[i] = 1.f;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// }
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">_cs149_vstore_float&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">output&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">one&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">maskIsZero&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// else
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">maskIsNotZero&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">_cs149_mask_not&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">maskIsZero&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 消除最后一次循环时，i+VECTOR_WIDTH超出N的情况
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">maskIsNotZero&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">_cs149_mask_and&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">maskIsNotZero&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">maskAll&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// float result = x;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">__cs149_vec_float&lt;/span> &lt;span class="n">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// int count = y - 1;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">__cs149_vec_int&lt;/span> &lt;span class="n">count&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">_cs149_vsub_int&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">count&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">oneInt&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">maskIsNotZero&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 哪些count&amp;gt;0
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">__cs149_mask&lt;/span> &lt;span class="n">countMark&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">_cs149_vgt_int&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">countMark&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">count&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">zeroInt&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">maskIsNotZero&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// while (count &amp;gt; 0)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">_cs149_cntbits&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">countMark&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// result *= x;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">_cs149_vmult_float&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">result&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">countMark&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// count--;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">_cs149_vsub_int&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">count&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">count&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">oneInt&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">countMark&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 哪些count&amp;gt;0
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">_cs149_vgt_int&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">countMark&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">count&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">zeroInt&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">countMark&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// if (result &amp;gt; 9.999999f)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">__cs149_mask&lt;/span> &lt;span class="n">gtNineMask&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">_cs149_vgt_float&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">gtNineMask&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">nine&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">maskIsNotZero&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// { reult = 9.999999f;}
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">_cs149_vmove_float&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">result&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">nine&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">gtNineMask&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// output[i] = result;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">_cs149_vstore_float&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">output&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">maskIsNotZero&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>通过init_ones来防止在有n%vectorWith!=0时 越界.&lt;/p>
&lt;ul>
&lt;li>在最开始的maskAll时设置&lt;/li>
&lt;li>在取反码后也要设置一次&lt;/li>
&lt;/ul>
&lt;p>count循环:
通过设置一个mask来标记哪些count&amp;gt;0, 从而实现循环.&lt;/p>
&lt;p>修改vectorWidth为2, 4, 8, to 16来回答:
Does the vector utilization increase, decrease or stay the same as VECTOR_WIDTH changes? Why?&lt;/p>
&lt;p>vectorWidth为2时, 结果如下:
****************** Printing Vector Unit Statistics *******************
Vector Width: 2
Total Vector Instructions: 162728
Vector Utilization: 77.0%
Utilized Vector Lanes: 250653
Total Vector Lanes: 325456&lt;/p>
&lt;p>vectorWidth为4时, 结果如下:
****************** Printing Vector Unit Statistics *******************
Vector Width: 3
Total Vector Instructions: 119440
Vector Utilization: 72.2%
Utilized Vector Lanes: 258879
Total Vector Lanes: 358320&lt;/p>
&lt;p>vectorWidth为8时, 结果如下:
****************** Printing Vector Unit Statistics *******************
Vector Width: 8
Total Vector Instructions: 51628
Vector Utilization: 66.0%
Utilized Vector Lanes: 272539
Total Vector Lanes: 413024&lt;/p>
&lt;p>vectorWidth为16时, 结果如下:
****************** Printing Vector Unit Statistics *******************
Vector Width: 16
Total Vector Instructions: 26968
Vector Utilization: 64.2%
Utilized Vector Lanes: 277188
Total Vector Lanes: 431488&lt;/p>
&lt;p>可以发现, 随着vectorWidth的增加, vectorUtilization也在减少.&lt;/p>
&lt;p>原因:
有多个条件语句,当vectorWidth增加时, 每次在某个条件中不执行的指令也会增加.&lt;/p>
&lt;h3 id="3-实现arraysumvector">3 实现arraySumVector&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">float&lt;/span> &lt;span class="nf">arraySumVector&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">float&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">values&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// CS149 STUDENTS TODO: Implement your vectorized version of arraySumSerial here
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">__cs149_vec_float&lt;/span> &lt;span class="n">sum&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">_cs149_vset_float&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mf">0.f&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">VECTOR_WIDTH&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">__cs149_mask&lt;/span> &lt;span class="n">maskAll&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">__cs149_vec_float&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// All ones
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">maskAll&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">_cs149_init_ones&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 防止在最后一次循环时，i+VECTOR_WIDTH超出N
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">VECTOR_WIDTH&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">maskAll&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">_cs149_init_ones&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">N&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// float x = values[i];
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">_cs149_vload_float&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">values&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">maskAll&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// sum += x;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">_cs149_vadd_float&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">sum&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">sum&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">maskAll&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">float&lt;/span> &lt;span class="n">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mf">0.f&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// log2(VECTOR_WIDTH)内解决
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">log2&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">VECTOR_WIDTH&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 使用_cs149_hadd_float函数，将sum中的每两个元素相加
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 再使用_cs149_interleave_float函数，将sum中的每两个元素交叉放置
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 重复log2(VECTOR_WIDTH)次
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">_cs149_hadd_float&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">sum&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">sum&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">_cs149_interleave_float&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">sum&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">sum&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 将sum中的第一个元素赋值给result
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">sum&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>假设VECTOR_WIDTHs始终是N的因子.&lt;/p>
&lt;p>可以实现在O(N/VECTOR_WIDTH + log2(VECTOR_WIDTH))的时间内完成计算.&lt;/p>
&lt;p>最后的log2实现方式.
提示中给了两个函数
hadd: 将每两个元素相加
interleave: 将每两个元素交叉放置&lt;/p>
&lt;p>因此我们可以类似与归并排序的方式,将sum中的每两个元素相加,再将每两个元素交叉放置.
重复log2(VECTOR_WIDTH)次后,第一个元素就是结果.&lt;/p>
&lt;h2 id="program-3-ispc">program-3 ISPC&lt;/h2>
&lt;p>前提: L3&lt;/p>
&lt;h3 id="part1-ispc-basic">part1 ISPC basic&lt;/h3>
&lt;p>任务:学习ISPC基本概念和编写.&lt;/p>
&lt;p>ISPC是一种编译器,可以将C代码编译为SIMD指令.&lt;/p>
&lt;h3 id="part2-ispc-task">part2 ISPC task&lt;/h3>
&lt;p>任务描述:
观察ISPCtask执行的结果&lt;/p>
&lt;h4 id="1">1&lt;/h4>
&lt;p>启动mandelbrot_ispc &amp;ndash;tasks&lt;/p>
&lt;p>结果:
[mandelbrot serial]: [424.881] ms
Wrote image file mandelbrot-serial.ppm
[mandelbrot ispc]: [97.180] ms
Wrote image file mandelbrot-ispc.ppm
[mandelbrot multicore ispc]: [48.986] ms
Wrote image file mandelbrot-task-ispc.ppm
(4.37x speedup from ISPC)
(8.67x speedup from task ISPC)&lt;/p>
&lt;p>因为设置了两个task所以大约是两倍的加速比 对于 ISPC&lt;/p>
&lt;h4 id="2">2&lt;/h4>
&lt;p>修改mandelbrot_ispc_withtasks()中的task数量,
you should be able to achieve performance that exceeds the sequential version of the code by over 32 times!
How did you determine how many tasks to create?
Why does the number you chose work best?&lt;/p>
&lt;p>根据机器的最大超线程数量设置
我设置了16个task, 因为我的机器是4核8线程, 16个task可以使得每个线程都有两个task.&lt;/p>
&lt;h4 id="3">3&lt;/h4>
&lt;p>what happens when you launch 10,000 ISPC tasks? What happens when you launch 10,000 threads?&lt;/p>
&lt;p>向量加速&lt;/p>
&lt;p>思考题:
Q: Why are there two different mechanisms (foreach and launch) for expressing independent, parallelizable work to the ISPC system?
A:foreach是将一个任务分配给多个线程,而launch是将多个任务分配给多个线程.&lt;/p>
&lt;p>Q: Couldn&amp;rsquo;t the system just partition the many iterations of foreach across all cores and also emit the appropriate SIMD code for the cores?
A:&lt;/p>
&lt;h2 id="program-4-iterative-sqrt-15-points">program-4 Iterative sqrt (15 points)&lt;/h2>
&lt;p>用sqrt复习ISPC的基本概念&lt;/p>
&lt;h3 id="1-1">1&lt;/h3>
&lt;p>运行结果:
[sqrt serial]: [1316.793] ms
[sqrt ispc]: [301.134] ms
[sqrt task ispc]: [52.439] ms
(4.37x speedup from ISPC)
(25.11x speedup from task ISPC)
4.37x speedup due to SIMD
25.11 / 4.37 = 5.74x speedup due to multi-core&lt;/p>
&lt;h3 id="2-1">2&lt;/h3>
&lt;p>构造数组使得加速比最大.&lt;/p>
&lt;p>全部数为2.998.
思路:
因为每个元素相同可以让计算更均匀,2.998可以充分调动cpu
结构:
(5.60x speedup from ISPC)
(30.39x speedup from task ISPC)&lt;/p>
&lt;h3 id="3-1">3&lt;/h3>
&lt;p>构造数组使得加速比最小.&lt;/p>
&lt;p>全部数为1
思路:
1的sqrt计算迭代最少.&lt;/p>
&lt;p>结果:
(2.50x speedup from ISPC)
(3.08x speedup from task ISPC)&lt;/p>
&lt;h2 id="program-5-blas-saxpy-10-points">program-5 BLAS saxpy (10 points)&lt;/h2>
&lt;h3 id="1-2">1&lt;/h3>
&lt;p>运行观察加速比
[saxpy ispc]: [25.098] ms [11.874] GB/s [1.594] GFLOPS
[saxpy task ispc]: [18.438] ms [16.164] GB/s [2.169] GFLOPS
(1.36x speedup from use of tasks)&lt;/p>
&lt;p>因为需要访问内存所以加速比不高.&lt;/p>
&lt;h3 id="2-2">2&lt;/h3>
&lt;p>Even though saxpy loads one element from X, one element from Y, and writes one element to result the multiplier by 4 is correct. Why is this the case? (Hint, think about how CPU caches work.)&lt;/p>
&lt;p>当程序写入结果的一个元素时，它首先将包含这个元素的缓存行提取到缓存中。这需要一个内存操作。然后，当不需要这个缓存行时，它将从缓存中闪现出来，这需要另一个内存操作。&lt;/p></description></item><item><title>asst2</title><link>https://ysyyhhh.github.io/blog/asst2/</link><pubDate>Fri, 01 Mar 2024 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/blog/asst2/</guid><description>&lt;h2 id="c-sync">C++ Sync&lt;/h2>
&lt;h3 id="thread的使用">thread的使用&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;thread&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">my_func&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">thread_id&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">num_threads&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Hello from spawned thread %d of %d&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">thread_id&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">num_threads&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">argc&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">char&lt;/span>&lt;span class="o">**&lt;/span> &lt;span class="n">argv&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="kr">thread&lt;/span> &lt;span class="n">t0&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="kr">thread&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">my_func&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="kr">thread&lt;/span> &lt;span class="n">t1&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="kr">thread&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">my_func&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;The main thread is running concurrently with spawned threads.&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">t0&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">t1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Spawned threads have terminated at this point.&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="mutex">mutex&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;chrono&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;map&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;mutex&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;string&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;thread&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">map&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">string&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">g_pages&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">mutex&lt;/span> &lt;span class="n">g_pages_mutex&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">save_page&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">string&lt;/span>&lt;span class="o">&amp;amp;&lt;/span> &lt;span class="n">url&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// simulate a long page fetch
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">this_thread&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">sleep_for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">chrono&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">seconds&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">string&lt;/span> &lt;span class="n">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#34;fake content&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">lock_guard&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">mutex&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">guard&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">g_pages_mutex&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">g_pages&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">url&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="kr">thread&lt;/span> &lt;span class="n">t1&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">save_page&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;http://foo&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="kr">thread&lt;/span> &lt;span class="n">t2&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">save_page&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;http://bar&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">t1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">t2&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// safe to access g_pages without lock now, as the threads are joined
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="k">auto&lt;/span>&lt;span class="o">&amp;amp;&lt;/span> &lt;span class="nl">pair&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="n">g_pages&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">pair&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">first&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34; =&amp;gt; &amp;#34;&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">pair&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">second&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="sc">&amp;#39;\n&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Output&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">http://bar &lt;span class="o">=&lt;/span>&amp;gt; fake content
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">http://foo &lt;span class="o">=&lt;/span>&amp;gt; fake content
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="condition_variable">condition_variable&lt;/h3>
&lt;p>线程调用 wait (lock)来指示它希望等待来自另一个线程的通知。&lt;/p>
&lt;p>注意，互斥对象(包装在 std: : only _ lock 中)被传递给 wait ()调用。当通知线程时，条件变量将获得锁。&lt;/p>
&lt;p>这意味着当调用 wait ()返回时，调用线程是锁的当前持有者。锁通常用于保护线程现在需要检查的共享变量，以确保它正在等待的条件为真。&lt;/p>
&lt;p>创建 N 个线程。N-1个线程等待来自线程0的通知，然后在接到通知后，自动递增一个受共享互斥锁保护的计数器。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="cm">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * Wrapper class around a counter, a condition variable, and a mutex.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">ThreadState&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">public&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">condition_variable&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">condition_variable_&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">mutex&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">mutex_&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">counter_&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">num_waiting_threads_&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ThreadState&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">num_waiting_threads&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">condition_variable_&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">condition_variable&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">mutex_&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">mutex&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">counter_&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">num_waiting_threads_&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">num_waiting_threads&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">~&lt;/span>&lt;span class="n">ThreadState&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">delete&lt;/span> &lt;span class="n">condition_variable_&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">delete&lt;/span> &lt;span class="n">mutex_&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">signal_fn&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ThreadState&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">thread_state&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Acquire mutex to make sure the shared counter is read in a
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// consistent state.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">thread_state&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">mutex_&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">lock&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">thread_state&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">counter_&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">thread_state&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">num_waiting_threads_&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">thread_state&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">mutex_&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">unlock&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Release the mutex before calling `notify_all()` to make sure
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// waiting threads have a chance to make progress.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">thread_state&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">condition_variable_&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">notify_all&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Re-acquire the mutex to read the shared counter again.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">thread_state&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">mutex_&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">lock&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">thread_state&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">mutex_&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">unlock&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">wait_fn&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ThreadState&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">thread_state&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// A lock must be held in order to wait on a condition variable.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// This lock is atomically released before the thread goes to sleep
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// when `wait()` is called. The lock is atomically re-acquired when
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// the thread is woken up using `notify_all()`.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">unique_lock&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">mutex&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">lk&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">thread_state&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">mutex_&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">thread_state&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">condition_variable_&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">wait&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">lk&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Increment the shared counter with the lock re-acquired to inform the
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// signaling thread that this waiting thread has successfully been
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// woken up.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">thread_state&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">counter_&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Lock re-acquired after wait()...&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">lk&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">unlock&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * Signaling thread spins until each waiting thread increments a shared
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * counter after being woken up from the `wait()` method.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">condition_variable_example&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">num_threads&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;==============================================================&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Starting %d threads for signal-and-waiting...&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">num_threads&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="kr">thread&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">threads&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="kr">thread&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">num_threads&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ThreadState&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">thread_state&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">ThreadState&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">num_threads&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">threads&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="kr">thread&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">signal_fn&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">thread_state&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">num_threads&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">threads&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="kr">thread&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">wait_fn&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">thread_state&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">num_threads&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">threads&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;==============================================================&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">delete&lt;/span> &lt;span class="n">thread_state&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">delete&lt;/span>&lt;span class="p">[]&lt;/span> &lt;span class="n">threads&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="part_a">part_a&lt;/h2>
&lt;h3 id="step-1-实现tasksystemparallelspawn">step 1 实现TaskSystemParallelSpawn&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c++" data-lang="c++">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="n">TaskSystemParallelSpawn&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">run&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">IRunnable&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">runnable&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">num_total_tasks&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// TODO: CS149 students will modify the implementation of this
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// method in Part A. The implementation provided below runs all
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// tasks sequentially on the calling thread.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">atomic&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">taskId&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">num_threads&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">num_threads&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="kr">thread&lt;/span> &lt;span class="n">threads&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">num_threads&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 交叉分配任务
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">num_threads&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">threads&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="kr">thread&lt;/span>&lt;span class="p">([&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">]()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">task_id&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">taskId&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">fetch_add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">task_id&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">num_total_tasks&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">runnable&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">runTask&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">task_id&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">num_total_tasks&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">task_id&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">taskId&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">fetch_add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">num_threads&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">threads&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// printf(&amp;#34;done\n&amp;#34;);
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Q:How will you assign tasks to your worker threads? Should you consider static or dynamic assignment of tasks to threads?
A:交叉分配任务，动态分配任务&lt;/p>
&lt;p>Q:How will you ensure that all tasks are executed exactly once?
A:使用原子变量taskId&lt;/p>
&lt;h3 id="step-2-实现--tasksystemparallelthreadpoolspinning">step 2 实现 TaskSystemParallelThreadPoolSpinning&lt;/h3>
&lt;p>step1 的overhead主要是创建线程的开销(尤其是计算量低的任务上)，因此使用线程池可以减少开销&lt;/p>
&lt;p>要求: 在TestSystem 创建时,或者在run时创建线程池&lt;/p>
&lt;p>Q1: 作为一个开始的实现，我们建议您将worker threads设计为连续循环，始终检查它们是否有更多的工作要执行。(进入 while 循环直到条件为真的线程通常称为“spinning”)
那么worker thread 如何确定有work要执行呢？&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c++" data-lang="c++">&lt;span class="line">&lt;span class="cl">&lt;span class="n">TaskSystemParallelThreadPoolSpinning&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">TaskSystemParallelThreadPoolSpinning&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">num_threads&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">ITaskSystem&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">num_threads&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// TODO: CS149 student implementations may decide to perform setup
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// operations (such as thread pool construction) here.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// Implementations are free to add new class member variables
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// (requiring changes to tasksys.h).
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">exit_flag_&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">false&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">num_threads&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">threads&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">emplace_back&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">TaskSystemParallelThreadPoolSpinning&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">func&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">TaskSystemParallelThreadPoolSpinning&lt;/span>&lt;span class="o">::~&lt;/span>&lt;span class="n">TaskSystemParallelThreadPoolSpinning&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">exit_flag_&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">true&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">auto&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="kr">thread&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">threads&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">thread&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="n">TaskSystemParallelThreadPoolSpinning&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">run&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">IRunnable&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">runnable&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">num_total_tasks&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// TODO: CS149 students will modify the implementation of this
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// method in Part A. The implementation provided below runs all
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// tasks sequentially on the calling thread.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// printf(&amp;#34;run\n&amp;#34;);
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">runnable_&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">runnable&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">num_tasks_&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">num_total_tasks&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">num_tasks_done_&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">num_total_tasks&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">num_total_tasks&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">tasks_mutex_&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">lock&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">tasks_&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">push&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">tasks_mutex_&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">unlock&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">num_tasks_done_&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">num_total_tasks&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">this_thread&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">yield&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Q:为什么要使用yield
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// A:因为如果不使用yield，那么线程会一直占用CPU，导致其他线程无法运行
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// Q:那我直接死循环呢
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// A:死循环会导致CPU占用率100%，导致其他线程无法运行
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Q2:确保 run ()实现所需的同步行为是非常重要的。如何更改 run ()的实现以确定批量任务启动中的所有任务都已完成？
A:使用原子变量num_tasks_done_，每个任务完成时，num_tasks_done_加一，当num_tasks_done_等于num_total_tasks时，所有任务完成&lt;/p>
&lt;h3 id="step-3-实现-tasksystemparallelthreadpoolsleeping">step 3 实现 TaskSystemParallelThreadPoolSleeping&lt;/h3>
&lt;p>Step2的缺点：
当线程“spin”等待某些操作时，它们会利用 CPU 核心的执行资源。&lt;/p>
&lt;ul>
&lt;li>例如，工作线程可能会循环等待新任务到达。&lt;/li>
&lt;li>另一个例子是，主线程可能会循环等待辅助线程完成所有任务，这样它就可以从 run ()调用返回。&lt;/li>
&lt;/ul>
&lt;p>这可能会影响性能，因为即使这些线程没有做有用的工作，也会使用 CPU 资源来运行这些线程。&lt;/p>
&lt;p>在任务的这一部分中，我们希望您通过让线程处于休眠状态来提高任务系统的效率，直到它们所等待的条件得到满足。&lt;/p>
&lt;p>您的实现可以选择使用条件变量来实现此行为。条件变量是一个同步原语，它允许线程在等待条件存在时休眠(不占用 CPU 处理资源)。其他线程向等待唤醒的线程发出“信号”，以查看它们所等待的条件是否已经满足。例如，如果没有工作要做，您的工作线程可能会处于休眠状态(这样它们就不会从尝试执行有用工作的线程那里占用 CPU 资源)。另一个例子是，调用 run ()的主应用程序线程可能希望在等待批量任务启动中的所有任务由工作线程完成时休眠。(否则，一个旋转的主线程将从工作线程那里夺走 CPU 资源!)有关 C + + 中条件变量的更多信息，请参见我们的 C + + 同步教程。&lt;/p>
&lt;p>您在这部分作业中的实现可能需要考虑棘手的race conditions 。您需要考虑许多可能的线程行为交错&lt;/p>
&lt;p>您可能需要考虑编写额外的测试用例来测试您的系统。赋值入门代码包括评分脚本用于评分代码性能的工作负载，但是我们也将使用一组更广泛的工作负载来测试您的实现的正确性，而我们在入门代码中并没有提供这些工作负载！&lt;/p>
&lt;p>The assignment starter code includes the workloads that the grading script will use to grade the performance of your code, but we will also test the correctness of your implementation using a wider set of workloads that we are not providing in the starter code!&lt;/p>
&lt;p>tasksys.h&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="cm">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * TaskSystemParallelThreadPoolSleeping: This class is the student&amp;#39;s
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * optimized implementation of a parallel task execution engine that uses
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * a thread pool. See definition of ITaskSystem in
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * itasksys.h for documentation of the ITaskSystem interface.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">TaskSystemParallelThreadPoolSleeping&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="k">public&lt;/span> &lt;span class="n">ITaskSystem&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">public&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">TaskSystemParallelThreadPoolSleeping&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">num_threads&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">~&lt;/span>&lt;span class="n">TaskSystemParallelThreadPoolSleeping&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">const&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nf">name&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">void&lt;/span> &lt;span class="nf">run&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">IRunnable&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">runnable&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">num_total_tasks&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">TaskID&lt;/span> &lt;span class="nf">runAsyncWithDeps&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">IRunnable&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">runnable&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">num_total_tasks&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">const&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">vector&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">TaskID&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">deps&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">void&lt;/span> &lt;span class="nf">sync&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">private&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">vector&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="kr">thread&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">threads&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">num_tasks_&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">bool&lt;/span> &lt;span class="n">exit_flag_&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">atomic&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">num_tasks_done_&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">queue&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">tasks_&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">mutex&lt;/span> &lt;span class="n">tasks_mutex_&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">IRunnable&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">runnable_&lt;/span>&lt;span class="p">{};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">void&lt;/span> &lt;span class="nf">func&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">condition_variable&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">queue_condition_&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">condition_variable&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">condition_variable&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">all_done_condition_&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">condition_variable&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">num_waiting_threads_&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">atomic&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">num_tasks_remaining_&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">mutex&lt;/span> &lt;span class="n">all_done_mutex_&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>tasksys.cpp&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="cm">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * ================================================================
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * Parallel Thread Pool Sleeping Task System Implementation
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * ================================================================
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">const&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">TaskSystemParallelThreadPoolSleeping&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="s">&amp;#34;Parallel + Thread Pool + Sleep&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="n">TaskSystemParallelThreadPoolSleeping&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">func&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">task_id&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">exit_flag_&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">task_id&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">task_id&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">unique_lock&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">mutex&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">lk&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">tasks_mutex_&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 等待任务
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">queue_condition_&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">wait&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">lk&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">[]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">exit_flag_&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">tasks_&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">empty&lt;/span>&lt;span class="p">())&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">task_id&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">tasks_&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">front&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">tasks_&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">pop&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">runnable_&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">runTask&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">task_id&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">num_tasks_&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">num_tasks_remaining_&lt;/span>&lt;span class="o">--&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">num_tasks_remaining_&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 通知主线程
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// printf(&amp;#34;notify_all_done\n&amp;#34;);
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">all_done_condition_&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">notify_one&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 通知其他线程
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// printf(&amp;#34;notify_all\n&amp;#34;);
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">queue_condition_&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">notify_one&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">TaskSystemParallelThreadPoolSleeping&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">TaskSystemParallelThreadPoolSleeping&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">num_threads&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">ITaskSystem&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">num_threads&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// TODO: CS149 student implementations may decide to perform setup
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// operations (such as thread pool construction) here.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// Implementations are free to add new class member variables
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// (requiring changes to tasksys.h).
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">exit_flag_&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">false&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">num_threads&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">threads&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">emplace_back&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">TaskSystemParallelThreadPoolSleeping&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">func&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">TaskSystemParallelThreadPoolSleeping&lt;/span>&lt;span class="o">::~&lt;/span>&lt;span class="n">TaskSystemParallelThreadPoolSleeping&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// TODO: CS149 student implementations may decide to perform cleanup
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// operations (such as thread pool shutdown construction) here.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// Implementations are free to add new class member variables
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// (requiring changes to tasksys.h).
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">exit_flag_&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">true&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">queue_condition_&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">notify_all&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">auto&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="kr">thread&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">threads&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">thread&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="n">TaskSystemParallelThreadPoolSleeping&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">run&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">IRunnable&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">runnable&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">num_total_tasks&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// TODO: CS149 students will modify the implementation of this
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// method in Parts A and B. The implementation provided below runs all
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// tasks sequentially on the calling thread.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">runnable_&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">runnable&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">num_tasks_&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">num_total_tasks&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">num_tasks_remaining_&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">num_total_tasks&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">tasks_mutex_&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">lock&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">num_total_tasks&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">tasks_&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">push&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">tasks_mutex_&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">unlock&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 通知其他线程
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">queue_condition_&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">notify_all&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// printf(&amp;#34;run\n&amp;#34;);
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">num_tasks_remaining_&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">unique_lock&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">mutex&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">lk2&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">all_done_mutex_&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">all_done_condition_&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">wait&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">lk2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">[]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// printf(&amp;#34;all done\n&amp;#34;);
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// printf(&amp;#34;all done\n&amp;#34;);
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>结果分析:&lt;/p>
&lt;p>sleep对spin的提升效果不明显，可能是因为任务太少，线程切换的开销比较大.&lt;/p>
&lt;p>运行结果:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">&lt;span class="o">================================================================================&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Running task system grading harness... &lt;span class="o">(&lt;/span>&lt;span class="m">11&lt;/span> total tests&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> - Detected CPU with &lt;span class="m">16&lt;/span> execution contexts
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> - Task system configured to use at most &lt;span class="m">8&lt;/span> &lt;span class="nv">threads&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">================================================================================&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">================================================================================&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Executing test: super_super_light...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Reference binary: ./runtasks_ref_linux
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Results &lt;span class="k">for&lt;/span>: super_super_light
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> STUDENT REFERENCE PERF?
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Serial&lt;span class="o">]&lt;/span> 5.281 5.788 0.91 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Always Spawn&lt;span class="o">]&lt;/span> 95.221 92.995 1.02 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Spin&lt;span class="o">]&lt;/span> 10.877 10.446 1.04 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Sleep&lt;span class="o">]&lt;/span> 6.943 42.705 0.16 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">================================================================================&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Executing test: super_light...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Reference binary: ./runtasks_ref_linux
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Results &lt;span class="k">for&lt;/span>: super_light
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> STUDENT REFERENCE PERF?
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Serial&lt;span class="o">]&lt;/span> 37.497 37.844 0.99 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Always Spawn&lt;span class="o">]&lt;/span> 108.136 108.805 0.99 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Spin&lt;span class="o">]&lt;/span> 10.777 13.615 0.79 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Sleep&lt;span class="o">]&lt;/span> 10.274 44.686 0.23 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">================================================================================&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Executing test: ping_pong_equal...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Reference binary: ./runtasks_ref_linux
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Results &lt;span class="k">for&lt;/span>: ping_pong_equal
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> STUDENT REFERENCE PERF?
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Serial&lt;span class="o">]&lt;/span> 603.419 606.739 0.99 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Always Spawn&lt;span class="o">]&lt;/span> 167.412 178.638 0.94 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Spin&lt;span class="o">]&lt;/span> 105.983 123.525 0.86 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Sleep&lt;span class="o">]&lt;/span> 108.243 148.316 0.73 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">================================================================================&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Executing test: ping_pong_unequal...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Reference binary: ./runtasks_ref_linux
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Results &lt;span class="k">for&lt;/span>: ping_pong_unequal
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> STUDENT REFERENCE PERF?
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Serial&lt;span class="o">]&lt;/span> 1126.19 1109.329 1.02 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Always Spawn&lt;span class="o">]&lt;/span> 259.271 260.822 0.99 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Spin&lt;span class="o">]&lt;/span> 199.088 198.013 1.01 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Sleep&lt;span class="o">]&lt;/span> 198.777 214.293 0.93 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">================================================================================&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Executing test: recursive_fibonacci...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Reference binary: ./runtasks_ref_linux
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Results &lt;span class="k">for&lt;/span>: recursive_fibonacci
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> STUDENT REFERENCE PERF?
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Serial&lt;span class="o">]&lt;/span> 1052.273 1128.069 0.93 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Always Spawn&lt;span class="o">]&lt;/span> 156.014 172.113 0.91 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Spin&lt;span class="o">]&lt;/span> 156.31 171.337 0.91 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Sleep&lt;span class="o">]&lt;/span> 156.462 166.476 0.94 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">================================================================================&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Executing test: math_operations_in_tight_for_loop...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Reference binary: ./runtasks_ref_linux
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Results &lt;span class="k">for&lt;/span>: math_operations_in_tight_for_loop
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> STUDENT REFERENCE PERF?
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Serial&lt;span class="o">]&lt;/span> 411.426 423.96 0.97 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Always Spawn&lt;span class="o">]&lt;/span> 537.747 532.353 1.01 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Spin&lt;span class="o">]&lt;/span> 99.286 104.844 0.95 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Sleep&lt;span class="o">]&lt;/span> 95.817 239.76 0.40 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">================================================================================&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Executing test: math_operations_in_tight_for_loop_fewer_tasks...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Reference binary: ./runtasks_ref_linux
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Results &lt;span class="k">for&lt;/span>: math_operations_in_tight_for_loop_fewer_tasks
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> STUDENT REFERENCE PERF?
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Serial&lt;span class="o">]&lt;/span> 413.681 415.961 0.99 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Always Spawn&lt;span class="o">]&lt;/span> 514.021 505.234 1.02 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Spin&lt;span class="o">]&lt;/span> 108.644 117.702 0.92 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Sleep&lt;span class="o">]&lt;/span> 106.84 260.724 0.41 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">================================================================================&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Executing test: math_operations_in_tight_for_loop_fan_in...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Reference binary: ./runtasks_ref_linux
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Results &lt;span class="k">for&lt;/span>: math_operations_in_tight_for_loop_fan_in
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> STUDENT REFERENCE PERF?
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Serial&lt;span class="o">]&lt;/span> 212.534 211.52 1.00 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Always Spawn&lt;span class="o">]&lt;/span> 76.402 76.09 1.00 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Spin&lt;span class="o">]&lt;/span> 37.203 39.662 0.94 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Sleep&lt;span class="o">]&lt;/span> 36.523 57.039 0.64 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">================================================================================&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Executing test: math_operations_in_tight_for_loop_reduction_tree...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Reference binary: ./runtasks_ref_linux
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Results &lt;span class="k">for&lt;/span>: math_operations_in_tight_for_loop_reduction_tree
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> STUDENT REFERENCE PERF?
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Serial&lt;span class="o">]&lt;/span> 208.076 207.488 1.00 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Always Spawn&lt;span class="o">]&lt;/span> 45.054 45.227 1.00 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Spin&lt;span class="o">]&lt;/span> 33.079 33.9 0.98 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Sleep&lt;span class="o">]&lt;/span> 34.502 38.389 0.90 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">================================================================================&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Executing test: spin_between_run_calls...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Reference binary: ./runtasks_ref_linux
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Results &lt;span class="k">for&lt;/span>: spin_between_run_calls
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> STUDENT REFERENCE PERF?
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Serial&lt;span class="o">]&lt;/span> 353.553 382.373 0.92 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Always Spawn&lt;span class="o">]&lt;/span> 180.401 197.119 0.92 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Spin&lt;span class="o">]&lt;/span> 205.374 222.315 0.92 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Sleep&lt;span class="o">]&lt;/span> 214.819 197.579 1.09 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">================================================================================&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Executing test: mandelbrot_chunked...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Reference binary: ./runtasks_ref_linux
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Results &lt;span class="k">for&lt;/span>: mandelbrot_chunked
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> STUDENT REFERENCE PERF?
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Serial&lt;span class="o">]&lt;/span> 257.289 256.815 1.00 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Always Spawn&lt;span class="o">]&lt;/span> 34.395 34.058 1.01 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Spin&lt;span class="o">]&lt;/span> 34.241 34.922 0.98 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Sleep&lt;span class="o">]&lt;/span> 35.191 35.273 1.00 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">================================================================================&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Overall performance results
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Serial&lt;span class="o">]&lt;/span> : All passed Perf
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Always Spawn&lt;span class="o">]&lt;/span> : All passed Perf
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Spin&lt;span class="o">]&lt;/span> : All passed Perf
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Sleep&lt;span class="o">]&lt;/span> : All passed Perf
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="part_b">part_b&lt;/h2>
&lt;p>在任务的 B 部分中，您将扩展您的 A 部分任务系统实现，以支持可能依赖于以前任务的任务的异步启动。这些任务间依赖关系创建了任务执行库必须遵守的调度约束。&lt;/p>
&lt;p>ITaskSystem 接口还有一个方法:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="k">virtual&lt;/span> &lt;span class="n">TaskID&lt;/span> &lt;span class="nf">runAsyncWithDeps&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">IRunnable&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">runnable&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">num_total_tasks&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">const&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">vector&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">TaskID&lt;/span>&lt;span class="o">&amp;gt;&amp;amp;&lt;/span> &lt;span class="n">deps&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>RunAsyncWithDeps ()类似于 run () ，因为它也用于执行 num &lt;em>total&lt;/em> asks 任务的批量启动。但是，它与 run ()在许多方面有所不同&amp;hellip;&lt;/p>
&lt;h3 id="asynchronous-task-launch">Asynchronous Task Launch&lt;/h3>
&lt;p>首先，使用 runAsyncWithDeps ()创建的任务由任务系统与调用线程异步执行。&lt;/p>
&lt;p>这意味着 runAsyncWithDeps ()应该立即返回给调用方，即使任务尚未完成执行。&lt;/p>
&lt;p>该方法返回与此批量任务启动关联的唯一标识符。&lt;/p>
&lt;p>调用线程可以通过调用 sync ()来确定大容量任务启动的实际完成时间。&lt;/p>
&lt;p>&lt;code>virtual void sync() = 0;&lt;/code>&lt;/p>
&lt;p>只有当与之前所有批量任务启动关联的任务完成时，sync ()才返回给调用方。例如，考虑以下代码:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// assume taskA and taskB are valid instances of IRunnable...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">vector&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">TaskID&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">noDeps&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// empty vector
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">ITaskSystem&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">t&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">TaskSystem&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">num_threads&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// bulk launch of 4 tasks
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">TaskID&lt;/span> &lt;span class="n">launchA&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">t&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">runAsyncWithDeps&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">taskA&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">noDeps&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// bulk launch of 8 tasks
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">TaskID&lt;/span> &lt;span class="n">launchB&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">t&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">runAsyncWithDeps&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">taskB&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">8&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">noDeps&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// at this point tasks associated with launchA and launchB
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// may still be running
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">t&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">sync&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// at this point all 12 tasks associated with launchA and launchB
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// are guaranteed to have terminated
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如上面的注释中所述，在线程调用sync() runAsyncWithDeps() ) 的任务已完成。 准确地说， runAsyncWithDeps()告诉您的任务系统执行新的批量任务启动，但您的实现可以灵活地在下次调用sync()之前随时执行这些任务。 请注意，此规范意味着无法保证您的实现在从 launchB 启动任务之前先执行 launchA 中的任务！&lt;/p>
&lt;h3 id="support-for-explicit-dependencies">Support for Explicit Dependencies&lt;/h3>
&lt;p>runAsyncWithDeps()的第二个关键细节是它的第三个参数：TaskID 标识符向量，必须引用之前使用runAsyncWithDeps()启动的批量任务。 该向量指定当前批量任务启动中的任务所依赖的先前任务。 因此，在依赖向量中给出的启动中的所有任务完成之前，您的任务运行时无法开始执行当前批量任务启动中的任何任务！ 例如，考虑以下示例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">vector&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">TaskID&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">noDeps&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// empty vector
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">vector&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">TaskID&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">depOnA&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">vector&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">TaskID&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">depOnBC&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">ITaskSystem&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">t&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">TaskSystem&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">num_threads&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">TaskID&lt;/span> &lt;span class="n">launchA&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">t&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">runAsyncWithDeps&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">taskA&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">128&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">noDeps&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">depOnA&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">push_back&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">launchA&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">TaskID&lt;/span> &lt;span class="n">launchB&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">t&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">runAsyncWithDeps&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">taskB&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">depOnA&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">TaskID&lt;/span> &lt;span class="n">launchC&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">t&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">runAsyncWithDeps&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">taskC&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">6&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">depOnA&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">depOnBC&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">push_back&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">launchB&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">depOnBC&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">push_back&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">launchC&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">TaskID&lt;/span> &lt;span class="n">launchD&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">t&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">runAsyncWithDeps&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">taskD&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">32&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">depOnBC&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">t&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">sync&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面的代码有四个批量任务启动（taskA：128 个任务，taskB：2 个任务，taskC：6 个任务，taskD：32 个任务）。 请注意，任务 B 和任务 C 的启动取决于任务 A。 taskD 的批量启动 ( launchD ) 取决于launchB和launchC的结果。 因此，虽然您的任务运行时可以按任意顺序（包括并行）处理与launchB和launchC关联的任务，但这些启动中的所有任务必须在launchA的任务完成后开始执行，并且它们必须在运行时开始之前完成从launchD执行任何任务。&lt;/p>
&lt;p>我们可以通过任务图直观地说明这些依赖关系。 任务图是有向无环图 (DAG)，其中图中的节点对应于批量任务启动，从节点 X 到节点 Y 的边表示 Y 对 X 输出的依赖关系。上述代码的任务图是：
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="https://github.com/jeremyephron/asst2/raw/master/figs/task_graph.png" alt="Alt text" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>请注意，如果您在具有八个执行上下文的 Myth 计算机上运行上面的示例，则并行调度launchB和launchC中的任务的能力可能非常有用，因为单独的批量任务启动都不足以使用所有执行机器的资源。&lt;/p>
&lt;h3 id="task">Task&lt;/h3>
&lt;p>您必须从 A 部分扩展任务系统实现，才能正确实现TaskSystem::runAsyncWithDeps()和TaskSystem::sync() 。 与 A 部分一样，我们为您提供以下入门提示：&lt;/p>
&lt;ul>
&lt;li>It may be helpful to think about the behavior of runAsyncWithDeps() as pushing a record corresponding to the bulk task launch, or perhaps records corresponding to each of the tasks in the bulk task launch onto a &amp;ldquo;work queue&amp;rdquo;. Once the record to work to do is in the queue, runAsyncWithDeps() can return to the caller.&lt;/li>
&lt;li>The trick in this part of the assignment is performing the appropriate bookkeeping to track dependencies. What must be done when all the tasks in a bulk task launch complete? (This is the point when new tasks may become available to run.)&lt;/li>
&lt;li>It can be helpful to have two data structures in your implementation: (1) a structure representing tasks that have been added to the system via a call to runAsyncWithDeps(), but are not yet ready to execute because they depend on tasks that are still running (these tasks are &amp;ldquo;waiting&amp;rdquo; for others to finish) and (2) a &amp;ldquo;ready queue&amp;rdquo; of tasks that are not waiting on any prior tasks to finish and can safely be run as soon as a worker thread is available to process them.&lt;/li>
&lt;li>You need not worry about integer wrap around when generating unique task launch ids. We will not hit your task system with over 2^31 bulk task launches.&lt;/li>
&lt;li>You can assume all programs will either call only run() or only runAsyncWithDeps(); that is, you do not need to handle the case where a run() call needs to wait for all proceeding calls to runAsyncWithDeps() to finish.&lt;/li>
&lt;/ul>
&lt;p>在part_b/子目录中实现B部分实现，以与正确的参考实现（ part_b/runtasks_ref_* ）进行比较。&lt;/p></description></item><item><title>L2</title><link>https://ysyyhhh.github.io/blog/l2/</link><pubDate>Fri, 01 Mar 2024 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/blog/l2/</guid><description>&lt;h2 id="并行程序">并行程序&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c++" data-lang="c++">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">sinx&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">terms&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">float&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">float&lt;/span> &lt;span class="n">number&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">sign&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">denom&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">6&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">terms&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">j&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">value&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">sign&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">number&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="n">denom&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">sign&lt;/span> &lt;span class="o">*=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">denom&lt;/span> &lt;span class="o">*=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">number&lt;/span> &lt;span class="o">*=&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">result&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>转换成汇编后大致如下:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-asm" data-lang="asm">&lt;span class="line">&lt;span class="cl">&lt;span class="nf">ld&lt;/span> &lt;span class="no">r0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">addr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="no">r1&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">mul&lt;/span> &lt;span class="no">ri&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">r0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">r0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">mul&lt;/span> &lt;span class="no">r1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">r1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">r0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">可以看到每次循环都是独立的。&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">对于最简单的是顺序执行。&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">通过超线程(超标量处理器具有从单个指令流中提取多个指令的能力)可以提高性能。有时称指令级并行性。(&lt;/span>&lt;span class="nf">ILP&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">Instruction&lt;/span> &lt;span class="no">Level&lt;/span> &lt;span class="no">Parallelism&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">但在这些汇编指令中必须顺序执行。&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">因此实现指令级并行性是一个挑战。&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">但即使是纯顺序执行的代码,也有很多方式使其运行更快(基于写代码的方式和编译器的智能程度).&lt;/span> &lt;span class="nf">Pentium&lt;/span> &lt;span class="mi">4&lt;/span> &lt;span class="err">比如先取多条指令等&lt;/span>&lt;span class="p">.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">(有个黑匣子会预测分支,预测错误的话就会清空流水线,浪费时间)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">解决方法:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">1.&lt;/span> &lt;span class="err">通过&lt;/span>&lt;span class="nf">pthread编写并行性的程序&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">2.&lt;/span> &lt;span class="err">假设有一种语言可以表示并行性,编译器可以自动并行化程序&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">如:&lt;/span> &lt;span class="nf">forall&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">int&lt;/span> &lt;span class="no">i&lt;/span> &lt;span class="no">from&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="no">to&lt;/span> &lt;span class="no">n-1&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="err">{}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">自动并行化可能的解决方法:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">1.&lt;/span> &lt;span class="err">直接分为&lt;/span>&lt;span class="nf">k个线程&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="err">每个线程处理&lt;/span>&lt;span class="no">n&lt;/span>&lt;span class="err">/&lt;/span>&lt;span class="no">k个循环.&lt;/span> &lt;span class="err">然后将结果合并&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">2.&lt;/span> &lt;span class="err">在硬件上执行.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">有一堆性能较低但具有并行性的处理器时,&lt;/span> &lt;span class="err">也需要更多电力/时间来驱动很多信号从一端到另一端.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">## CPU &amp;amp;&amp;amp; GPU
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nf">GPU将核心的概念带到了极致&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="err">抛弃了所有的分支预测&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="err">只是控制逻辑而不完成计算&lt;/span>&lt;span class="p">.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">对于上面的程序有垂直和水平两种分割方式:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">-&lt;/span> &lt;span class="err">垂直:&lt;/span> &lt;span class="err">每个线程处理一个循环&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">-&lt;/span> &lt;span class="err">水平:&lt;/span> &lt;span class="err">同时处理多个循环,&lt;/span> &lt;span class="err">如先同时进行所有的第一个乘法&lt;/span>&lt;span class="na">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">## SIMD Single Instruction Multiple Data
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="err">假设我正在执行的多次操作之间没有依赖关系,都能够并行运行.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">a&lt;/span> &lt;span class="no">single&lt;/span> &lt;span class="no">instruction&lt;/span> &lt;span class="no">is&lt;/span> &lt;span class="no">applied&lt;/span> &lt;span class="no">to&lt;/span> &lt;span class="no">multiple&lt;/span> &lt;span class="no">data&lt;/span> &lt;span class="no">elements&lt;/span> &lt;span class="no">simultaneously.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">即:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">同时对8个数值和另一个地方的8个数值取出并进行加法.&lt;/span> &lt;span class="err">有时这些数值可以被称作向量.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">使用&lt;/span>&lt;span class="nf">AVX&lt;/span> &lt;span class="no">intrinsics的向量化程序&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">```&lt;/span>&lt;span class="nf">c&lt;/span>&lt;span class="err">++&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">void&lt;/span> &lt;span class="no">sinx&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">int&lt;/span> &lt;span class="no">N&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">int&lt;/span> &lt;span class="no">terms&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">float&lt;/span>&lt;span class="p">*&lt;/span> &lt;span class="no">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">float&lt;/span>&lt;span class="p">*&lt;/span> &lt;span class="no">result&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="err">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="no">int&lt;/span> &lt;span class="no">i&lt;/span> &lt;span class="err">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="c1">; i &amp;lt; N; i+=8) {
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">__m256&lt;/span> &lt;span class="no">origx&lt;/span> &lt;span class="err">=&lt;/span> &lt;span class="no">_mm256_load_ps&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="err">&amp;amp;&lt;/span>&lt;span class="no">x&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="no">i&lt;/span>&lt;span class="p">])&lt;/span>&lt;span class="c1">;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">__m256&lt;/span> &lt;span class="no">value&lt;/span> &lt;span class="err">=&lt;/span> &lt;span class="no">origx&lt;/span>&lt;span class="c1">;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">__m256&lt;/span> &lt;span class="no">number&lt;/span> &lt;span class="err">=&lt;/span> &lt;span class="no">_mm256_mul_ps&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">origx&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">_mm256_mul_ps&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">origx&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">origx&lt;/span>&lt;span class="p">))&lt;/span>&lt;span class="c1">;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">float&lt;/span> &lt;span class="no">sign&lt;/span> &lt;span class="err">=&lt;/span> &lt;span class="p">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="c1">;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">__m256&lt;/span> &lt;span class="no">denom&lt;/span> &lt;span class="err">=&lt;/span> &lt;span class="no">_mm256_set1_ps&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">6&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="c1">;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="no">int&lt;/span> &lt;span class="no">j&lt;/span> &lt;span class="err">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="c1">; j &amp;lt; terms; j++) {
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//value += sign * number / denom;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">__m256&lt;/span> &lt;span class="no">tmp&lt;/span> &lt;span class="err">=&lt;/span> &lt;span class="no">_mm256_div_ps&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">number&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">denom&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="c1">;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">tmp&lt;/span> &lt;span class="err">=&lt;/span> &lt;span class="no">_mm256_mul_ps&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">tmp&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">_mm256_set1_ps&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">sign&lt;/span>&lt;span class="p">))&lt;/span>&lt;span class="c1">;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">value&lt;/span> &lt;span class="err">=&lt;/span> &lt;span class="no">_mm256_add_ps&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">value&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">tmp&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="c1">;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">sign&lt;/span> &lt;span class="p">*&lt;/span>&lt;span class="err">=&lt;/span> &lt;span class="p">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="c1">;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//denom *= (2*j+3)*(2*j+2);
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">denom&lt;/span> &lt;span class="err">=&lt;/span> &lt;span class="no">_mm256_mul_ps&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">denom&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">_mm256_set1_ps&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">*&lt;/span>&lt;span class="no">j&lt;/span>&lt;span class="err">+&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">)*(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">*&lt;/span>&lt;span class="no">j&lt;/span>&lt;span class="err">+&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">)))&lt;/span>&lt;span class="c1">;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//number *= x[i] * x[i];
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">number&lt;/span> &lt;span class="err">=&lt;/span> &lt;span class="no">_mm256_mul_ps&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">number&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">_mm256_mul_ps&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">origx&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">origx&lt;/span>&lt;span class="p">))&lt;/span>&lt;span class="c1">;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="err">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">_mm256_store_ps&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="err">&amp;amp;&lt;/span>&lt;span class="no">result&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="no">i&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="no">value&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="c1">;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//result[i] = value;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="err">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>编译成汇编后大致如下:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-asm" data-lang="asm">&lt;span class="line">&lt;span class="cl">&lt;span class="nf">vloadps&lt;/span> &lt;span class="no">xmm0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">addr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="no">r1&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">vmulps&lt;/span> &lt;span class="no">xmm1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">xmm0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">xmm0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">vmulps&lt;/span> &lt;span class="no">xmm2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">xmm1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">xmm0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="no">vstoreps&lt;/span> &lt;span class="no">addr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="no">xmm2&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="no">xmm0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>AVX代表高级矢量扩展, 256代表每次可以处理256位的数据, 也就是8个float.
有多个版本:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-md" data-lang="md">&lt;span class="line">&lt;span class="cl">AVX: 128位 = 4 &lt;span class="ge">* 4 *&lt;/span> 8 = 32字节
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">AVX2: 256位 = 8 &lt;span class="ge">* 4 *&lt;/span> 8 = 32字节
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">AVX512: 512位 = 16 &lt;span class="ge">* 4 *&lt;/span> 8 = 64字节
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>XMM寄存器是特殊的32字节 256位寄存器, 有16个, 从xmm0到xmm15. 用于支持vectorized SIMD指令.&lt;/p>
&lt;p>那么有没有办法让编译器自动将代码向量化呢?&lt;/p>
&lt;ul>
&lt;li>有,GCC的-O3选项可以自动向量化代码.&lt;/li>
&lt;/ul>
&lt;p>但只有非常结构化,精心编写的代码才能被自动向量化.&lt;/p>
&lt;h3 id="条件">条件&lt;/h3>
&lt;p>如果加入条件判断,如何向量化?&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c++" data-lang="c++">&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;span class="k">else&lt;/span>&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>SIMD可能的做法:
设置一个掩码, 用于标记哪些元素需要执行哪些不需要执行.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-md" data-lang="md">&lt;span class="line">&lt;span class="cl">x &lt;span class="p">&amp;lt;&lt;/span> &lt;span class="nt">0:&lt;/span> &lt;span class="na">1&lt;/span> &lt;span class="na">1&lt;/span> &lt;span class="na">0&lt;/span> &lt;span class="na">0&lt;/span> &lt;span class="na">1&lt;/span> &lt;span class="na">0&lt;/span> &lt;span class="na">0&lt;/span> &lt;span class="na">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">x &lt;/span>&lt;span class="o">=&lt;/span> &lt;span class="s">-x:&lt;/span> &lt;span class="na">1&lt;/span> &lt;span class="na">1&lt;/span> &lt;span class="na">0&lt;/span> &lt;span class="na">0&lt;/span> &lt;span class="na">1&lt;/span> &lt;span class="na">0&lt;/span> &lt;span class="na">0&lt;/span> &lt;span class="na">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">翻转:&lt;/span> &lt;span class="na">0&lt;/span> &lt;span class="na">0&lt;/span> &lt;span class="na">1&lt;/span> &lt;span class="na">1&lt;/span> &lt;span class="na">0&lt;/span> &lt;span class="na">1&lt;/span> &lt;span class="na">1&lt;/span> &lt;span class="na">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">x &lt;/span>&lt;span class="o">=&lt;/span> &lt;span class="s">x:&lt;/span> &lt;span class="na">0&lt;/span> &lt;span class="na">0&lt;/span> &lt;span class="na">1&lt;/span> &lt;span class="na">1&lt;/span> &lt;span class="na">0&lt;/span> &lt;span class="na">1&lt;/span> &lt;span class="na">1&lt;/span> &lt;span class="na">1&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>但大多时候只保留了一半的效率,因为每次有可能只有一半的数据需要执行.
不过这很好的保证了一致性,因为分支结束后又回到了同一个执行路径.
即保持一致性,远离分歧.&lt;/p>
&lt;p>coherent execution: 所有的线程都执行相同的指令.&lt;/p>
&lt;p>divergent: a lack of instruction stream coherence.&lt;/p>
&lt;p>对于生成这些矢量操作,要么有聪明的编译器,要么就是有耐心的程序员.&lt;/p>
&lt;h3 id="simd-execution-on-many-modern-gpus">SIMD execution on many modern GPUs&lt;/h3>
&lt;p>SPMD: Single Program Multiple Data&lt;/p>
&lt;p>GPU给的不是SIMD,而是SPMD. 单个程序,多个数据. 意味着程序的不同部分可以执行不同的指令.&lt;/p>
&lt;p>在这之下,还是用SIMD来实现大部分逻辑,采用异构的方式来实现并行.&lt;/p>
&lt;p>但有n个加法, 即两个包含n个值的向量相加.
实际上不是所有单位都在等待计算.而是会先计算出如何分配到块中,底层块的实际大小是32, 32values而不是32byte. 这个被称作SIMD宽度,一般是8-32.&lt;/p>
&lt;h3 id="gpu和cpu的差别">GPU和CPU的差别&lt;/h3>
&lt;p>CPU i7:&lt;/p>
&lt;ul>
&lt;li>4核&lt;/li>
&lt;li>8 SIMD ALUs per core&lt;/li>
&lt;li>每秒大概几千次浮点运算&lt;/li>
&lt;/ul>
&lt;p>GPU: RTX 1080&lt;/p>
&lt;ul>
&lt;li>20 cores&lt;/li>
&lt;li>32 SIMD ALUs per core&lt;/li>
&lt;li>每秒大概8m次浮点运算&lt;/li>
&lt;/ul>
&lt;p>GPU的核心摒弃了分支预测等只用做control,因此可以有更多的ALU.填充进来.&lt;/p>
&lt;p>大概是80:1的原始计算能力差异.&lt;/p>
&lt;h3 id="总结">总结&lt;/h3>
&lt;p>三种方法实现并行计算&lt;/p>
&lt;p>多核CPU:&lt;/p>
&lt;ul>
&lt;li>线程级实现并行&lt;/li>
&lt;/ul>
&lt;p>SIMD:&lt;/p>
&lt;ul>
&lt;li>指令级并行&lt;/li>
&lt;li>通过向量化指令实现&lt;/li>
&lt;li>但依赖于事先知道执行的指令优先级顺序&lt;/li>
&lt;/ul>
&lt;p>Superscaler:
exploit ILP within an instruction stream&lt;/p>
&lt;h2 id="paart2-accessing-memory">paart2 accessing memory&lt;/h2>
&lt;p>Memory latency: 从CPU到内存的时间&lt;/p>
&lt;ul>
&lt;li>example: DRAM访问时间 100 cycles, 100ns&lt;/li>
&lt;/ul>
&lt;p>Memory bandwidth: 从内存到CPU的时间&lt;/p>
&lt;ul>
&lt;li>example: 20GB/s 其实不是很快&lt;/li>
&lt;/ul>
&lt;p>Stall: CPU等待内存的时间
当cpu试图进行读取而内存不可用时，就会停等知道内存可用.&lt;/p>
&lt;p>缓存就是为了解决Stall的问题.&lt;/p>
&lt;p>在多级缓存中,靠近核心的缓存是私有的.
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l2/img/2023-10-05-16-43-06_hu18c235196594db696f84796cb1ead687_215427_6a724ed12fad9a3240b03da2a1c0ff6b.webp 400w,
/blog/l2/img/2023-10-05-16-43-06_hu18c235196594db696f84796cb1ead687_215427_9ceee60bd8fdd3eb63114e89b322d0b0.webp 760w,
/blog/l2/img/2023-10-05-16-43-06_hu18c235196594db696f84796cb1ead687_215427_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l2/img/2023-10-05-16-43-06_hu18c235196594db696f84796cb1ead687_215427_6a724ed12fad9a3240b03da2a1c0ff6b.webp"
width="760"
height="424"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
这样可以通过写入读出L2缓存的数据来实现通讯,而不需要经过DRAM.&lt;/p>
&lt;p>缓存对延迟和带宽都有帮助.&lt;/p>
&lt;h3 id="prefecthing-reduces-stalls">Prefecthing reduces stalls&lt;/h3>
&lt;p>硬件通常通过预取来&lt;strong>减少延迟&lt;/strong>.
即预测下一次可能会访问的数据,并将其提前读取到缓存中.
不过可能会造成信息泄露&lt;/p>
&lt;p>使用预取的效果:
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l2/img/2023-10-05-16-47-27_hu9e755d86af4542e2c891b6ef523b2239_504134_f5783346b6eafcc279c7b7eadc75a246.webp 400w,
/blog/l2/img/2023-10-05-16-47-27_hu9e755d86af4542e2c891b6ef523b2239_504134_e1a197eee3ba4938657b7931766d1231.webp 760w,
/blog/l2/img/2023-10-05-16-47-27_hu9e755d86af4542e2c891b6ef523b2239_504134_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l2/img/2023-10-05-16-47-27_hu9e755d86af4542e2c891b6ef523b2239_504134_f5783346b6eafcc279c7b7eadc75a246.webp"
width="760"
height="556"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="multi-threading-reduces-stalls">Multi-threading reduces stalls&lt;/h3>
&lt;p>让多个线程交替进行, 如asst1/prog2的实现&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l2/img/2023-10-05-16-53-05_hu018724600a89671805482e5e14021481_143403_2c3960edeb7b7146e69b7397f368eed9.webp 400w,
/blog/l2/img/2023-10-05-16-53-05_hu018724600a89671805482e5e14021481_143403_ae5cc04b79da4d5c206e7798358b5dff.webp 760w,
/blog/l2/img/2023-10-05-16-53-05_hu018724600a89671805482e5e14021481_143403_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l2/img/2023-10-05-16-53-05_hu018724600a89671805482e5e14021481_143403_2c3960edeb7b7146e69b7397f368eed9.webp"
width="760"
height="284"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
这也是超线程的实现,在一个核心中多路复用多个指令流.
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l2/img/2023-10-05-16-52-35_hu6c2acc8845dfbfbe4383d0d236adfe16_560224_3bc248fc2800b46d51b509a0fd52a08a.webp 400w,
/blog/l2/img/2023-10-05-16-52-35_hu6c2acc8845dfbfbe4383d0d236adfe16_560224_f27aeda0e160298c73ea9b46e9eef185.webp 760w,
/blog/l2/img/2023-10-05-16-52-35_hu6c2acc8845dfbfbe4383d0d236adfe16_560224_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l2/img/2023-10-05-16-52-35_hu6c2acc8845dfbfbe4383d0d236adfe16_560224_3bc248fc2800b46d51b509a0fd52a08a.webp"
width="760"
height="563"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>对于CPU&amp;amp;GPU, 谁来组织线程是不同的做法.(操作系统 or 硬件)&lt;/p>
&lt;p>通常情况下内存要比其他因素更加限制速度&lt;/p></description></item><item><title>L4 Parallel Programing basics</title><link>https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/</link><pubDate>Fri, 01 Mar 2024 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/</guid><description>&lt;p>主要用三种方式实现并行程序(没有进行真正的优化)&lt;/p>
&lt;p>例子 n-body simulation&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-19-08-15_hue48a4921cc49cf57e882ed55cfa33ec8_653223_300d6e55ae7158eb7f77967a00820153.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-19-08-15_hue48a4921cc49cf57e882ed55cfa33ec8_653223_6c1a606d891b45c87635608e28e74a79.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-19-08-15_hue48a4921cc49cf57e882ed55cfa33ec8_653223_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-19-08-15_hue48a4921cc49cf57e882ed55cfa33ec8_653223_300d6e55ae7158eb7f77967a00820153.webp"
width="760"
height="566"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>创建并行程序的过程&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-19-12-34_hu8ca133d8fdd22bace72d28bc0e9f928f_717995_d7d48a19c6b8d98d4bb025be7407106a.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-19-12-34_hu8ca133d8fdd22bace72d28bc0e9f928f_717995_becf2ea517713a91c8190995e7cc73a3.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-19-12-34_hu8ca133d8fdd22bace72d28bc0e9f928f_717995_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-19-12-34_hu8ca133d8fdd22bace72d28bc0e9f928f_717995_d7d48a19c6b8d98d4bb025be7407106a.webp"
width="760"
height="569"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="1-decomposition">1. Decomposition&lt;/h3>
&lt;p>主要思想: 创造至少足够的任务让所有的处理单元都有事情做&lt;/p>
&lt;p>Amdahl&amp;rsquo;s Law: 串行部分的比例越大, 并行程序的加速比就越小,因为增加处理单元的数量并不能减少串行部分的时间&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-19-17-14_hu6b8d57c08ba6ce2d6ea30fe8baefa3d4_659251_0e9ae484b47d7b98ce1bcb4d1368d085.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-19-17-14_hu6b8d57c08ba6ce2d6ea30fe8baefa3d4_659251_f894a7fc4c613f87e7daa182688bfbb2.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-19-17-14_hu6b8d57c08ba6ce2d6ea30fe8baefa3d4_659251_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-19-17-14_hu6b8d57c08ba6ce2d6ea30fe8baefa3d4_659251_0e9ae484b47d7b98ce1bcb4d1368d085.webp"
width="760"
height="570"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-19-25-06_hu46e8e5fd6fd42d95218680164502ccdb_474311_26ca6d976940fa163bdb00a72d487ab2.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-19-25-06_hu46e8e5fd6fd42d95218680164502ccdb_474311_7d794c4862846294ba020113fcbd3a99.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-19-25-06_hu46e8e5fd6fd42d95218680164502ccdb_474311_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-19-25-06_hu46e8e5fd6fd42d95218680164502ccdb_474311_26ca6d976940fa163bdb00a72d487ab2.webp"
width="760"
height="562"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>分解的任务更多是程序员的工作, 编译器还无法很好的帮助我们&lt;/p>
&lt;h3 id="2assignment">2.Assignment&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-19-27-56_huac3192b45d26432b1fbf3a13b42c3714_518393_f4b6891d6e8836e5b078c7b6aec5aadd.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-19-27-56_huac3192b45d26432b1fbf3a13b42c3714_518393_65d2c13a7bb828fa5c068bca90139c7a.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-19-27-56_huac3192b45d26432b1fbf3a13b42c3714_518393_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-19-27-56_huac3192b45d26432b1fbf3a13b42c3714_518393_f4b6891d6e8836e5b078c7b6aec5aadd.webp"
width="760"
height="568"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>需要考虑让每个处理单元尽可能减少沟通.&lt;/p>
&lt;p>有一种方法是随机分配,但会最大化沟通
还有一个极端是全部由一个处理单元完成,但是这样就没有并行了&lt;/p>
&lt;p>这是另一个挑战&lt;/p>
&lt;p>分配可以静态也可以动态发生&lt;/p>
&lt;p>静态: 在程序开始时就确定好.
动态: 在程序运行时分配
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-19-32-26_hue221ecbb5d082188d974279744465ae6_739363_469ecdbd4a9b8454fd47173ba40269f8.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-19-32-26_hue221ecbb5d082188d974279744465ae6_739363_b3390ceebc8efeab9b8139e9845c32b3.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-19-32-26_hue221ecbb5d082188d974279744465ae6_739363_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-19-32-26_hue221ecbb5d082188d974279744465ae6_739363_469ecdbd4a9b8454fd47173ba40269f8.webp"
width="760"
height="562"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>静态分配的问题:&lt;/p>
&lt;ul>
&lt;li>无法适应不同的输入(如:工作量不均匀)&lt;/li>
&lt;li>无法适应不同的处理单元数量&lt;/li>
&lt;/ul>
&lt;p>动态分配: 通过消息传递来实现, 每个处理单元都有一个队列, 用来存放需要处理的任务(tasks). 当一个处理单元完成了一个任务, 就从队列中取出一个任务来处理
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-19-41-07_hu6c85e4ef3ddfa256fd5b280b3f1947d5_610384_1ec3e9269d1b9769ff7549ca3e7ff991.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-19-41-07_hu6c85e4ef3ddfa256fd5b280b3f1947d5_610384_435b8b910d0cf444fe612cbec0958114.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-19-41-07_hu6c85e4ef3ddfa256fd5b280b3f1947d5_610384_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-19-41-07_hu6c85e4ef3ddfa256fd5b280b3f1947d5_610384_1ec3e9269d1b9769ff7549ca3e7ff991.webp"
width="760"
height="526"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>缺点:
队列需要同步, 会有额外的开销&lt;/p>
&lt;h3 id="3-orchestration-编排阶段">3. Orchestration 编排阶段&lt;/h3>
&lt;p>编排的目标是:
减少沟通和同步的成本, preserve &lt;strong>locality&lt;/strong> of data reference, reduce overhead.&lt;/p>
&lt;h3 id="4mapping">4.mapping&lt;/h3>
&lt;p>这是程序员最不需要关心的, 交给编译器就好了
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-19-48-55_hu7d458683065d371a53e4f3bbced0dc5b_674886_dd70cb98c5d235d4af085a8b85d717eb.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-19-48-55_hu7d458683065d371a53e4f3bbced0dc5b_674886_d0427d53091c240e55a9032cbafa5c74.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-19-48-55_hu7d458683065d371a53e4f3bbced0dc5b_674886_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-19-48-55_hu7d458683065d371a53e4f3bbced0dc5b_674886_dd70cb98c5d235d4af085a8b85d717eb.webp"
width="760"
height="574"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h2 id="example">example&lt;/h2>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-20-28-08_hu4bc1ad631611432311f7608937c4d974_532911_378f26ab2469867248ef1ea890a944f5.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-28-08_hu4bc1ad631611432311f7608937c4d974_532911_2b961a92c582af81689691d4ee62333d.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-28-08_hu4bc1ad631611432311f7608937c4d974_532911_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-20-28-08_hu4bc1ad631611432311f7608937c4d974_532911_378f26ab2469867248ef1ea890a944f5.webp"
width="760"
height="568"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>顺序程序:
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-20-29-38_huef0e497a0a3be02bd46e8912ca469521_552238_b0a20d7e5de93d8bfdaa4a330e9fd80e.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-29-38_huef0e497a0a3be02bd46e8912ca469521_552238_eb0f8d018192eebde00a35c3f9fa78f1.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-29-38_huef0e497a0a3be02bd46e8912ca469521_552238_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-20-29-38_huef0e497a0a3be02bd46e8912ca469521_552238_b0a20d7e5de93d8bfdaa4a330e9fd80e.webp"
width="760"
height="579"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>那么如何并行执行呢?&lt;/p>
&lt;h3 id="step1-identify-dependenciesproblem-decomposition">Step1: identify dependencies(problem decomposition)&lt;/h3>
&lt;p>因为会迭代很多次,所以会引起不同迭代次数的数据竞争.&lt;/p>
&lt;p>有一种划分方法是沿着对角线:
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-20-32-11_hua770f7c3378cf5e52779686442875f74_850357_eac19ef97378e0332e37b6120c1b7460.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-32-11_hua770f7c3378cf5e52779686442875f74_850357_11f821c7ea9de7edb4def82251e9efdf.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-32-11_hua770f7c3378cf5e52779686442875f74_850357_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-20-32-11_hua770f7c3378cf5e52779686442875f74_850357_eac19ef97378e0332e37b6120c1b7460.webp"
width="760"
height="617"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>不足之处是:&lt;/p>
&lt;ul>
&lt;li>有些对角线很短, 负载不均衡&lt;/li>
&lt;li>需要额外的计算(对角线下标)&lt;/li>
&lt;/ul>
&lt;p>另一种方法是滚动数组:
用两个数组, 一个用来存放当前迭代的结果, 一个用来存放上一次迭代的结果&lt;/p>
&lt;p>这样计算时不会有数据竞争.&lt;/p>
&lt;p>但很多人不希望有额外的内存开销.&lt;/p>
&lt;p>事实上使用的是红黑排序.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-20-37-00_hub6902c6359b72f71195b1f839828355e_586963_5d8ef9fd25d94e005487943ac9894f81.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-37-00_hub6902c6359b72f71195b1f839828355e_586963_34f7f339aea72b213c8a668102485760.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-37-00_hub6902c6359b72f71195b1f839828355e_586963_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-20-37-00_hub6902c6359b72f71195b1f839828355e_586963_5d8ef9fd25d94e005487943ac9894f81.webp"
width="760"
height="566"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>每次迭代只更新红色的部分, 然后再翻转.
这样就不需要复制数组了.&lt;/p>
&lt;h3 id="step2-assign-tasks">Step2: assign tasks&lt;/h3>
&lt;p>我们不把每一个元素作为一个任务,而是把每一行作为一个任务.&lt;/p>
&lt;p>同时:
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-20-41-36_hubdceb7f300441a8766ba1431277c7cc4_755276_711347c7e817fe638550eebcc34b2faf.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-41-36_hubdceb7f300441a8766ba1431277c7cc4_755276_accd9f6717d58f6ab57f5c5748534b83.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-41-36_hubdceb7f300441a8766ba1431277c7cc4_755276_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-20-41-36_hubdceb7f300441a8766ba1431277c7cc4_755276_711347c7e817fe638550eebcc34b2faf.webp"
width="760"
height="569"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>红黑排序有一个同步的步骤: 必须等待所有的红色部分都计算完毕, 才能开始计算黑色部分.&lt;/p>
&lt;p>为了最小化沟通, 相邻行作为捆包是更好的选择, 这样只在更新边界时需要沟通.&lt;/p>
&lt;h3 id="三种实现方法">三种实现方法&lt;/h3>
&lt;h4 id="data-parallel-expression-of-solver">Data-parallel expression of solver&lt;/h4>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-20-45-17_hu05b94560b10f4189a08c6cb5f48bfd71_676413_6071d1eabf8eb456c38c7ab568c29c85.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-45-17_hu05b94560b10f4189a08c6cb5f48bfd71_676413_bd6ad13f2f63aba99999c5aa7836e481.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-45-17_hu05b94560b10f4189a08c6cb5f48bfd71_676413_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-20-45-17_hu05b94560b10f4189a08c6cb5f48bfd71_676413_6071d1eabf8eb456c38c7ab568c29c85.webp"
width="760"
height="568"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>这个的特点是系统做了很多工作, 程序只需要指定哪里需要并行.&lt;/p>
&lt;h4 id="shared-address-space-code">shared-address-space code&lt;/h4>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-20-49-07_hud4acc75f44d57621c38bcef37ecf69ad_501385_5ac6b61cbfefc82f7f4c733828aa1374.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-49-07_hud4acc75f44d57621c38bcef37ecf69ad_501385_4fee6b612cf87991254c9c57b904ce52.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-49-07_hud4acc75f44d57621c38bcef37ecf69ad_501385_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-20-49-07_hud4acc75f44d57621c38bcef37ecf69ad_501385_5ac6b61cbfefc82f7f4c733828aa1374.webp"
width="760"
height="576"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>version1 :
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-20-49-41_hu397a5c725eab7f2ec6ba703b751c7761_745157_533e533992488749606b9438d64b007c.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-49-41_hu397a5c725eab7f2ec6ba703b751c7761_745157_0b75e1a598b6dc90f1d0988f46b9c18f.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-49-41_hu397a5c725eab7f2ec6ba703b751c7761_745157_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-20-49-41_hu397a5c725eab7f2ec6ba703b751c7761_745157_533e533992488749606b9438d64b007c.webp"
width="760"
height="577"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>但是有个锁会使得程序变慢
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-20-51-52_hue0bce16ea2bc879cd28793bae80b6fdb_858650_008576a8562e19a9b68a706920f134f5.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-51-52_hue0bce16ea2bc879cd28793bae80b6fdb_858650_162d8768bd53d226b92aa1e3c8b841ae.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-51-52_hue0bce16ea2bc879cd28793bae80b6fdb_858650_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-20-51-52_hue0bce16ea2bc879cd28793bae80b6fdb_858650_008576a8562e19a9b68a706920f134f5.webp"
width="760"
height="564"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>version2:
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-20-53-12_hu36b9d35db431827e24b4b081d064641f_693240_d83b71c546167384983d9a1ef9afcab6.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-53-12_hu36b9d35db431827e24b4b081d064641f_693240_0b8c610136d7c28529574edd2eba5bbd.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-53-12_hu36b9d35db431827e24b4b081d064641f_693240_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-20-53-12_hu36b9d35db431827e24b4b081d064641f_693240_d83b71c546167384983d9a1ef9afcab6.webp"
width="760"
height="574"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>有三个barrier来保证红黑顺序
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-20-54-07_hudaa8f328867329c6ba35530421eebfde_512012_66c627513b8313419cea65ed7635bd4f.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-54-07_hudaa8f328867329c6ba35530421eebfde_512012_b8e8413bb73b3bc460895c08c728e194.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-54-07_hudaa8f328867329c6ba35530421eebfde_512012_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-20-54-07_hudaa8f328867329c6ba35530421eebfde_512012_66c627513b8313419cea65ed7635bd4f.webp"
width="760"
height="545"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
为什么是三个呢?&lt;/p>
&lt;p>每一部分都要被分割&lt;/p>
&lt;p>最后一个是为了diff的分割
第一个是为了myDiff的分割
第二个是为了diff的分割&lt;/p>
&lt;p>所以可以使用diff数组&lt;/p>
&lt;p>version3:
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-20-57-40_hu0d1996844693b134151c8d82ee5425bd_617614_38e643162361d034d8e8ed437c443f84.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-57-40_hu0d1996844693b134151c8d82ee5425bd_617614_5ce102c5ce45f0dbc1dac41b6096bf7b.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-57-40_hu0d1996844693b134151c8d82ee5425bd_617614_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-20-57-40_hu0d1996844693b134151c8d82ee5425bd_617614_38e643162361d034d8e8ed437c443f84.webp"
width="760"
height="566"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>barrier的问题:
barrier还是有点笨重, 这会强制所有线程到一个起跑线
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-20-59-07_huaecac9eeb7b6b74f7510d557e9b6e26a_572209_41fd0f188cd297c382afe2bc81211c7e.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-59-07_huaecac9eeb7b6b74f7510d557e9b6e26a_572209_8f25e59fa55106ba0b7456f62971f92b.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-59-07_huaecac9eeb7b6b74f7510d557e9b6e26a_572209_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-20-59-07_huaecac9eeb7b6b74f7510d557e9b6e26a_572209_41fd0f188cd297c382afe2bc81211c7e.webp"
width="760"
height="584"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>但如果有更精确的信息, 只需要等待依赖的线程就好了&lt;/p>
&lt;h4 id="message-passing-code">message-passing code&lt;/h4>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-21-00-57_hue70b1faf829cca87f081e5bc424c7628_594886_3dcdaa90f3dc0b6edb968742fde6788b.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-21-00-57_hue70b1faf829cca87f081e5bc424c7628_594886_5f9edad42ee570536dbb24cbbf0e2313.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-21-00-57_hue70b1faf829cca87f081e5bc424c7628_594886_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-21-00-57_hue70b1faf829cca87f081e5bc424c7628_594886_3dcdaa90f3dc0b6edb968742fde6788b.webp"
width="760"
height="574"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>需要有额外的划分,来存储相邻处理器的数据&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-21-02-04_hu4c6d7b1bda54071ab3467deea4424d30_799693_194c426e9f4bd30f2c0f56092d87ed1d.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-21-02-04_hu4c6d7b1bda54071ab3467deea4424d30_799693_201679da15e21745058c91d98624422d.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-21-02-04_hu4c6d7b1bda54071ab3467deea4424d30_799693_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-21-02-04_hu4c6d7b1bda54071ab3467deea4424d30_799693_194c426e9f4bd30f2c0f56092d87ed1d.webp"
width="760"
height="579"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>同时,在最后计算diff时,需要等待所有的处理器都计算完毕.
这里选中了一个processor zero来计算diff, 其他的处理器都发送自己的diff给它.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-21-04-12_hu40d62451cdfd210f1a8f99acfc52e78e_920652_34bd425bc4ebe88a31f4957864cd7fe4.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-21-04-12_hu40d62451cdfd210f1a8f99acfc52e78e_920652_a4c392a2099e53a7ae0b5f3bc237eb21.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-21-04-12_hu40d62451cdfd210f1a8f99acfc52e78e_920652_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-21-04-12_hu40d62451cdfd210f1a8f99acfc52e78e_920652_34bd425bc4ebe88a31f4957864cd7fe4.webp"
width="760"
height="562"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>但沟通时有可能发生死锁. 因为每个处理器都在等待其他处理器的消息, 但是自己的消息又没有发送出去.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-21-06-02_huc087edeeaded9dcd70e781a8caf24d42_565877_7664ca781070f75ef349661a85c63958.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-21-06-02_huc087edeeaded9dcd70e781a8caf24d42_565877_68b90074dc227e55c1a49326a35e5e23.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-21-06-02_huc087edeeaded9dcd70e781a8caf24d42_565877_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-21-06-02_huc087edeeaded9dcd70e781a8caf24d42_565877_7664ca781070f75ef349661a85c63958.webp"
width="760"
height="574"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>所以需要分奇偶来发送&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-21-07-24_hu36e0868a51b260305696d6733ba21ec5_677923_a6befff3da24916d55d41b8bb71c4d75.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-21-07-24_hu36e0868a51b260305696d6733ba21ec5_677923_1053a357a9c5aa6773e8e220d458f49a.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-21-07-24_hu36e0868a51b260305696d6733ba21ec5_677923_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-21-07-24_hu36e0868a51b260305696d6733ba21ec5_677923_a6befff3da24916d55d41b8bb71c4d75.webp"
width="760"
height="590"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p></description></item><item><title>L5 Work distribution and scheduling</title><link>https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/</link><pubDate>Fri, 01 Mar 2024 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/</guid><description>&lt;h2 id="三种分配策略的总结">三种分配策略的总结&lt;/h2>
&lt;h3 id="静态分配">静态分配&lt;/h3>
&lt;p>优点:&lt;/p>
&lt;ul>
&lt;li>几乎没有运行时的开销(关于分配)&lt;/li>
&lt;/ul>
&lt;p>缺点:&lt;/p>
&lt;ul>
&lt;li>不总是均匀的分配任务&lt;/li>
&lt;/ul>
&lt;p>什么时候使用:&lt;/p>
&lt;ul>
&lt;li>(最简单的例子) 当知道每个任务的工作量相当的时候&lt;/li>
&lt;li>当每个任务的工作量是可预测的,但不一定相等的时候&lt;/li>
&lt;/ul>
&lt;p>半静态分配&lt;/p>
&lt;ul>
&lt;li>场景: 当工作量会随时间发生改变,当变化比较慢时.(任务量不可预测)&lt;/li>
&lt;li>做法: 定期的重新分配任务
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-15-17-17-21_huc4d2be410d647016a3206e85b20b8291_1107621_5880584d2300544cd55841de43263248.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-15-17-17-21_huc4d2be410d647016a3206e85b20b8291_1107621_68fb3d31df2ca327d35ff36a5b6491e8.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-15-17-17-21_huc4d2be410d647016a3206e85b20b8291_1107621_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-15-17-17-21_huc4d2be410d647016a3206e85b20b8291_1107621_5880584d2300544cd55841de43263248.webp"
width="760"
height="574"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/li>
&lt;/ul>
&lt;h3 id="动态分配">动态分配&lt;/h3>
&lt;p>场景: 当每个任务的工作量或者任务的数量是不可预测的时候&lt;/p>
&lt;p>每个计算单元都要去获取任务&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-15-17-25-21_hua6a3c077cced5abdb9b7bbaa576a7ec8_874748_13253e7a7b20fe3aefc71947e01ae37c.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-15-17-25-21_hua6a3c077cced5abdb9b7bbaa576a7ec8_874748_7546cdc1ebd3007df3f8be6534e94e4f.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-15-17-25-21_hua6a3c077cced5abdb9b7bbaa576a7ec8_874748_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-15-17-25-21_hua6a3c077cced5abdb9b7bbaa576a7ec8_874748_13253e7a7b20fe3aefc71947e01ae37c.webp"
width="760"
height="552"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>但这样的实现, 每次的任务可能会很少,
会使得更多的开销在争夺锁(获取任务的锁)上面.&lt;/p>
&lt;p>有一个办法是一次性计算更多的任务.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-15-17-26-57_huf835b5eac9d37b49ce3c30a88aace822_752046_764dee7c21fd261f1ea42dd03deaac94.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-15-17-26-57_huf835b5eac9d37b49ce3c30a88aace822_752046_d2c2f29cd40410d16e80729d86a1a85a.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-15-17-26-57_huf835b5eac9d37b49ce3c30a88aace822_752046_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-15-17-26-57_huf835b5eac9d37b49ce3c30a88aace822_752046_764dee7c21fd261f1ea42dd03deaac94.webp"
width="760"
height="535"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>但分配更多的任务可能会导致负载不平衡.&lt;/p>
&lt;p>因此需要在分配任务数量上要找一个平衡, 不花费过多的时间在争夺锁上, 也不会导致负载不平衡.&lt;/p>
&lt;p>&lt;strong>Schedule long tasks first&lt;/strong>
但如果有一个大任务在最后，将出现如下情况：
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-08-53-07_hu91d4bd1fcd6b2d3a4a21166e27be8ac1_532596_a319b7fbc769ba12a45b529df1c65503.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-08-53-07_hu91d4bd1fcd6b2d3a4a21166e27be8ac1_532596_dbd94cdf2d21f71697636c8d4408b78a.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-08-53-07_hu91d4bd1fcd6b2d3a4a21166e27be8ac1_532596_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-16-08-53-07_hu91d4bd1fcd6b2d3a4a21166e27be8ac1_532596_a319b7fbc769ba12a45b529df1c65503.webp"
width="760"
height="567"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>因此，如果知道有一个大任务，可以提前处理，而不是放到最后一个.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-08-56-01_hubaef0c3f89c826d5b1d5dd6890516517_550046_ac355852c6e4b1b13a70e8840c1e0592.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-08-56-01_hubaef0c3f89c826d5b1d5dd6890516517_550046_ec03d531275ed3b43bc45e5ddf89fe21.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-08-56-01_hubaef0c3f89c826d5b1d5dd6890516517_550046_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-16-08-56-01_hubaef0c3f89c826d5b1d5dd6890516517_550046_ac355852c6e4b1b13a70e8840c1e0592.webp"
width="760"
height="566"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h4 id="work-stealing">Work stealing&lt;/h4>
&lt;p>当一个计算单元没有任务的时候, 从其他计算单元那里偷取任务.&lt;/p>
&lt;p>实现的一些问题:&lt;/p>
&lt;p>1.从哪个线程开始偷取任务呢?
有随机的, 也有从最后一个开始偷取的.&lt;/p>
&lt;p>2.应该偷取多少任务呢?
应该偷取尽可能多一些,这样可以减少偷取任务的次数.&lt;/p>
&lt;p>3.怎样检测一个计算单元是否有任务呢?
可能会循环遍历,&lt;/p>
&lt;p>4.使用本地队列(分布式队列)会更快(在有互斥锁的情况下)&lt;/p>
&lt;p>还有一种方式是使用特殊的数据结构来存储任务间的依赖关系, 从而可以在任务完成的时候, 自动的调度下一个任务.
缺点是额外开销
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-32-31_hu882ba279ae3cd004bfdf46a1a891da1b_594941_ef134a9b1bd58c72a760187990732c21.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-32-31_hu882ba279ae3cd004bfdf46a1a891da1b_594941_c2a7dd664f517f7aea7b9a0f8edb78b1.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-32-31_hu882ba279ae3cd004bfdf46a1a891da1b_594941_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-32-31_hu882ba279ae3cd004bfdf46a1a891da1b_594941_ef134a9b1bd58c72a760187990732c21.webp"
width="760"
height="564"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h2 id="常见的并行编程模式">常见的并行编程模式&lt;/h2>
&lt;p>循环
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-42-32_hua668693ef93510a897eb16b96202656c_595050_512dd4ec637d5bdea75de7f988ef7ae6.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-42-32_hua668693ef93510a897eb16b96202656c_595050_d23d15f8a4c93c3c3ca1dbe1f069c539.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-42-32_hua668693ef93510a897eb16b96202656c_595050_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-42-32_hua668693ef93510a897eb16b96202656c_595050_512dd4ec637d5bdea75de7f988ef7ae6.webp"
width="760"
height="571"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>创建显示线程
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-43-32_hu787070f973929fd30cb38c336bbde5e3_506261_1bd6943adefdb492091091335d4f6790.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-43-32_hu787070f973929fd30cb38c336bbde5e3_506261_fd4d25059248640d13177979d28dfbe2.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-43-32_hu787070f973929fd30cb38c336bbde5e3_506261_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-43-32_hu787070f973929fd30cb38c336bbde5e3_506261_1bd6943adefdb492091091335d4f6790.webp"
width="760"
height="575"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>递归时的并行&lt;/p>
&lt;p>递归可以编写出简单的代码, 但是递归的并行化是比较困难的.&lt;/p>
&lt;p>因为递归的并行化需要在递归的每一层都要进行并行化, 并且需要在每一层都要进行同步.&lt;/p>
&lt;p>但只要有独立的子问题, 就可以创造很多潜在的并行性.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-45-15_hue5ded81e796c68dee0b0618a6e0920dd_758799_83e684b20ad601fbffd05f681e98b070.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-45-15_hue5ded81e796c68dee0b0618a6e0920dd_758799_f656576fbd7c80b31534d8c55418bd72.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-45-15_hue5ded81e796c68dee0b0618a6e0920dd_758799_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-45-15_hue5ded81e796c68dee0b0618a6e0920dd_758799_83e684b20ad601fbffd05f681e98b070.webp"
width="760"
height="576"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h2 id="fork-join-pattern">Fork-Join pattern&lt;/h2>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-47-18_hu0f4ed4729d5da33b2852ec7891c96ad1_815835_a69bafaace4900b4f73d3c5cf6d9df30.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-47-18_hu0f4ed4729d5da33b2852ec7891c96ad1_815835_56c44942eb8197b75e566cfc48810c8c.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-47-18_hu0f4ed4729d5da33b2852ec7891c96ad1_815835_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-47-18_hu0f4ed4729d5da33b2852ec7891c96ad1_815835_a69bafaace4900b4f73d3c5cf6d9df30.webp"
width="760"
height="567"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>cilk_spawn: 会创建一个新的线程, 并且在新的线程中执行函数, 并且不会阻塞当前的线程.&lt;/p>
&lt;p>cilk_sync: 会等待所有的子线程执行完毕, 并且会阻塞当前的线程.&lt;/p>
&lt;p>每个函数的结尾隐式的调用了cilk_sync.&lt;/p>
&lt;p>example:
有一个主线程+fork的线程.
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-49-40_hu6b2a13e8c61edb007acb8c68ac6cc24d_722419_3330ee920e588071cd2cc18ca84067e5.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-49-40_hu6b2a13e8c61edb007acb8c68ac6cc24d_722419_9e9c62ec66af9b2387fa7b6c712555a7.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-49-40_hu6b2a13e8c61edb007acb8c68ac6cc24d_722419_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-49-40_hu6b2a13e8c61edb007acb8c68ac6cc24d_722419_3330ee920e588071cd2cc18ca84067e5.webp"
width="760"
height="573"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>快排的例子:
在规模较小的时候, 使用串行的快排. 这样可以减少线程的创建和销毁的开销.
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-53-13_hub5a36810580b89ed0b40df5af3f5878e_872565_77c644f2c45c972574415e31fe8b84ab.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-53-13_hub5a36810580b89ed0b40df5af3f5878e_872565_9e81ba5d6c1f18ad17e02f7b2e7199ab.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-53-13_hub5a36810580b89ed0b40df5af3f5878e_872565_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-53-13_hub5a36810580b89ed0b40df5af3f5878e_872565_77c644f2c45c972574415e31fe8b84ab.webp"
width="760"
height="560"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>不要忽略了抽象和实现的区别.&lt;/strong>
spawn不是生成一个具体的线程, 而是声明这里有一个可以并行的任务.&lt;/p>
&lt;p>任务的数量至少需要比硬件线程多,但也不能大于100倍.
8倍是一个比较好的选择.
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-01-49_huac690f525b910e3151d41f9e83b20825_725705_68336c190f129e2e078badf9a4caf4bc.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-01-49_huac690f525b910e3151d41f9e83b20825_725705_3b3a6a1947f775d0efca7c18769e335e.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-01-49_huac690f525b910e3151d41f9e83b20825_725705_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-01-49_huac690f525b910e3151d41f9e83b20825_725705_68336c190f129e2e078badf9a4caf4bc.webp"
width="760"
height="500"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h2 id="cilk的实现">Cilk的实现&lt;/h2>
&lt;p>假设我们要去实现clik_spawn 和 cilk_sync
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-04-28_huef2c8d13f3726a6bfffc8a2b7080cdd9_608019_2241e98cd40fefed3853c0a484c7dd60.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-04-28_huef2c8d13f3726a6bfffc8a2b7080cdd9_608019_cf4047faa49cace03c1989649aefba72.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-04-28_huef2c8d13f3726a6bfffc8a2b7080cdd9_608019_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-04-28_huef2c8d13f3726a6bfffc8a2b7080cdd9_608019_2241e98cd40fefed3853c0a484c7dd60.webp"
width="760"
height="566"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>线程池的实现(CILB):&lt;/p>
&lt;p>thread1 需要找到一种方法来发现有新的任务可以执行.
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-15-52_hu6062ae083bda93fd6d07b13dc77a746e_457683_347386d8c0afd36698d48e122a0c1825.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-15-52_hu6062ae083bda93fd6d07b13dc77a746e_457683_b919d83502c83d6232a5d7d03bf95db5.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-15-52_hu6062ae083bda93fd6d07b13dc77a746e_457683_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-15-52_hu6062ae083bda93fd6d07b13dc77a746e_457683_347386d8c0afd36698d48e122a0c1825.webp"
width="760"
height="593"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>所以thread 0不能简单的调用foo, 它的作用是执行foo.&lt;/p>
&lt;p>但需要在执行foo前,把特殊的东西放入工作队列中.&lt;/p>
&lt;p>此时如果另一个线程突然变得空闲, 它就可以从工作队列中获取任务.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-26-10_hu0eab66eeb24e199a2ed3f547cb3fdbbd_614646_2713f0abd710a06c367e46d38effce5b.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-26-10_hu0eab66eeb24e199a2ed3f547cb3fdbbd_614646_df1c7581b35efeb6316a776aaa66ab1c.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-26-10_hu0eab66eeb24e199a2ed3f547cb3fdbbd_614646_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-26-10_hu0eab66eeb24e199a2ed3f547cb3fdbbd_614646_2713f0abd710a06c367e46d38effce5b.webp"
width="760"
height="564"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>为什么不把foo放入队列, 直接执行bar呢?(上面是执行foo bar放入队列)&lt;/p>
&lt;p>这涉及到 continuation first(child stealing) 和 child first(continuation stealing) 的问题.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-34-20_hufa1a658f74f9b4a90809f48194848857_696273_fe7736de0427a88b81b2c7d0be7754ad.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-34-20_hufa1a658f74f9b4a90809f48194848857_696273_cb1ddf6b4689a69077e0506ca9f22a9f.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-34-20_hufa1a658f74f9b4a90809f48194848857_696273_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-34-20_hufa1a658f74f9b4a90809f48194848857_696273_fe7736de0427a88b81b2c7d0be7754ad.webp"
width="760"
height="567"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-36-22_huf67bed5371ecbc7f84d380e6087a42a4_776363_40fcf8e5060f66ffb6e517fa52d3f196.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-36-22_huf67bed5371ecbc7f84d380e6087a42a4_776363_ecff36fcf2da6712dd8f81729708df45.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-36-22_huf67bed5371ecbc7f84d380e6087a42a4_776363_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-36-22_huf67bed5371ecbc7f84d380e6087a42a4_776363_40fcf8e5060f66ffb6e517fa52d3f196.webp"
width="760"
height="570"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>continuation first会导致线程0的大量工作排队.(广度优先队列)
child first会导致其他线程把下一个任务偷走时, 会导致线程0的工作队列为空.(深度优先队列)&lt;/p>
&lt;p>实际上child first是合理的.(在递归中是最合适的)&lt;/p>
&lt;p>在递归程序中,会先将所有深度的任务放入队列中.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-48-23_hu66dd5b38ec1cb04147fc744f7a6b03af_704850_1c76cdef873f64be703a63df2b13a2f4.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-48-23_hu66dd5b38ec1cb04147fc744f7a6b03af_704850_46b3b02be3b190b15285021529e61fd4.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-48-23_hu66dd5b38ec1cb04147fc744f7a6b03af_704850_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-48-23_hu66dd5b38ec1cb04147fc744f7a6b03af_704850_1c76cdef873f64be703a63df2b13a2f4.webp"
width="760"
height="567"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>按照之前优先执行大任务的策略, 其他线程会优先从队列顶部(先入的)中偷取任务.
因为在分而治之的算法中, 大任务会被分解成小任务, 因此大任务会先被放入队列中.&lt;/p>
&lt;p>实际中使用了双端队列:&lt;/p>
&lt;ul>
&lt;li>从队列头部获取任务&lt;/li>
&lt;li>从队列尾部放入任务&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-52-42_hu052208d2ad01dc27d0149b8c74cf57ec_616787_49c97faec0e975c38ed21774d1caec1a.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-52-42_hu052208d2ad01dc27d0149b8c74cf57ec_616787_7bf3fcf44cbc5d63c27fb37d53c448c5.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-52-42_hu052208d2ad01dc27d0149b8c74cf57ec_616787_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-52-42_hu052208d2ad01dc27d0149b8c74cf57ec_616787_49c97faec0e975c38ed21774d1caec1a.webp"
width="760"
height="571"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>但之前有一个问题: 很多队列,该从哪个队列中获取任务呢?
也许是随机的. 偷取任务的时候, 不随机的更可能会引起负载不均衡.&lt;/p>
&lt;p>本地线程访问的是本地队列的尾部, 偷取时也是放入尾部.(偷其他队列的头部)
这样也有利于空间局部性.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-58-04_huef94ca176ae555045fd9f51c7aa174d2_800473_b158461eeda1557071d3b4c63c8e3fe8.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-58-04_huef94ca176ae555045fd9f51c7aa174d2_800473_9d3eab37557ed64ca33376a218896efe.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-58-04_huef94ca176ae555045fd9f51c7aa174d2_800473_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-58-04_huef94ca176ae555045fd9f51c7aa174d2_800473_b158461eeda1557071d3b4c63c8e3fe8.webp"
width="760"
height="567"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>那么如何实现同步呢?&lt;/p>
&lt;p>Example1: stalling join policy
拖延政策: 所有我创建的任务都必须完成后, 我才能继续执行.
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-11-01-00_hu7eda749a9f38115f90e5a19b6e792dce_643232_b716a896fce22ab605c4290cace396e0.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-11-01-00_hu7eda749a9f38115f90e5a19b6e792dce_643232_5b91177fc136336170132f872072d0ec.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-11-01-00_hu7eda749a9f38115f90e5a19b6e792dce_643232_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-16-11-01-00_hu7eda749a9f38115f90e5a19b6e792dce_643232_b716a896fce22ab605c4290cace396e0.webp"
width="760"
height="572"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>Example2: greedy join policy(cilk的实现方法)&lt;/p>
&lt;p>有一个跟踪数据结构,但那个东西可以四处移动.&lt;/p>
&lt;p>最后一个完成的线程会偷走这个数据结构&lt;/p>
&lt;p>所以一旦最后一个任务完成, 就可以继续执行了.&lt;/p>
&lt;p>这样不会浪费时间等待同步.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-11-04-26_hu803153c610f9240dc37b9df9cd593271_620138_b52217a08b08c5bd606846c2329641a3.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-11-04-26_hu803153c610f9240dc37b9df9cd593271_620138_140ed442354f7ce867bd06440a9c0b7d.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-11-04-26_hu803153c610f9240dc37b9df9cd593271_620138_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-16-11-04-26_hu803153c610f9240dc37b9df9cd593271_620138_b52217a08b08c5bd606846c2329641a3.webp"
width="760"
height="570"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>第一个方法实现起来更简单,但速度更慢.
因为它总是首线程只等待其他线程完成.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-11-09-58_hu4b706f34d698b4c5ca13bee75ebcc6f0_719518_a9b876038607b0430400742d4c1f6534.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-11-09-58_hu4b706f34d698b4c5ca13bee75ebcc6f0_719518_9d10c292ac70375ca23c48a9647fc5ab.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-11-09-58_hu4b706f34d698b4c5ca13bee75ebcc6f0_719518_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-16-11-09-58_hu4b706f34d698b4c5ca13bee75ebcc6f0_719518_a9b876038607b0430400742d4c1f6534.webp"
width="760"
height="570"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-11-10-26_hu503fb65c817ae1cedfa6301188230a3a_411373_6fa573df606795d8a26e44006a6d0209.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-11-10-26_hu503fb65c817ae1cedfa6301188230a3a_411373_1efd01f734283ebc6881240856c4c447.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-11-10-26_hu503fb65c817ae1cedfa6301188230a3a_411373_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-16-11-10-26_hu503fb65c817ae1cedfa6301188230a3a_411373_6fa573df606795d8a26e44006a6d0209.webp"
width="760"
height="421"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p></description></item><item><title>L6</title><link>https://ysyyhhh.github.io/blog/l6/</link><pubDate>Fri, 01 Mar 2024 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/blog/l6/</guid><description>&lt;p>虚拟文件系统&lt;/p>
&lt;p>/proc/cpuinfo&lt;/p>
&lt;ul>
&lt;li>model name&lt;/li>
&lt;li>cpu MHz - 频率&lt;/li>
&lt;li>cache size - 缓存大小&lt;/li>
&lt;li>siblings - 逻辑cpu数量&lt;/li>
&lt;li>processor - 逻辑cpu编号&lt;/li>
&lt;li>cpu cores - 物理cpu数量&lt;/li>
&lt;li>core id - 物理cpu编号&lt;/li>
&lt;li>&lt;/li>
&lt;/ul>
&lt;p>这样查看的cpu数量很多&lt;/p>
&lt;p>siblings是逻辑cpu的数量&lt;/p>
&lt;p>cpu cores是物理cpu的数量&lt;/p>
&lt;p>为什么报告的processor数量是40而siblings是20呢?
因为报告的processor包括超线程的逻辑cpu. 这样操作系统就可以直接根据逻辑cpu的数量来分配任务.&lt;/p>
&lt;p>Memory bandwidth - 内存带宽
Power consumption - 功耗
能源消耗实际上是一个很大的问题.
Intel code name - 代号
Functional units&lt;/p>
&lt;ul>
&lt;li>latency - 延迟&lt;/li>
&lt;li>issue time - 发射时间&lt;/li>
&lt;li>capacity - 容量&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="http://www.agner.org/optimize/microarchitecture.pdf" target="_blank" rel="noopener">微处理架构&lt;/a>&lt;/p>
&lt;h2 id="function-units">function units&lt;/h2>
&lt;ul>
&lt;li>latency - 延迟，执行一个指令所需要的时钟周期数(不包括等待)&lt;/li>
&lt;li>issue time - 发射时间，指令发射到执行所需要的时钟周期数(包括等待)&lt;/li>
&lt;li>capacity - 容量&lt;/li>
&lt;/ul>
&lt;p>优化的地方:&lt;/p>
&lt;ul>
&lt;li>搞清楚到底哪些代码是执行次数最多的(内部循环)(对实际使用情况来说)&lt;/li>
&lt;li>基本运算消耗时间: 除法 &amp;gt; 乘法 &amp;gt; 加法 &amp;gt; 位移&lt;/li>
&lt;/ul>
&lt;p>基本的程序:
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l6/img/2023-10-17-20-22-45_hu85293fdaa222549af0ddcf65b2bf7284_658635_5ab47a1042335e55b8938e5994f8e82a.webp 400w,
/blog/l6/img/2023-10-17-20-22-45_hu85293fdaa222549af0ddcf65b2bf7284_658635_e757e717e52c37dae010bd08781bf275.webp 760w,
/blog/l6/img/2023-10-17-20-22-45_hu85293fdaa222549af0ddcf65b2bf7284_658635_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l6/img/2023-10-17-20-22-45_hu85293fdaa222549af0ddcf65b2bf7284_658635_5ab47a1042335e55b8938e5994f8e82a.webp"
width="760"
height="362"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>合并重复计算的简单的提升:
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l6/img/2023-10-17-20-23-02_hudb10c716aa5853d9906cab8e836be839_490764_e61947fe8d466c3906248b8957252142.webp 400w,
/blog/l6/img/2023-10-17-20-23-02_hudb10c716aa5853d9906cab8e836be839_490764_139df3e7b8e363317855fbed39089e3f.webp 760w,
/blog/l6/img/2023-10-17-20-23-02_hudb10c716aa5853d9906cab8e836be839_490764_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l6/img/2023-10-17-20-23-02_hudb10c716aa5853d9906cab8e836be839_490764_e61947fe8d466c3906248b8957252142.webp"
width="760"
height="363"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l6/img/2023-10-17-20-24-13_hud8148b776d8e4bb3b0215a9ad8cf6f95_349342_738cfac8407fe76b9bd88d182792930c.webp 400w,
/blog/l6/img/2023-10-17-20-24-13_hud8148b776d8e4bb3b0215a9ad8cf6f95_349342_63cfbdb2168372034d159f8ad1ec2a56.webp 760w,
/blog/l6/img/2023-10-17-20-24-13_hud8148b776d8e4bb3b0215a9ad8cf6f95_349342_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l6/img/2023-10-17-20-24-13_hud8148b776d8e4bb3b0215a9ad8cf6f95_349342_738cfac8407fe76b9bd88d182792930c.webp"
width="760"
height="389"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>将除法次数减少,(不依赖于内层循环的变量的计算拿出来)&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l6/img/2023-10-17-20-24-42_hu3b7220bf0b4c94aedaa80f1185888619_507170_9095d26daddab8794efd73a5792f17c3.webp 400w,
/blog/l6/img/2023-10-17-20-24-42_hu3b7220bf0b4c94aedaa80f1185888619_507170_5ff7d026f194e0d2cd56e0d7a8225adb.webp 760w,
/blog/l6/img/2023-10-17-20-24-42_hu3b7220bf0b4c94aedaa80f1185888619_507170_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l6/img/2023-10-17-20-24-42_hu3b7220bf0b4c94aedaa80f1185888619_507170_9095d26daddab8794efd73a5792f17c3.webp"
width="760"
height="383"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>循环展开 loop unrolling&lt;/p>
&lt;p>如果每一次循环都要进行一次是否终止的测试,开销会很大.(尤其是一次循环的计算 相比于 循环次数来说很小 时)&lt;/p>
&lt;p>所以处理器从简单的策略开始,如预测循环的次数. 大部分都是基于统计预测的.&lt;/p>
&lt;p>如果可以预测循环的次数,就可以将循环展开. 每次循环多执行4 或 8 或&amp;hellip;次原来循环做的事情.&lt;/p>
&lt;p>但展开时不一定均匀,&lt;/p>
&lt;p>uniform可以使得循环展开的更好.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l6/img/2023-10-17-20-35-48_huf0320ca0eb40e0cc3f8446f56f4bb928_788707_4a9e00eea4a0274ea68f3d4c2a674fbf.webp 400w,
/blog/l6/img/2023-10-17-20-35-48_huf0320ca0eb40e0cc3f8446f56f4bb928_788707_2f730b863ed7aa2fc673db2504200996.webp 760w,
/blog/l6/img/2023-10-17-20-35-48_huf0320ca0eb40e0cc3f8446f56f4bb928_788707_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l6/img/2023-10-17-20-35-48_huf0320ca0eb40e0cc3f8446f56f4bb928_788707_4a9e00eea4a0274ea68f3d4c2a674fbf.webp"
width="760"
height="459"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l6/img/2023-10-17-20-39-50_hu45d93cab90138384d4beff72db4bc99e_596600_e755b84003b152ad93396cb9cfcd83e7.webp 400w,
/blog/l6/img/2023-10-17-20-39-50_hu45d93cab90138384d4beff72db4bc99e_596600_800800c4cbdaf41f00d08bd8121bf03d.webp 760w,
/blog/l6/img/2023-10-17-20-39-50_hu45d93cab90138384d4beff72db4bc99e_596600_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l6/img/2023-10-17-20-39-50_hu45d93cab90138384d4beff72db4bc99e_596600_e755b84003b152ad93396cb9cfcd83e7.webp"
width="760"
height="452"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>为什么8维向量获得了超过8倍的加速呢?
因为uniform, 原本要做8次的判断,现在只需要做一次.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l6/img/2023-10-17-20-42-45_hudc3741a959af0eae57271f90b977df00_280278_baf35b7a782eb349a2031ec1a434ece4.webp 400w,
/blog/l6/img/2023-10-17-20-42-45_hudc3741a959af0eae57271f90b977df00_280278_93cfbec29770590a36c25754a7afcd12.webp 760w,
/blog/l6/img/2023-10-17-20-42-45_hudc3741a959af0eae57271f90b977df00_280278_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l6/img/2023-10-17-20-42-45_hudc3741a959af0eae57271f90b977df00_280278_baf35b7a782eb349a2031ec1a434ece4.webp"
width="760"
height="306"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>常规优化提升了15倍
向量优化提升了5.4倍
总计提升了82倍&lt;/p>
&lt;p>向量化很好且是free的,但不能忽略了传统的优化&lt;/p>
&lt;p>传统的优化(213 program)使得速度提升了三倍&lt;/p>
&lt;p>要做到极致的优化,就比如要花3个星期的时间在编码风格上, 最后30分钟花在向量化上.&lt;/p>
&lt;p>但要看情况来决定编码风格的优化.
因为如果我们编写的代码不是执行次数最多(如内核,场景仿真,高频), 那么可能更需要的是可读性.&lt;/p>
&lt;p>可读性变差 可能会导致bug很容易被引入, 并且非常不容易被发现和维护.&lt;/p></description></item><item><title>L7</title><link>https://ysyyhhh.github.io/blog/l7/</link><pubDate>Fri, 01 Mar 2024 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/blog/l7/</guid><description>&lt;p>GPU&lt;/p>
&lt;h2 id="图形渲染">图形渲染&lt;/h2>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l7/img/2023-10-18-22-45-21_huf26ab9cd16631e333ae7f2c3af77eb19_132208_4715ef0685f9d6c48ae4ca6038102849.webp 400w,
/blog/l7/img/2023-10-18-22-45-21_huf26ab9cd16631e333ae7f2c3af77eb19_132208_d0293c4adf5cdc95de68440138589056.webp 760w,
/blog/l7/img/2023-10-18-22-45-21_huf26ab9cd16631e333ae7f2c3af77eb19_132208_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l7/img/2023-10-18-22-45-21_huf26ab9cd16631e333ae7f2c3af77eb19_132208_4715ef0685f9d6c48ae4ca6038102849.webp"
width="686"
height="519"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>图像中的每个对象都有很自然的并行性。&lt;/p></description></item><item><title>NoRBERT：使用迁移学习改进需求分类任务</title><link>https://ysyyhhh.github.io/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/</link><pubDate>Fri, 01 Mar 2024 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/</guid><description>&lt;p>NoRBERT: Transfer Learning for Requirements Classification
Tobias Hey， Jan Keim， Anne Koziolek， Walter F. Tichy
Karlsruhe Institute of Technology (KIT)&lt;/p>
&lt;h2 id="引用">引用&lt;/h2>
&lt;p>T. Hey, J. Keim, A. Koziolek and W. F. Tichy, &amp;ldquo;NoRBERT: Transfer Learning for Requirements Classification,&amp;rdquo; 2020 IEEE 28th International Requirements Engineering Conference (RE), Zurich, Switzerland, 2020, pp. 169-179, doi: 10.1109/RE48521.2020.00028.&lt;/p>
&lt;p>论文：https://sdq.kastel.kit.edu/publications/pdfs/hey2020.pdf
仓库：https://github.com/tobhey/NoRBERT&lt;/p>
&lt;h2 id="摘要">摘要&lt;/h2>
&lt;p>本文提出了NoRBERT，它使用了BERT模型进行微调，在需求工程领域进行迁移学习。他在PROMISE NFR数据集上，对功能性和非功能性需求的分类任务F1分数高达94％。对于分类非功能性需求的子类，超越了最近的方法，最常见的类别平均F1分数达到87%。在一个未见过的项目设置下，它比最近的方法高出15个百分点。此外，我们根据所包含的关注点，即功能、数据和行为，来分类功能性要求，标记了PROMISE NFR数据集中的功能性需求，并应用于测试NoRBERT，最终取得了高达92%的F1分数。NoRBERT提高了需求分类的准确性，并且可以很好地应用于未见过的项目。&lt;/p>
&lt;h2 id="1-引言">1 引言&lt;/h2>
&lt;p>需求的主要来源仍然是自然语言文档。对需求进行分类对于在项目早期识别出特定需求（如与安全相关的需求）非常重要。尽管已有的自动分类方法在多样化数据集上表现不错，但它们在未见过的项目上的性能会下降，因为需求的表述和结构依赖于项目和作者，而现有方法缺乏泛化能力。为了解决这个问题，我们探索了迁移学习方法，这种方法在NLP领域广泛应用，通过在大型数据集上训练来捕捉文本的深层含义，并能针对特定任务进行微调，从而在少量数据下实现更好的性能和泛化。
我们提出了NoRBERT方法，它基于BERT模型。BERT是一种预训练在大型文本语料库上的语言模型。BERT可以通过提供少量数据在特定任务上进行微调。我们使用NoRBERT在PROMISE NFR数据集上进行需求分类，并测试了其在重新标记的NFR数据集上的泛化能力。此外，我们还使用NoRBERT根据Glinz提出的关注点对功能性需求进行分类。这种方法在需求工程中特别有用，因为它可以在有限的标记数据情况下提供有效的分类。
本文的贡献包括以下三方面：
我们研究了通过迁移学习对已知和未知项目的需求进行分类的改进程度。
我们提供了一个新的数据集，根据功能、数据和行为的关注点进一步对功能性需求进行分类。
我们评估了基于迁移学习的方法在新数据集和任务上的表现。&lt;/p>
&lt;h2 id="2-技术介绍">2 技术介绍&lt;/h2>
&lt;h3 id="21相关工作">2.1相关工作&lt;/h3>
&lt;p>在需求工程领域，功能性需求与非功能性需求的区分是一个广泛研究的主题。功能性需求指的是系统必须执行的具体任务，而非功能性需求则涉及系统的质量标准，如性能、可靠性等，它们没有明确的执行标准。一些研究者将非功能性需求视为质量目标，而另一些则将其归类为系统属性或约束。
自动从文档中提取和分类需求是研究者关注的重点，已经发展出多种方法。例如，Cleland-Huang等人利用信息检索技术，通过识别指示词来分类需求，但这种方法在精确度上有所欠缺。Hussain等人通过使用特定词汇和决策树分类器改进了需求分类。Kurtanović和Maleej则采用自动化特征选择来预测需求类别。还有研究者使用深度学习技术，如卷积神经网络（CNN），来分类需求。
尽管这些方法展示了不同技术的潜力，但它们在实际应用中可能存在局限性，如过度依赖特定数据集、对措辞和句子结构敏感，或需要手动预处理。此外，这些方法在泛化到新项目上的能力上也存在不足。为了解决这些问题，我们尝试迁移学习方法，以期望在较少的训练数据下实现更好的性能和泛化能力。&lt;/p>
&lt;h3 id="22-bert介绍">2.2 BERT介绍&lt;/h3>
&lt;p>BERT（Bidirectional Encoder Representations from Transformers）是一种语言模型（LM）。用于预测词序列中词的概率，具有迁移学习的能力，即能在微调后适应不同任务。它起源于词嵌入技术，如word2vec，但通过使用ELMo的双向LSTM解决了word2vec忽略词义歧义的问题。BERT采用预训练和微调的方法进一步发展了语言模型，。
BERT的核心是Transformer架构，它用自注意力编码器-解码器结构替代了LSTM。自注意力层让模型能够识别并赋予相关词更高的权重，而忽略不相关的词。Transformer的多头注意力机制使模型能同时关注不同位置的词，提高了对词义的理解。
BERT的训练结合了双向预训练和掩码语言建模。在训练中，一部分输入词被掩码，模型需要预测这些词，同时学习判断句子是否可能连续。这种训练方法使BERT在多个NLP任务上取得了优异的表现。
BERT有两个版本：基础模型和大模型，分别具有不同数量的编码器层、隐藏单元和注意力头，参数数量也有所不同。基础模型有1.1亿参数，而大模型有3.4亿参数。BERT最初是在英文维基百科和BooksCorpus上训练的。BERT和类似的方法目前正在取代传统的自然语言处理系统。Tenney等人对BERT的不同层次和底层学习结构的分析表明，BERT重塑了类似于NLP流水线的相似结构。
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-06-42_huc8b64004ae082380fceeb6a9cfbbeb07_31345_3c1781b45a3d97aba38f4017c3469efb.webp 400w,
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-06-42_huc8b64004ae082380fceeb6a9cfbbeb07_31345_132fca3f76a341537ef1ec54a8e7014b.webp 760w,
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-06-42_huc8b64004ae082380fceeb6a9cfbbeb07_31345_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-06-42_huc8b64004ae082380fceeb6a9cfbbeb07_31345_3c1781b45a3d97aba38f4017c3469efb.webp"
width="522"
height="293"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
图1：用于微调 BERT 进行分类的架构。
图1展示了如何使用BERT进行分类。输入被分词。BERT的第一个输入标记始终是特殊标记[CLS]。标记[SEP]是一个特殊的分隔符标记，例如用于分隔句子，而标记[PAD]用于填充。对于分类和类似的下游任务，BERT产生的唯一输出是BERT为第一个标记([CLS])产生的输出，这是所有标记的聚合输出。这个聚合输出可以输入到一个单层前馈神经网络中，该网络使用softmax为不同类别分配概率。&lt;/p>
&lt;h2 id="3-实验评估">3 实验评估&lt;/h2>
&lt;h3 id="31-实验设置">3.1 实验设置&lt;/h3>
&lt;p>研究问题。在本文中，我们研究以下研究问题：
RQ1：迁移学习在需求分类中的表现如何？
RQ2：迁移学习是否提高了在未见项目上对需求进行分类的性能？
RQ3：迁移学习方法能够多大程度上检测到功能性需求的子类？
评估数据集。为了回答RQ1和RQ2，我们利用了两个现有的数据集。一个是广泛使用的PROMISE NFR数据集，该数据集在RE'17数据挑战中进行了处理，另一个是由Dalpiaz等人提供了一个重新标记的版本。前者来自15个项目的625个需求。这625个需求包括255个功能性需求和370个非功能性需求。表I显示了数据集中类别的分布以及每个类别需求的平均长度。每个需求只被标记为一个类别（F或11个NFR子类之一）。这些类别的分布不均匀。该数据集中F类要比NFR类少115个，且NFR子类的数量差异很大，从可用性的67个到可移植性的1个不等。可用性、安全性、操作性和性能是超过50个示例的类别，而容错性、法律性、可维护性和可移植性的类别则低于20个。
表I：原始 NFR 数据集的分布
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-06-59_hu388e9616551c1f5bdec730c883c65300_84423_70eead7a812275fb0c16047b4993e02c.webp 400w,
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-06-59_hu388e9616551c1f5bdec730c883c65300_84423_2f89f33ca0f4dcb3b1a90ef60ee5cdcd.webp 760w,
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-06-59_hu388e9616551c1f5bdec730c883c65300_84423_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-06-59_hu388e9616551c1f5bdec730c883c65300_84423_70eead7a812275fb0c16047b4993e02c.webp"
width="554"
height="377"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
由于数据集中F和NFR之间的区分有争议，并且数据集包含重复和错误标记的需求，Dalpiaz等人提供了一个重新标记的数据集。表II展示了数据集的概述。它仅由原始625个需求中的612个组成，并且仅使用了两个类别。一个需求可以具有功能性（F）或质量方面（Q）或两者都有。80个需求两者都有。230个需求仅具有功能性方面（OnlyF），而302个需求仅包含质量方面（OnlyQ）。
表II：重新标记的 NFR 数据集的分布
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-07-15_hu02e0e06c76d63d35764eae008a391e88_45107_c74c6d3c38e54489cfb77b0ebc0d1c64.webp 400w,
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-07-15_hu02e0e06c76d63d35764eae008a391e88_45107_47fb1dd26c8aa895635ef42f0c40500a.webp 760w,
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-07-15_hu02e0e06c76d63d35764eae008a391e88_45107_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-07-15_hu02e0e06c76d63d35764eae008a391e88_45107_c74c6d3c38e54489cfb77b0ebc0d1c64.webp"
width="554"
height="195"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
对比方法。基于数据集，我们将我们的方法应用于以下任务：
任务1：在原始NFR数据集上对F/NFR进行二元分类。
任务2：在原始NFR数据集上对四个最常见的NFR子类（US，SE，O，PE）进行二元和多类分类。
任务3：在原始NFR数据集中对所有NFR子类进行多类分类。
任务4：使用Dalpiaz等人提供的重新标记的NFR数据集，根据功能和质量方面对需求进行二元分类。
评估指标。对于所有任务，使用精确率（P）、召回率（R）和F1分数（F1）。对于多类分类，还报告了预测类别的加权平均F1分数（A）。
采用不同的设置来评估这些任务，包括使用.75-split描述了一个单次分成75%训练和25%测试集分割的数据集，以及使用了分层的10折交叉验证，即将数据集分割为10次，其中90%为训练集，10%为测试集，并对结果进行平均。分层分割确保数据集中类别的分布在训练集和测试集中保持一致。
为了进一步研究方法的可迁移性，使用了两种特定于项目的折叠策略。使用p-fold描述了Dalpiaz等人使用的项目级交叉验证，将数据集分割为10次，其中3个项目作为测试集，12个项目作为训练集，确保功能和质量方面的均匀分布。此外，还使用了一种留一项目交叉验证（loPo），即在n-1个项目上进行n次训练，并在留出的项目上进行测试。对于像NFR子类这样高度不平衡的二元任务，我们尝试了欠采样和过采样策略。我们还尝试了早期停止（ES）和不同的训练周期数。早期停止是一种常用的正则化技术，用于避免迭代学习器过拟合。&lt;/p>
&lt;h3 id="32norbert-使用bert进行非功能性和功能性需求分类">3.2NORBERT: 使用BERT进行非功能性和功能性需求分类&lt;/h3>
&lt;p>我们使用BERT的微调版本来研究迁移学习对需求分类任务的影响。
我们使用了两种不同的预训练BERT模型，基础和大型模型，都是带词性的版本。我们还尝试了不带词性的模型，但带词性的模型表现更好。这可能是因为需求中使用的命名实体被误认为是普通名词。我们使用BERT分词器，不对需求进行预处理。在预训练模型的基础上，我们定义了输出层，即分类头。我们使用BERT的序列中的第一个标记[CLS]的输出。这个输出被输入到由一个单层的线性神经元组成的前馈神经网络的分类头。输出直接计算自加权输入的总和（再加上一些偏差）。我们使用softmax函数为不同的标签获得概率分布。在训练过程中，我们使用交叉熵损失函数，并使用以下公式量化预测分布与真实分布的接近程度。：&lt;/p>
&lt;p>H(p，q)=-∑_x▒〖p(x) log⁡〖q(x)〗 〗&lt;/p>
&lt;p>p(x)表示目标概率，q(x)表示实际概率，x代表不同的标签。对于正确标签，p(x)设为1，其他错误标签设为0。损失函数旨在惩罚不准确或不确定的预测，同时奖励那些准确的自信预测。
我们使用AdamW优化器而非传统的随机梯度下降来更新网络权重。AdamW引入了权重衰减校正，但不补偿偏差。我们设置权重衰减为0.01，最大学习率为2e-05，与BERT原始论文中的设置相同。实验表明，批量大小16在所有测试中表现最佳。我们根据模型大小设定最大序列长度，以优化性能并避免内存问题。
在微调NoRBERT的超参数时，我们认为增加训练周期可以提高模型对训练数据的拟合度，但也可能增加过拟合的风险。实验显示，对于二元分类，10到32个训练周期，对于多类分类，10到64个训练周期效果最佳。&lt;/p>
&lt;h3 id="33任务1分类功能性和非功能性需求">3.3任务1分类功能性和非功能性需求&lt;/h3>
&lt;p>对于第一个任务，我们想要衡量NoRBERT在原始PROMISE NFR数据库上将需求分类为功能性（F）或非功能性（NFR）的性能。
我们使用分层10折交叉验证设置来回答关于迁移学习在需求分类性能方面的RQ1。我们训练了二元分类模型，即预测一个需求是F还是NFR，并与其他最新方法进行比较。
表III：在 PROMISE NFR 数据集上的 F/NFR 分类。粗体数值显示每个类别的每个指标的最高得分。
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-07-28_hu2335320fabdcdd914c3c2750d176ede8_133308_e10aa20ebe9e75babaeb2be06f5cba26.webp 400w,
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-07-28_hu2335320fabdcdd914c3c2750d176ede8_133308_ba29e752a0afb1564f99fce882834466.webp 760w,
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-07-28_hu2335320fabdcdd914c3c2750d176ede8_133308_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-07-28_hu2335320fabdcdd914c3c2750d176ede8_133308_e10aa20ebe9e75babaeb2be06f5cba26.webp"
width="507"
height="360"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
表III显示了我们的结果与其它方法报告的结果的比较。NoRBERT 在功能性需求和非功能性需求的 F1 分数上分别为 90% 和 93%。在NFR上，除了依赖手动提供的字典和规则进行数据预处理的Abad等人的方法外，NoRBERT超过了所有其他方法。NoRBERT与之相比不需要手动预处理，因此可以轻松地迁移到任何其他数据集。
我们的10折交叉验证结果显示，模型性能不受BERT模型选择或训练周期数的显著影响。Kurtanovi ´c和Maleej在功能性需求上取得了更高的F1分数，但他们的方法可能存在过拟合问题。
表III中的结果也有助于回答关于我们方法泛化能力的RQ2。10折没有考虑到数据集包含不同项目、不同领域和措辞。为了评估在未见过的项目上的性能，我们使用了特定于项目的设置（loPo和p-fold）。结果与10折评估相似或更好。这表明NoRBERT能够从训练期间看到的措辞中泛化出来。在不同项目和领域的数据集上，NoRBERT也能保持稳定性能。这与需要针对每个项目调整的手动字典和规则定义方法形成鲜明对比。&lt;/p>
&lt;h3 id="34-非功能性需求子类的分类">3.4 非功能性需求子类的分类&lt;/h3>
&lt;p>为了解决PROMISE NFR数据库中定义的非功能性需求（NFR）子类的分类任务。首先研究了数据库中四个最频繁的NFR子类的分类（任务2）。接着还研究了所有NFR子类的分类（任务3）。&lt;/p>
&lt;h4 id="a-任务2-最常见nfr子类的分类">A. 任务2: 最常见NFR子类的分类&lt;/h4>
&lt;p>我们使用NoRBERT对四种最常见的NFR进行了二元和多类分类。结果显示，NoRBERT在二元分类中取得了高达83%的加权平均F1分数，在多类分类中达到了87%。NoRBERT在大多数类别上的表现都超过了Kurtanovi´c和Maleej的模型。此外，NoRBERT在不同设置下的表现也有所不同，最佳二元分类结果是在16个周期、过采样和早停的情况下获得的。
表V: NFR 数据集上所有 NFR 子类的多类别分类。16、32 和 50 表示使用的时代数，bin 表示二元分类，mult 表示多类分类，B 和 L 分别表示使用的 BERT 模型（基础/大型）。bin16 还额外使用了 OS，multiL32 使用了 ES。LDA 和 NB（朴素贝叶斯）是指 Abad 等人的方法，其中有（P）或没有（UP）预处理过的数据。
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-07-38_huba703d7661994bccd6dab0abad0e6024_137406_528dccf1c61689f97642321c7a35c991.webp 400w,
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-07-38_huba703d7661994bccd6dab0abad0e6024_137406_ff72545e5cc5db6610093f4866007b5e.webp 760w,
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-07-38_huba703d7661994bccd6dab0abad0e6024_137406_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-07-38_huba703d7661994bccd6dab0abad0e6024_137406_528dccf1c61689f97642321c7a35c991.webp"
width="554"
height="179"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h4 id="b-任务3-所有nfr子类的多类分类">B. 任务3: 所有NFR子类的多类分类&lt;/h4>
&lt;p>我们使用NoRBERT对所有NFR子类别进行了多类分类。多类分类器尤其是在代表数量较少的类别上表现良好。所有多类模型在平均性能上都优于相应的二元分类器。基于BERT-large的模型在这项任务上表现最佳，这可能是因为它们具有更大的参数空间，能够更好地处理语言的微妙差异。NoRBERT在这项任务上的表现超过了Navarro-Almanza等人的方法，这表明迁移学习在这项任务上优于基于词嵌入的深度学习。
我们还探讨了NoRBERT在未见过的项目上的性能（RQ2）。在p折和loPo设置中，NoRBERT的性能略有下降，但多类分类器仍然优于二元分类器。尽管在loPo设置中NoRBERT的表现略逊于p折，但多类分类器和大型模型在所有设置中都优于二元分类器。
NoRBERT在分类NFR子类别方面表现出色，即使在训练数据有限的情况下也能识别出代表性不足的子类别。NoRBERT提供了一种可行的方法来替代手动数据预处理。&lt;/p>
&lt;h3 id="35-任务4-功能性和质量方面的分类">3.5 任务4: 功能性和质量方面的分类&lt;/h3>
&lt;p>功能性（F）和非功能性需求（NFR）之间的区别并不总是清晰的，一些需求包含了两者的方面。因此，我们在Dalpiaz等人提供的重新标记的PROMISE NFR数据库上衡量NoRBERT的性能[9]，并将NoRBERT与Kurtanovi´c和Maleej[8]的方法进行比较。
表 VI：重新标记的 PROMISE NFR 数据集中类的二元分类。粗体数值代表每个类别每个指标的最高分。星号标记的 F1 分数与其他出版物报道的精度和召回率不匹配。
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-07-44_hu451a5970b1399f4901b17b67f458adc0_110807_f9c826fb2c531078bb010cbbd3b32e88.webp 400w,
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-07-44_hu451a5970b1399f4901b17b67f458adc0_110807_400b1161088cb767f7f83b529a74a4c9.webp 760w,
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-07-44_hu451a5970b1399f4901b17b67f458adc0_110807_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-07-44_hu451a5970b1399f4901b17b67f458adc0_110807_f9c826fb2c531078bb010cbbd3b32e88.webp"
width="554"
height="213"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
表VI显示了在重新标记集上训练的二元分类器的结果。我们使用与Dalpiaz等人相同的设置，即.75-split、10-fold、p-fold和随机种子（42），此外还评估了loPo设置。NoRBERT在所有这些设置中都优于其他方法。因此，迁移学习方法明显提高了分类需求的性能（RQ1）。
在.75分割中，NoRBERT的基础模型在纯功能或质量类别上表现更佳，而大型模型在其他类别上表现更好。在10折交叉验证中，NoRBERT的最佳模型平均优于Dalpiaz等人的最佳模型10个百分点，尤其在仅含功能方面的需求上（F1得分91% vs 73%）。p折和loPo的结果显示NoRBERT在未见项目上的迁移能力强。与Kurtanovi´c和Maleej的方法相比，NoRBERT在处理未见项目上表现更好，平均F1得分高出15个百分点。
这表明NoRBERT具有良好的泛化能力，无需重新训练即可在实际项目中使用。我们认为，在评估需求分类方法时，应更重视其在未见项目上的表现。&lt;/p>
&lt;h3 id="36功能性需求的分类">3.6功能性需求的分类&lt;/h3>
&lt;p>NoRBERT在分类非功能性需求上表现出了良好的效果。现在研究它在分类功能性需求方面的表现。功能性需求通常根据它们所属的产品部分（例如用户界面或业务逻辑）来分类。有些模型则采用基于关注点的方法，包括功能性和行为性需求以及数据。如果我们想要开发能够自动理解功能性需求的系统，比如自动化追踪或建模系统，那么了解功能性需求的子类别就很重要，因为它们定义了需求可能的实现方式。
我们采用了Glinz提出的基于关注点的模型，它帮助我们理解功能性需求是描述系统的功能、系统展示的行为，还是仅仅是数据和数据结构。我们使用以下子类别：
功能：系统应执行的功能。 例子：系统应允许房地产经纪人查询MLS信息。
数据：应成为系统状态一部分的数据项或数据结构。 例子：审计报告应包括估计中使用的回收部件总数。
行为：系统展示的行为或由一个或多个刺激触发的反应。 例子：如果射门被标记为命中，产品应允许进攻球员定义射门。
需求可能包含多个关注点，这些类别可能会重叠，例如，“只有注册客户可以购买流媒体电影”。它既包含功能也包含行为。
为了回答RQ3，即迁移学习方法是否能够识别功能性需求中的关注点，由两位作者独立手动标记了PROMISE NFR数据集中的310个功能性需求。我们使用了Krippendorff的α（Kα）来衡量标注者间的一致性，发现功能和数据类别的一致性超过了0.8，而行为类别的一致性为0.752，虽然略低，但仍然是可接受的。
表VII: 功能性需求数据集概述
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-07-53_huc2ad73bdeda65935e5b408996e7bffdf_39679_375dd2a87193dc3e3b5df6204b31e3da.webp 400w,
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-07-53_huc2ad73bdeda65935e5b408996e7bffdf_39679_44287f837bac2078888284819104f442.webp 760w,
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-07-53_huc2ad73bdeda65935e5b408996e7bffdf_39679_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-07-53_huc2ad73bdeda65935e5b408996e7bffdf_39679_375dd2a87193dc3e3b5df6204b31e3da.webp"
width="554"
height="127"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
表VII显示了项目中类别的分布。需求的数量少于每个项目中类别代表的数量，因为每个需求可能包含多个关注点。项目11到14包含的需求数量较少，因为它们主要由非功能性需求组成。
A. 在功能性需求数据集上评估NoRBERT
我们使用标记好的数据集来评估NoRBERT在分类功能性需求上的表现。我们训练了二元分类模型，并在10折交叉验证和loPo（低代表性项目）设置下进行了评估。
表 VIII：使用 NoRBERT 在新数据集上对功能性需求子类进行二元分类，采用 10 折交叉验证和 loPo 设置。粗体数值代表每个类别每个指标的最高分。b 和 l 分别代表基础模型和大型模型
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-08-03_hu40c15b79533008f61d7df5aa86d8eea3_116653_6b3b08e00faba501d946fd636ee5c031.webp 400w,
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-08-03_hu40c15b79533008f61d7df5aa86d8eea3_116653_9a8c617c4e0be7eaae5dbeb72d0bf711.webp 760w,
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-08-03_hu40c15b79533008f61d7df5aa86d8eea3_116653_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-08-03_hu40c15b79533008f61d7df5aa86d8eea3_116653_6b3b08e00faba501d946fd636ee5c031.webp"
width="554"
height="338"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
表VIII结果显示，NoRBERT在功能和行为类别上表现良好，但在数据类别上的召回率较低。这可以归因于这个类别缺乏训练数据和数据集的不平衡。我们发现欠采样和过采样对不同类别的影响不同。
在loPo设置中，NoRBERT的表现与10折交叉验证相似，功能类别的F1分数甚至略有提高，但数据类别的性能下降到了56%。尽管如此，与10折交叉验证相比，这个结果仍然是好的。我们还发现，在loPo设置中，大型模型在所有类别上的表现优于基础模型，这可能是因为loPo设置要求更好的泛化能力。
为了回答RQ3，我们可以得出结论，对于这些数据量，NoRBERT在处理功能性需求方面表现不错，尤其是在功能和行为类别上。虽然数据类别的表现有待提高，但通过更多的训练数据，NoRBERT的性能有望进一步提升。这可能有助于能够改进诸如追踪链接恢复或自动化建模等方法。&lt;/p></description></item><item><title>P0 [C++ Primer](https://15445.courses.cs.cmu.edu/fall2022/project0/)</title><link>https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/</link><pubDate>Fri, 01 Mar 2024 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/</guid><description>&lt;h1 id="l1-relational-model--relational-algebra">L1 Relational Model &amp;amp; Relational Algebra&lt;/h1>
&lt;h2 id="11-databases">1.1 Databases&lt;/h2>
&lt;p>数据库：an organized collection of inter-related data that models some aspect of the real-world&lt;/p>
&lt;p>数据库管理系统 DBMS：the software that manages a database&lt;/p>
&lt;h2 id="12-flat-file-strawman">1.2 Flat File Strawman&lt;/h2>
&lt;p>数据库常常以CSV(comma-separated value)文件的形式存储，由DBMS进行管理。每次应用程序要读取或者更新记录时，都必须解析文件(parse files)。&lt;/p>
&lt;h2 id="13-database-management-system">1.3 Database Management System&lt;/h2>
&lt;ul>
&lt;li>A general-purpose(通用) &lt;strong>DBMS&lt;/strong> is designed to allow the definition, creation, querying, update, and administration of databases in accordance with some &lt;strong>data model&lt;/strong>.&lt;/li>
&lt;li>A &lt;strong>data model&lt;/strong> is a collection of concepts for describing the data in database
&lt;ul>
&lt;li>Examples: &lt;strong>relational&lt;/strong> (most common), NoSQL (&lt;strong>key/value&lt;/strong>, graph), array/matrix/vectors&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>A &lt;strong>schema&lt;/strong>(模式) is a description of a particular collection of data based on a &lt;strong>data model&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>早期，数据库应用很难建立和维护，因为逻辑层和物理层之间存在着紧密的耦合。&lt;/p>
&lt;ul>
&lt;li>逻辑层： 描述了数据库有哪些实体和属性。&lt;/li>
&lt;li>物理层： 是这些实体和属性的存储方式。&lt;/li>
&lt;/ul>
&lt;p>所以早期的数据库，一旦改变了物理层，逻辑层也得跟着变。&lt;/p>
&lt;h2 id="14-relational-model">1.4 Relational Model&lt;/h2>
&lt;p>人们每次改变物理层都要重新写数据管理系统，故Ted Codd注意到后提出了关系模型。&lt;/p>
&lt;p>The relational model defines a database abstraction based on relations to avoid &lt;strong>maintenance overhead&lt;/strong>(维护开销).&lt;/p>
&lt;p>三要点:&lt;/p>
&lt;ul>
&lt;li>Store database in simple data structures (relations).&lt;/li>
&lt;li>Access data through high-level language, DBMS &lt;strong>figures out&lt;/strong>(找出) best execution strategy.&lt;/li>
&lt;li>Physical storage &lt;strong>left up to&lt;/strong>(取决于) the DBMS implementation.&lt;/li>
&lt;/ul>
&lt;p>三概念&lt;/p>
&lt;p>The relational data model defines three concepts:&lt;/p>
&lt;ul>
&lt;li>Structure: The definition of relations and their contents. This is the attributes the relations have and the values that those attributes can hold.&lt;/li>
&lt;li>&lt;strong>Integrity&lt;/strong>(完整性): Ensure the database’s contents satisfy constraints.
&lt;ul>
&lt;li>实体完整性 entity integrity:主属性不能为空&lt;/li>
&lt;li>参照完整性 referential integrity: 外键的值必须存在&lt;/li>
&lt;li>用户定义的完整性
&lt;ul>
&lt;li>An example constraint would be that any value for the year attribute has to be a number.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Manipulation: How to access and modify a database’s contents.&lt;/li>
&lt;/ul>
&lt;p>关系:&lt;/p>
&lt;p>&lt;strong>A relation&lt;/strong> is an &lt;strong>unordered&lt;/strong> set that contains the relationship of attributes that represent entities. So the DBMS can store them in any way it wants, allowing for &lt;strong>optimization&lt;/strong>(允许优化).&lt;/p>
&lt;p>元组:&lt;/p>
&lt;p>&lt;strong>A tuple&lt;/strong> is a set of &lt;strong>attribute values&lt;/strong> (also known as its &lt;strong>domain&lt;/strong> 域 一组相同数据类型的值的集合) in the relation. &lt;strong>Originally&lt;/strong>, values had to be atomic or scalar(标量), but &lt;strong>now&lt;/strong> values can also be lists or &lt;strong>nested&lt;/strong>(嵌套) data structures. Every attribute can be a special value, &lt;strong>NULL&lt;/strong>, which means for a given tuple the attribute is &lt;strong>undefined&lt;/strong>.&lt;/p>
&lt;p>关系:&lt;/p>
&lt;p>&lt;strong>A relation&lt;/strong> with n attributes is called &lt;strong>an n-ary relation&lt;/strong>.&lt;/p>
&lt;p>键&lt;/p>
&lt;p>&lt;strong>A relation’s primary key&lt;/strong> uniquely identifies a single tuple.&lt;/p>
&lt;ul>
&lt;li>Some DBMSs automatically create an internal primary key if you do not define one.&lt;/li>
&lt;li>A lot of DBMSs have support for autogenerated keys so an application does not have to &lt;strong>manually increment&lt;/strong>(手动增加) the keys, but a primary key is still required for some DBMSs.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>A foreign key&lt;/strong> specifies that an attribute from one relation has to map to a tuple in another relation.&lt;/p>
&lt;h2 id="15-data-manipulation-languages-dmls">1.5 Data Manipulation Languages (DMLs)&lt;/h2>
&lt;p>Methods to store and retrieve information from a database.&lt;/p>
&lt;p>There are two classes of languages for this:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Procedural&lt;/strong>(程序上的): The query &lt;strong>specifies the (high-level) strategy&lt;/strong> the DBMS should use to find &lt;strong>the desired result based on sets / bags.&lt;/strong> (relational &lt;strong>algebra&lt;/strong> 代数)&lt;/li>
&lt;li>Non-Procedural (&lt;strong>Declarative&lt;/strong> 声明): The query specifies only what data is wanted and not how to find it. (relational &lt;strong>calculus&lt;/strong> 微积分/关系演算)&lt;/li>
&lt;/ul>
&lt;p>一般现在都是用第二种的，我不管DBMS用什么&lt;strong>策略&lt;/strong>，我只需要你给我我想要的数据。&lt;/p>
&lt;h2 id="16-relational-algebra-关系代数">1.6 Relational Algebra 关系代数&lt;/h2>
&lt;p>&lt;strong>Relational Algebra&lt;/strong> is a set of fundamental operations to &lt;strong>retrieve&lt;/strong>(检索) and manipulate tuples in a relation.&lt;/p>
&lt;p>Each operator &lt;strong>takes in&lt;/strong>(需要) one or more relations as inputs, and outputs a new relation. To write queries we can “&lt;strong>chain&lt;/strong>(链)” these operators together to create more complex operations.&lt;/p>
&lt;p>5种基本&lt;strong>关系操作&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>选择,投影,并,差,笛卡儿积&lt;/li>
&lt;/ul>
&lt;p>传统&lt;strong>集合运算&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>二目运算: 并,差,交,笛卡尔积&lt;/li>
&lt;/ul>
&lt;p>专门的&lt;strong>关系运算&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>选择selection ,投影projection,连接 join,除 dividen&lt;/li>
&lt;/ul>
&lt;p>选择:在&lt;strong>关系R&lt;/strong>中,选择符合条件的&lt;strong>元组&lt;/strong>,是从行的角度进行运算.&lt;/p>
&lt;p>投影:在&lt;strong>关系R&lt;/strong>中,选择出&lt;strong>若干属性列&lt;/strong>组成新的关系,从列的角度&lt;/p>
&lt;p>连接:两个关系的&lt;strong>笛卡尔积&lt;/strong>中,选取属性中满足一定条件的元组&lt;/p>
&lt;ul>
&lt;li>自然连接 内连接: 不保留悬浮元组.&lt;/li>
&lt;li>外连接 outer join : 保留&lt;strong>悬浮元组&lt;/strong>(填NULL)的连接&lt;/li>
&lt;li>左连接 left outer join: 只保留&lt;strong>左边关系R&lt;/strong>中的悬浮空组.&lt;/li>
&lt;li>右连接 right outer join: 只保留&lt;strong>右边关系R&lt;/strong>中的悬浮空组.&lt;/li>
&lt;/ul>
&lt;p>除: R除以S得到T, 则T包含所有&lt;strong>在R而不在S&lt;/strong>的&lt;strong>属性及其值&lt;/strong>. 且T和S的所有组合都在R中.&lt;/p>
&lt;h1 id="l2-modern-sql">L2 Modern SQL&lt;/h1>
&lt;h2 id="21-relation-languages">2.1 Relation Languages&lt;/h2>
&lt;p>用户只需要使用声明性语言（即SQL）来指定他们想要的结果。DBMS 负责确定产生该答案的最有效计划。&lt;/p>
&lt;p>关系代数基于 sets (unordered, no duplicates)。 SQL基于 bags (unordered, allows duplicates)&lt;/p>
&lt;h2 id="22-sql-history">2.2 SQL History&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>SEQUEL Structured English Query Language&lt;/p>
&lt;p>SQL Structured Query Language&lt;/p>
&lt;/li>
&lt;li>
&lt;p>该语言由不同类别的命令组成：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>DML&lt;/strong> Data Manipulation Language &lt;code>SELECT, INSERT, UPDATE, DELETE&lt;/code>&lt;/li>
&lt;li>&lt;strong>DDL&lt;/strong> Data Definition Language Schema definitions for tables, indexes, views, and other objects.&lt;/li>
&lt;li>&lt;strong>DCL&lt;/strong> Data Control Language Security, access controls.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>SQL仍在不断发展的&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="23-join">2.3 Join&lt;/h2>
&lt;p>结合一个或多个表的列，产生一个新的表。用来表达涉及跨越多个表的数据的查询&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">CREATE TABLE student (
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> sid INT PRIMARY KEY,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> name VARCHAR(16),
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> login VARCHAR(32) UNIQUE,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> age SMALLINT,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> gpa FLOAT
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">CREATE TABLE course (
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> cid VARCHAR(32) PRIMARY KEY,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> name VARCHAR(32) NOT NULL
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">CREATE TABLE enrolled (
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> sid INT REFERENCES student (sid),
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> cid VARCHAR(32) REFERENCES course (cid),
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> grade CHAR(1)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">找出在15-721拿到A的学术
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">SELECT s.name
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">FROM enrolled AS e, student AS s
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">WHERE e.grade = &amp;#39;A&amp;#39; AND e.cid = &amp;#39;15-721&amp;#39;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">AND e.sid = s.sid;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="24-aggregates-聚合函数">2.4 Aggregates 聚合函数&lt;/h2>
&lt;p>聚合函数接受一组列表，然后产生一个单一的标量值作为其输出。基本上只能在SELECT输出列表中使用！&lt;/p>
&lt;p>函数：&lt;/p>
&lt;ul>
&lt;li>&lt;code>AVG&lt;/code>&lt;/li>
&lt;li>&lt;code>MIN&lt;/code>&lt;/li>
&lt;li>&lt;code>MAX&lt;/code>&lt;/li>
&lt;li>&lt;code>COUNT&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>当使用goup时,聚合函数输出为每个组的输出.&lt;/p>
&lt;p>having 在聚合计算的基础过滤输出结果.而不是where&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SELECT AVG(s.gpa) AS avg_gpa, e.cid
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">FROM enrolled AS e, student AS s
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">WHERE e.sid = s.sid
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">GROUP BY e.cid
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">HAVING avg_gpa &amp;gt; 3.9;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="25-sting-operation">2.5 Sting Operation&lt;/h2>
&lt;p>&lt;strong>SQL标准&lt;/strong>是&lt;strong>区分大小写&lt;/strong>的，而且只能是&lt;strong>单引号&lt;/strong>！有一些函数可以处理字符串，可以在查询的任何部分使用。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>Pattern Matching&lt;/strong>:&lt;/p>
&lt;p>Like 关键字&lt;/p>
&lt;ul>
&lt;li>&lt;code>%&lt;/code> : matches any substrings (including empty).&lt;/li>
&lt;li>&lt;code>_&lt;/code> : matches any one character&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>String Function:&lt;/strong> &lt;code>SUBSTRING(S, B, E)&lt;/code> &lt;code>UPPER(S)&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Concatenation&lt;/strong>(连接) : &lt;code>||&lt;/code> concatenate two or more strings together into a single string&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="26-date-and-time">2.6 Date and Time&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>时间函数&lt;/p>
&lt;ul>
&lt;li>当前日期时间 &lt;code>NOW()&lt;/code>, &lt;code>CURRENT_TIMESTAMP()&lt;/code>&lt;/li>
&lt;li>当前UNIX时间戳 &lt;code>UNIX_TIMESTAMP()&lt;/code>&lt;/li>
&lt;li>当前日期 &lt;code>CURRENT_DATE()&lt;/code>&lt;/li>
&lt;li>当前时间 &lt;code>CURRENT_TIME()&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>日期时间转换函数&lt;/p>
&lt;ul>
&lt;li>当前时间戳转换为北京时间 &lt;code>FROM_UNIXTIME()&lt;/code>&lt;/li>
&lt;li>北京时间转换为时间戳 &lt;code>UNIX_TIMESTAMP()&lt;/code>&lt;/li>
&lt;li>时间中解析年月日时间 &lt;code>DATE_FORMAT(date, format)&lt;/code>&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">select DATE_FORMAT(&amp;#39;2021-01-01 08:30:50&amp;#39;,&amp;#39;%Y-%m-%d&amp;#39;)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>日期时间运算函数&lt;/p>
&lt;ol>
&lt;li>
&lt;p>在某个时间的基础上加上或者减去某个时间 &lt;code>DATE_ADD(date,INTERVAL expr unit)&lt;/code> &lt;code>DATE_SUB(date,INTERVAL expr unit)&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>返回两个日期值之间的天数 &lt;code>DATEDIFF(expr1,expr2))&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">select DATEDIFF(&amp;#39;2021-01-02&amp;#39;,&amp;#39;2021-01-01&amp;#39;)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>时间差函数 &lt;code>TIMESTAMPDIFF(unit,datetime_expr1,datetime_expr2)&lt;/code>&lt;/p>
&lt;p>unit：天(DAY)、小时(HOUR），分钟(MINUTE)和秒(SECOND)，TIMESTAMPDIFF函数比DATEDIFF函数用起来更加灵活&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;h2 id="27-output-redirection">2.7 Output Redirection&lt;/h2>
&lt;p>你可以告诉DBMS将查询结果存储到另一个表中，而不是将查询结果返回给客户端（例如，终端）。结果存储到另一个表中。然后你可以在随后的查询中访问这些数据&lt;/p>
&lt;ul>
&lt;li>
&lt;p>New Table: 将查询的输出存储到一个新的（永久）表中。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SELECT DISTINCT cid INTO CourseIds FROM enrolled;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>Exustubg Table:&lt;/p>
&lt;p>将&lt;strong>查询的输出存储到数据库中已经存在的表&lt;/strong>中。该表 目标表必须有与目标表相同数量和相同类型的列，但输出查询中的列名不需要匹配。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">INSERT INTO CourseIds (SELECT DISTINCT cid FROM enrolled)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;h2 id="28-output-control">2.8 Output Control&lt;/h2>
&lt;p>可以用ORDER BY来对输出进行排序,后面可以加&lt;code>DESC&lt;/code>, &lt;code>ASC&lt;/code>来指定排序策略&lt;/p>
&lt;p>输出的数量可以用&lt;code>LIMIT n&lt;/code> 进行指定,当然也可以用&lt;code>OFFSET&lt;/code> 来提供一个bias。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">ELECT sid, grade FROM enrolled WHERE cid = &amp;#39;15-721&amp;#39;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ORDER BY grade;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">SELECT sid, name FROM student WHERE login LIKE &amp;#39;%@cs&amp;#39;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">LIMIT 20 OFFSET 10;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="29-nested-queries">2.9 Nested Queries&lt;/h2>
&lt;p>在其他查询中调用查询，在单个查询中执行更复杂的逻辑。嵌套查询往往难以优化。&lt;/p>
&lt;p>外部查询的范围包括在内部查询中（即&lt;strong>内部查询可以访问来自外部查询&lt;/strong>），反之不行。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>内部查询几乎可以出现在一个查询的任何部分。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;code>SELECT&lt;/code> Output Targets&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SELECT (SELECT 1) AS one FROM student;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;code>FROM&lt;/code> &lt;strong>Clause&lt;/strong>(条件):&lt;/p>
&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SELECT name
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> FROM student AS s, (SELECT sid FROM enrolled) AS e
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> WHERE s.sid = e.sid;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="3">
&lt;li>&lt;code>WHERE&lt;/code> Clause&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SELECT name FROM student
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> WHERE sid IN ( SELECT sid FROM enrolled );
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>例子： 获取在15-445中注册的学生名字&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SELECT name FROM student
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> WHERE sid IN (
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> SELECT sid FROM enrolled
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> WHERE cid = &amp;#39;15-445&amp;#39;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>请注意，根据它在查询中出现的位置，sid有不同的范围。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>例子： 找到注册了至少一门课的最大的学生id&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SELECT student.sid, name
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> FROM student
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> JOIN (SELECT MAX(sid) AS sid
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> FROM enrolled) AS max_e
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ON student.sid = max_e.sid;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;h3 id="nested-query-results-expressions">Nested Query Results Expressions:&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>关键字：&lt;/p>
&lt;ul>
&lt;li>&lt;code>ALL&lt;/code> Must satisfy expression for all rows in sub-query&lt;/li>
&lt;li>&lt;code>ANY&lt;/code> Must satisfy expression for at least one row in sub-query.&lt;/li>
&lt;li>&lt;code>IN&lt;/code> Equivalent to =ANY().&lt;/li>
&lt;li>&lt;code>EXISTS&lt;/code> At least one row is returned.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>例子： 找到所有没有学生注册的课&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SELECT * FROM course
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> WHERE NOT EXISTS(
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> SELECT * FROM enrolled
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> WHERE course.cid = enrolled.cid
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;h2 id="210-window-functions">2.10 Window Functions&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>函数： 窗口函数可以是我们上面讨论的任何一个聚合函数。也有一些特殊的窗口函数。&lt;/p>
&lt;ol>
&lt;li>&lt;code>ROW_NUMBER&lt;/code>: 当前列的数字&lt;/li>
&lt;li>&lt;code>RANK&lt;/code>: 当前列的顺序&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>Grouping: &lt;strong>OVER子句指定了在计算窗口函数时如何对图元进行分组&lt;/strong>。使用&lt;strong>PARTITION BY&lt;/strong>来指定分组&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SELECT cid, sid, ROW_NUMBER() OVER (PARTITION BY cid)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> FROM enrolled ORDER BY cid;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们也可以在OVER中放入ORDER BY，以确保结果的确定性排序，即使数据库内部发生变化。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SELECT *, ROW_NUMBER() OVER (ORDER BY cid)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> FROM enrolled ORDER BY cid;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;strong>重要提示：&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>DBMS在窗函数排序后计算&lt;code>RANK&lt;/code>，而在排序前计算&lt;code>ROW_NUMBER&lt;/code>。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>找到每门课程中成绩第二高的学生&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SELECT * FROM (
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> SELECT *, RANK() OVER (PARTITION BY cid
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ORDER BY grade ASC) AS rank
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> FROM enrolled) AS ranking
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">WHERE ranking.rank = 2;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="211-commom-table-expressions">2.11. Commom Table Expressions&lt;/h2>
&lt;p>在编写更复杂的查询时，通用表表达式（CTE）是窗口或嵌套查询的一种替代方法。复杂的查询时，可以替代窗口或嵌套查询。它们提供了一种方法来为用户在一个更大的查询中编写辅助语句.&lt;/p>
&lt;p>可以理解为一个辅助表。&lt;/p>
&lt;p>&lt;code>WITH&lt;/code>子句将内部查询的输出与一个具有该名称的临时结果绑定。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>例子： 生成一个名为cteName的CTE，其中包含一个单一属性设置为 &amp;ldquo;1 &amp;ldquo;的元组。从这个CTE中选择所有属性。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">WITH cteName AS (
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> SELECT 1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">SELECT * FROM cteName;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们可以在AS之前将输出列绑定到名称上&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">WITH cteName (col1, col2) AS (
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> SELECT 1, 2
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">SELECT col1 + col2 FROM cteName;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>一个查询可能包含多个CTE声明&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">WITH cte1 (col1) AS (SELECT 1), cte2 (col2) AS (SELECT 2)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">SELECT * FROM cte1, cte2;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>递归能力 在WITH后面&lt;strong>添加RECURSIVE关键字&lt;/strong>允许CTE引用自己。这使得在SQL查询中可以实现递归。有了递归的CTE，SQL被证明是图灵完备的，这意味着它在计算上的表现力不亚于更多的通用编程语言&lt;/p>
&lt;/li>
&lt;li>
&lt;p>例子：打印从1到10的数字&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">WITH RECURSIVE cteSource (counter) AS (
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ( SELECT 1 )
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> UNION
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ( SELECT counter + 1 FROM cteSource
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> WHERE counter &amp;lt; 10 )
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">SELECT * FROM cteSource;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;h1 id="homework-1---sql">Homework #1 - SQL&lt;/h1>
&lt;p>CASE 语句&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SELECT name,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> CASE
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> when died is not null
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> then died-born
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> else &amp;#39;2022&amp;#39; - born
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> END as age
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">FROM people
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">where born &amp;gt;= &amp;#39;1900&amp;#39;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ORDER by age DESC,name
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">LIMIT 20;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>CAST AS TEXT 转换成字符串，字符串连接用 ||&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">select
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">CAST(titles.premiered/10*10 AS TEXT) || &amp;#39;s&amp;#39; as decade,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">round(avg(rating),2) as avg,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">max(rating) as top,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">min(rating) as min,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">count(*) as NUM_RELEASES
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">from ratings
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">join titles on titles.title_id = ratings.title_id
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">where decade is not null
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">GROUP by decade
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">order by avg DESC,decade
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">limit 20;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>第一个with后，用,隔开&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">with person_title as (
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> select people.name,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> people.person_id,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> crew.title_id
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> from people
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> join crew on crew.person_id = people.person_id
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> join titles on titles.title_id = crew.title_id
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> where born = 1955 and titles.type = &amp;#34;movie&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">),
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">person_avg as (
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> select person_title.name,round(avg(rating),2) as avg
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> from RATINGS
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> join person_title on person_title.title_id = ratings.title_id
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> group by person_title.person_id
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">),
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">quantiles as (
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> select * ,NTILE(10) OVER (ORDER BY avg ASC) as QuantileRating from person_avg
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">select
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">name,avg
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">from quantiles
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">where QuantileRating = 9
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">order by avg DESC,name;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>把表格数据压缩成一行，用，隔开&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">with p as(
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> select akas.title as dubbed
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> from titles
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> join akas on akas.title_id = titles.title_id
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> where primary_title = &amp;#34;House of the Dragon&amp;#34; and type = &amp;#34;tvSeries&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> group by primary_title,dubbed
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> order by dubbed
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">select GROUP_CONCAT(dubbed,&amp;#39;, &amp;#39;) from p;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="l3--4database-storage">L3 -4Database Storage&lt;/h1>
&lt;h2 id="31-storage">3.1 Storage&lt;/h2>
&lt;p>The DBMS assumes that the primary storage location of the database is on non-volatile disk.&lt;/p>
&lt;p>The DBMS&amp;rsquo;s components manage the movement of data between non-volatile and volatile storage.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222153223421" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222153223421_hud22ed9fb7e05b813d6f8ec53aae116f9_88815_5cb0075bf1c94b9519597682f898623e.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222153223421_hud22ed9fb7e05b813d6f8ec53aae116f9_88815_25d36e1da19b804aeaf0d87a056222ff.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222153223421_hud22ed9fb7e05b813d6f8ec53aae116f9_88815_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222153223421_hud22ed9fb7e05b813d6f8ec53aae116f9_88815_5cb0075bf1c94b9519597682f898623e.webp"
width="760"
height="456"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>Volatile Devices:&lt;/p>
&lt;ul>
&lt;li>Volatile means that if you pull the power from the machine, then the data is lost.&lt;/li>
&lt;li>Volatile storage supports fast &lt;strong>random access&lt;/strong> with byte-addressable locations. This means that the program can jump to any byte address and get the data that is there.&lt;/li>
&lt;li>For our purposes, we will always refer to this storage class as “memory.”&lt;/li>
&lt;/ul>
&lt;p>Non-Volatile Devices:&lt;/p>
&lt;ul>
&lt;li>Non-volatile means that the storage device does not require continuous power in order for the device to retain the bits that it is storing.&lt;/li>
&lt;li>It is also block/page addressable. This means that &lt;strong>in order to read a value at a particular offset&lt;/strong>, the program &lt;strong>first has to load the 4 KB page into memory&lt;/strong> that holds the value the program wants to read.&lt;/li>
&lt;li>Non-volatile storage is &lt;strong>traditionally better at sequential access&lt;/strong> (reading multiple contiguous chunks of data at the same time).&lt;/li>
&lt;li>We will refer to this as “disk.” We will not make a (major) distinction between solid-state storage (SSD) and spinning hard drives (HDD).&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222153508116" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222153508116_hu2bfa840c291ed983668d96ded6216345_109474_09dd1725ed7f8adc8264af1eee03297d.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222153508116_hu2bfa840c291ed983668d96ded6216345_109474_86de3de50577edcb256e34e8562b58cb.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222153508116_hu2bfa840c291ed983668d96ded6216345_109474_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222153508116_hu2bfa840c291ed983668d96ded6216345_109474_09dd1725ed7f8adc8264af1eee03297d.webp"
width="746"
height="467"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h2 id="32-disk-oriented-dbms-overview">3.2 Disk-Oriented DBMS Overview&lt;/h2>
&lt;p>The database is &lt;strong>all on disk&lt;/strong>, and the data in database files is organized into pages, with the first page being the directory page.&lt;/p>
&lt;p>To operate on the data, the DBMS needs to bring the data into memory. It does this by &lt;strong>having a buffer pool&lt;/strong> that &lt;strong>manages the data movement back and forth&lt;/strong> between disk and memory&lt;/p>
&lt;p>The DBMS also has an &lt;strong>execution engine&lt;/strong> that will execute queries. The execution engine will &lt;strong>ask the buffer pool for a specific page&lt;/strong>, and the buffer pool will take care of bringing that page into memory and &lt;strong>giving the execution engine a pointer&lt;/strong> to that page in memory.&lt;/p>
&lt;p>The buffer pool manager will &lt;strong>ensure&lt;/strong> that &lt;strong>the page is there while the execution engine operates on that part of memory&lt;/strong>.&lt;/p>
&lt;h2 id="33-dbms-vs-os">3.3 DBMS vs OS&lt;/h2>
&lt;ul>
&lt;li>DBMS的一个&lt;strong>高级设计目标是支持超过可用内存量&lt;/strong>的数据库。因为访问disk的代价很大，所以使用disk应该要小心。我们不希望从磁盘上访问数据时停顿太久，从而拖慢其他一切。我们希望DBMS能够处理在等待从磁盘获取数据时，能够处理其他查询。&lt;/li>
&lt;li>这个高层次的设计目标就像虚拟内存一样，有一个大的地址空间和一个供操作系统从磁盘引入页面的地方。&lt;/li>
&lt;li>实现这种虚拟内存的方法之一是使用mmap来映射进程地址空间中的文件内容，这使得操作系统负责在磁盘和内存之间来回移动页面。 但不幸的是，如果&lt;strong>mmap遇到页面故障，进程将会被阻塞&lt;/strong>。
&lt;ul>
&lt;li>如果你需要写入，你永远不想在你的DBMS中使用mmap。&lt;/li>
&lt;li>DBMS（几乎）总是想自己控制事情，而且可以做得更好，因为它知道更多关于被访问的数据和被处理的查询。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>可以通过使用操作系统：
&lt;ul>
&lt;li>&lt;code>madvise&lt;/code>: 告诉操作系统你打算何时读某些页面。&lt;/li>
&lt;li>&lt;code>mlock&lt;/code>: 告诉操作系统不要把内存范围换到磁盘上。&lt;/li>
&lt;li>&lt;code>msync&lt;/code>: 告诉操作系统将内存范围刷新到磁盘。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>出于正确性和性能的考虑，我们不建议在DBMS中使用&lt;/strong>&lt;code>mmap&lt;/code>。&lt;/p>
&lt;h2 id="34-file-storage">3.4 File Storage&lt;/h2>
&lt;ul>
&lt;li>在其最基本的形式中，DBMS将&lt;strong>数据库存储为磁盘上的文件&lt;/strong>。有些可能使用文件层次结构，有些则可能使用单个文件&lt;/li>
&lt;li>操作系统对这些文件的内容一无所知。&lt;strong>只有DBMS知道如何解读它们的内容&lt;/strong>，因为它是以DBMS特有的方式编码的。&lt;/li>
&lt;li>DBMS的存储管理器负责管理数据库的文件。它将文件表示为一个 页的集合。它还跟踪哪些数据被读和写到了页面上，以及这些页面有多少可用空间。这些页面中还有多少可用空间。&lt;/li>
&lt;/ul>
&lt;h2 id="35-database-pages">3.5 Database Pages&lt;/h2>
&lt;ul>
&lt;li>DBMS将数据库组织在&lt;strong>一个或多个文件中的固定大小的数据块&lt;/strong>，称为页。页面可以包含不同种类的数据（tuple、indexes等）。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;ul>
&lt;li>大多数系统不会将这些类型混合在一页中。 有些系统会要求页面是自成一体（self-contained）的，也就是说，阅读每个页面所需的所有信息都在页面本身。读取每一页的所有信息都在页面本身&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;ul>
&lt;li>Each page is given a unique identifier.
&lt;ul>
&lt;li>The DBMS uses an indirection layer to map page IDs to physical locations.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>There are three different &lt;strong>notions&lt;/strong> of &amp;ldquo;pages&amp;rdquo; in a DBMS:&lt;/p>
&lt;ul>
&lt;li>Hardware Page (usually 4KB)&lt;/li>
&lt;li>OS Page (usually 4KB)&lt;/li>
&lt;li>Database Page (512B-16KB)&lt;/li>
&lt;/ul>
&lt;p>存储设备保证写的操作是atomic 原子的。 这意味着，如果我们的数据库页面比我们的硬件页面大，DBMS将不得不采取额外的措施 以确保数据被安全地写出来。 因为当系统崩溃时，程序可能已经完成了将数据库页面写入磁盘的一部分&lt;/p>
&lt;p>Different DBMSs manage pages in files on disk in different ways.&lt;/p>
&lt;ul>
&lt;li>Heap File Organization&lt;/li>
&lt;li>Tree File Organization&lt;/li>
&lt;li>Sequential / Sorted File Organization (ISAM)&lt;/li>
&lt;li>Hashing File Organization&lt;/li>
&lt;/ul>
&lt;p>At this point in the &lt;strong>hierarchy&lt;/strong>(层次结构) we don&amp;rsquo;t need to know anything about what is inside of the pages.&lt;/p>
&lt;h2 id="36-database-heap">3.6 Database Heap&lt;/h2>
&lt;p>A &lt;strong>heap file&lt;/strong> is an &lt;strong>unordered&lt;/strong> collection of pages with tuples that are stored in random order.&lt;/p>
&lt;ul>
&lt;li>Create / Get / Write / Delete Page&lt;/li>
&lt;li>Must also support iterating over all pages.&lt;/li>
&lt;/ul>
&lt;p>DBMS可以通过使用页面的链接列表或页面目录在磁盘上找到一个给定的页面ID&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Linked List: Header page持有指向自由页列表和数据页列表的指针。然而，如果 DBMS正在寻找一个特定的页面，它必须在数据页列表上进行顺序扫描，直到它找到它要找的页面。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Page Directory:&lt;/p>
&lt;p>DBMS维护特殊的页面，跟踪数据页的位置以及每页的可用空间。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222155657027" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222155657027_hue6ceeb2c876f7e8bb9567dc43df03885_128348_19e1f258c1eaffbced6c82db8733249f.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222155657027_hue6ceeb2c876f7e8bb9567dc43df03885_128348_c485bf2a46a3ac3c1a373535423f72ae.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222155657027_hue6ceeb2c876f7e8bb9567dc43df03885_128348_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222155657027_hue6ceeb2c876f7e8bb9567dc43df03885_128348_19e1f258c1eaffbced6c82db8733249f.webp"
width="760"
height="413"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222155526907" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222155526907_hu2514056af22ca82486386cbb9fdb114c_40697_179a9702190fbffc038bb147ea6b13d3.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222155526907_hu2514056af22ca82486386cbb9fdb114c_40697_3a0493d5dbdbc9057477b0943ccd7e23.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222155526907_hu2514056af22ca82486386cbb9fdb114c_40697_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222155526907_hu2514056af22ca82486386cbb9fdb114c_40697_179a9702190fbffc038bb147ea6b13d3.webp"
width="760"
height="214"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>Need &lt;strong>meta-data&lt;/strong> to keep track of what pages exist in multiple files and which ones have free space.&lt;/p>
&lt;h2 id="37-page-layout">3.7 Page Layout&lt;/h2>
&lt;ul>
&lt;li>每个页面都包括一个header，记录关于页面内容的元数据。
&lt;ul>
&lt;li>Page size&lt;/li>
&lt;li>Checksum&lt;/li>
&lt;li>DBMS version&lt;/li>
&lt;li>Transaction visibility&lt;/li>
&lt;li>Self-containment(自成一体) (Some systems like Oracle require this.)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>For any page storage architecture, we now need to decide &lt;strong>how to organize the data inside of the page.&lt;/strong>&lt;/p>
&lt;p>We are still assuming that we are only storing &lt;strong>tuples&lt;/strong>.&lt;/p>
&lt;p>Two approaches:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Tuple&lt;/strong>-oriented (其实是 &lt;strong>slotted-page&lt;/strong>)
&lt;ul>
&lt;li>页面将slots映射到offsets,slot array 记录对应tuple的便宜量&lt;/li>
&lt;li>Header keeps track of the number of used slots, the offset of the starting location of the last used slot, and a slot array, which keeps track of the location of the start of each tuple.&lt;/li>
&lt;li>To add a tuple, the slot array will grow from the beginning to the end, and the data of the tuples will grow from end to the beginning. The page is considered full when the slot array and the tuple data meet&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Log-structured&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222161048229" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161048229_hub44ae70f4f7c00c2718018a74f4c1d06_119403_a6fd6f2414dd48c987770212b2738c6c.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161048229_hub44ae70f4f7c00c2718018a74f4c1d06_119403_8f4f905424d552352ad3eae80f9367af.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161048229_hub44ae70f4f7c00c2718018a74f4c1d06_119403_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161048229_hub44ae70f4f7c00c2718018a74f4c1d06_119403_a6fd6f2414dd48c987770212b2738c6c.webp"
width="760"
height="412"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h2 id="38-tuple-layout">3.8 Tuple Layout&lt;/h2>
&lt;p>tuple 内部的结构&lt;/p>
&lt;p>tuples本质上是一个字节序列。DBMS的工作是将这些字节解释为属性类型和值。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Tuple Header：包含了tuple的元数据&lt;/p>
&lt;ul>
&lt;li>DBMS的并发控制协议的可见性信息。关于哪个事务创建/修改了该元组&lt;/li>
&lt;li>NULL值的位图。&lt;/li>
&lt;li>注意，DBMS不需要在这里存储关于数据库模式的元数据。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Tuple Data：数据的实际属性&lt;/p>
&lt;ul>
&lt;li>属性通常按照你创建表时指定的顺序存储&lt;/li>
&lt;li>大多数DBMS不允许一个tuple超过一个页面的大小。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Unique Identifier&lt;/p>
&lt;ul>
&lt;li>数据库中的每个tuple都被分配一个唯一的标识符&lt;/li>
&lt;li>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222161450033" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161450033_hu3bd19195469812a461a7fa0e1b7190f8_46490_e95fc6290195b3eb2c3331929231fd6e.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161450033_hu3bd19195469812a461a7fa0e1b7190f8_46490_e384fcb96492f2d64c31cba4265d83d8.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161450033_hu3bd19195469812a461a7fa0e1b7190f8_46490_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161450033_hu3bd19195469812a461a7fa0e1b7190f8_46490_e95fc6290195b3eb2c3331929231fd6e.webp"
width="315"
height="415"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/li>
&lt;li>一般是：&lt;code>page_id + (offset or slow)&lt;/code>&lt;/li>
&lt;li>一个应用程序&lt;strong>不能&lt;/strong>依赖这些ID来表示任何东西&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>De-normalized Tuple Data:&lt;/p>
&lt;p>如果两个表是相关的，DBMS可以 &amp;ldquo;pre-join&amp;quot;它们，所以这些表最终会出现在 在同一个页面上。这使得读取速度加快，因为DBMS只需要加载一个页面而不是两个 独立的页面。然而，这使得更新更加昂贵，因为DBMS需要更多的空间给每个 tuples&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222161346650" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161346650_hu37427914b57f6d5043c3ef126690e110_173412_a754a7e3373b1eff757670a5400a061e.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161346650_hu37427914b57f6d5043c3ef126690e110_173412_0911b0c56d26d1b17e1b5084d21fb464.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161346650_hu37427914b57f6d5043c3ef126690e110_173412_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161346650_hu37427914b57f6d5043c3ef126690e110_173412_a754a7e3373b1eff757670a5400a061e.webp"
width="760"
height="401"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="39-log-structured-storage">3.9 Log-Structured Storage&lt;/h2>
&lt;p>（也叫Append-only Sequence of Data） 参考: &lt;a href="https://www.cnblogs.com/muzhongjiang/p/15151758.html" target="_blank" rel="noopener">Log-Structured 结构&lt;/a>&lt;/p>
&lt;ul>
&lt;li>与Slotted-Page Design有关的问题是：
&lt;ul>
&lt;li>
&lt;p>Fragmentation: 删除tuple会在page中留下空隙。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Useless Disk I/O:&lt;/p>
&lt;p>由于非易失性存储的block-oriented的性质，需要读取整个块来获取tuple。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Random Disk I/O: 磁盘阅读器可能不得不跳到20个不同的地方来更新20个不同的tuples，这可能会非常慢。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>如果我们在一个&lt;strong>只允许创建新数据而不允许覆盖&lt;/strong>的系统上工作呢？日志结构的存储模型与这个假设相配合，解决了上面列出的一些问题。&lt;/p>
&lt;p>&lt;strong>Log-Structured Storage:&lt;/strong> DBMS不存储tuples，&lt;strong>只存储日志记录&lt;/strong>。&lt;/p>
&lt;ul>
&lt;li>将数据库如何被修改的记录存储到文件中（放入和删除）。每条日志包含tuples的唯一标识符&lt;/li>
&lt;li>要读取一条记录，DBMS会&lt;strong>从最新的到最旧的逆向扫描日志文件&lt;/strong>，并 &amp;ldquo;重新创建 &amp;ldquo;这个 tuple。&lt;/li>
&lt;li>写的快，读的可能慢。磁盘写入是连续的，现有的页面是不可改变的，这导致了随机磁盘I/O的减少。&lt;/li>
&lt;li>在append-only的存储上工作得很好，因为DBMS不能回溯并更新数据。&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222161821846" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161821846_hua80a0ff1847a6d1a6c9d3b75314bb106_64825_2925de20dcd852f9471f48dabd0fcb23.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161821846_hua80a0ff1847a6d1a6c9d3b75314bb106_64825_00586507062e203fe557843ecc7f1243.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161821846_hua80a0ff1847a6d1a6c9d3b75314bb106_64825_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161821846_hua80a0ff1847a6d1a6c9d3b75314bb106_64825_2925de20dcd852f9471f48dabd0fcb23.webp"
width="424"
height="434"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>The log will grow forever. The DBMS needs to periodically &lt;strong>compact&lt;/strong>(紧凑) pages to reduce wasted space.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222161836461" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161836461_hub1621e620434fb3b865eb5d8264521d8_64617_c2cf10f301cf5187656ce3f081399858.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161836461_hub1621e620434fb3b865eb5d8264521d8_64617_bfd0edee3f66195e04817c5518a68003.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161836461_hub1621e620434fb3b865eb5d8264521d8_64617_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161836461_hub1621e620434fb3b865eb5d8264521d8_64617_c2cf10f301cf5187656ce3f081399858.webp"
width="760"
height="276"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;ul>
&lt;li>由于不再需要时间信息，数据库可以&lt;strong>将日志压缩到一个按id排序的表&lt;/strong>中。这些被称为分类字符串表（SSTables），它们可以使tuple搜索非常快。&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222161958064" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161958064_hu853b98a7ab66e59b808393c705129b31_31074_1b4c2521981b41a66e203eaaadb83c6b.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161958064_hu853b98a7ab66e59b808393c705129b31_31074_dad1be2109155288503ef62dd1a9cd30.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161958064_hu853b98a7ab66e59b808393c705129b31_31074_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161958064_hu853b98a7ab66e59b808393c705129b31_31074_1b4c2521981b41a66e203eaaadb83c6b.webp"
width="350"
height="325"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;ul>
&lt;li>紧凑化的问题是，DBMS最终会出现写入放大的情况。(&lt;strong>它一次又一次地重写相同的数据&lt;/strong>）。&lt;/li>
&lt;/ul>
&lt;p>Compaction coalesces larger log files into smaller files by removing unnecessary records.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222162056924" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222162056924_hu94b5ec96540e02aacf1a9c4b3c0322af_57974_acfb438b8cbb51498683bf00bf750498.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222162056924_hu94b5ec96540e02aacf1a9c4b3c0322af_57974_c3c50f7856f5ce4ae6704e9031d1a8c1.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222162056924_hu94b5ec96540e02aacf1a9c4b3c0322af_57974_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222162056924_hu94b5ec96540e02aacf1a9c4b3c0322af_57974_acfb438b8cbb51498683bf00bf750498.webp"
width="760"
height="234"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>Log-structured storage managers are more common today. This is partly due to the &lt;strong>proliferation&lt;/strong>(扩散) of RocksDB.&lt;/p>
&lt;h2 id="311-data-representation">3.11 Data Representation&lt;/h2>
&lt;p>A tuple is essentially a sequence of bytes.&lt;/p>
&lt;p>It&amp;rsquo;s the job of the DBMS to &lt;strong>interpret&lt;/strong> those bytes into attribute types and values.&lt;/p>
&lt;p>The DBMS&amp;rsquo;s &lt;strong>catalogs&lt;/strong>(目录) contain the schema information about tables(数据表示方案) that the system uses to figure out the tuple&amp;rsquo;s layout.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222162403262" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222162403262_hu70eda27e5caa1f7624547d63d7ed8d9b_93868_badd799e61d26959ac3480d2740cf2b7.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222162403262_hu70eda27e5caa1f7624547d63d7ed8d9b_93868_9db2e901358ffcc4e60ebb67fda9624d.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222162403262_hu70eda27e5caa1f7624547d63d7ed8d9b_93868_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222162403262_hu70eda27e5caa1f7624547d63d7ed8d9b_93868_badd799e61d26959ac3480d2740cf2b7.webp"
width="640"
height="327"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;ul>
&lt;li>&lt;strong>INTEGER, BIGINT, SMALLINT, TINYINT.&lt;/strong> (Integers)大多数DBMS使用IEEE-754标准规定的 &amp;ldquo;native &amp;ldquo;C/C++类型来存储整数。这些值是&lt;strong>固定长度&lt;/strong>的。&lt;/li>
&lt;li>&lt;strong>FLOAT, REAL&lt;/strong> (Variable Precision Numbers) 这些是不精确的、可变精度的数字类型, &amp;ldquo;native &amp;ldquo;C/C++类型,这些值也是&lt;strong>固定长度&lt;/strong>的。
&lt;ul>
&lt;li>&lt;strong>变精度数的运算比任意精度数的运算更快&lt;/strong>，因为CPU可以直接对其执行指令。然而，在进行计算时&lt;strong>可能会出现精度损失&lt;/strong>！&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>NUMERIC, DECIMAL.&lt;/strong>(Fixed-Point Precision Numbers) 通常&lt;strong>以精确的、可变长度&lt;/strong>的二进制表示法（像一个字符串）来存储.带有&lt;strong>额外的元数据&lt;/strong>，这些数据将告诉系统诸如&lt;strong>数据的长度和小数点应该在哪里&lt;/strong>。&lt;/li>
&lt;li>当误差不可接受的时候，DBMS就要付出性能的代价来提高精度。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>VARCHAR, VARBINARY, TEXT, BLOB&lt;/strong> Variable-Length Data&lt;/p>
&lt;ul>
&lt;li>代表任意长度的数据类型。它们通常是用一个header来存储的，这个header可以追踪到字符串的长度，以便于跳转到下一个值。它还可能包含一个数据的校验和。&lt;/li>
&lt;li>&lt;strong>大多数DBMS不允许一个tuple超过一个页面的大小。&lt;/strong> &lt;strong>但是！那些允许的系统将数据存储在一个特殊的 &amp;ldquo;溢出 &amp;ldquo;页&lt;/strong>上，并让tuple包含一个对该页的引用。这些溢出页可以包含指向其他溢出页的指针，直到所有的数据都可以被存储。(类似分级页表)&lt;/li>
&lt;li>有些系统会让你把这些大的数值存储在一个外部文件中，然后元组会包含一个指向该文件的指针。例如，如果数据库存储的是照片信息，DBMS可以将照片存储在外部文件中，而不是让它们占用DBMS中的大量空间。这样做的一个缺点是，DBMS&lt;strong>不能操作这个文件的内容&lt;/strong>。因此，No durability protections. No transaction protections.没有耐久性或交易保护。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>TIME, DATE, TIMESTAMP.&lt;/strong> Dates and Times 不同的系统对日期/时间的表示方法不同。通常情况下，它们被表示为一些单位时间 (自unix时代的（微/毫）秒）。&lt;/p>
&lt;p>&lt;strong>System Catalogs&lt;/strong>&lt;/p>
&lt;p>为了使DBMS能够识别tuple的内容，它维护了 INFORMATION_SCHEMA&lt;strong>内部目录&lt;/strong>来告诉它关于数据库的元数据。&lt;strong>元数据将包含关于数据库有哪些表和列的信息&lt;/strong>，以及它们的类型和值的顺序。&lt;/p>
&lt;p>大多数DBMS将其目录以其表的格式存储在自己的内部。他们使用 特殊代码来 &amp;ldquo;bootstrap &amp;ldquo;这些目录表。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222163207453" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222163207453_hu1de67d00dd19777e263b680b12012894_58781_72c0389207336ff887aa4ac718aef10b.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222163207453_hu1de67d00dd19777e263b680b12012894_58781_d8d8d09727a46772250e13fef7222bf5.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222163207453_hu1de67d00dd19777e263b680b12012894_58781_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222163207453_hu1de67d00dd19777e263b680b12012894_58781_72c0389207336ff887aa4ac718aef10b.webp"
width="651"
height="380"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222163222109" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222163222109_hucc8f4beb738041586f0e722c881afc7a_61914_602903fb3f3eac4fe1e67a69f5be2ced.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222163222109_hucc8f4beb738041586f0e722c881afc7a_61914_52129ab6a3c2ed22b595f15cf049d390.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222163222109_hucc8f4beb738041586f0e722c881afc7a_61914_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222163222109_hucc8f4beb738041586f0e722c881afc7a_61914_602903fb3f3eac4fe1e67a69f5be2ced.webp"
width="661"
height="367"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h1 id="l5-storage-models--compression">L5 Storage Models &amp;amp; Compression&lt;/h1>
&lt;h2 id="51-database-workloads">5.1 Database Workloads&lt;/h2>
&lt;p>OLTP: Online Transaction Processing&lt;/p>
&lt;ul>
&lt;li>
&lt;p>An OLTP workload is characterized by &lt;strong>fast, short running operations&lt;/strong>, simple queries that &lt;strong>operate on single entity at a time&lt;/strong>, and &lt;strong>repetitive operations&lt;/strong>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>An OLTP workload will typically handle &lt;strong>more writes than reads&lt;/strong>.&lt;/p>
&lt;blockquote>
&lt;p>An example of an OLTP workload is the Amazon storefront. Users can add things to their cart, they can make purchases, but the actions only affect their account.&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ul>
&lt;p>OLAP: Online Analytical Processing&lt;/p>
&lt;ul>
&lt;li>
&lt;p>An OLAP workload is characterized by &lt;strong>long running(长期运行), complex queries, reads on large portions&lt;/strong> of the database.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>In OLAP workloads, the database system is analyzing and &lt;strong>deriving&lt;/strong>(推导/添加) new data from existing data collected on the OLTP side.&lt;/p>
&lt;blockquote>
&lt;p>An example of an OLAP workload would be Amazon computing the most bought item in Pittsburgh on a day when its raining.&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ul>
&lt;p>HTAP: Hybrid Transaction + Analytical Processing&lt;/p>
&lt;p>A new type of workload which has become popular recently is HTAP, which is like &lt;strong>a combination which tries to do OLTP and OLAP together&lt;/strong> on the same database.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222165717923" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222165717923_hub0e80189cc2c5cb3a5257af30c0344c9_131577_0292e6a043d9305c6b098fefcb4dc65d.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222165717923_hub0e80189cc2c5cb3a5257af30c0344c9_131577_1519b8a1f5640119d79da7b248547314.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222165717923_hub0e80189cc2c5cb3a5257af30c0344c9_131577_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222165717923_hub0e80189cc2c5cb3a5257af30c0344c9_131577_0292e6a043d9305c6b098fefcb4dc65d.webp"
width="760"
height="421"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h2 id="52-storage-models">5.2 Storage Models&lt;/h2>
&lt;h3 id="n-ary-storage-model-nsm">N-Ary Storage Model (NSM)&lt;/h3>
&lt;p>In the n-ary storage model, the DBMS &lt;strong>stores all of the attributes for a single tuple contiguously in a single page&lt;/strong>&lt;/p>
&lt;p>This approach is &lt;strong>ideal for OLTP workloads&lt;/strong> where requests are insert-heavy and transactions tend to operate only an individual entity.&lt;/p>
&lt;p>It is ideal because it takes only one fetch to be able to get all of the attributes for a single tuple.&lt;/p>
&lt;p>Advantages:&lt;/p>
&lt;ul>
&lt;li>Fast inserts, updates, and deletes.&lt;/li>
&lt;li>Good for queries that need the entire tuple.&lt;/li>
&lt;/ul>
&lt;p>Disadvantages:&lt;/p>
&lt;ul>
&lt;li>Not good for &lt;strong>scanning large portions of the table&lt;/strong> and/or &lt;strong>a subset of the attributes.&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222164813494" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222164813494_huba6e0bab0a29c92faf18ea4e71a32e29_109880_c9725ffe5d520ec47aac014c07067a7a.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222164813494_huba6e0bab0a29c92faf18ea4e71a32e29_109880_e35880066c5994e6f0c71713fa0c4c6d.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222164813494_huba6e0bab0a29c92faf18ea4e71a32e29_109880_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222164813494_huba6e0bab0a29c92faf18ea4e71a32e29_109880_c9725ffe5d520ec47aac014c07067a7a.webp"
width="684"
height="464"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="decomposition-分解-storage-model-dsm">Decomposition 分解 Storage Model (DSM)&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222165051507" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222165051507_hu9c03f1f657567e7c08df7e4576dd36b4_88960_0c0e1f70958b4350817e058ba88859a2.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222165051507_hu9c03f1f657567e7c08df7e4576dd36b4_88960_84ee7de04f474641008f5079f01fa063.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222165051507_hu9c03f1f657567e7c08df7e4576dd36b4_88960_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222165051507_hu9c03f1f657567e7c08df7e4576dd36b4_88960_0c0e1f70958b4350817e058ba88859a2.webp"
width="712"
height="388"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>This model is &lt;strong>ideal for OLAP&lt;/strong> workloads with many read-only queries that perform large scans over a subset of the table’s attributes.&lt;/p>
&lt;p>Advantages:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Reduces the amount of I/O wasted&lt;/strong> because the DBMS only reads the data that it needs for that query.&lt;/li>
&lt;li>Better query processing and data compression&lt;/li>
&lt;/ul>
&lt;p>Disadvantages:&lt;/p>
&lt;ul>
&lt;li>Slow for point queries, inserts, updates, and deletes because of tuple splitting/&lt;strong>stitching&lt;/strong>(缝合).&lt;/li>
&lt;/ul>
&lt;p>To &lt;strong>put the tuples back together&lt;/strong> when using a column store,there are two common approaches:&lt;/p>
&lt;p>fixed-length offsets(most common): Each value is the same length for an attribute&lt;/p>
&lt;p>Embedded Tuple Ids:Each value is stored with its tuple id in a column&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222165430923" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222165430923_hu884be268e032fdeb7a677f672b846f24_81619_b2995747ad547db94d64a161da8089db.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222165430923_hu884be268e032fdeb7a677f672b846f24_81619_1a31b3560becd543e3983206645f3cf7.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222165430923_hu884be268e032fdeb7a677f672b846f24_81619_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222165430923_hu884be268e032fdeb7a677f672b846f24_81619_b2995747ad547db94d64a161da8089db.webp"
width="760"
height="377"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h2 id="53-database-compression">5.3 Database Compression&lt;/h2>
&lt;blockquote>
&lt;ul>
&lt;li>
&lt;p>压缩操作被在&lt;strong>disk-based&lt;/strong> DBMSs广泛应用。因为disk的I/O总是瓶颈，所以压缩可以让系统提升性能，尤其是只读analyt Managical workloads上。&lt;/p>
&lt;p>如果事先对tuples进行了压缩，DBMS可以获取更多有用的tuple，但代价是要付出更大的压缩和解压的计算开销。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>内存中的DBMS更加复杂，因为它们不必从磁盘中获取数据来执行一个查询。 内存比磁盘快得多，但压缩数据库可以减少DRAM需求和处理。&lt;/p>
&lt;p>而且必须在速度和压缩率中取得一个平衡。压缩数据库可以减少DRAM的需求和查询执行过程中的CPU成本。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果数据集是完全随机的bits，那么我们没有办法进行压缩。然而，现实世界中的数据集有一些key properties 是可以进行压缩的。&lt;/p>
&lt;ul>
&lt;li>数据集往往具有高度倾斜的属性值分布（例如，Brown语料库的Zipfian分布）。&lt;/li>
&lt;li>数据集往往在同一元组的属性之间有很高的相关性（例如，邮政编码到城市。订单日期与发货日期）。 Manag&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Given this, we want a database compression scheme to have the following properties:&lt;/p>
&lt;ul>
&lt;li>Must produce &lt;strong>fixed-length values&lt;/strong>. The only exception is var-length data stored in separate pools. This because the DBMS should follow word-&lt;strong>alignment&lt;/strong>(对齐) and be able to access data using offsets.&lt;/li>
&lt;li>Allow the DBMS to &lt;strong>postpone&lt;/strong>(推迟) decompression as long as possible during query execution (late materialization).&lt;/li>
&lt;li>Must be &lt;strong>a lossless scheme&lt;/strong> because people do not like losing data. Any kind of lossy compression has to be performed at the application level.&lt;/li>
&lt;/ul>
&lt;h3 id="compression-granularity">Compression Granularity&lt;/h3>
&lt;p>在给DBMS增加压缩功能之前，我们需要决定我们要压缩什么样的数据。这个决定决定了压缩方案的可用性。有四个级别的压缩 Manag颗粒度（granularity）&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Block Level: 压缩同一张表的tuple块。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Tuple Level: 压缩整个tuples的内容（仅NSM）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Attribute Level: 在一个tuple内压缩单个属性值。可以针对同一tuple的多个属性。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Columnar Level:&lt;/p>
&lt;p>为多个tuple存储的一个或多个属性压缩多个值 (只限于DSM)。这允许更复杂的压缩方案。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="54-naive-compression">5.4 Naive Compression&lt;/h2>
&lt;p>DBMS使用一个&lt;strong>通用的算法&lt;/strong>对数据进行压缩 (e.g., gzip, LZO, LZ4, Snappy, Brotli, Oracle OZIP, Zstd)。 尽管DBMS可以使用几种压缩算法，但工程师们往往选择那些经常提供较低压缩率以换取更快的压缩/解压的算法。&lt;/p>
&lt;p>naive compression例子： &lt;strong>MySQL InnoDB&lt;/strong>&lt;/p>
&lt;p>DBMS对磁盘页面进行压缩，将其压缩到2KB的幂数，并将其存储到缓冲池中。然而，每次DBMS试图读取数据时，缓冲池中的压缩数据必须被解压&lt;/p>
&lt;p>缺点:&lt;/p>
&lt;ul>
&lt;li>由于访问数据&lt;strong>需要对压缩的数据进行解压&lt;/strong>，这就限制了压缩方案的范围。 如果目标是将整个表压缩成一个巨大的块，使用naive compression 方案是不可能的，因为每次访问都需要对整个表进行压缩/解压缩。 因此，对于MySQL来说，由于压缩范围有限，它将表分解成更小的块状。&lt;/li>
&lt;li>naive方案也没有考虑到数据的高级含义或语义。 该算法既不考虑数据的结构，也不考虑查询打算如何访问 数据。因此，这就&lt;strong>失去了利用late materialization 的机会&lt;/strong>，因为DBMS不能知道它何时能够延迟数据的解压。&lt;/li>
&lt;/ul>
&lt;h2 id="55-columnar-compression-柱状压缩">5.5 Columnar Compression 柱状压缩**&lt;/h2>
&lt;h3 id="run-length-encoding">Run-length Encoding&lt;/h3>
&lt;p>Compress runs of the same value in a single column into triplets:&lt;/p>
&lt;ul>
&lt;li>The value of the attribute.&lt;/li>
&lt;li>The start position in the column segment.&lt;/li>
&lt;li>The # of elements in the run.&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222170534215" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222170534215_hua4e94f5df4190ac6a4cb2081ee5bae21_52535_205fac9c1d51344ba77ad176c2aa57d7.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222170534215_hua4e94f5df4190ac6a4cb2081ee5bae21_52535_7c1f361f36253fa4c36314fb1dc5291d.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222170534215_hua4e94f5df4190ac6a4cb2081ee5bae21_52535_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222170534215_hua4e94f5df4190ac6a4cb2081ee5bae21_52535_205fac9c1d51344ba77ad176c2aa57d7.webp"
width="727"
height="383"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>Requires the columns to be sorted &lt;strong>intelligently&lt;/strong>(智能) to maximize compression opportunities.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222170706032" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222170706032_hua84612ef4007d4d9946188cfd8be97bb_36555_064b5f70fed9b64ec4039b8dc8cff6b5.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222170706032_hua84612ef4007d4d9946188cfd8be97bb_36555_a76950044ff733e9d5d314b23132fd6c.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222170706032_hua84612ef4007d4d9946188cfd8be97bb_36555_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222170706032_hua84612ef4007d4d9946188cfd8be97bb_36555_064b5f70fed9b64ec4039b8dc8cff6b5.webp"
width="693"
height="406"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="bit-packing-encoding">Bit-Packing Encoding&lt;/h3>
&lt;p>When values for an attribute are &lt;strong>always less than the value&amp;rsquo;s declared largest size,&lt;/strong> &lt;strong>store them as smaller data type&lt;/strong>.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222170800172" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222170800172_hu46b31a996c3f521c96953fd3435620cc_45759_a9f1efec0e024234e7aaefe39722348b.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222170800172_hu46b31a996c3f521c96953fd3435620cc_45759_8042099dbf818e90140c64761452fefb.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222170800172_hu46b31a996c3f521c96953fd3435620cc_45759_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222170800172_hu46b31a996c3f521c96953fd3435620cc_45759_a9f1efec0e024234e7aaefe39722348b.webp"
width="760"
height="189"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>Bit-packing variant that uses a &lt;strong>special marker&lt;/strong> to indicate when a value exceeds largest size and then maintain a look-up table to store them.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222170818530" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222170818530_hu97c6f66a875eded62edadc7467f078a1_46217_2eb479e5b8191b0f95d3234bcb4ad1bc.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222170818530_hu97c6f66a875eded62edadc7467f078a1_46217_a8ee8ad03b3461e63dbce31825e184fd.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222170818530_hu97c6f66a875eded62edadc7467f078a1_46217_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222170818530_hu97c6f66a875eded62edadc7467f078a1_46217_2eb479e5b8191b0f95d3234bcb4ad1bc.webp"
width="760"
height="187"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="bitmap-encoding">Bitmap Encoding&lt;/h3>
&lt;p>Store a separate bitmap for each unique value for an attribute where &lt;strong>an offset in the vector corresponds to a tuple.&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>The i th position in the Bitmap corresponds to the i th tuple in the table.&lt;/li>
&lt;li>Typically segmented into chunks to avoid allocating large blocks of contiguous memory. Only practical &lt;strong>if the value cardinality(基数) is low&lt;/strong>. Some DBMSs provide bitmap indexes.&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222171138540" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222171138540_huab479fb3d05c1d9c70bb01c8efde26f2_64903_cafe57d1b3648b09128cc49a5ff8d6bc.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222171138540_huab479fb3d05c1d9c70bb01c8efde26f2_64903_201d70af675d42e783e8b5b81b093844.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222171138540_huab479fb3d05c1d9c70bb01c8efde26f2_64903_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222171138540_huab479fb3d05c1d9c70bb01c8efde26f2_64903_cafe57d1b3648b09128cc49a5ff8d6bc.webp"
width="760"
height="387"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="delta-encoding">Delta Encoding&lt;/h3>
&lt;p>&lt;strong>Recording the difference&lt;/strong> between values that follow each other in the same column.&lt;/p>
&lt;ul>
&lt;li>Store base value in-line or in a separate look-up table.&lt;/li>
&lt;li>&lt;strong>Combine with RLE to get even better compression ratios.&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222171254392" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222171254392_hu4544ac5a826f509c4a673c460def9e0a_55990_331f471414a83ff3627dfa2947d69f3e.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222171254392_hu4544ac5a826f509c4a673c460def9e0a_55990_221ed394c99859231a398861ca0b947d.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222171254392_hu4544ac5a826f509c4a673c460def9e0a_55990_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222171254392_hu4544ac5a826f509c4a673c460def9e0a_55990_331f471414a83ff3627dfa2947d69f3e.webp"
width="760"
height="230"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="incremental-encoding">Incremental Encoding&lt;/h3>
&lt;p>Type of delta encoding that &lt;strong>avoids duplicating common prefixes/suffixes between consecutive tuples&lt;/strong>. This works best with sorted data.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222171338403" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222171338403_hu7a5d9e6f86d19720fec133f61e26c137_73268_c5451d5937c6ba6a785ee7b45203b98d.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222171338403_hu7a5d9e6f86d19720fec133f61e26c137_73268_c74575a2c57aff662bede8e943f027a9.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222171338403_hu7a5d9e6f86d19720fec133f61e26c137_73268_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222171338403_hu7a5d9e6f86d19720fec133f61e26c137_73268_c5451d5937c6ba6a785ee7b45203b98d.webp"
width="760"
height="212"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="dictionary-encoding">Dictionary Encoding&lt;/h3>
&lt;p>Build a data structure that &lt;strong>maps variable-length values to a smaller integer identifier.&lt;/strong>&lt;/p>
&lt;p>Replace those values with their corresponding identifier in the dictionary data structure.&lt;/p>
&lt;ul>
&lt;li>Need to support fast encoding and decoding.
&lt;ul>
&lt;li>Encode/Locate: For a given uncompressed value, convert it into its compressed form.&lt;/li>
&lt;li>Decode/Extract: For a given compressed value, convert it back into its original form.&lt;/li>
&lt;li>No magic hash function will do this for us.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Need to also support range queries.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Most widely used compression scheme in DBMSs.&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222171632448" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222171632448_hu85d19909300784701cd1e9eb06f25528_107171_4ff0b43f8b662b8b02b04023a05900b5.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222171632448_hu85d19909300784701cd1e9eb06f25528_107171_46026c2a80f2ac66b89e41dd7a419b8b.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222171632448_hu85d19909300784701cd1e9eb06f25528_107171_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222171632448_hu85d19909300784701cd1e9eb06f25528_107171_4ff0b43f8b662b8b02b04023a05900b5.webp"
width="760"
height="357"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h1 id="homework-2-storage--indexeshttps15445coursescscmuedufall2022fileshw2-cleanpdf">Homework #2 &lt;a href="https://15445.courses.cs.cmu.edu/fall2022/files/hw2-clean.pdf" target="_blank" rel="noopener">Storage &amp;amp; Indexes&lt;/a>&lt;/h1>
&lt;h2 id="question-1-storage-models">Question 1: Storage Models&lt;/h2>
&lt;p>a database with a single table &lt;strong>R(q_id,txns,total,failed)&lt;/strong>, where q_id is the &lt;strong>primary key&lt;/strong>, and &lt;strong>all attributes are the same fixed width.&lt;/strong>&lt;/p>
&lt;p>Suppose R has 20,000 tuples that fit into 100 pages, &lt;strong>Ignore any additional storage&lt;/strong> overhead for the table (e.g., page headers, tuple headers).&lt;/p>
&lt;p>Assumptions:&lt;/p>
&lt;ul>
&lt;li>The DBMS does &lt;strong>not have any additional meta-data&lt;/strong> (e.g., sort order, zone maps).&lt;/li>
&lt;li>R does &lt;strong>not have any indexes&lt;/strong> (including for primary key q_id)&lt;/li>
&lt;li>&lt;strong>None&lt;/strong> of R’s pages are already &lt;strong>in the buffer pool&lt;/strong>.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SELECT total - failed FROM R
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">WHERE q id = 96 AND txns &amp;gt; 420;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="a-suppose-the-dbms-uses-the-decomposition-storage-model-dsm-with-implicit-offsets">(a) Suppose the DBMS uses the decomposition storage model (DSM) with implicit offsets&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>i What is the &lt;strong>minimum number of pages&lt;/strong> that the DBMS will potentially have to read from disk to answer this query?&lt;/p>
&lt;p>题意是存在这样一条记录,找到该条记录最少的磁盘读次数.&lt;/p>
&lt;p>官方解答是: 4 pages. 1 to find the primary key, + 3 to access txns, total, failed at their corresponding offsets.&lt;/p>
&lt;p>因为使用分解存储模式DSM, 按列存储.&lt;/p>
&lt;p>因此找到主键后就可以通过偏移量找其他属性的值. 读盘次数的限制在找主键上.&lt;/p>
&lt;p>显然,找主键至少需要一次读盘.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ii What is the &lt;strong>maximum number of pages&lt;/strong> that the DBMS will potentially have to read from disk to answer this query?&lt;/p>
&lt;p>官方解答: 28 pages. &lt;strong>There are 25 pages per attribute.&lt;/strong> In the worst case, we scan through all 25 pages to find the primary key, and then + 3 to access txns, total, failed at their corresponding offsets.&lt;/p>
&lt;p>上题可知,找主键次数决定了读盘次数.&lt;/p>
&lt;p>也就是当q_id = 96的记录越靠后, 找主键次数越多.&lt;/p>
&lt;p>因为没有顺序,所以96是无用的信息.&lt;/p>
&lt;p>同时因为&lt;strong>有四个属性,且所有属性大小固定&lt;/strong>. 所以当每个属性都占25页时,且q_id=26所在的记录是最后一个(25),找主键次数最大为25次.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="bsuppose-the-dbms-uses-the-n-ary-storage-model-nsm">(b)Suppose the DBMS uses the N-ary storage model (NSM)&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>i. What is the minimum number of pages that the DBMS will potentially have to read from disk to answer this query?&lt;/p>
&lt;p>Solution: We find the tuple with the matching primary key on the first page. No need to look in other pages since all attributes are stored together.&lt;/p>
&lt;p>在第一页&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ii. [4 points] What is the maximum number of pages that the DBMS will potentially have to read from disk to answer this query?&lt;/p>
&lt;p>在最后一页 100&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="question-2-cuckoo-hashing">Question 2: Cuckoo Hashing&lt;/h2>
&lt;p>几道哈希表计算的题目,较简单&lt;/p>
&lt;p>2进制：0b，8进制：0o，10进制：无前缀，16进制：0x&lt;/p>
&lt;h2 id="question-3-extendible-hashing">Question 3: Extendible Hashing&lt;/h2>
&lt;p>Consider an extendible hashing structure such that:&lt;/p>
&lt;ul>
&lt;li>Each bucket can hold up to two records.&lt;/li>
&lt;li>The hashing function uses the lowest g bits, where g is the global depth.&lt;/li>
&lt;/ul>
&lt;p>题目是一个二进制可扩展哈希. 哈希函数是二进制最低g位.&lt;/p>
&lt;p>每个哈希值对应一个桶, 每个桶最多两个, 所有刚好就是二进制.&lt;/p>
&lt;h3 id="a-starting-from-an-empty-table-insert-keys-15-14-23-11-9">(a) Starting from an empty table, insert keys 15, 14, 23, 11, 9.&lt;/h3>
&lt;p>二进制表示&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">15: 00001111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">14: 00001110
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">23: 00010111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">11: 00001011
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">9 : 00001001
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>插入步骤(括号内为局部深度,全局深度为最大局部深度)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">插入15
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">全局: 1; 桶 1(1):15
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">14
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">全局: 1; 桶 1(1):15 ; 0(1):14
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">23
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">全局: 1; 桶 1(1):15,23; 0(1):14
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">11
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">全局: 1; 桶 1(1):15,23,11; 0(1):14
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">桶1此时有三条记录,需要扩展深度,扩展为2
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">全局: 2; 桶 11(2):15,23,11; 01(2):; 0(1):14
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">桶11此时有三条记录,需要扩展深度,扩展为3
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">全局: 3; 桶 111(3):15,23; 011(3):11;01(2):; 0(1):14
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">9
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">全局: 3; 桶 111(3):15,23; 011(3):11; 0(1):14; 01(2):9;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>
&lt;p>i. What is the global depth of the resulting table?&lt;/p>
&lt;p>显然,当g至少等于3的时候才能使得同一个哈希值最多对应两个记录.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ii. [4 points] What is the local depth the bucket containing 15?&lt;/p>
&lt;p>为3&lt;/p>
&lt;/li>
&lt;li>
&lt;p>iii. [4 points] What is the local depth of the bucket containing 14?&lt;/p>
&lt;p>为1&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="b-starting-from-the-result-in-a-you-insert-keys-12-5-7-13-2">(b) Starting from the result in (a), you insert keys 12, 5, 7, 13, 2.&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">15: 00001111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">14: 00001110
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">23: 00010111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">11: 00001011
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">9 : 00001001
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">此时 全局: 3; 桶 111(3):15,23; 011(3):11; 0(1):14; 01(2):9;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">12: 00001010
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">5 : 00000101
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">7 : 00000111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">13: 00001101
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">2 : 00000010
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">12
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">全局: 3; 桶 111(3):15,23; 011(3):11; 0(1):14,12; 01(2):9;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">5
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">全局: 3; 桶 111(3):15,23; 011(3):11; 0(1):14,12; 01(2):9;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">7
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">全局: 3; 桶 111(3):15,23; 011(3):11; 0(1):14,12; 1(1):9,5;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">此时111桶有3个,增加深度为4
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">全局: 4; 桶 1111(4):15;0111(4):23,7; 011(3):11; 0(1):14,12; 1(1):9,5;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">13
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">全局: 4; 桶 1111(4):15;0111(4):23,7; 011(3):11; 0(1):14,12; 1(1):9,5;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">01(2):13;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">2
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">全局: 4; 桶 1111(4):15;0111(4):23,7; 011(3):11; 0(1):14,12; 1(1):9,5;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">01(2):13;01(2):2
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>
&lt;p>i. [4 points] Which key will first cause a split (without doubling the size of the table)?&lt;/p>
&lt;p>这里的split操作指的是&lt;strong>增加桶的数量&lt;/strong>,而不double.也就是不增加全局深度.(增加全局深度会翻一倍)&lt;/p>
&lt;p>所以是13第一个增加了桶的数量.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ii. [4 points] Which key will first make the table double in size?&lt;/p>
&lt;p>7&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="c-now-consider-the-table-below-along-with-the-following-deletion-rules">(c) Now consider the table below, along with the following deletion rules:&lt;/h3>
&lt;ol>
&lt;li>If two buckets satisfy the following:&lt;/li>
&lt;/ol>
&lt;p>(a) They have the same local depth d&lt;/p>
&lt;p>(b) They share the first d − 1 bits of their indexes (e.g. b010 and b110 share the first 2 bits)&lt;/p>
&lt;p>(c) Their constituent elements fit in a single bucket. Then they can be merged into a single bucket with local depth d − 1.&lt;/p>
&lt;ol start="2">
&lt;li>If the global depth g becomes strictly greater than all local depths, then the table can be halved in size. The resulting global depth is g − 1.&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">00
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">28:11100
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">8 :01000
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">01
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">25:11001
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">10
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">30:11110
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">22:10110
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">18:10010
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">011
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">11:01011
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">27:11011
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">23:10111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">7 :00111
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Starting from the table above, delete keys 25, 18, 22, 27, 7.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">delete 25
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">00
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">28:11100
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">8 :01000
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">10
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">30:11110
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">22:10110
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">18:10010
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">011
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">11:01011
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">27:11011
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">23:10111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">7 :00111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">delete 18
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">00
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">28:11100
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">8 :01000
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">10
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">30:11110
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">22:10110
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">011
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">11:01011
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">27:11011
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">23:10111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">7 :00111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">delete 22
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">00
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">28:11100
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">8 :01000
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">10
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">30:11110
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">011
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">11:01011
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">27:11011
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">23:10111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">7 :00111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">此时00 和 10可进行合并
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">0
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">28:11100
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">8 :01000
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">30:11110
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">011
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">11:01011
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">27:11011
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">23:10111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">7 :00111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">delete 27
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">0
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">28:11100
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">8 :01000
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">30:11110
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">011
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">11:01011
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">23:10111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">7 :00111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">此时 011 和 111可合并为11,一次合并最多减少1, 此时global depth = 2
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">0
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">28:11100
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">8 :01000
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">30:11110
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">11
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">11:01011
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">23:10111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">7 :00111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">delete 7
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">0
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">28:11100
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">8 :01000
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">30:11110
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">11
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">11:01011
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">23:10111
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>i. Which deletion first causes a reduction in a local depth.&lt;/li>
&lt;/ul>
&lt;p>22&lt;/p>
&lt;ul>
&lt;li>
&lt;p>ii. Which deletion first causes a reduction in global depth.&lt;/p>
&lt;p>27&lt;/p>
&lt;p>Solution: Deleting 27 from bucket b011 allows it to merge with b111. Since these two buckets are the only ones of depth d = 3, this merge reduces the global depth to d = 2&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="question-4-btree">Question 4: B+Tree&lt;/h2>
&lt;p>还行,就是有个奇怪的点. 索引节点的值一般会出现在叶子节点上.&lt;/p>
&lt;p>最后一题是找出指定的节点 非法的地方.&lt;/p>
&lt;h1 id="p1">P1&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">1: 0001
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">2: 0010
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">3: 0011
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">4: 0100
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">5: 0101
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">6: 0110
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">7: 0111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">8: 1000
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">9: 1001
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">1 2 3 4
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">全局1 1(1):1,3;0(1):2,4;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">5
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">全局1 1(1):1,3,5;0(1):2,4;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">全局2 01(2):1,5;11(2)3;0(1):2,4;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">6
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">全局2 01(2):1,5;11(2)3;00(2):4;10(2):2,6;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">7
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">全局2 01(2):1,5;11(2)3,7;00(2):4;10(2):2,6;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">8
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">全局2 01(2):1,5;11(2)3,7;00(2):4,8;10(2):2,6;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">9
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">全局2 01(2):1,5,9;11(2)3,7;00(2):4,8;10(2):2,6;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">全局3 001(3):1,9;101(3):5;11(2)3,7;00(2):4,8;10(2):2,6;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="lru-k">LRU-K&lt;/h2>
&lt;p>The LRU-K algorithm &lt;strong>evicts&lt;/strong>(剔除) a frame whose &lt;strong>backward k-distance&lt;/strong> is maximum of all frames in the replacer.&lt;/p>
&lt;p>&lt;strong>Backward k-distance&lt;/strong> is computed as the &lt;strong>difference&lt;/strong> in time between current timestamp and the timestamp of kth previous access.&lt;/p>
&lt;p>A frame with less than k historical accesses is given +inf as its backward k-distance. When &lt;strong>multipe frames have +inf backward k-distance&lt;/strong>, the replacer evicts the frame &lt;strong>with the earliest timestamp&lt;/strong>.&lt;/p>
&lt;p>先弄清楚逻辑在写，不要把时间花在无意义的bug上。&lt;/p>
&lt;h1 id="p2-btree">P2 B+Tree&lt;/h1>
&lt;h2 id="概述">概述&lt;/h2>
&lt;p>内部节点：索引作用&lt;/p>
&lt;p>叶子节点：包含真正的数据实体&lt;/p>
&lt;p>由于树是动态增长和收缩，所以要处理 split 和 merge&lt;/p>
&lt;blockquote>
&lt;p>Since the tree structure grows and shrink dynamically, you are required to handle the logic of split and merge.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>Checkpoint #1 — Due Date: Oct 11 @ 11:59pm&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&lt;a href="https://15445.courses.cs.cmu.edu/fall2022/project2/#b&amp;#43;tree-pages" target="_blank" rel="noopener">Task #1 - B+Tree Pages&lt;/a>&lt;/strong>&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://15445.courses.cs.cmu.edu/fall2022/project2/#b&amp;#43;tree-structure" target="_blank" rel="noopener">Task #2 - B+Tree Data Structure (Insertion, Deletion, Point Search)&lt;/a>&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Checkpoint #2 — Due Date: Oct 26 @ 11:59pm&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&lt;a href="https://15445.courses.cs.cmu.edu/fall2022/project2/#index-iterator" target="_blank" rel="noopener">Task #3 - Index Iterator&lt;/a>&lt;/strong>&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://15445.courses.cs.cmu.edu/fall2022/project2/#concurrent_index" target="_blank" rel="noopener">Task #4 - Concurrent Index&lt;/a>&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>该project 要依赖于上一个 buffer pool 的正确实现。&lt;/p>
&lt;p>由于第一个检查点与第二个检查点密切相关，在第二个检查点中，您将在现有的B+索引中实现索引抓取，因此我们传入了一个名为transaction的指针参数，其默认值为nullptr。在任务#4之前，您不需要更改或调用与参数相关的任何函数。&lt;/p>
&lt;h2 id="task-1---btree-pages">Task #1 - B+Tree Pages&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>&lt;a href="https://15445.courses.cs.cmu.edu/fall2022/project2/#b&amp;#43;tree-page" target="_blank" rel="noopener">B+Tree Parent Page&lt;/a>&lt;/strong>&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://15445.courses.cs.cmu.edu/fall2022/project2/#b&amp;#43;tree-internal-page" target="_blank" rel="noopener">B+Tree Internal Page&lt;/a>&lt;/strong>&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://15445.courses.cs.cmu.edu/fall2022/project2/#b&amp;#43;tree-leaf-page" target="_blank" rel="noopener">B+Tree Leaf Page&lt;/a>&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h3 id="btree-parent-page">B+Tree Parent Page&lt;/h3>
&lt;p>ParenPage 被 Internal Page 和 Leaf Page所继承。&lt;/p>
&lt;p>并且只包含了 子类 所共享的信息。&lt;/p>
&lt;p>&lt;strong>可以规定&lt;/strong> &lt;code>parent_page_id_&lt;/code> 为 &lt;code>INVALID_PAGE_ID&lt;/code> 表示根节点。&lt;/p>
&lt;p>| Variable Name | Size | Description | | &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; | &amp;mdash;- | &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; | | page_type_ | 4 | Page Type (internal or leaf) | | lsn_ | 4 | Log sequence number (Used in Project 4) | | size_ | 4 | Number of Key &amp;amp; Value pairs in page | | max_size_ | 4 | Max number of Key &amp;amp; Value pairs in page | | parent_page_id_ | 4 | Parent Page Id | | page_id_ | 4 | Self Page Id |&lt;/p>
&lt;h3 id="btree-internal-page">B+Tree Internal Page&lt;/h3>
&lt;ul>
&lt;li>不存储真实数据。只存储 m个有序 key和m+1个child 指针。&lt;/li>
&lt;li>因为key的数量和指针数量不相等。第一个key被设定为invalid。所有方法需要从第二个key开始（下标为1）&lt;/li>
&lt;li>实际存储如下&lt;/li>
&lt;li>键,指针,键,指针,&amp;hellip;,键,指针.&lt;/li>
&lt;li>此时有m+1个键,为了保证只有m个键,所以第一个键设置为无效的.&lt;/li>
&lt;/ul>
&lt;p>key的数量限制&lt;/p>
&lt;ul>
&lt;li>在任何时间，最少装了一半（half-full）。&lt;/li>
&lt;li>删除时，两个 half-full可以被joined 成为一个合法的 Internal Page
&lt;ul>
&lt;li>或者被重新分配来避免merge&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>当插入到一个fullpage时，可以被split成两个。&lt;/li>
&lt;li>This is an example of one of the many design choices that you will make in the implementation of the B+ Tree.&lt;/li>
&lt;/ul>
&lt;p>三个泛型 KeyType, ValueType, KeyComparator。&lt;/p>
&lt;p>&lt;strong>KeyType&lt;/strong> 不一定直接可用大于小于号比较，所以引入了 KeyComparator，从 cpp 文件中的实例化可以看出用的是 GenericKey 和 GenericComparator，查看二者源码可以得到以下信息：&lt;/p>
&lt;p>&lt;strong>GenericKey&lt;/strong> 可以调用 ToString() 函数得到其 int64 表示，然后用 **%ld 格式符打印。**这对我们后面调试时非常重要。 GenericComparator 的比较规则是：左边小于右边时，返回 -1；左边大于右边时，返回 1；相等返回 0。&lt;/p>
&lt;p>&lt;strong>ValueType&lt;/strong> 代表的是指向子页面的指针，从实例化可以看出实际只用了 page_id_t，也就是 &lt;strong>int&lt;/strong>。&lt;/p>
&lt;p>数据存储上，其理论结构应为 &amp;lt;指针，键，指针，键…，键，指针&amp;gt;，为方便存储，实际上&lt;strong>在头部多补了一个无效键&lt;/strong>，从而可以用一个 pair 的数组存储：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">#define MappingType std::pair&amp;lt;KeyType, ValueType&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">class BPlusTreeInternalPage : public BPlusTreePage {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">private:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // Flexible array member for page data.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> MappingType array_[1];
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>array_[1] 等价与 pair类型的指针.指向pair数组. 数组的每一个元素是&amp;lt;键,值&amp;gt;&lt;/p>
&lt;p>在内部节点中,值代表指针.(第一个元素的键是无效的,但值是存在的).&lt;/p>
&lt;p>因为节点对象使用的是预先分配好的固定空间，array_ 可以控制从该位置开始到 Page 的 data 结束为止的这一段空间。&lt;/p>
&lt;p>因此，节点对象的生命周期也不是由 new 和 delete，而是由 BufferPoolManager 管理.&lt;/p>
&lt;ul>
&lt;li>取一个页面，用 FetchPage；&lt;/li>
&lt;li>使用结束归还一个页面，用 UnpinPage。&lt;/li>
&lt;li>page_id_ 不仅是 B+ 树中节点的编号，同时也是这个节点使用的 Page 在 BufferPool 中的编号。&lt;/li>
&lt;/ul>
&lt;h3 id="btree-leaf-page">B+Tree Leaf Page&lt;/h3>
&lt;ul>
&lt;li>存储 m个有序key，m个 value 实体&lt;/li>
&lt;li>在这次实现中，value 仅仅是64位的record_id, 被用于定位真实的tuples的存储位置.
&lt;ul>
&lt;li>see &lt;code>RID&lt;/code> class defined under in &lt;code>src/include/common/rid.h&lt;/code>.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>对于键值对的数量限制与Internal Page一致.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>重要&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>尽管叶子节点和内部节点有相同类型的key.但他们值的类型不一样.
&lt;ul>
&lt;li>所以&lt;strong>max_size 也应该是不同的&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>每个节点的 &lt;strong>data_&lt;/strong>,都是从buffer pool 中fetch得到的 内存页面.
&lt;ul>
&lt;li>所以当写或读时,要先使用唯一的page_id,从buffer pool 中fetch 出来.&lt;/li>
&lt;li>然后使用 reinterpret cast, 转换成 叶子节点或内部节点.&lt;/li>
&lt;li>并且要在读或写操作结束后,unpin这个页面.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="task-2---btree-data-structure">Task #2 - B+Tree Data Structure&lt;/h2>
&lt;ul>
&lt;li>只支持 unique keys. 也就是说,当有重复的key插入时, 不进行任何操作并返回false&lt;/li>
&lt;li>同时当删除操作导致 页面key数量低于阈值时, 需要正确地执行 merge 和 redistribute(也叫做 coalescing) 操作.&lt;/li>
&lt;/ul>
&lt;p>对于checkpoint , B+Tree Index 只需要支持 &lt;strong>insertions&lt;/strong> (&lt;code>Insert()&lt;/code>), &lt;strong>point search&lt;/strong> (&lt;code>GetValue()&lt;/code>), and &lt;strong>deletes&lt;/strong> (&lt;code>Delete()&lt;/code>)&lt;/p>
&lt;p>插入操作 引起 split操作的情况:&lt;/p>
&lt;ul>
&lt;li>插入操作后, 叶子节点中 pair的数量 等于 max_size&lt;/li>
&lt;li>插入 操作前, 内部节点 孩子数量等于 max_size&lt;/li>
&lt;/ul>
&lt;p>因为写操作会导致, root_page_id的改变,所以也要在 &lt;strong>header page&lt;/strong> 同时更新 root_page_id (&lt;code>src/include/storage/page/header_page.h&lt;/code>).&lt;/p>
&lt;p>更新的方法是调用 &lt;code>UpdateRootPageId&lt;/code> (已经提供了)&lt;/p>
&lt;p>需要隐藏类型和比较.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">template &amp;lt;typename KeyType,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> typename ValueType,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> typename KeyComparator&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">class BPlusTree{
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // ---
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>KeyType&lt;/code>: 索引中key的类型,只可能是 &lt;code>GenericKey&lt;/code>.
&lt;ul>
&lt;li>GeneriKey真实的size是特定的.&lt;/li>
&lt;li>是通过模板参数指定和实例化的，并取决于索引属性的数据类型.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>ValueType&lt;/code>: 索引中值的类型. 只可能是 64-bit RID.&lt;/li>
&lt;li>&lt;code>KeyComparator&lt;/code>: 用来比较两个KeyType实例 大小关系. 左边小于右边时，返回 -1；左边大于右边时，返回 1；相等返回 0。&lt;/li>
&lt;/ul>
&lt;h2 id="checkpoint-1查找插入和删除">Checkpoint 1：查找，插入和删除&lt;/h2>
&lt;h3 id="约定">约定&lt;/h3>
&lt;p>这里约定 内部节点array中key 与子节点的关系.&lt;/p>
&lt;ul>
&lt;li>左子节点的keys &amp;lt;= 父节点的keys&lt;/li>
&lt;li>右子节点的keys &amp;gt; 父节点的keys&lt;/li>
&lt;/ul>
&lt;h3 id="查找">查找&lt;/h3>
&lt;p>给定key，返回查找的页面。&lt;/p>
&lt;p>页面的数据存在叶子节点中。&lt;/p>
&lt;p>因此要从根节点开始，一层一层往下找&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="n">findValue&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="n">Page&lt;/span> &lt;span class="n">page&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">KeyType&lt;/span> &lt;span class="n">key&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//二分查找 page的array中,找到最大的小于等于key的 pair
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">pair&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">GetLeaf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Page&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">KeyType&lt;/span> &lt;span class="n">key&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Page&lt;/span> &lt;span class="n">now&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">now&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">type&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">leaf&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">now&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">findValue&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">now&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">now&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">GetValue&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">KeyType&lt;/span> &lt;span class="n">key&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Page&lt;/span> &lt;span class="n">now&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">GetLeaf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//现在now为叶子节点,在叶子节点中找对应的值.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">findValue&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">now&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//如果返回值的key不相等则没找到.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//相等则返回找到
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="插入叶子节点">插入(叶子节点)&lt;/h3>
&lt;p>因为以下的操作都基于至少有一个根节点的情况.&lt;/p>
&lt;p>因此在最开始要判断是否为空树,如为空树则创建根, 直接返回&lt;/p>
&lt;p>首先看键存不存在,如果已经存在,则直接返回.&lt;/p>
&lt;p>因为B+树的真实数据存在叶子节点中. 因此插入的第一步就是在找到对应叶子节点,并**插入(叶子节点)**到对应位置.&lt;/p>
&lt;p>此后可能会引起分裂.&lt;/p>
&lt;ol>
&lt;li>先直接**插入(叶子节点)**到叶子节点中.&lt;/li>
&lt;li>当发现**插入(叶子节点)**后, 叶子节点的pair数量等于max_size时进行分裂.&lt;/li>
&lt;/ol>
&lt;p>split(page) 操作&lt;strong>这里不分内部叶子节点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>当前节点是full page,因此可以将当前节点分裂成 (左子节点 half full, 新父节点 , half full)&lt;/li>
&lt;li>其中新父节点的值是左子节点的最后一个.&lt;/li>
&lt;li>新父节点 需要 &lt;strong>插入(内部节点)&lt;/strong> 到原来的父节点中.
&lt;ul>
&lt;li>&lt;strong>插入(内部节点)前&lt;/strong>, 要判断 &lt;strong>原父节点的孩子数量是否等于max_size&lt;/strong>&lt;/li>
&lt;li>如果等于, 则先&lt;strong>将原父节点分裂&lt;/strong> 后.&lt;/li>
&lt;li>再执行当前的**插入(内部节点)**操作.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>特殊的. 如果page是根节点, 即没有原父亲节点.
&lt;ul>
&lt;li>则将 根节点 更新成新父节点后, 返回即可.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>插入(内部节点)&lt;/strong> : 因为在插入前已经处理好了插入操作的合法性,因此直接插入即可.&lt;/p>
&lt;p>伪代码:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="n">SetRoot&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">page_id&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">root_page_id&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">page_id&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//一定要调用 UpdateRootPageId
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">split&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">page&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//分裂出下面三个节点
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">left_page&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">right_page&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">new_parent_page&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="c1">//key为左节点的最后一个key, value为指向左节点的指针
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//判断是否为根节点
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">page&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">type&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">rootType&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">SetRoot&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">new_parent_page&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">page_id&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//获取父亲节点
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">parent_page&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">parent_page&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">isFull&lt;/span>&lt;span class="p">()){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">split&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">parent_page&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//将new_parent_page 插入到 parent_page中
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">parent_page&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">insert&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">Insert&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//判断是否为空树
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">valid&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Page&lt;/span> &lt;span class="n">new_page&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Page&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">SetRoot&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">newpage&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">page_id&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//先查找
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">Page&lt;/span> &lt;span class="n">leaf_page&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">GetLeaf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//直接调用叶子节点的插入
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">leaf_page&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Insert&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">leaf_page&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">Page&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">page&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="p">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">LeafPage&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">Insert&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Page&lt;/span> &lt;span class="n">new_page&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//直接插入,同时只需要更新指向 new_page 和 new_page的 next
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//满了就分裂.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">isFull&lt;/span>&lt;span class="p">()){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">split&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">InternalPage&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">Insert&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Page&lt;/span> &lt;span class="n">new_page&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//直接插入,但array中key的有效位置是从1开始
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//上面代码还需要考虑
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//页面的创建和释放
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="删除">删除&lt;/h3>
&lt;p>B+树最难的地方。但比起splay来说还是简单太多了。并且因为B+树只有叶子节点存值。在内部节点的删除上比B树简单了很多。&lt;/p>
&lt;p>删除的核心操作：&lt;/p>
&lt;ol>
&lt;li>叶子节点/内部节点删除元素后;
若小于下限,则按下面的优先级考虑;&lt;/li>
&lt;li>如相邻兄弟结点丰满（即 元素个数 大于 下限+1），则向兄弟结点&lt;strong>借&lt;/strong>一个元素。（具体是 先从相邻方向上的父亲结点变成借来的元素左右(这里具体要看借左边还是右边)，而后对应相邻的兄弟补回这个元素）。否则：&lt;/li>
&lt;li>与相邻的兄弟结点 &lt;strong>合并&lt;/strong>&lt;/li>
&lt;/ol>
&lt;p>父亲节点被删除后, 需要继续执行上面的操作.&lt;/p>
&lt;p>叶子节点和内部节点的差异:&lt;/p>
&lt;ul>
&lt;li>借
&lt;ul>
&lt;li>内部节点和B树操作一样, 先&lt;strong>从相邻方向上的父亲结点拿一个元素&lt;/strong>，而后&lt;strong>对应相邻的兄弟补回这个元素&lt;/strong>&lt;/li>
&lt;li>叶子节点的父亲只是索引节点,因此 把兄弟节点的元素拿来后, 父亲节点的值根据 从左边/右边拿 变成相应的合法的值即可.&lt;/li>
&lt;li>借的操作都&lt;strong>不会涉及父亲节点的删除&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>合并
&lt;ul>
&lt;li>内部节点和B树操作一样, 将兄弟和父亲节点一起合并. (也相当于删除了父亲节点)下限+(下限-1) + 1 等于上限,因此合法&lt;/li>
&lt;li>叶子节点是 两个叶子节点合并后直接删除父亲节点.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>特殊地,如果删除的是根节点的元素，且根结点只有一个元素，则&lt;strong>下降一层&lt;/strong>退出。&lt;/p>
&lt;ul>
&lt;li>因为只有一个待删除的元素，说明目前只有一个儿子结点（刚刚合并了）。&lt;/li>
&lt;li>直接将儿子结点作为根节点。&lt;/li>
&lt;/ul>
&lt;p>伪代码&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//tree的Remove操作
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">Remove&lt;/span>&lt;span class="p">(){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//1.判断是否为空
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">empty&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//返回
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//2.找到叶子结点，并在叶子结点中删除该元素
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">leaf_page&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="c1">//找到叶子节点
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//TODO 删除元素
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//3.判断叶子结点元素个数是是否小于下限
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span> &lt;span class="err">小于&lt;/span> &lt;span class="err">下限&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">UnderFlow&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">Underflow&lt;/span>&lt;span class="p">(){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//3.0 判断是否为根节点
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">IsRoot&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//根节点的下限是1.说明应该减少一层.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//3.0.1a找到根节点唯一的子节点.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//该子节点变为根节点.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//3.0.1b 根节点没有子节点
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//直接删除,树变成空树.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//3.1a. 找兄弟节点借
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">Borrow&lt;/span>&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//3.1a.1a找左兄弟节点借
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">borrow&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">left_&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//3.1a.1b左兄弟不能借，就找右兄弟节点借
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">borrow&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">right_&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//3.1b.借失败了，就准备合并
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">union&lt;/span>&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//3.1b.1a 左兄弟结点存在,就找左兄弟节点合并
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">have&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">left&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="k">union&lt;/span>&lt;span class="err">(&lt;/span>&lt;span class="nc">left_&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//3.1b.1b 没有左兄弟节点, 找右兄弟节点合并.(除根节点外肯定至少有一个兄弟节点)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">union&lt;/span>&lt;span class="err">(&lt;/span>&lt;span class="nc">right_&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">borrow&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">bro_page&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//如果兄弟节点的 size &amp;lt;= 下限,不能借
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">bro_page&lt;/span> &lt;span class="n">size&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="err">下限&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//否则可以借
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//是叶子结点
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//直接拿 对应兄弟结点最靠近的元素
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//是内部结点
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//加入的元素 = 中间父亲结点对应的元素
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//中间父亲结点对应的元素 = 兄弟结点最靠近的元素.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//兄弟结点最靠近的元素删除
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">union&lt;/span>&lt;span class="err">(&lt;/span>&lt;span class="nc">bro_page&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//是叶子结点
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//两个结点合并成一个结点
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//是内部结点
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//好像都是直接把右合并到左就可以.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//删除父亲结点中间的元素.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//如果父亲结点size 小于等于 下限
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//父亲结点采取下溢操作
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Why parallelism? Why efficiency?</title><link>https://ysyyhhh.github.io/blog/why-parallelism-why-efficiency/</link><pubDate>Fri, 01 Mar 2024 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/blog/why-parallelism-why-efficiency/</guid><description>&lt;h2 id="parallelism">Parallelism&lt;/h2>
&lt;p>加速比 Speed up 是指：
程序在单处理器上运行的时间 / 程序在多处理器上运行的时间&lt;/p>
&lt;p>我们一般会期望用两倍的硬件得到两倍的速度提升,但是实际上并不是这样的。&lt;/p>
&lt;p>制约性能提升可能的因素有:&lt;/p>
&lt;ul>
&lt;li>资源分配不均匀&lt;/li>
&lt;li>通信开销&lt;/li>
&lt;li>短板效应&lt;/li>
&lt;li>共享资源读写冲突&lt;/li>
&lt;/ul>
&lt;p>为什么要去了解硬件？&lt;/p>
&lt;ul>
&lt;li>什么是限制性能的因素？&lt;/li>
&lt;li>导致性能瓶颈的原因是什么？&lt;/li>
&lt;/ul>
&lt;h2 id="efficiency">Efficiency&lt;/h2>
&lt;p>fast != efficient&lt;/p>
&lt;ul>
&lt;li>什么是效率？
尽可能地利用资源，减少浪费&lt;/li>
&lt;/ul>
&lt;p>比如按时间租用服务器。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>并行程序的挑战：&lt;/p>
&lt;ul>
&lt;li>负载均衡 Load balance&lt;/li>
&lt;li>通信延迟 Communication latency&lt;/li>
&lt;li>集体工作时，真正用于计算的时间很少&lt;/li>
&lt;/ul></description></item><item><title>Nvidia</title><link>https://ysyyhhh.github.io/showcase/nvidia/</link><pubDate>Sat, 17 Feb 2024 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/showcase/nvidia/</guid><description/></item><item><title>openai 相关QA</title><link>https://ysyyhhh.github.io/blog/openai-%E7%9B%B8%E5%85%B3qa/</link><pubDate>Fri, 08 Dec 2023 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/blog/openai-%E7%9B%B8%E5%85%B3qa/</guid><description>&lt;h2 id="无法连接">无法连接&lt;/h2>
&lt;p>Q:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">openai.error.APIConnectionError: Error communicating with OpenAI: HTTPSConnectionPool&lt;span class="o">(&lt;/span>&lt;span class="nv">host&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;api.openai.com&amp;#39;&lt;/span>, &lt;span class="nv">port&lt;/span>&lt;span class="o">=&lt;/span>443&lt;span class="o">)&lt;/span>: Max retries exceeded with url: /v1/chat/completions &lt;span class="o">(&lt;/span>Caused by ProxyError&lt;span class="o">(&lt;/span>&lt;span class="s1">&amp;#39;Unable to connect to proxy&amp;#39;&lt;/span>, SSLError&lt;span class="o">(&lt;/span>SSLZeroReturnError&lt;span class="o">(&lt;/span>6, &lt;span class="s1">&amp;#39;TLS/SSL connection has been closed (EOF) (_ssl.c:1131)&amp;#39;&lt;/span>&lt;span class="o">))))&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>A:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">问题出在模块 urllib3 的版本，报错的是 1.26.3，没报错的是 1.25.11
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">在原报错环境中使用下面命令重装低版本 urllib3：
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">pip install &lt;span class="nv">urllib3&lt;/span>&lt;span class="o">==&lt;/span>1.25.11
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">然后测试果然就没问题了。
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>杂</title><link>https://ysyyhhh.github.io/blog/%E6%9D%82/</link><pubDate>Sun, 23 Jul 2023 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/blog/%E6%9D%82/</guid><description>&lt;p>session权限问题&lt;/p>
&lt;p>&lt;a href="https://blog.51cto.com/u_15162069/2778036" target="_blank" rel="noopener">https://blog.51cto.com/u_15162069/2778036&lt;/a>&lt;/p>
&lt;h5 id="rsa前后端解密出错">RSA前后端解密出错&lt;/h5>
&lt;p>14：07&lt;/p>
&lt;p>JSEncrypt支持的是&lt;a href="https://so.csdn.net/so/search?q=openssl&amp;amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener">openssl&lt;/a>生成的pkcs1格式私钥，java需要pkcs8格式私钥，公钥格式不变&lt;/p>
&lt;p>前端加入替换 encodeURI(encodeData).replace(/\+/g, &amp;lsquo;%2B&amp;rsquo;)&lt;/p>
&lt;p>后端接口加入 URLDecoder.decode(password,&amp;ldquo;UTF-8&amp;rdquo;);&lt;/p>
&lt;p>&lt;a href="https://blog.csdn.net/qq_42979402/article/details/109184787" target="_blank" rel="noopener">https://blog.csdn.net/qq_42979402/article/details/109184787&lt;/a>&lt;/p>
&lt;p>真正错误是密码加了hash函数后，返回值是数字而不是字符串！！！&lt;/p>
&lt;h4 id="数据库返回乱码">数据库返回乱码&lt;/h4>
&lt;p>&lt;a href="https://www.cnblogs.com/fanbi/p/13940432.html" target="_blank" rel="noopener">https://www.cnblogs.com/fanbi/p/13940432.html&lt;/a>&lt;/p>
&lt;h4 id="实际上是apigateway-放入-header-后再取出-乱码httpsblogcsdnnetqq_31277409articledetails118544597">&lt;a href="https://blog.csdn.net/qq_31277409/article/details/118544597" target="_blank" rel="noopener">实际上是apigateway 放入 header 后再取出 乱码&lt;/a>&lt;/h4>
&lt;h4 id="存储过程返回多结果集并接收">存储过程返回多结果集并接收&lt;/h4>
&lt;h4 id="test时报错-aop之类的">test时报错 AOP之类的&lt;/h4>
&lt;p>&lt;a href="https://blog.csdn.net/crxk_/article/details/103196146" target="_blank" rel="noopener">禁用字节码校验&lt;/a>&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/guide/%E5%BC%80%E5%8F%91/%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/guide/%E5%BC%80%E5%8F%91/%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/</guid><description>&lt;h2 id="git">git&lt;/h2>
&lt;p>测试环境&lt;/p>
&lt;ul>
&lt;li>自动化部署&lt;/li>
&lt;li>一键转移到生成环境&lt;/li>
&lt;/ul>
&lt;h2 id="部署">部署&lt;/h2>
&lt;h2 id="项目代码">项目代码&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>测试代码&lt;/p>
&lt;ul>
&lt;li>编码风格测试&amp;amp;修正&lt;/li>
&lt;li>功能测试&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Dockerfile&lt;/p>
&lt;/li>
&lt;li>
&lt;p>docker-compose&lt;/p>
&lt;/li>
&lt;li>
&lt;p>测试脚本&lt;/p>
&lt;/li>
&lt;li>
&lt;p>部署脚本&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="前端代码结构">前端代码结构&lt;/h2>
&lt;h3 id="优点">优点&lt;/h3>
&lt;p>接口可以根据环境自动替换:&lt;/p>
&lt;ul>
&lt;li>开发环境的接口&lt;/li>
&lt;li>生产环境&lt;/li>
&lt;/ul>
&lt;h3 id="1docker-runsh">1.docker-run.sh&lt;/h3>
&lt;p>描述: 部署脚本在git clone之后运行的脚本&lt;/p>
&lt;p>内容: 包括docker的构建和运行&lt;/p>
&lt;p>示例&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">docker-compose down
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker rmi digitalmapadmin-frontend
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker build -t digitalmapadmin-frontend .
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker-compose pull
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker-compose up -d
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="2docker-composeyaml">2.docker-compose.yaml&lt;/h3>
&lt;p>描述: docker-run.sh 会用到docker-compose指令&lt;/p>
&lt;p>内容:&lt;/p>
&lt;ul>
&lt;li>Dockerfile 路径&lt;/li>
&lt;li>端口&lt;/li>
&lt;li>环境变量
&lt;ul>
&lt;li>&lt;strong>生产环境下的后端接口&lt;/strong> # 这样可以在部署时 自动替换成生产环境的后端接口.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-dockerfile" data-lang="dockerfile">&lt;span class="line">&lt;span class="cl">version: &lt;span class="s1">&amp;#39;3.0&amp;#39;&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>services:&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span> frontend:&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span> build:&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span> context: .&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span> dockerfile: ./Dockerfile&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span> ports:&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span> - 8004:80&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span> environment:&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span> - &lt;span class="nv">NODE_ENV&lt;/span>&lt;span class="o">=&lt;/span>production&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span> - &lt;span class="nv">VITE_APP_TITLE&lt;/span>&lt;span class="o">=&lt;/span>数据资源管理平台&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span> - &lt;span class="nv">VITE_APP_BASE_API&lt;/span>&lt;span class="o">=&lt;/span>/api&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span> - &lt;span class="nv">VITE_SERVE&lt;/span>&lt;span class="o">=&lt;/span>http://121.40.252.139:8089/&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="3dockerfile">3.Dockerfile&lt;/h3>
&lt;p>描述: 根据项目构建docker 镜像&lt;/p>
&lt;p>内容:&lt;/p>
&lt;ul>
&lt;li>获取dist:
&lt;ul>
&lt;li>安装 npm: 并进行npm install&lt;/li>
&lt;li>npm run build&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>用nginx运行项目
&lt;ul>
&lt;li>配置nginx&lt;/li>
&lt;li>启动项目&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">FROM node:lts-alpine
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">WORKDIR /app
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 先将package.json和package-lock.json拷贝到工作目录中
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">COPY package*.json ./
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">RUN npm install
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 将当前目录下的所有文件拷贝到工作目录中
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">COPY . .
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">RUN npm run build
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">FROM nginx:alpine
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 将打包后的dist目录下全部文件拷贝到nginx的html/目录下
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># COPY ./dist/ /usr/share/nginx/html/
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">COPY --from=0 /app/dist /usr/share/nginx/html
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 删除nginx中之前的配置
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">RUN rm /etc/nginx/conf.d/default.conf
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 拷贝当前的文件到nginx中
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">COPY nginx.conf /etc/nginx/nginx.conf
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">COPY default.conf.template /etc/nginx/conf.d
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 启动nginx
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">CMD /bin/sh -c &amp;#34;envsubst &amp;#39;80&amp;#39; &amp;lt; /etc/nginx/conf.d/default.conf.template &amp;gt; /etc/nginx/conf.d/default.conf&amp;#34; &amp;amp;&amp;amp; nginx -g &amp;#39;daemon off;&amp;#39;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;/li>
&lt;/ul></description></item><item><title/><link>https://ysyyhhh.github.io/docs/guide/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/guide/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</guid><description>&lt;h1 id="用hugo--github-pagesaction--py--任务计划程序-搭建-全自动化markdown笔记转博客">用Hugo + Github Pages/Action + py + 任务计划程序 搭建 全自动化markdown笔记转博客&lt;/h1>
&lt;h4 id="tldr">TL;DR&lt;/h4>
&lt;blockquote>
&lt;ol>
&lt;li>背景: 已使用nextcloud和typora写笔记&lt;/li>
&lt;li>需求: 将笔记转换为博客.(且因为本人太懒,😂 所以需要全自动化)
&lt;ol>
&lt;li>在nextcloud中, 专门设置一个文件夹&amp;quot;笔记&amp;quot; 转换为博客文件夹&lt;/li>
&lt;li>不能改变原来记笔记的方式&lt;/li>
&lt;li>不能有任何新增的操作&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>方案:
&lt;ol>
&lt;li>使用hugo搭建博客&lt;/li>
&lt;li>使用Github pages部署博客&lt;/li>
&lt;li>使用Github Actions自动化部署&lt;/li>
&lt;li>使用py脚本将笔记转换为博客&lt;/li>
&lt;li>使用任务计划程序定时执行py脚本&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;h2 id="使用hugo搭建博客">使用hugo搭建博客&lt;/h2>
&lt;p>参考:
&lt;a href="https://gohugo.io/getting-started/quick-start/" target="_blank" rel="noopener">hugo官网&lt;/a>
&lt;a href="https://zhuanlan.zhihu.com/p/568470172" target="_blank" rel="noopener">Hugo+Github Pages+Github Action博客方案之二&lt;/a>
&lt;a href="https://zhuanlan.zhihu.com/p/568764664" target="_blank" rel="noopener">Hugo+Github Pages+Github Action博客方案之三&lt;/a>
&lt;a href="https://github.com/adityatelange/hugo-PaperMod/wiki/Installation" target="_blank" rel="noopener">PaperMod主题&lt;/a>&lt;/p>
&lt;h4 id="创建github仓库">创建github仓库&lt;/h4>
&lt;p>要创建两个仓库&lt;/p>
&lt;ol>
&lt;li>一个仓库用于存放博客源码&lt;/li>
&lt;li>一个仓库用于存放博客静态文件&lt;/li>
&lt;/ol>
&lt;h6 id="创建博客静态文件仓库">创建博客静态文件仓库&lt;/h6>
&lt;p>设置仓库名为: &lt;code>用户名.github.io&lt;/code>
&lt;a href="https://github.com/ysyyhhh/ysyyhhh.github.io" target="_blank" rel="noopener">我的博客仓库&lt;/a>&lt;/p>
&lt;h6 id="创建博客源码仓库">创建博客源码仓库&lt;/h6>
&lt;p>设置仓库名为: &lt;code>hugo-blog&lt;/code> // 仓库名可以自定义
&lt;a href="https://github.com/ysyyhhh/hugo-blog" target="_blank" rel="noopener">我的博客源码仓库&lt;/a>&lt;/p>
&lt;h4 id="安装hugo">安装hugo&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">scoop install hugo
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="创建hugo博客">创建hugo博客&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">hugo new site hugo-blog
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="安装主题">安装主题&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="nb">cd&lt;/span> hugo-blog &lt;span class="c1">## 进入博客目录, 这个是博客源码仓库&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git init
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git submodule add --depth&lt;span class="o">=&lt;/span>&lt;span class="m">1&lt;/span> https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git submodule update --init --recursive &lt;span class="c1">## needed when you reclone your repo (submodules may not get cloned automatically)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="配置主题">配置主题&lt;/h4>
&lt;p>这里使用yaml格式的配置文件, 也可以使用toml格式的配置文件
所以需要删除config.toml文件, 并创建config.yaml文件&lt;/p>
&lt;p>config.yaml:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">baseURL&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">title&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ysyy&amp;#39;s blog&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">theme&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">PaperMod&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">languageCode&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">zh-cn&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://github.com/adityatelange/hugo-PaperMod/wiki/Installation#sample-configyml" target="_blank" rel="noopener">剩余配置参考&lt;/a>&lt;/p>
&lt;h4 id="创建文章">创建文章&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">hugo new posts/first/hello-world.md
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="本地预览">本地预览&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">hugo server -D
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="生成静态文件">生成静态文件&lt;/h4>
&lt;p>生成静态文件, 生成的静态文件在 &lt;code>public&lt;/code>文件夹中。
之后我们将这个文件夹中复制到博客静态文件仓库中&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">hugo
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="部署到github-pages">部署到github pages&lt;/h4>
&lt;p>创建静态文件夹&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">git clone git@用户名.github.io.git
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">cd&lt;/span> 用户名.github.io
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cp -r hugo-blog/public/* ./
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>提交到github&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">git add .
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git commit -m &lt;span class="s2">&amp;#34;first commit&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git push origin main
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="配置github-pages">配置github pages&lt;/h4>
&lt;p>在github中的 &lt;code>用户名.github.io&lt;/code>仓库中,
点击 &lt;code>Settings&lt;/code>选项卡, 找到 &lt;code>GitHub Pages&lt;/code>选项,
将 &lt;code>Source&lt;/code>选项设置为 &lt;code>main&lt;/code>分支, 点击 &lt;code>Save&lt;/code>按钮,
这样就可以通过 &lt;code>https://用户名.github.io&lt;/code>访问博客了&lt;/p>
&lt;h2 id="使用github-actions自动化部署">使用Github Actions自动化部署&lt;/h2>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/568764664" target="_blank" rel="noopener">参考&lt;/a>&lt;/p>
&lt;p>如果每一次更新/发布新博客都需要手动执行上面的步骤, 那么就太麻烦了, 所以我们需要自动化部署&lt;/p>
&lt;p>在博客源码仓库的根目录下创建
&lt;code>.github/workflows/deploy.yml&lt;/code>文件&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ysyyblog&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">on&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">push&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">branches&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="l">main&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">jobs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">build-deploy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">runs-on&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ubuntu-20.04&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c"># runs-on: macos-latest&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">steps&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">uses&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">actions/checkout@v3&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">with&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">submodules&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># Fetch Hugo themes (true OR recursive)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">fetch-depth&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">0&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># Fetch all history for .GitInfo and .Lastmod&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Setup Hugo&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">uses&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">peaceiris/actions-hugo@v2&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">with&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">hugo-version&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;latest&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c"># extended: true&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Build&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">run&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">hugo --minify&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Deploy&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">uses&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">peaceiris/actions-gh-pages@v3&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">with&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">personal_token&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">${{ secrets.PERSONAL_TOKEN }}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># 另外还支持 deploy_token 和 github_token&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">external_repository&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ysyyhhh/ysyyhhh.github.io&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># 修改为你的 静态文件GitHub Pages 仓库&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">publish_dir&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">./public&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c"># keep_files: false&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">publish_branch&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">main&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c"># 如果使用自定义域名，还需要添加下面一行配置&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c"># cname: www&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="创建personal_token">创建personal_token&lt;/h3>
&lt;p>在github主页的右上角点击头像, 点击 &lt;code>Settings&lt;/code>选项卡, 找到 &lt;code>Developer settings&lt;/code>选项,&lt;/p>
&lt;p>找到 &lt;code>Personal access tokens&lt;/code>选项, 点击 &lt;code>Generate new token&lt;/code>按钮, 创建一个新的token&lt;/p>
&lt;h3 id="配置personal_token">配置personal_token&lt;/h3>
&lt;p>在hugo-blog仓库中, 点击 &lt;code>Settings&lt;/code>选项卡, 找到 &lt;code>Secrets&lt;/code>选项, 点击 &lt;code>New repository secret&lt;/code>按钮,&lt;/p>
&lt;p>新增一个名为 &lt;code>PERSONAL_TOKEN&lt;/code>的secret, 值为上面创建的personal_token&lt;/p>
&lt;h3 id="测试自动化部署">测试自动化部署&lt;/h3>
&lt;p>在本地的hugo-blog仓库中, 修改 &lt;code>content/posts/first/hello-world.md&lt;/code>文件, 然后提交到github&lt;/p>
&lt;p>可以在 &lt;code>Actions&lt;/code>选项卡中查看自动化部署的状态&lt;/p>
&lt;p>如果在 &lt;code>Actions&lt;/code>选项卡中看到了 &lt;code>build-deploy&lt;/code>任务, 且状态为 &lt;code>success&lt;/code>, 那么就说明自动化部署成功了&lt;/p>
&lt;p>可以在 &lt;code>用户名.github.io&lt;/code>仓库中查看是否已经更新.&lt;/p>
&lt;h2 id="使用任务计划程序和py脚本实现全自动化">使用任务计划程序和py脚本实现全自动化&lt;/h2>
&lt;p>上面的步骤已经让我们发布笔记的过程变成:&lt;/p>
&lt;ol>
&lt;li>使用hugo new / 直接编辑 content的文件 来创建笔记&lt;/li>
&lt;li>提交到hugo-blog仓库&lt;/li>
&lt;/ol>
&lt;p>然后hugo-blog仓库就会自动部署到用户名.github.io仓库中&lt;/p>
&lt;p>虽然已经只剩两步了,但遵循能自动化就自动化的原则, 我们还是要把这两步也自动化&lt;/p>
&lt;h3 id="使用py脚本将笔记转换为博客">使用py脚本将笔记转换为博客&lt;/h3>
&lt;p>安装python这些步骤就省去了,这里直接给出py脚本&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="s1">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1">每天定时更新博客内容
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1">1.进入项目根目录: D:/program_about/hugo/hugo-blog
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1">2. 将D:/nextcloud/笔记/下的文件同步到 ./content/posts/下
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1">3. 执行./push.bat 或 git add . &amp;amp;&amp;amp; git commit -m &amp;#34;update&amp;#34; &amp;amp;&amp;amp; git push
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1">&amp;#39;&amp;#39;&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">os&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">shutil&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">create_index&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s1">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1"> name = A.md
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1"> 在root下生成&amp;#39;A&amp;#39;文件夹
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1"> 将A.md移动到A文件夹下，并重命名为index.md
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1"> 如果 存在 root + &amp;#39;/img&amp;#39; 的文件夹
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1"> 将 root + &amp;#39;/img&amp;#39; 复制到 root + &amp;#39;/A/img&amp;#39; 下
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1"> &amp;#39;&amp;#39;&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 生成文件夹&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">dir_name&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">split&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;.&amp;#39;&lt;/span>&lt;span class="p">)[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">dir_name&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">os&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">mkdir&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">os&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">dir_name&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 移动文件&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">shutil&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">move&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">os&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="n">os&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">dir_name&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s1">&amp;#39;index.md&amp;#39;&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 处理img&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">os&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">exists&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">os&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s1">&amp;#39;img&amp;#39;&lt;/span>&lt;span class="p">)):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">shutil&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">copytree&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">os&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s1">&amp;#39;img&amp;#39;&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="n">os&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">dir_name&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s1">&amp;#39;img&amp;#39;&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">adjust&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">dir&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">os&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">chdir&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">dir&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s1">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1"> 将所有下面的格式
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1"> - A.md
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1"> - img
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1"> - A-1.png
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1"> 转换成
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1"> - A
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1"> - index.md
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1"> - img
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1"> - A-1.png
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1"> 如果遇到&amp;#34;.md&amp;#34;文件,直接删除
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1"> &amp;#39;&amp;#39;&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">dirs&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">files&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">os&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">walk&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;.&amp;#34;&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">root&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">os&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">dir&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">name&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">files&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">name&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="s1">&amp;#39;.md&amp;#39;&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">os&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">remove&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">os&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">continue&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">endswith&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;.md&amp;#39;&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">create_index&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">name&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">dirs&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 递归调用&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">adjust&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">os&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">sync&lt;/span>&lt;span class="p">():&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">root_path&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s1">&amp;#39;D:/program_about/hugo/hugo-blog&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">os&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">chdir&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root_path&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 当文件已存在时，无法创建该文件。: &amp;#39;./content/posts/&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">shutil&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">rmtree&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;./content/posts/&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># git中也要删除&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">os&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">system&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;git rm -r ./content/posts/&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">shutil&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">copytree&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;D:/nextcloud/笔记/&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s1">&amp;#39;./content/posts/&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 把所有文件夹和文件的名称大写转换为小写&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">os&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">chdir&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;./content/posts/&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">dirs&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">files&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">os&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">walk&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;.&amp;#34;&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">name&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">files&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">new_name&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">lower&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">os&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">rename&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">os&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="n">os&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">new_name&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">name&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">dirs&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">new_name&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">lower&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">os&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">rename&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">os&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="n">os&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">new_name&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 调整文件夹结构&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">adjust&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root_path&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="s1">&amp;#39;./content/posts/&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 上传到git&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># os.chdir(&amp;#39;./content/posts/&amp;#39;)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">os&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">chdir&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;D:/program_about/hugo/hugo-blog&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">os&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">system&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;git add ./content/posts/&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">os&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">system&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;git commit -m &amp;#34;update&amp;#34;&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">os&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">system&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;git push&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">os&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">chdir&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;D:/program_about/hugo/hugo-blog&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;sync done&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="vm">__name__&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="s1">&amp;#39;__main__&amp;#39;&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">sync&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>将上面的路径修改为自己的路径, 然后保存为 &lt;code>sync.py&lt;/code>文件
可以执行py脚本,测试一下&lt;/p>
&lt;h4 id="关于图片路径问题">关于图片路径问题&lt;/h4>
&lt;p>&lt;a href="https://discourse.gohugo.io/t/image-path-with-relative-urls/21970/3" target="_blank" rel="noopener">参考方案&lt;/a>&lt;/p>
&lt;p>因为我平时的图片路径是&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-markdown" data-lang="markdown">&lt;span class="line">&lt;span class="cl">&lt;span class="k">-&lt;/span> A.md
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">-&lt;/span> img
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">-&lt;/span> A-1.png
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>但是hugo会将A.md文件转换为A文件夹, 所以此时是无法访问A-1.png的.&lt;/p>
&lt;p>这里是通过改变相对路径关系来解决的, 即代码中的adjust()&lt;/p>
&lt;p>当然如果你有图床就不需要这么麻烦了&lt;/p>
&lt;h3 id="使用任务计划程序定时执行py脚本">使用任务计划程序定时执行py脚本&lt;/h3>
&lt;p>参考
这里我使用的是win10自带的任务计划程序, 其他系统的任务计划程序也是类似的&lt;/p>
&lt;p>以下步骤由Claude生成&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-markdown" data-lang="markdown">&lt;span class="line">&lt;span class="cl">下面是如何使用Windows任务计划程序来配置定时每天执行Python脚本的步骤:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">打开任务计划程序(Windows + R 输入taskschd.msc回车)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">点击&amp;#34;操作&amp;#34;栏中的&amp;#34;创建基本任务&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">输入任务名称,选择触发器为每天定时,设置执行时间
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">在操作栏中,点击“新建”
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">选择“启动一个程序”
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">在“程序/脚本”框中输入Python解释器的路径,例如C:\Python37\python.exe
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">在“添加参数(可选)”中输入python脚本文件的完整路径,例如C:\Users\username\script.py
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">点击“确定”保存此操作
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">在下一页中选择用户账号,例如“当前用户”
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">点击“确定”完成创建任务
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">根据需要配置触发器记录和其他选项
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">点击“确定”保存任务
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">任务将在设定的时间自动执行python脚本文件
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">每次修改脚本后需要停止原有任务,然后再新建一个相同的任务来加载修改后的脚本代码。
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">需要注意python interpreter路径和脚本路径的正确性。定时执行格式也需要正确,这样就可以实现Windows系统中的自动定时任务执行Python脚本了。
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title/><link>https://ysyyhhh.github.io/docs/guide/%E9%83%A8%E7%BD%B2/docker%E7%9B%B8%E5%85%B3%E7%9A%84%E9%83%A8%E7%BD%B2%E8%A7%84%E8%8C%83/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/guide/%E9%83%A8%E7%BD%B2/docker%E7%9B%B8%E5%85%B3%E7%9A%84%E9%83%A8%E7%BD%B2%E8%A7%84%E8%8C%83/</guid><description>&lt;h1 id="docker-相关的部署规范">docker 相关的部署规范&lt;/h1>
&lt;h2 id="1命名规范">1.命名规范&lt;/h2>
&lt;h3 id="11镜像命名规范">1.1.镜像命名规范&lt;/h3>
&lt;p>镜像命名规范：&lt;code>&amp;lt;小组名&amp;gt;/&amp;lt;项目名&amp;gt;/&amp;lt;镜像名&amp;gt;:&amp;lt;版本号&amp;gt;&lt;/code>&lt;/p>
&lt;p>版本号：&lt;code>&amp;lt;主版本号&amp;gt;.&amp;lt;次版本号&amp;gt;.&amp;lt;修订号&amp;gt;&lt;/code> eg: &lt;code>1.0.0&lt;/code>&lt;/p>
&lt;h3 id="12容器命名规范">1.2.容器命名规范&lt;/h3>
&lt;p>容器命名规范：&lt;code>&amp;lt;小组名&amp;gt;-&amp;lt;项目名&amp;gt;-&amp;lt;容器名&amp;gt;-&amp;lt;版本号&amp;gt;&lt;/code>&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/guide/%E9%83%A8%E7%BD%B2/%E5%88%A9%E4%BA%8E%E9%83%A8%E7%BD%B2%E7%9A%84%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/guide/%E9%83%A8%E7%BD%B2/%E5%88%A9%E4%BA%8E%E9%83%A8%E7%BD%B2%E7%9A%84%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/</guid><description>&lt;h1 id="利于部署的开发规范手册">利于部署的开发规范手册&lt;/h1>
&lt;p>本规范用于在开发过程中，使得项目能够更好的部署，更好的维护。&lt;/p>
&lt;p>使用时间: 当项目开始开发时，就应该遵守本规范。&lt;/p>
&lt;p>核心要点:&lt;/p>
&lt;ul>
&lt;li>管理依赖库&lt;/li>
&lt;li>使用docker&lt;/li>
&lt;li>端口、ip地址等使用环境变量&lt;/li>
&lt;li>路径不能写死！尤其是绝对路径和根目录等，需要放在环境变量中！！&lt;/li>
&lt;/ul>
&lt;h2 id="后端">后端&lt;/h2>
&lt;h3 id="python项目">python项目&lt;/h3>
&lt;p>python常见的依赖库管理有:&lt;/p>
&lt;ul>
&lt;li>poetry&lt;/li>
&lt;li>requirements.txt&lt;/li>
&lt;li>pipenv&lt;/li>
&lt;/ul>
&lt;h4 id="poetry">poetry&lt;/h4>
&lt;p>初始化&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">poetry init
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>安装依赖&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">poetry install
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用poetry运行项目&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">poetry run python main.py
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>添加依赖&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">poetry add &amp;lt;package&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>dockerfile示例&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-dockerfile" data-lang="dockerfile">&lt;span class="line">&lt;span class="cl">&lt;span class="k">FROM&lt;/span>&lt;span class="s"> python:3.8.5-slim-buster&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">WORKDIR&lt;/span>&lt;span class="s"> /app&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 拷贝依赖文件&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">COPY&lt;/span> pyproject.toml poetry.lock ./&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 设置国内源&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> pip config &lt;span class="nb">set&lt;/span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 安装poetry&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> pip install poetry&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 安装依赖&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> poetry config virtualenvs.create &lt;span class="nb">false&lt;/span> &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> poetry install --no-dev --no-interaction --no-ansi&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># tips: 先只拷贝依赖文件，再安装依赖，可以利用docker的缓存机制，加快构建速度. &lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># (防止只是项目文件改变，而依赖文件没有改变，导致重新安装依赖)&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 拷贝项目文件&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">COPY&lt;/span> . .&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 运行项目&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">CMD&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;poetry&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;run&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;python&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;main.py&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="requirementstxt">requirements.txt&lt;/h4>
&lt;p>导出依赖&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">pip freeze &amp;gt; requirements.txt
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>安装依赖&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">pip install -r requirements.txt
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>dockerfile示例&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-dockerfile" data-lang="dockerfile">&lt;span class="line">&lt;span class="cl">&lt;span class="k">FROM&lt;/span>&lt;span class="s"> python:3.8.5-slim-buster&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">WORKDIR&lt;/span>&lt;span class="s"> /app&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 拷贝依赖文件&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">COPY&lt;/span> requirements.txt ./&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 设置国内源&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> pip config &lt;span class="nb">set&lt;/span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 安装依赖&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> pip install -r requirements.txt&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 拷贝项目文件&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">COPY&lt;/span> . .&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 运行项目&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">CMD&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;python&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;main.py&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="pipenv">pipenv&lt;/h4>
&lt;p>初始化&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">pipenv --python 3.8
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>安装依赖&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">pipenv install
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用pipenv运行项目&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">pipenv run python main.py
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>添加依赖&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">pipenv install &amp;lt;package&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>dockerfile示例&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-dockerfile" data-lang="dockerfile">&lt;span class="line">&lt;span class="cl">&lt;span class="k">FROM&lt;/span>&lt;span class="s"> python:3.8.5-slim-buster&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">WORKDIR&lt;/span>&lt;span class="s"> /app&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 设置国内源&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> pip config &lt;span class="nb">set&lt;/span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 拷贝依赖文件&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">COPY&lt;/span> Pipfile Pipfile.lock ./&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 安装依赖&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> pip install pipenv &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> pipenv install --system --deploy --ignore-pipfile&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 拷贝项目文件&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">COPY&lt;/span> . .&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 运行项目&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">CMD&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;pipenv&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;run&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;python&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;main.py&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="springboot项目">SpringBoot项目&lt;/h3>
&lt;p>&lt;a href="https://developer.aliyun.com/article/65274" target="_blank" rel="noopener">参考&lt;/a>
这里都以maven作为依赖管理工具。&lt;/p>
&lt;p>主要保留pom.xml文件&lt;/p>
&lt;p>dockerfile示例&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-dockerfile" data-lang="dockerfile">&lt;span class="line">&lt;span class="cl">&lt;span class="c"># 第一阶段: 构建jar包&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="s"> maven:3.6.3-jdk-8-slim AS build&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">WORKDIR&lt;/span>&lt;span class="s"> /app&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">COPY&lt;/span> pom.xml ./&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 设置国内源&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> mvn -B -e -C -T 1C org.apache.maven.plugins:maven-dependency-plugin:3.1.2:go-offline&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 拷贝项目文件&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">COPY&lt;/span> . .&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 构建jar包&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> mvn clean install -DskipTests&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 第二阶段: 运行jar包&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="s"> openjdk:8-jdk-alpine&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">WORKDIR&lt;/span>&lt;span class="s"> /app&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 拷贝第一阶段构建的jar包&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">COPY&lt;/span> --from&lt;span class="o">=&lt;/span>build /app/target/demo-0.0.1-SNAPSHOT.jar ./&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 运行项目&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">CMD&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;java&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;-jar&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;target/demo-0.0.1-SNAPSHOT.jar&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="数据库">数据库&lt;/h3>
&lt;p>通常后端要连接数据库，这里只是简单的示例，实际项目中应该使用&lt;a href="#%e5%b0%81%e8%a3%85%e6%95%b4%e4%b8%aa%e9%a1%b9%e7%9b%ae">docker-compose&lt;/a>来管理多个容器。&lt;/p>
&lt;p>dockerfile示例&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-dockerfile" data-lang="dockerfile">&lt;span class="line">&lt;span class="cl">&lt;span class="k">FROM&lt;/span>&lt;span class="s"> mysql:8.0.22&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 设置时区&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">ENV&lt;/span> &lt;span class="nv">TZ&lt;/span>&lt;span class="o">=&lt;/span>Asia/Shanghai&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 设置root密码&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">ENV&lt;/span> &lt;span class="nv">MYSQL_ROOT_PASSWORD&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">123456&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c"># 设置数据库名&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">ENV&lt;/span> &lt;span class="nv">MYSQL_DATABASE&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="nb">test&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c"># 设置用户名&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">ENV&lt;/span> &lt;span class="nv">MYSQL_USER&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="nb">test&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c"># 设置密码&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">ENV&lt;/span> &lt;span class="nv">MYSQL_PASSWORD&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">123456&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c"># 设置端口&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">EXPOSE&lt;/span>&lt;span class="s"> 3306&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>单独运行mysql&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">docker run -d -p 3306:3306 --name mysql -v /path/to/mysql/data:/var/lib/mysql mysql:8.0.22
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="前端">前端&lt;/h2>
&lt;p>前端使用npm作为依赖管理工具, 使用nginx作为web服务器。&lt;/p>
&lt;p>必要的文件:&lt;/p>
&lt;ul>
&lt;li>package.json # 依赖文件&lt;/li>
&lt;li>package-lock.json # 锁定依赖版本&lt;/li>
&lt;li>nginx.conf # nginx配置文件&lt;/li>
&lt;li>dockerfile&lt;/li>
&lt;/ul>
&lt;h3 id="npm">npm&lt;/h3>
&lt;p>npm初始化&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">npm init
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>安装依赖&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">npm install
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>添加依赖(默认添加到dependencies, 添加到devDependencies需要加上&amp;ndash;save-dev参数(或者-D)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">npm install &amp;lt;package&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="nginx">nginx&lt;/h3>
&lt;p>nginx.conf示例&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-nginx" data-lang="nginx">&lt;span class="line">&lt;span class="cl">&lt;span class="k">server&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">listen&lt;/span> &lt;span class="mi">80&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">server_name&lt;/span> &lt;span class="s">localhost&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">root&lt;/span> &lt;span class="s">/usr/share/nginx/html&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">index&lt;/span> &lt;span class="s">index.html&lt;/span> &lt;span class="s">index.htm&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">location&lt;/span> &lt;span class="s">/&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">try_files&lt;/span> &lt;span class="nv">$uri&lt;/span> &lt;span class="nv">$uri/&lt;/span> &lt;span class="s">/index.html&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="docker">docker&lt;/h3>
&lt;p>docker &lt;a href="https://cloud.tencent.com/developer/article/2246201" target="_blank" rel="noopener">使用多阶段构建&lt;/a>&lt;/p>
&lt;p>dockerfile示例&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-dockerfile" data-lang="dockerfile">&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 第一阶段: 构建项目&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="s"> node:lts-alpine as build&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">WORKDIR&lt;/span>&lt;span class="s"> /app&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 拷贝依赖文件&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">COPY&lt;/span> package.json package-lock.json ./&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 安装依赖&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> npm install&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 拷贝项目文件&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">COPY&lt;/span> . .&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 构建项目&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> npm run build&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 第一段构建完成, 获得/app/build文件夹&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 使用nginx作为web服务器&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="s"> nginx:1.19.4-alpine&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 拷贝nginx配置文件&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">COPY&lt;/span> nginx.conf /etc/nginx/conf.d/default.conf&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 拷贝第一阶段构建的项目文件&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">COPY&lt;/span> --from&lt;span class="o">=&lt;/span>build /app/build /usr/share/nginx/html&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 运行nginx&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">CMD&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;nginx&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;-g&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;daemon off;&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="项目部署-todo">项目部署 TODO&lt;/h2>
&lt;h3 id="封装整个项目单个项目时">封装整个项目(单个项目时)&lt;/h3>
&lt;p>经过上面的步骤已经将前后端 数据库封装到docker中了,但每次启动项目都需要手动启动三个容器, 这里使用docker-compose来管理多个容器。&lt;/p>
&lt;p>docker-compose.yml示例&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">version&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;3.8&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">services&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">mysql&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">mysql:8.0.22&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">environment&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">TZ&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Asia/Shanghai&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">MYSQL_ROOT_PASSWORD&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">123456&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">MYSQL_DATABASE&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">test&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">MYSQL_USER&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">test&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">MYSQL_PASSWORD&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">123456&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">ports&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="m">3306&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="m">3306&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">volumes&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="l">./mysql/data:/var/lib/mysql&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">backend&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">build&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">./backend&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">ports&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="m">8080&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="m">8080&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">depends_on&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="l">mysql&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">frontend&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">build&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">./frontend&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">ports&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="m">80&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="m">80&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">depends_on&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="l">backend&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="整个项目作为k8s的一个服务多个项目时">整个项目作为k8s的一个服务(多个项目时)&lt;/h3>
&lt;p>上面是使用docker-compose来管理 一个项目的多个容器.&lt;/p>
&lt;p>但如果有多个项目, 每个项目都有多个容器, 这时候就需要使用k8s来管理了.&lt;/p>
&lt;p>我们把一个项目(多个容器)作为一个k8s的一个服务.&lt;/p>
&lt;p>k8s的配置文件示例&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Service&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">test&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">labels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">app&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">test&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">ports&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">port&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">80&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">targetPort&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">80&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">protocol&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">TCP&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">selector&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">app&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">test&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">type&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">NodePort&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nn">---&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">apps/v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Deployment&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">test&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">labels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">app&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">test&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">replicas&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">selector&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">matchLabels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">app&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">test&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">template&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">labels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">app&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">test&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">containers&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">mysql&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">mysql:8.0.22&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">env&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">TZ&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">value&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Asia/Shanghai&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">MYSQL_ROOT_PASSWORD&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">value&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">123456&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">MYSQL_DATABASE&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">value&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">test&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">MYSQL_USER&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">value&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">test&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">MYSQL_PASSWORD&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">value&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">123456&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">ports&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">containerPort&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">3306&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">volumeMounts&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">mysql-data&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">mountPath&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/var/lib/mysql&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">backend&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">backend:latest&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">ports&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">containerPort&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">8080&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">env&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">MYSQL_HOST&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">value&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">mysql&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">MYSQL_PORT&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">value&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;3306&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">MYSQL_DATABASE&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">value&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">test&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">MYSQL_USER&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">value&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">test&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">MYSQL_PASSWORD&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">value&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">123456&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">frontend&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">frontend:latest&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">ports&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">containerPort&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">80&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">volumes&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">mysql-data&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">hostPath&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">path&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/path/to/mysql/data&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title/><link>https://ysyyhhh.github.io/docs/guide/%E9%83%A8%E7%BD%B2/%E9%83%A8%E7%BD%B2%E6%89%8B%E5%86%8C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/guide/%E9%83%A8%E7%BD%B2/%E9%83%A8%E7%BD%B2%E6%89%8B%E5%86%8C/</guid><description>&lt;h1 id="部署手册">部署手册&lt;/h1>
&lt;h2 id="docker-镜像上传到私有仓库">docker 镜像上传到私有仓库&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">docker login -u username -p password registry.cn-hangzhou.aliyuncs.com
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker tag image registry.cn-hangzhou.aliyuncs.com/username/image:tag
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker push registry.cn-hangzhou.aliyuncs.com/username/image:tag
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="server">Server&lt;/h2>
&lt;h3 id="springboot">SpringBoot&lt;/h3>
&lt;p>application.yml 必须使用环境变量来进行配置。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">spring&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">datasource&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">url&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">jdbc:mysql://${MYSQL_HOST:localhost}:${MYSQL_PORT:3306}/${MYSQL_DATABASE:test}?useUnicode=true&amp;amp;characterEncoding=utf-8&amp;amp;useSSL=false&amp;amp;serverTimezone=Asia/Shanghai&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">username&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">${MYSQL_USER:test}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">password&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">${MYSQL_PASSWORD:123456}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/llm/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%8E%9F%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/llm/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%8E%9F%E7%90%86/</guid><description>&lt;h1 id="大语言模型原理">大语言模型原理&lt;/h1>
&lt;h2 id="语言模型的基础技术">语言模型的基础技术&lt;/h2>
&lt;h3 id="transformer">transformer&lt;/h3>
&lt;h2 id="大语言模型">大语言模型&lt;/h2>
&lt;h3 id="gpt">GPT&lt;/h3>
&lt;h3 id="bert">BERT&lt;/h3>
&lt;p>&lt;a href="https://www.zhihu.com/tardis/zm/art/607605399?source_id=1003" target="_blank" rel="noopener">BERT vs GPT&lt;/a>&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/</guid><description>&lt;h1 id="linux">Linux&lt;/h1>
&lt;h4 id="epoll底层实现">epoll底层实现&lt;/h4>
&lt;p>epoll是Linux内核提供的一种高效的I/O多路复用机制，其底层实现主要包括以下几个部分：&lt;/p>
&lt;ol>
&lt;li>内核事件表：epoll使用一个内核事件表来存储所有的I/O事件，包括读、写和异常事件等。&lt;/li>
&lt;li>文件描述符表：epoll使用一个文件描述符表来存储所有需要监控的文件描述符，每个文件描述符都对应一个epoll_event结构体，用于存储该文件描述符上的事件信息。&lt;/li>
&lt;li>回调函数：当有I/O事件发生时，内核会调用注册的回调函数来处理该事件，回调函数可以是用户自定义的函数，也可以是系统提供的函数。&lt;/li>
&lt;/ol>
&lt;h4 id="五种io模型">五种IO模型&lt;/h4>
&lt;ol>
&lt;li>阻塞式I/O模型：当应用程序调用I/O操作时，如果数据没有准备好，应用程序会一直等待，直到数据准备好为止。&lt;/li>
&lt;li>非阻塞式I/O模型：当应用程序调用I/O操作时，如果数据没有准备好，应用程序会立即返回，不会等待数据准备好。&lt;/li>
&lt;li>I/O复用模型：应用程序使用select、poll或epoll等系统调用来监控多个文件描述符，当有数据准备好时，应用程序会被通知。&lt;/li>
&lt;li>信号驱动式I/O模型：应用程序使用sigaction系统调用来注册一个信号处理函数，当数据准备好时，内核会向应用程序发送一个信号，应用程序在信号处理函数中处理数据。&lt;/li>
&lt;li>异步I/O模型：应用程序调用aio_read或aio_write等异步I/O函数来发起I/O操作，内核会在I/O操作完成后通知应用程序。&lt;/li>
&lt;/ol>
&lt;h4 id="解释同步阻塞">解释同步，阻塞&lt;/h4>
&lt;p>同步是指应用程序在执行某个操作时，必须等待该操作完成后才能继续执行下一步操作。&lt;/p>
&lt;p>阻塞是指应用程序在执行某个操作时，如果该操作不能立即完成，应用程序会被挂起，直到该操作完成为止。&lt;/p>
&lt;p>在阻塞式I/O模型中，应用程序调用I/O操作时，如果数据没有准备好，应用程序会一直等待，直到数据准备好为止，这就是阻塞。而在非阻塞式I/O模型中，应用程序调用I/O操作时，如果数据没有准备好，应用程序会立即返回，这就是非阻塞。&lt;/p>
&lt;h4 id="nio和bio区别">NIO和BIO区别&lt;/h4>
&lt;p>BIO（Blocking I/O）是阻塞式I/O模型，应用程序调用I/O操作时，如果数据没有准备好，应用程序会一直等待，直到数据准备好为止。NIO（Non-blocking I/O）是非阻塞式I/O模型，应用程序调用I/O操作时，如果数据没有准备好，应用程序会立即返回，不会等待数据准备好。&lt;/p>
&lt;h4 id="nio的底层">NIO的底层&lt;/h4>
&lt;p>NIO的底层实现主要包括以下几个部分：&lt;/p>
&lt;ol>
&lt;li>缓冲区：NIO使用缓冲区来存储数据，包括读缓冲区和写缓冲区。&lt;/li>
&lt;li>通道：NIO使用通道来进行数据的读写操作，通道类似于流，但是可以双向传输数据。&lt;/li>
&lt;li>选择器：NIO使用选择器来监控多个通道的状态，当有数据准备好时，选择器会通知应用程序。&lt;/li>
&lt;/ol></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%A0%94/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%A0%94/</guid><description>&lt;h1 id="操作系统基础">操作系统基础&lt;/h1>
&lt;h2 id="第章-计算机系统概述">第⼀章 计算机系统概述&lt;/h2>
&lt;h3 id="01-操作系统的概念定义">01 操作系统的概念（定义）&lt;/h3>
&lt;p>概念（定义）&lt;/p>
&lt;ul>
&lt;li>负责管理协调硬件、软件等计算机资源的⼯作&lt;/li>
&lt;li>为上层⽤户、应⽤程序提供简单易⽤的服务&lt;/li>
&lt;li>是⼀种系统软件&lt;/li>
&lt;/ul>
&lt;p>资源的管理者&lt;/p>
&lt;ul>
&lt;li>处理机管理&lt;/li>
&lt;li>存储管理&lt;/li>
&lt;li>⽂件管理&lt;/li>
&lt;li>设备管理&lt;/li>
&lt;/ul>
&lt;p>命令接⼝&lt;/p>
&lt;ul>
&lt;li>联机命令接⼝：直接在命令⾏输⼊&lt;/li>
&lt;li>脱机命令接⼝：写命令脚本&lt;/li>
&lt;/ul>
&lt;h3 id="02-操作系统的四个特征">02 操作系统的四个特征&lt;/h3>
&lt;p>操作系统的特征
并发（Concurrence）——最基本的特征
概念：指两个或多个事件在同⼀时间间隔内发⽣。这些时间宏观上是同时发⽣
的，微观上是交替发⽣的。
并⾏：指两个或多个事件在同⼀时刻同时发⽣。
单核与多核
单核CPU同⼀时刻只能运⾏⼀个程序，并发执⾏程序
多核CPU同⼀时刻可以执⾏多个程序，并⾏执⾏程序
共享（Sharing）——最基本的特征，⼆者互为存在条件
概念：即资源共享，是指系统中的资源可供内存中多个并发执⾏的进程共同使
⽤。
两种资源共享⽅式
互斥共享⽅式
⼀个时间段内只允许⼀个进程访问该资源啊
例⼦：摄像头，QQ和微信不能同时使⽤
同时访问⽅式
允许⼀个时间段内由多个进程“同时”对他们进⾏访问（宏观同时）
例⼦：发送⽂件、扬声器（真同时）
如果失去并发性，系统中只有⼀个程序正在运⾏，共享性失去意义。
如果失去共享性，QQ和微信不能同时访问硬盘资源，⽆法实现同时发送⽂
件，也就⽆法并发。
虚拟（Virtual）
概念：把⼀个物理上的实体变为若⼲个逻辑上的对应物。物理实体（前者）是实
际存在的，⽽逻辑上对应物（后者）是⽤户感受到的。
虚拟存储器技术，内存划分给多个程序使⽤：虚拟技术中的“空分复⽤技术”
虚拟处理器，处理器被多个程序使⽤：虚拟技术中的“时分复⽤”技术，微观上交
替执⾏。
没有并发性，也就谈不上虚拟性
异步（Asynchronism）
概念：在多道程序环境下，允许多个程序并发执⾏，但由于资源有限，进程的执
⾏不是⼀贯到底的，⽽是⾛⾛停停，以不可预知的速度向前推进。
如果失去并发性，系统只能串⾏执⾏各个程序，当程序执⾏完毕后才会归还。只
有系统拥有并发性，才有可能导致异步性。&lt;/p>
&lt;h3 id="03-os的发展与分类">03 OS的发展与分类&lt;/h3>
&lt;p>⼿⼯操作阶段
纸带
输⼊输出速度较慢，处理速度快，⽤户独占全机，⼈机速度⽭盾，导致资源利⽤率极
低
批处理阶段
单道批处理系统
主要特征
⾃动性，磁带上的作业能⾃动逐个运⾏
顺序性，作业的完成顺序与进⼊内存的顺序应完全相同
单道性，内存中仅有⼀道程序运⾏，即监督程序每次从磁带上只调⼊⼀道程
序进⼊内存运⾏，当该程序完成或发⽣异常时，才换⼊其后继程序进⼊内存运⾏。
外围机
引⼊脱机输⼊/输出技术（⽤外围机+磁带），并由监督程序负责控制作业的输
⼊、输出
监督程序——操作系统的雏形
优点
缓解⼈及速度⽭盾，提升资源利⽤率
缺点
内存中只能有⼀道程序运⾏
CPU有⼤量时间是在空闲等待I/O完成，利⽤率依然较低
多道批处理系统（操作系统开始出现）
优点
多道程序并发执⾏，共享计算机资源。资源利⽤率⼤幅提升，CPU和其他资
源更能保持“忙碌”状态，系统吞吐量增⼤。
缺点
没有⼈机交互功能，提交作业后只能等待计算机处理，⽆法对中间过程进⾏
⼲预，⽐如调试，输⼊参数
⼯作示意图
分时操作系统
概念：计算机以时间⽚为单位轮流为每个⽤户/作业服务，各个⽤户可通过终端与计
算机进⾏交互。
优点
⽤户的请求可以被即时相应，解决了⼈机交互问题。
允许多个⽤户同时使⽤⼀台计算机，并且⽤户对计算机的操作相互独⽴，感受不
到别⼈的存在。
⽤户感觉独占全机
缺点
不能优先处理紧急任务。
操作系统对每个⽤户/作业都是完全公平的，循环地为每个⽤户/作业服务⼀个时
间⽚，不区分任务点⽽紧急⾏。
实时操作系统
计算机系统接收到外部信号后及时进⾏处理，并且要在严格的时限内处理完事件。实
时操作系统的主要特点是及时性和可靠性。
优点
能够响应⼀些紧急任务，某些紧急任务不需时间⽚排队。
硬实时系统
必须在绝对严格的规定时间内完成处理。
（导弹控制系统、⾃动驾驶系统
软实时系统
能接受偶尔违反事件规定
⽹络操作系统
把⽹络中的各个计算机有机地结合起来，实现数据传输等功能。
实现⽹络中各种资源的共享（如⽂件共享）和个台计算机之间的通信。
Windows NT就是⼀种典型的⽹络操作系统，⽹站服务器就可以使⽤。
分布式操作系统
主要特点是：分布性和并⾏性。
系统中各台计算机地位相同，任何⼯作都可以⽤分布在这些计算机上，由它们并⾏、
协同完成这个任务。
个⼈计算机操作系统
Windows XP、MacOS&lt;/p>
&lt;h3 id="04-操作系统的运机制">⭐04 操作系统的运⾏机制&lt;/h3>
&lt;p>程序是如何运⾏的
C语⾔代码➡编译➡机器指令（⼆进制）
CPU执⾏机器指令
两种程序
内核程序
执⾏⼀些特权指令
应⽤程序
只能执⾏⾮特权指令
两种指令
特权指令
如：内存清零指令，这些指令影响重⼤，只允许管理者（操作系统内核）使⽤。
⾮特权指令
如：加法指令、减法指令。
两种处理器状态
⽤于区分此时正在运⾏的是内核程序 or 应⽤程序
内核态（核⼼态、管态）
运⾏的是内核程序
可以执⾏特权指令
⽤户态（⽬态）
运⾏的是应⽤程序
只能执⾏⾮特权指令
如何区分这两种状态？
CPU中的PSW寄存器（程序状态字寄存器），其中有个⼆进制位，1表示“内核
态”，0表示“⽤户态”
⭐两种状态的切换
内核态➡⽤户态
执⾏⼀条特权指令——修改PSW的标志位为⽤户态，操作系统主动让出CPU控
制权
⽤户态➡内核态
由“中断”引发，CPU 硬件⾃动完成变态过程，触发中断信号意味着操作系统
将强⾏夺回CPU的使⽤权&lt;/p>
&lt;h3 id="05-中断和异常">05 中断和异常&lt;/h3>
&lt;p>中断的作⽤
中断会使CPU由⽤户态变为内核态，使操作系统重新夺回对CPU的控制权
如果没⽤中断机制，就⽆法进⾏并发
中断是操作系统内核夺回CPU使⽤权的唯⼀途径
中断的类型
内中断（也称 异常、例外）
与当前执⾏的指令有关，中断信号来源于CPU内部
由某个指令引发的中断
陷阱、陷⼊（trap）
由陷⼊指令引发的，是应⽤程序故意引发的
如：系统调⽤
故障（fault）
由错误条件引起，可能被内核程序修复。
如：缺⻚故障
终⽌（abort）
由致命错误引起，内核程序⽆法修复该错误。
如：整数除0、⾮法使⽤特权指令
外中断（也称 中断）
与当前执⾏的指令⽆关，中断信号来源于CPU外部
时钟中断
由时钟部件发来的中断信号
时钟部件每隔⼀个时间⽚，归给CPU发送⼀个时钟中断信号
I/O中断
由输⼊输出设备发来的中断信号
中断机制的基本原理
不同的中断信号，需要⽤不同的中断处理程序来处理
内中断：CPU在执⾏指令时会检查是否有异常发⽣
外中断：每个指令周期末尾，CPU都会检查是否有外中断信号需要处理。
中断向量表
CPU检测到中断后，根据中断信号的类型去查询中断向量表，找到相应的中断处
理程序（运⾏在 内核态）在内存中的存放位置&lt;/p>
&lt;h3 id="06-系统调">06 系统调⽤&lt;/h3>
&lt;p>什么是系统调⽤？
概念：操作系统提供给应⽤程序（程序员/编程⼈员）使⽤的接⼝，可以理解为⼀种
可供应⽤系统调⽤的特殊函数，应⽤系统可以通过系统调⽤来请求获得操作系统内核
的服务。
程序接⼝由系统调⽤组成。
系统调⽤与库函数的区别
普通应⽤程序
直接进⾏系统调⽤
使⽤库函数（有的库函数会涉及系统调⽤）
编程语⾔
向上提供库函数
或把系统调⽤封装为库函数
操作系统
向上提供系统调⽤
⼩例⼦：为什么系统调⽤是必须的？
⽤户通过系统调⽤请求资源，由操作系统内核进⾏统⼀管理分配，避免混乱。
什么功能要⽤系统调⽤实现？
系统调⽤（按功能分类）
设备管理
完成设备的 请求/释放/启动 等功能
⽂件管理
完成⽂件的 读/写/创建/删除 等功能
进程控制
完成进程的 创建/撤销/阻塞/唤醒 等功能
进程通信
完成进程之间的 消息传递/信号传递 等功能
内存管理
完成内存的 分配/回收 等功能
系统调⽤的过程
传递系统调⽤参数
执⾏陷⼊/trap/访管指令（⽤户态）
内核程序处理系统调⽤（核⼼态）
返回应⽤程序&lt;/p>
&lt;h3 id="07-操作系统的体系结构">07 操作系统的体系结构&lt;/h3>
&lt;p>内核
对系统资源进⾏管理的功能
进程管理
存储器管理
设备管理
时钟管理
利⽤时钟中断实现计时功能
中断处理
原语（设备驱动、CPU切换等）
⼀种特殊的程序，具有原⼦性。这段程序的运⾏不能被中断。
变态的过程是有成本的，消耗时间，频繁地变态会降低系统性能
⾮内核功能
如：GUI
Ubuntu、CentOS主要⼯作是实现⾮内核功能，内核都是使⽤Linux内核
⼤内核
将操作系统的主要功能模块都作为系统内核，运⾏在核⼼态
优点：⾼性能
缺点：内核代码庞⼤，结构混乱，难以维护。
典型的 ⼤内核/宏内核/单内核 操作系统
Linux、Unix
微内核
只把最基本的功能保留在内核
优点：内核功能说好，结构清晰，⽅便维护
缺点：需要频繁地在核⼼态和⽤户态之间切换，性能低
典型的 微内核 操作系统
Windows NT&lt;/p>
&lt;h2 id="第章-进程管理">第⼆章 进程管理&lt;/h2>
&lt;h3 id="01-进程的-概念组成特征">01 进程的 概念、组成、特征&lt;/h3>
&lt;p>概念
进程 和 程序 的区别
程序：是静态的，就是个存放在磁盘⾥的可执⾏⽂件，就是⼀系列的指令集合。
进程（Process）：是动态的，是程序的⼀次执⾏过程。
操作系统如何区分进程
当进程被创建时，操作系统会为该进程分配⼀个唯⼀的、不重复的PID（Process
ID，进程ID）
组成
⼀个进程实体（进程映像）由PCB、程序段、数据段组成
进程是动态的，进程实体是静态的
进程是进程实体的运⾏过程，是系统进⾏资源分配和调度的⼀个独⽴单位。
PCB是进程存在的唯⼀标志！
进程控制块（PCB）
进程描述信息
进程标识符PID
⽤户标识符UID
进程控制和管理信息
CPU、磁盘、⽹络流量使⽤情况统计
进程当前状态：就绪态/阻塞态/运⾏态&amp;hellip;
资源分配清单
正在使⽤哪些⽂件
正在使⽤哪些内存区域
正在使⽤哪些I/O设备
处理机相关信息
PSW、PC等等各种寄存器的值（⽤于实现进程切换）
程序段
三个QQ进程的程序段相同，数据段、PCB不同
数据段
特征
动态性（进程最基本的特征）
进程是程序的⼀次执⾏过程，是动态地产⽣、变化和消亡的。
并发性
内存中有多个进程实体，各进程可并发执⾏
独⽴性
进程是能独⽴运⾏、独⽴获得资源、独⽴接受调度的基本单位
异步性
各进程按各⾃独⽴的、不可预知的速度向前推进，操作系统要提供“进程同步机
制”来解决异步问题。
结构性
每个进程都会配置⼀个PCB。结构上看，进程由程序段、数据段、PCB组成。
02 进程的状态与转换
状态
运⾏状态（Runing）
占有CPU，并在CPU上运⾏
单核CPU同⼀时刻只会有⼀个进程处于运⾏态，多核CPU可能有多个进程处于运
⾏态
就绪状态（Ready）
具备运⾏条件，但由于没有空闲CPU，⽽暂时不能运⾏
阻塞状态（Waiting/Blocked，⼜称：等待态）（三种基本状态）
因等待某⼀事件⽽暂时不能运⾏
创建状态（New，⼜称新建态）
进程正在被创建，操作系统为进程分配资源、初始化PCB
终⽌状态（Terminated，⼜称：结束态）
进程正在从系统中撤销，操作系统会回收进程拥有的资源、撤销PCB
state变量，1表示创建态，2表示就绪态，3表示运⾏态
状态间的转换
就绪态➡运⾏态
进程被调度
运⾏态➡就绪态
时间⽚到
处理机被抢占
运⾏态➡阻塞态
等待系统资源分配
或等待某时间发⽣（进程主动⾏为）
阻塞态➡就绪态
资源分配到位，等待的事件发⽣（被动⾏为），操作系统发起
进程的组织⽅式
链接⽅式
按照进程状态将PCB分为多个队列
操作系统持有指向各个队列的指针
过程
索引⽅式
根据进程状态的不同，建⽴⼏张索引表
操作系统持有指向各个索引表的指针
过程
03 进程控制
基本概念
概念：进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进
程、撤销已有进程、实现进程状态转换等功能。
实质：实现进程状态转换
过程图
如何实现进程控制：⽤“原语”实现
如何实现原语的“原⼦性”
⽤关中断指令和开中断指令这两个特权指令实现原⼦性
进程控制相关的原语
进程的创建
创建原语
申请空⽩PCB
为新进程分配所需资源
初始化PCB
将PCB插⼊就绪队列（创建态➡就绪态）
引起进程创建的事件
⽤户登录
分时系统中，⽤户登录成功，系统会为其建⽴⼀个新的进程
作业调度
多道批处理系统中，有新的作业放⼊内存时，会为其建⽴⼀个新的进程
提供服务
⽤户向操作系统提出某些请求时，会新建⼀个进程处理该请求
应⽤请求
由⽤户进程主动请求创建⼀个⼦进程
进程的终⽌
就绪态/阻塞态/运⾏态➡终⽌态➡⽆
撤销原语
从PCB集合中找到终⽌进程的PCB
若进程正在运⾏，⽴即剥夺CPU，将CPU分配给其他进程
终⽌其所有⼦进程
进程间的关系是树形结构
将该进程拥有的所有资源归还给⽗进程或操作系统
删除PCB
引起进程终⽌的事件
正常结束
进程⾃⼰请求终⽌（exit系统调⽤）
异常结束
整数除0、⾮法使⽤特权指令，然后被操作系统强⾏杀掉
外界⼲预
Ctrl + Alt + delete，⽤户选择杀掉进程
进程的阻塞
阻塞原语（运⾏态➡阻塞态）
找到要阻塞的进程对应的PCB
保护进程运⾏现场，将PCB状态信息设置为“阻塞态”，暂时停⽌进程运⾏
将PCB插⼊响应时间的等待队列
引起进程阻塞的事件
需要等待系统分配某种资源
需要等待相互合作的其他进程完成⼯作
进程的唤醒（成对出现）
唤醒原语（阻塞态➡就绪态）
在事件等待队列中找到PCB
将PCB从等待队列移除，设置进程为就绪态
将PCB插⼊就绪队列，等待被调度
引起进程唤醒的时间
等待事件发⽣（因何事阻塞，就应由何事唤醒）
进程的切换
切换原语（运⾏态➡就绪态、就绪态➡运⾏态）
将运⾏环境信息存⼊PCB
PCB移⼊相应队列
选择另⼀个进程执⾏，并更新其PCB
根据PCB恢复新进程所需的运⾏环境
引起进程切换的事件
当前进程时间⽚到
有更⾼优先的进程到达
当前进程主动阻塞
当前进程终⽌
04 进程通信
进程之间的信息交换
共享存储器系统
设置⼀个共享空间
要互斥地访问共享空间
两种⽅式
基于数据结构的共享（低级）
基于存储区的共享（⾼级）
消息传递系统
进程间的数据交换以格式化的消息（Message）为单位。
进程通过操作系统提供的“发送消息/接收消息”两个原语进⾏数据交换
消息头，消息体
直接通信⽅式
消息直接挂到接收进程的消息缓冲队列上
间接通信⽅式
消息要先发送到中间实体（信箱）中，因此也称（信箱通信⽅式）。
例⼦：电⼦邮件系统
管道通信系统
只能采⽤半双⼯通信，某⼀时间段内只能实现单向的传输
各进程要互斥地访问管道
数据以字节流写⼊管道，当管道写满时，写进程的write()系统调⽤将被阻塞，等待读
进程将数据取⾛。当数据被全部取⾛，管道变空，读进程的read()系统调⽤将被阻
塞。
如果没写满，就不允许读。如果没读空，就不允许写。
数据⼀旦被读出，就被抛弃，因此，读进程最多只能有⼀个
05 线程
什么是线程，为什么要引⼊线程？
线程是⼀个基本的CPU执⾏单元，也是程序执⾏流的最⼩单元。
引⼊线程后，进程之间可以并发，进程内的各线程之间也可以并发
引⼊线程后，进程只作为除CPU之外的系统资源的分配单位
打印机、内存地址空间都是分配给进程的
引⼊线程机制后，有什么变化
资源分配、调度
传统进程机制中，进程是资源分配、调度的基本单位
引⼊线程后，进程是资源分配的基本单位，线程是调度的基本单位
并发性
传统进程机制中，只能进程间并发
引⼊线程后，各线程间也能并发，提⾼了并发度
系统开销
传统的进程间并发，需要切换进程的运⾏环境，系统开销很⼤
线程间并发，如果是统⼀进程内的线程切换，不需要切换进程环境，开销⼩
引⼊线程后，并发所带来的系统开销减⼩
线程有哪些重要的属性
线程是处理机调度的单位
多CPU计算机中，各个线程可占⽤不同的CPU
每个线程都有⼀个线程id，线程控制块（TCB）
线程也有就绪、阻塞、运⾏三种基本状态
线程⼏乎不⽤系统资源
同⼀进程的不同线程间共享进程的资源
由于共享内存地址空间，同⼀进程中的线程间通信甚⾄⽆需系统⼲预
同⼀进程中的线程切换，不会引起进程切换
不同进程中的线程切换，会引起进程切换
切换同进程内的线程，系统开销很⼩
切换进程，系统开销较⼤
06 线程的实现⽅式——多线程模型
线程实现的⽅式
⽤户级线程（User-Level-thread，ULT）
线程库
优点
开销⼩，效率⾼
缺点
如果单个线程被阻塞，整个进程都会被阻塞，并发度不⾼。
多个线程⽆法在多核处理机上并⾏运⾏。
内核级线程
操作系统会为每个内核级线程建⽴相应的TCB (Thread Control Block，线程控制
块)，通过TCB对线程进⾏管理。“内核级线程”就是“从操作系统内核视⻆看能看到
的线程”
优点
当⼀个线程被阻塞后，别的线程还可以继续执⾏，并发能⼒强。
多线程可在多核处理机上并⾏执⾏。
缺点
⼀个⽤户进程会占⽤多个内核级线程，线程切换由操作系统内核完成，需要
切换到核⼼态，因此线程管理的成本⾼，开销⼤。
多线程模型
⼀对⼀模型
⼀个⽤户级线程映射到⼀个内核级线程。每个⽤户进程有与⽤户级线程同数量的
内核级线程。
优点
当⼀个线程被阻塞后，别的线程还可以继续执⾏，并发能⼒强。
多线程可在多核处理机上并⾏执⾏。
缺点
⼀个⽤户进程会占⽤多个内核级线程，线程切换由操作系统内核完成，需要
切换到核⼼态，因此线程管理的成本⾼，开销⼤。
多对⼀模型
多个⽤户级线程映射到⼀个内核级线程。且⼀个进程只被分配⼀个内核级线程。
优点
⽤户级线程的切换在⽤户空间即可完成，不需要切换到核⼼态，线程管理的
系统开销⼩，效率⾼
缺点
当⼀个⽤户级线程被阻塞后，整个进程都会被阻塞，并发度低。多个线程不
可在多核处理机上并⾏运⾏
操作系统只“看得⻅”内核级线程，因此只有内核级线程才是处理机分配的单位。
多对多模型
n⽤户及线程映射到m个内核级线程(n&amp;gt;=m)。每个⽤户进程对应m个内核级线程。
克服了多对⼀模型并发度不⾼的缺点(⼀个阻塞全体阻塞)，⼜克服了⼀对⼀模型
中⼀个⽤户进程占⽤太多内核级线程，开销太⼤的缺点。
⽤户级线程是“代码逻辑”的载体
内核级线程是“运⾏机会”的载体
07 处理机调度概念、层次
处理机调度
基本概念
当有⼀堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定
某种规则来决定处理这些任务的顺序，这就是“调度”研究的问题。
三个层次
⾼级调度（作业调度）
按⼀定的原则从外存的作业后备队列中挑选⼀个作业调⼊内存，并创建进
程，每个作业只调⼊⼀次，调出⼀次。作业调⼊时会建⽴PCB， 调出时才撒
销PCB。
中级调度（内存调度）
按照某种策略决定将哪个处于挂起状态的进程重新调⼊内存。
内存不够时，可将某些进程的数据调出外存。等内存空闲或者进程需要运⾏
时再重新调⼊内存。
暂时调到外存等待的进程状态为挂起状态（挂起态，suspend）。被挂起的进
程PCB会被组织成挂起队列
⾼频
低级调度（进程调度/处理机调度）
按照某种策略从就绪队列中选取⼀⼀个进程，将处理机分配给它。
进程调度是操作系统中最基本的⼀种调度，在⼀般的操作系统中都必须配置
进程调度。
三层调度的联系、对⽐
补充知识
进程的“挂起态”
就绪挂起
阻塞挂起
七状态模型
08 进程调度的时机、切换与过程调度⽅式
时机
什么时候需要进程调度?
主动放弃
进程正常终⽌
运⾏过程中发⽣异常⽽终⽌
进程主动请求阻塞（如等待I/O）
被动放弃
分给进程的时间⽚⽤完
有更紧急的事需要处理（如I/O中断）
有更⾼优先级的进程进⼊就绪队列
什么时候不能进⾏进程调度?
在处理中断的过程中。中断处理过程复杂，与硬件密切相关，很难做到在中断处
理过程中进⾏进程切换。
进程在操作系统内核程序临界区中。
在原⼦操作过程中（原语）。原⼦操作不可中断，要⼀⽓呵成（如之前讲过的修
改PCB中进程状态标志，并把PCB放到相应队列）
2012年联考真题
进程在操作系统内核程序临界区中不能进⾏调度与切换✅
进程处于临界区时不能进⾏处理机调度❌
普通临界区/内核临界区
临界资源
⼀个时间段内只允许⼀个进程使⽤的资源。各进程需要互斥地访问临界资
源。
临界区
访问临界资源的那段代码。
内核程序临界区
⼀般是⽤来访问某种内核数据结构的
如：进程的就绪队列(由各就绪进程的PCB组成)
切换与过程
&amp;ldquo;狭义的调度&amp;quot;与&amp;quot;切换”的区别
狭义的进程调度
指的是从就绪队列中选中⼀个要运⾏的进程。(这 个进程可以是刚刚被暂停执
⾏的进程，也可能是另⼀个进程，后⼀种情况就需要进程切换)
进程切换
指⼀个进程让出处理机，由另⼀个进程占⽤处理机的过程。
⼴义的进程调度包含了选择⼀个进程和进程切换两个步骤。
进程切换的过程需要做什么?
过程
对原来运⾏进程各种数据的保存
对新的进程各种数据的恢复(如:程序计数器、程序状态字、各种数据寄存器等
处理机现场信息，这些信息⼀般保存在进程控制块)
有代价的，如果过于频繁进⾏进程调度、切换，系统的效率会降低。
⽅式
⾮剥夺调度⽅式(⾮抢占式)
⾮剥夺调度⽅式，⼜称⾮抢占⽅式。即，只允许进程主动放弃处理机。在运⾏过
程中即便有更紧迫的任务到达，当前进程依然会继续使⽤处理机，直到该进程终
⽌或主动要求进⼊阻塞态。
实现简单，系统开销⼩但是⽆法及时处理紧急任务，适合于早期的批处理系统
剥夺调度⽅式(抢占式)
剥夺调度⽅式，⼜称抢占⽅式。当⼀个进程正在处理机上执⾏时，如果有⼀个更
重要或更紧迫的进程需要使⽤处理机，则⽴即暂停正在执⾏的进程，将处理机分
配给更重要紧迫的那个进程。
可以优先处理更紧急的进程，也可实现让各进程按时间⽚轮流执⾏的功能( 通过
时钟中断)。适合于分时操作系统、实时操作系统
09 调度算法的评价指标（计算）
CPU利⽤率
指CPU“忙碌”的时间占总时间的⽐例。
利⽤率 = 忙碌的时间/总时间（道/秒）
⽢特图
系统吞吐量
单位时间内完成作业的数量
系统吞吐量 = 总共完成了多少道作业 / 总共花了多少时间
周转时间
周转时间
指从作业被提交给系统开始，到作业完成为⽌的这段时间间隔。
（作业）周转时间 = 作业完成时间 - 作业提交时间
四部分
作业在外存后备队列上等待作业调度(⾼级调度)的时间
进程在就绪队列上等待进程调度( 低级调度)的时间
进程在CPU上执⾏的时间
进程等待I/O操作完成的时间
后三项在⼀个作业的整个处理过程中，可能发⽣多次。
平均周转时间
平均周转时间 = 各作业周转时间之和 / 作业数
带权周转时间
带权周转时间 = 作业周转时间 / 作业实际运⾏的时间
平均带权周转时间
平均带权周转时间 = 各作业带权周转时间之和 / 作业数
等待时间
指进程/作业处于等待处理机状态时间之和。
对于进程来说，等待时间就是指进程建⽴后等待被服务的时间之和，在等待I/O完成
的期间其实进程也是在被服务的，所以不计⼊等待时间。
对于作业来说，不仅要考虑建⽴进程后的等待时间，还要加上作业在外存后备队列中
等待的时间。
调度算法只会影响作业/进程的等待时间。
平均等待时间即各个 进程/作业 等待时间的平均值
响应时间
指从⽤户提交请求到⾸次产⽣响应所⽤的时间。
10 调度算法 先来先服务、最短作业优先、最⾼响应⽐优先
先来先服务（FCFS，First Come First Serve）
算法规则
按照作业/进程到达的先后顺序进⾏服务
⽤于作业/进程调度
⽤于作业调度时，考虑的是哪个作业先到达后备队列
⽤于进程调度时，考虑的是哪个进程先到达就绪队列
⾮抢占式
优点
公平、算法实现简单
缺点
排在⻓作业(进程)后⾯的短作业需要等待很⻓时间，带权周转时间很⼤，对短作
业来说⽤户体验不好。即，FCFS算法对⻓作业有利，对短作业不利
例如：排队买奶茶
最短作业优先（SJF）
思想
追求最少的平均等待时间，最少的平均周转时间、最少的平均平均带权周转时间
算法规则
最短的作业/进程优先得到服务(所谓“最短”，是指要求服务时间最短)
每次调度时选择当前已到达且运⾏时间最短的作业/进程
⽤于作业/进程调度
即可⽤于作业调度，也可⽤于进程调度。
⽤于进程调度时称为“短进程优先(SPF, Shortest Process First)算法
⾮抢占式
SJF和SPF是⾮抢占式的算法。但是也有抢占式的版本——最短剩余时间优先算法(
SRTN, Shortest Remaining Time Next )
最短剩余时间优先算法：每当有进程加⼊就绪队列改变时就需要调度，如果
新到达的进程剩余时间⽐当前运⾏的进程剩余时间更短，则由新进程抢占处
理机，当前运⾏进程重新回到就绪队列。另外，当⼀个进程完成时也需要调
度。
细节
如果未特别说明，短作业/进程优先算法默认是⾮抢占式的
在所有进程都⼏乎同时到达时，采⽤SJF调度算法的平均等待时间、平均周转
时间最少
抢占式的短作业/进程优先调度算法(最短剩余时间优先, SRNT算法)的平均等
待时间、平均周转时间最少”
缺点
对短作业有利，⻓作业不利。
可能产⽣饥饿现象。
最⾼响应⽐优先（HRRN，Highest Reponse Ratio Next）
思想
要综合考虑作业/进程的等待时间和要求服务的时间
算法规则
在每次调度时先计算各个作业/进程的响应⽐，选择响应⽐最⾼的作业/进程为其
服务
响应⽐ = （等待时间 + 要求服务时间）/ 要求服务时间
⽤于作业/进程调度
既可⽤于作业调度，也可⽤于进程调度
是否可抢占
⾮抢占式的算法。因此只有当前运⾏的作业/进程主动放弃处理机时，才需要调
度，才需要计算响应⽐
优缺点
综合考虑了等待时间和运⾏时间(要求服务时间)等待时间相同时，要求服务时间
短的优先(SJF 的优点)要求服务时间相同时，等待时间⻓的优先(FCFS 的优点)对于
⻓作业来说，随着等待时间越来越久，其响应⽐也会越来越⼤，从⽽避免了⻓作
业饥饿的问题
是否饥饿
不会导致饥饿
三种算法的⽐较
适⽤性
适⽤于早起的批处理系统，FCFS算法也常结合其他的算法使⽤
11 调度算法——时间⽚轮转、优先级调度、多级反馈队列
时间⽚轮转调度算法（RR，Round-Robin）
算法规则
按照各进程到达就绪队列的顺序，轮流让各个进程执⾏⼀个时间⽚(如100ms)。若
进程未在⼀个时间⽚内执⾏完，则剥夺处理机，将进程重新放到就绪队列队尾重
新排队。
⽤于作业/进程调度
是否可抢占
若进程未能在时间⽚内运⾏完，将被强⾏剥夺处理机使⽤权，因此时间⽚轮转调
度算法属于抢占式的算法。
由时钟装置发出时钟中断来通知CPU时间⽚已到。
优缺点
不会饥饿
时间⽚过⼤的影响
优先级调度算法
算法思想
随着计算机的发展，特别是实时操作系统的出现，越来越多的应⽤场景需要根据
任务的紧急程度来决定处理顺序。
调度规则
调度时选择优先级最⾼的作业/进程
⽤于作业调度/进程调度
既可⽤于作业调度，也可⽤于进程调度。甚⾄，还会⽤于在之后会学习的I/O调度
中
是否可抢占
抢占式、⾮抢占式都有。做题时的区别在于：⾮抢占式只需在进程主动放弃处理
机时进⾏调度即可，⽽抢占式还需在就绪队列变化时，检查是否会发⽣抢占。
优缺点
优点
⽤优先级区分紧急程度、重要程度，适⽤于实时操作系统。可灵活地调整对
各种作业/进程的偏好程度。
缺点
若源源不断地有⾼优先级进程到来，则可能导致饥
会导致饥饿
多级反馈队列调度算法
算法思想
对其他调度算法的折中权衡
算法规则
设置多级就绪队列，各级队列优先级从⾼到低，时间⽚从⼩到⼤
新进程到达时先进⼊第1级队列，按FCFS原则排队等待被分配时间⽚。若⽤完时
间⽚进程还未结束，则进程进⼊下⼀级队列队尾。如果此时已经在最下级的队
列，则重新放回最下级队列队尾
只有第k级队列为空时，才会为k+1级队头的进程分配时间⽚
抢占式
在k级队列的进程运⾏过程中，若更上级的队列(1~k-1级)中进⼊了⼀个新进程，则
由于新进程处于优先级更⾼的队列中，因此新进程会抢占处理机，原来运⾏的进
程放回k级队列队尾。
优点
对各类型进程相对公平(FCFS的优点) ；
每个新到达的进程都可以很快就得到响应(RR的优点)；
短进程只⽤较少的时间就可完成(SPF的优点) ；
不必实现估计进程的运⾏时间(避免⽤户作假) ;
可灵活地调整对各类进程的偏好程度，⽐如CPU密集型进程、I/0密集型进程(拓
展:可以将因I/O⽽阻塞的进程重新放回原队列，这样I/O型进程就可以保持较⾼优
先级)
会饥饿
综合⽐较
适合于交互式系统，⽐如：Unix
12 进程同步、进程互斥
进程同步
并发性带来了异步性，有时需要通过进程同步解决这种异步问题。
有的进程之间需要相互配合地完成⼯作，各进程的⼯作推进需要遵循- -定的先后顺
序。
进程互斥
对临界资源的访问，需要互斥的进⾏。即同⼀时间段内只能允许⼀个进程访问该资源
四个部分
进⼊区
检查是否可进⼊临界区，若可进⼊，需要“上锁”
临界区
访问临界资源的那段代码
退出区
负责&amp;quot;解锁&amp;rdquo;
剩余区
其余代码部分
需要遵循的原则
空闲让进
临界区空闲时，应允许⼀个进程访问
忙则等待
如临界区正在被访问时， 其他试图访问的进程需要等待
有限等待
要在有限时间内进⼊临界区，保证不会饥饿
让权等待
如进不了 临界区的进程，要释放处理机，防⽌忙等
13 进程互斥的软件实现⽅法
单标志法
算法思想
两个进程在访问完临界区后会把使⽤临界区的权限转交给另⼀个进程。也就是说
每个进程进⼊临界区的权限只能被另⼀个进程赋予。
int turn = 0; //turn表示当前允许进⼊临界区的进程号
同⼀时刻最多只允许⼀个进程访问临界区
双标志先检查
算法思想
设置⼀个布尔型数组flag[]， 数组中各个元素⽤来标记各进程想进⼊临界区的意
愿，⽐如“flag[0] = ture” 意味着0号进程PO现在想要进⼊临界区。每个进程在进⼊
临界区之前先检查当前有没有别的进程想进⼊临界区，如果没有，则把⾃身对应
的标志flag[]设为true,之后开始访问临界区。
双标志后检查
算法思想
双标志先检查法的改版。前⼀个算法的问题是先“检查”后“上锁”，但是这两个操
作⼜⽆法⼀⽓呵成，因此导致了两个进程同时进⼊临界区的问题。因此，⼈们⼜
想到先“上锁”后“检查”的⽅法，来避免上述问题。
优劣
解决了“忙则等待”的问题，违背了“空闲让进”和“有限等待”原则，会产⽣饥饿。
Peterson算法
算法思想
结合双标志法、单标志法的思想。如果双⽅都争着想进⼊临界区，那可以让进程
尝试“孔融让梨”(谦让)。做⼀个有礼貌的进程。
bool flag[2]; // 表示进⼊临界区意愿的数组，初始值都是false
int turn = 0; // turn表示优先让哪个进程进⼊临界区
图解
优劣
⽤软件⽅法解决了进程互斥问题，遵循了空闲让进、忙则等待、有限等待三个原
则，但是依然未遵循让权等待的原则。
14 进程互斥的硬件实现⽅法
中断屏蔽⽅法
使⽤“开关中断”指令实现
优点
简单⾼效
缺点
只适⽤于单处理机
只适⽤于操作系统内核进程
TestAndSet（TS指令/TSL指令）
过程：
old记录是否被上锁
再将lock设为true
检查临界区是否已被上锁（若已上锁，则循环重复前⼏步）
优点
实现简单
适⽤于多处理机环境
缺点
不满⾜“让权等待”
Swap指令（XCHG指令）
同TSL
15 信号量机制
⽤户进程可以通过使⽤操作系统提供的⼀对原语来对信号量进⾏操作，从⽽很⽅便的实
现了进程互斥、进程同步。
信号量其实就是⼀个变量(可以是⼀个整数，也可以是更复杂的记录型变量)，可以⽤
⼀个信号量来表示系统中某种资源的数量，⽐如：系统中只有⼀台打印机，就可以设
置⼀个初值为1的信号量。
原语是⼀种特殊的程序段，其执⾏只能⼀⽓呵成，不可被中断。原语是由关中断/开
中断指令实现的。软件解决⽅案的主要问题是由“进⼊区的各种操作⽆法⼀⽓呵成”，
因此如果能把进⼊区、退出区的操作都⽤“原语”实现，使这些操作能“⼀⽓呵成”就能
避免问题。
⼀对原语：wait(S)原语和signal(S)原语，可以把原语理解为我们⾃⼰写的函数，函数
名分别为wait和signal，括号⾥的信号量S其实就是函数调⽤时传⼊的⼀个参数。
wait、signal 原语常简称为P、V操作(来⾃荷兰语proberen和verhogen)。因此，做题的
时候常把wait(S)、signal(S)两个操作分别写为P(S)、V(S)
整型信号量
⽤⼀个整数型的变量作为信号量，⽤来表示系统中某种资源的数量。
整型信号量与普通整型变量的区别:对信号量只能执⾏初始化、P、V三种操作
存在的问题
不满⾜“让权等待”原则，会发⽣“忙等”
记录型信号量（⾼频考点）
即⽤记录型数据结构表示的信号量。
S.value表示某种资源数, S.L 指向等待该资源的队列
P 操作中，⼀定是先S.value&amp;ndash;，之后可能需要执⾏block原语
V 操作中，⼀定是先S.value++,之后可能需要执⾏wakeup原语
注意
要能够⾃⼰推断在什么条件下需要执⾏block或wakeup
功能
可以⽤记录型信号量实现系统资源的&amp;quot;申请&amp;quot;和&amp;quot;释放&amp;quot;
可以⽤记录型信号量实现进程互斥、进程同步
过程
16 ⽤信号量机制实现进程互斥、同步、前驱关系
⼀个信号量对应⼀种资源
实现进程互斥
过程
分析并发进程的关键活动，划定临界区（如：对临界资源打印机的访问就应该放
在临界区）
设置互斥信号量mutex，初值为1（semaphore mutex = 1; // 初始化信号量，默认
是记录型信号量）
在进⼊区P(mutex)——申请资源
在退出区V(mutex)——释放资源
注意：
对不同的临界资源需要设置不同的互斥信号量。
P、V操作必须成对出现。
实现进程同步
过程
1.分析什么地⽅需要实现“同步关系”，即必须保证“⼀前⼀后”执⾏的两个操作(或
两句代码)
2.设置同步信号量S，初始为0&lt;/p>
&lt;ol>
&lt;li>在“前操作”之后执⾏V(S)
4.在“后操作”之前执⾏P(S)
前V后P
演示
实现进程的前驱关系
过程
要为每⼀对前驱关系各设置⼀个同步信号量
在“前操作”之后对相应的同步信号量执⾏V操作
在“后操作”之前对相应的同步信号量执⾏P操作
实现进程的前驱关系
17 ⽣产者消费者问题
如何实现
⽣产者、消费者共享⼀个初始为空、⼤⼩为n的缓冲区。
只有缓冲区没满时，⽣产者才能把产品放⼊缓冲区，否则必须等待。
只有缓冲区不空时，消费者才能从中取出产品，否则必须等待。
缓冲区是临界资源，各进程必须互斥地访问。
实现图解
思考：能否改变相邻P、V操作的顺序？
会发⽣死锁
实现互斥的P操作⼀定要在实现同步的P操作之后
V操作不会导致进程阻塞，因此，两个V操作顺序可以交换
易错点
实现互斥和实现同步的两个P操作的先后顺序（死锁问题）
两对同步关系
18 多⽣产者-多消费者
加上互斥信号量。互斥的P操作⼀定要在实现同步的P操作之后，否则可能引起“死锁”
解题思路
1.关系分析。找出题⽬中描述的各个进程，分析它们之间的同步、互斥关系。&lt;/li>
&lt;li>整理思路。根据各进程的操作流程确定P、V操作的⼤致顺序。&lt;/li>
&lt;li>设置信号量。设置需要的信号量，并根据题⽬条件确定信号量初值。 (互斥信号量
初值⼀般为1，同步信号量的初始值要看对应资源的初始值是多少)
解决“多⽣产者-多消费者问题”的关键在于理清复杂的同步关系。
在分析同步问题(⼀前⼀后问题)的时候不能从单个进程⾏为的⻆度来分析，要把“⼀前
⼀后”发⽣的事看做是两种“事件”的前后关系。
过程关系
19 吸烟者问题
代码分析
20 读者-写者问题
实现
两种问题的区别与使⽤
21 哲学家进餐问题
每个进程需要同时持有多个临界资源
防⽌死锁的发⽣
⽅案①、②
⽅案③
22 管程
为什么要引⼊管程
信号量机制存在的问题
编写程序困难、易出错
⾼级同步机制
封装的思想
定义
管程是⼀种特殊的软件模块
组成部分&lt;/li>
&lt;li>局部于管程的共享数据结构说明；&lt;/li>
&lt;li>对该数据结构进⾏操作的⼀组过程；&lt;/li>
&lt;li>对局部于管程的共享数据设置初始值的语句；&lt;/li>
&lt;li>管程有⼀个名字。
基本特征&lt;/li>
&lt;li>局部于管程的数据只能被局部于管程的过程所访问;&lt;/li>
&lt;li>⼀个进程只有通过调⽤管程内的过程才能进⼊管程访问共享数据;&lt;/li>
&lt;li>每次仅允许⼀个进程在管程内执⾏某个内部过程。
拓展1：⽤管程解决⽣产者消费者问题
各进程必须互斥访问管程的特性是由编译器实现的
实现⽅法
具体过程&lt;/li>
&lt;li>需要在管程中定义共享数据(如⽣产者消费者问题的缓冲区)&lt;/li>
&lt;li>需要在管程中定义⽤于访问这些共享数据的“⼊⼝”——其实就是⼀-些函数(如⽣
产者消费者问题中，可以定义⼀个函数⽤于将产品放⼊缓冲区，再定义⼀个函数
⽤于从缓冲区取出产品)&lt;/li>
&lt;li>只有通过这些特定的“⼊⼝”才能访问共享数据&lt;/li>
&lt;li>管程中有很多“⼊⼝”，但是每次只能开放其中⼀个“⼊⼝”，并且只能让⼀个进
程或线程进⼊(如⽣产者消费者问题中，各进程需要互斥地访问共享缓冲区。管程
的这种特性即可保证⼀个时间段内最多只会有⼀个进程在访问缓冲区。注意:这种
互斥特性是由编译器负责实现的，程序员不⽤关⼼) 。&lt;/li>
&lt;li>可在管程中设置条件变量及等待/唤醒操作以解决同步问题。可以让⼀个进程或
线程在条件变量上等待(此时，该进程应先释放管程的使⽤权，也就是让出“⼊
⼝”) ；可以通过唤醒操作将等待在条件变量上的进程或线程唤醒。
程序员可以⽤某种特殊的语法来定义⼀个管程monitor，之后其他程序员可以使⽤这
个管程提供的⼊⼝，⽅便实现进程同步/互斥
拓展2：Java中类似于管程的机制
Java中的synchronized
23 死锁的概念
什么是死锁
在并发环境下，各进程因竞争资源⽽造成的⼀种互相等待对⽅⼿⾥的资源，导致各进
程都阻塞，都⽆法向前推进的现象，就是“死锁”。
发⽣死锁后若⽆外⼒⼲涉，这些进程都将⽆法向前推进。
进程死锁、饥饿、死循环的区别
死锁
各进程互相等待对⽅⼿⾥的资源，导致各进程都阻塞，⽆法向前推进的现象。
饥饿
由于⻓期得不到想要的资源，某进程⽆法向前推进的现象。⽐如：在短进程优先
(SPF) 算法中，若有源源不断的短进程到来，则⻓进程将⼀直得不到处理机， 从
⽽发⽣⻓进程“饥饿”。
死循环
某进程执⾏过程中⼀直跳不出某个循环的现象。有时是因为程序逻辑bug导致
的，有时是程序员故意设计的。
三者的区别
死锁产⽣的必要条件
互斥条件
只有对必须互斥使⽤的资源的争抢才会导致死锁(如哲学家的筷⼦、打印机设
备)。像内存、扬声器这样可以同时让多个进程使⽤的资源是不会导致死锁的(因
为进程不⽤阻塞等待这种资源)。
不剥夺条件
进程所获得的资源在未使⽤完之前，不能由其他进程强⾏夺⾛，只能主动释放。
请求和保持条件
进程已经保持了⾄少⼀个资源，但⼜提出了新的资源请求，⽽该资源⼜被其他进
程占有，此时请求进程被阻塞，但⼜对⾃⼰已有的资源保持不放。
循环等待条件
存在⼀种进程资源的循环等待链，链中的每⼀个进程已获得的资源同时被下⼀个
进程所请求。
发⽣死锁时⼀定有循环等待，但是发⽣循环等待时未必死锁
什么时候会发⽣死锁
对不可剥夺资源的不合理分配，可能导致死锁&lt;/li>
&lt;li>对系统资源的竞争。各进程对不可剥夺的资源( 如打印机)的竞争可能引起死锁，对
可剥夺的资源(CPU)的竞争是不会引起死锁的。&lt;/li>
&lt;li>进程推进顺序⾮法。请求和释放资源的顺序不当，也同样会导致死锁。例如，并发
执⾏的进程P1、P2分别申请并占有了资源R1、R2，之后进程P1⼜紧接着申请资源
R2，⽽进程P2⼜申请资源R1,两者会因为申请的资源被对⽅占有⽽阻塞，从⽽发⽣死
锁。
3.信号量的使⽤不当也会造成死锁。如⽣产者-消费者问题中，如果实现互斥的P操作
在实现同步的P操作之前，就有可能导致死锁。( 可以把互斥信号量、同步信号量也看
做是⼀&amp;ldquo;种抽象的系统资源)
死锁的处理逻辑
预防死锁
破坏死锁产⽣的四个必要条件
避免死锁
避免系统进⼊不安全状态（银⾏家算法）
死锁的检测和解除
允许死锁发⽣，系统负责检测出死锁并解除
24 死锁的处理策略——预防死锁（静态策略）
破坏互斥条件
只有对必须互斥使⽤的资源的争抢才会导致死锁。
SPOOLing技术把独占设备在逻辑上改造成共享设备
破坏不剥夺条件
不剥夺条件：
进程所获得的资源在未使⽤完之前，不能由其他进程强⾏夺⾛，只能主动释放。
⽅案⼀
某些资源上位使⽤完，也要主动释放，从⽽破坏不可剥夺条件。
⽅案⼆
当某个进程需要的资源被其他进程所占有的时候，由操作系统协助，将想要的资
源强⾏剥夺。
缺点
实现复杂
可能会造成前⼀阶段⼯作的失效。只适⽤于易保存和恢复状态的资源，如CPU
增加系统开销，降低系统吞吐量
可能导致某个进程饥饿
破坏请求和保持条件
请求和保持条件：
进程已经保持了⾄少⼀个资源，但⼜提出了新的资源请求，⽽该资源⼜被其他进
程占有，此时请求进程被阻塞，但⼜对⾃⼰已有的资源保持不放。
采⽤静态分配⽅法，即进程在运⾏前⼀次申请完它所需要的全部资源，在它的资源未
满⾜前，不让它投⼊运⾏。⼀旦投⼊运⾏后，这些资源就⼀直归它所有， 该进程就
不会再请求别的任何资源了。
缺点
资源利⽤率低。导致某些进程饥饿。
破坏循环等待条件
循环等待条件
存在⼀种进程资源的循环等待链，链中的每⼀- 个进程已获得的资源同时被下⼀
⼀个进程所请求。
可采⽤顺序资源分配法。
⾸先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类
资源(即编号相同的资源)⼀次申请完。
原理分析
⼀个进程只有已占有⼩编号的资源时，才有资格申请更⼤编号的资源。按此规
则，已持有⼤编号资源的进程不可能逆向地回来申请⼩编号的资源，从⽽就不会
产⽣循环等待的现象。
缺点
不⽅便增加新设备
会导致资源浪费
⽤户变成麻烦
25 死锁的处理策略——避免死锁（动态策略）
什么是安全序列
如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要找出⼀个安全序
列，系统就是安全状态，安全序列可能有多个。
什么是系统的不安全状态，与死锁有何联系
如果分配了资源之后，系统中找不出任何⼀个安全序列，系统就进⼊了不安全状态。
可能会导致所有进程都⽆法顺利的执⾏下去，也有可能冲洗你回到安全状态。
如果处于安全状态，就⼀定不会发⽣死锁。如果进⼊不安全状态，可能会导致死锁。
如何避免系统进⼊不安全状态——银⾏家算法
数据结构
⻓度为m的⼀-维数组Available 表示还有多少可⽤资源
n&lt;em>m矩阵Max表示各进程对资源的最⼤需求数
n&lt;/em>m矩阵Allocation表示已经给各进程分配了多少资源
Max-Allocation=Need矩阵表示各进程最多还需要多少资源
⽤⻓度为m的⼀-位数组Request表示进程此次申请的各种资源数
银⾏家算法步骤
①检查此次申请是否超过了之前声明的最⼤需求数
②检查此时系统剩余的可⽤资源是否还能满⾜这次请求
③试探着分配，更改各数据结构
④⽤安全性算法检查此次分配是否会导致系统进⼊不安全状态
安全性算法步骤
检查当前的剩余可⽤资源是否能满⾜某个进程的最⼤需求，如果可以，就把该进
程加⼊安全序列,并把该进程持有的资源全部回收。
不断重复上述过程，看最终是否能让所有进程都加⼊安全序列。
系统处于不安全状态未必死锁，但死锁时⼀定处于不安全状态。系统处于安全状态⼀定
不 会死锁。
26 死锁的处理策略——检测和解除（允许死锁的发⽣）
死锁的检测
数据结构资源分配图
两种结点
进程结点
对应⼀个进程
资源结点
对应⼀类资源，⼀类资源可能有多个
两种边
进程结点——&amp;gt;资源结点
表示进程想申请⼏个资源（每条边代表⼀个）
资源结点——&amp;gt;进程结点
表示已经为进程分配了⼏个资源（每条边代表⼀个）
是否可以消除所有边
检测死锁的算法
1)在资源分配图中，找出既不阻塞⼜不是孤点的进程Pi (即找出⼀条有向边与它相
连，且该有向边对应资源的申请数量⼩于等于系统中已有空闲资源数量。如下图
中，R1没有空闲资源，R2有⼀个空闲资源。若所有的连接该进程的边均满⾜上述
条件，则这个进程能继续运⾏直⾄完成，然后释放它所占有的所有资源)。消去它
所有的请求边和分配边，使之称为孤⽴的结点。在下图中，P1是满⾜这⼀条件的
进程结点，于是将P1的所有边消去。
2)进程Pi所释放的资源，可以唤醒某些因等待这些资源⽽阻塞的进程，原来的阻
塞进程可能变为⾮阻塞进程。在下图中，P2就满⾜这样的条件。根据1)中的⽅法
进⾏⼀系列简化后，若能消去途中所有的边，则称该图是可完全简化的。
死锁定理
如果某时刻系统的资源分配图是不可完全简化的，那么此时系统死锁。
死锁的解除
⼀旦检测出死锁的发⽣，就应该⽴即解除死锁
并不是系统中所有的进程都是死锁状态。⽤死锁检测算法化简资源分配图后，还连着
边的那些进程就是死锁进程
解除死锁的主要⽅法有&lt;/li>
&lt;li>资源剥夺法。挂起( 暂时放到外存上)某些死锁进程，并抢占它的资源，将这些
资源分配给其他的死锁进程。但是应防⽌被挂起的进程⻓时间得不到资源⽽饥
饿。&lt;/li>
&lt;li>撤销进程法(或称终⽌进程法)。强制撤销部分、甚⾄全部死锁进程，并剥夺这
些进程的资源。这种⽅式的优点是实现简单，但所付出的代价可能会很⼤。因为
有些进程可能已经运⾏了很⻓时间，已经接近结束了，⼀旦被终⽌可谓功亏⼀
篑，以后还得从头再来。&lt;/li>
&lt;li>进程回退法。让⼀个或多个死锁进程回退到⾜以避免死锁的地步。这就要求系
统要记录进程的历史信息，设置还原点。
如何决定“对谁动⼿”
1.进程优先级
2.已执⾏多⻓时间
3.还要多久能完成
4.进程已经使⽤了多少资源
5.进程是交互式的还是批处理式的
第三章 内存管理
01 内存的基础知识
什么是内存，有何作⽤
内存可存放数据。
程序执⾏前需要先放到内存中才能被CPU处理——缓冲CPU与硬盘之间的速度⽭盾
按字节编址
每个存储单元⼤⼩为1字节
按字编址
如果字⻓为16位，按字编址，每个存储单元⼤⼩为1个字；16个⼆进制位
进程运⾏的基本原理
指令的⼯作原理
操作码+参数
MOV, A, B
逻辑地址VS物理地址
相对地址
绝对地址
如何实现地址转换
装⼊的三种⽅式
绝对装⼊
编译时产⽣绝对地址
可重定位装⼊（静态重定位）
⼀次分配完所需要的内存空间
动态运⾏时装⼊（动态重定位）
动态重定位
重定位寄存器
从写程序到程序运⾏的过程
编译
由编译程序将⽤户源代码编译成若千个⽬标模块(编译就是把⾼级语⾔翻译为
机器语⾔)
链接
由链接程序将编译后形成的⼀-组⽬标模块，以及所需库函数链接在⼀起，形
成-⼀个完整的装⼊模块
装⼊(装载)
由装⼊程序将装⼊模块装⼊内存运⾏
链接的三种⽅式
静态链接
在程序运⾏之前，先将各⽬标模块及它们所需的库函数连接成⼀个完整的可
执⾏⽂件(装⼊模块) ，之后不再拆开。
装⼊时动态链接
将各⽬标模块装⼊内存时，边装⼊边链接的链接⽅式。
运⾏时动态链接
在程序执⾏中需要该⽬标模块时，才对它进⾏链接。其优点是便于修改和更
新，便于实现对⽬标模块的共享。
02 内存管理的概念
内存空间的分配与回收
内存空间的扩充
地址转换
逻辑地址与物理地址的转换
三种装⼊⽅式
绝对装⼊（单道程序阶段，⽆操作系统）
编译时产⽣绝对地址
可重定位装⼊（早期多道批处理阶段）
装⼊时将逻辑地址转换为物理地址
动态运⾏时装⼊（现代操作系统）
运⾏时将逻辑地址转换为物理地址，需设置重定位寄存器
存储保护
保证各进程在⾃⼰的内存空间内运⾏，不会越界访问
两种⽅式
设置上下限寄存器
利⽤重定位寄存器、界地址寄存器进⾏判断
03 覆盖与交换（内存空间的扩充）
覆盖技术
解决 程序⼤⼩超过物理内存总和
必须由程序员声明覆盖结构，操作系统完成⾃动覆盖。
缺点
对⽤户不透明，增加了⽤户编程负担
交换（对换）技术
内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运⾏条
件的进程换⼊内存(进程在内存与磁盘间动态调度)
中级调度（内存调度）
决定将哪个处于挂起状态的进程重新调⼊内存
在外存的什么位置保存被换出的进程
具有对换功能的操作系统中，通常把磁盘空间分为⽂件区和对换区两部分。
⽂件区
主要⽤于存放⽂件，主要追求存储空间的利⽤率，因此对⽂件区空间的管理
采⽤离散分配⽅式。
对换区
对换区空间只占磁盘空间的⼩部分，被换出的进程数据就存放在对换区。由
于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求
换⼊换出速度，因此通常对换区采⽤连续分配⽅式( 学过⽂件管理章节后即可
理解)。总之，对换区的I/O速度⽐⽂件区的更快。
什么时候交换
内存吃紧时进⾏，系统负荷降低就暂停
例如
在发现许多进程运⾏时经常发⽣缺⻚，就说明内存紧张，此时可以换出⼀些
进程:
如果缺⻚率明显下降，就可以暂停换出。
应该换出哪些进程
优先换出阻塞进程
可换出优先级低的进程
防⽌优先级低的进程在被调⼊内存后很快被换出，还需考虑进程在内存的驻留时
间
PCB会常驻内存
虚拟存储技术
04 连续分配管理⽅式
单⼀连续分配
内存被分为系统区、⽤户区
内存中只能有⼀道⽤户程序，⽤户程序独占整个⽤户区
优点
实现简单
⽆外部碎⽚
可以采⽤覆盖技术扩充内存
不⼀定需要采取内存保护
缺点
只能⽤于单⽤户、单任务操作系统
有内部碎⽚（有些内部空间没有被利⽤到）
存储利⽤率极低
固定分区分配
分区⼤⼩相等
缺乏灵活性，适⽤于⼀台计算机控制多个相同对象的场合
将程序分段
固定区
调⼊后就不再调出，直⾄运⾏结束
覆盖区
覆盖区中的程序段在运⾏过程中会根据需要调⼊调出
分区⼤⼩不等
增加了灵活性，满⾜不同⼤⼩的进程需求，操作系统根据作业⼤⼩情况进⾏划分
⽆外部碎⽚，有内部碎⽚
动态分区分配
根据进程⼤⼩动态地建⽴分区
分区的⼤⼩和数⽬是可变的
采⽤什么数据结构记录内存的使⽤情况
空闲分区表
空闲分区链
动态分区分配算法
动态分区分配没有内部碎⽚，但是有外部碎⽚
内部碎⽚，分配给某进程的内存区域中，有些部分没有⽤上
外部碎⽚，内存中的某些空闲分区由于太⼩⽽难以利⽤
外部碎⽚可⽤“紧凑”技术来解决
回收内存的四种情况
回收区之后有相邻的空闲分区
回收区之前有相邻的空闲分区
回收区前、后都有相邻的空闲分区
回收区前、后都没有相邻的空闲分区
05 动态分区分配算法
⾸次适应算法（FF，First Fit）
算法思想
每次都从低地址开始查找，找到第⼀个能满⾜⼤⼩的空闲分区。
如何实现
空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链(或空闲分
区表)，找到⼤⼩能满⾜要求的第⼀个空闲分区。
最佳适应算法（BF，Best Fit）
算法思想
由于动态分区分配是⼀种连续分配⽅式，为各进程分配的空间必须是连续的⼀整
⽚区域。因此为了保证当“⼤进程”到来时能有连续的⼤⽚空间，可以尽可能多地
留下⼤⽚的空闲区即，优先使⽤更⼩的空闲区。
如何实现
空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链( 或空闲分
区表)，找到⼤⼩能满⾜要求的第⼀个空闲分区。
缺点
每次都选最⼩的分区进⾏分配，会留下越来越多的、很⼩的、难以利⽤的内存
块。因此这种⽅法会产⽣很多的外部碎⽚。
最坏适应算法（WF，Worst Fit）
⼜称最⼤适应算法（Largest Fit）
算法思想
为了解决最佳适应算法的问题⼀&amp;mdash;即留下太多难以利⽤的⼩碎⽚，可以在每次分
配时优先使⽤最⼤的连续空闲区，这样分配后剩余的空闲区就不会太⼩，更⽅便
使⽤。
如何实现
空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区
表)，找到⼤⼩能满⾜要求的第⼀个空闲分区。
邻近适应算法（NF，Next Fit）
算法思想
如何实现
优点
⾸次适应算法效果最好
⽐较
06 基本分⻚存储管理的基本概念
内存空间的分配与回收
连续分配管理⽅式
连续分配：为⽤户进程分配的必须是⼀⼀个连续的内存空间。
⾮连续分配管理⽅式
⾮连续分配：为⽤户进程分配的可以是-⼀些分散的内存空间。
基本分⻚存储管理
什么是分⻚存储
内存空间分为⼀个个⼤⼩相等的分区，每个分区就是⼀个“⻚框”（⻚框=
⻚帧=内存块=物理块=物理⻚⾯）。每个⻚框有⼀个编号，即“⻚框
号”（⻚框号=⻚帧号=内存块号=物理块号=物理⻚号），⻚框号从0开
始。
将进程的逻辑地址空间也分为与⻚框⼤⼩相等的⼀个个部分，每个部分
称为⼀个“⻚”或“⻚⾯”。每个⻚⾯也有⼀个编号，即“⻚号”，⻚号也是从
0开始
进程的⻚⾯与内存的⻚框有⼀⼀对应的关系。
各个⻚⾯不必连续存放，可以放到不相邻的各个⻚框中。
易混淆
⻚、⻚⾯ vs ⻚框、⻚帧、物理⻚；
⻚号、⻚⾯号 vs ⻚框号、⻚帧号、物理⻚号
⻚表
⻚表通常存在PCB中
⼀个进程对应⼀张⻚表
进程的每个⻚⾯对应⼀个⻚表项
每个⻚表项由“⻚号”和“块号”组成
⻚表记录进程⻚⾯和实际存放的内存块之间的映射关系
具体关系图
已知内存⼤⼩，⻚⾯⼤⼩，计算每个⻚表项需要多⼤
内存⼤⼩/⻚⾯⼤⼩，换算为⽐特位，再转换为字节
计算⽅法
如何实现地址转换&lt;/li>
&lt;li>计算出逻辑地址对应的【⻚号，业内偏移量】&lt;/li>
&lt;li>找到对应⻚⾯在内存中的存放位置（查⻚表）&lt;/li>
&lt;li>物理地址 = ⻚⾯始址 + ⻚内偏移量
逻辑地质结构——可拆分为【⻚号P，⻚内偏移量W】
⻚号 = 逻辑地址 / ⻚⾯⼤⼩；
⻚内偏移量 = 逻辑地址 % ⻚⾯⼤⼩
如果⻚⾯⼤⼩刚好是2的整数次幂呢
结论:如果每个⻚⾯⼤⼩为2^K B，⽤⼆进制数表示逻辑地址，则末尾
K位即为⻚内偏移量，其余部分就是⻚号
基本地址变换机构【⻅P7】
基本分段存储管理
段⻚式存储管理
内存空间的扩充
地址转换
存储保护
07 基本地址变换机构
⻚表寄存器的作⽤
存放⻚表起始地址
存放⻚表⻓度
⚡地址变换过程&lt;/li>
&lt;li>根据逻辑地址算出⻚号、⻚内偏移量&lt;/li>
&lt;li>⻚号的合法性检查(与⻚表⻓度对⽐)&lt;/li>
&lt;li>若⻚号合法，再根据⻚表起始地址、⻚号找到对应⻚表项&lt;/li>
&lt;li>根据⻚表项中记录的内存块号、⻚内偏移量得到最终的物理地址&lt;/li>
&lt;li>访问物理内存对应的内存单元
其他⼩细节
⻚内偏移量位数与⻚⾯⼤⼩之间的关系(要能⽤其中⼀个条件推出另⼀个条件)
⻚式管理中地址是⼀维的
实际应⽤中，通常使-个⻚框恰好能放⼊整数个⻚表项
为了⽅便找到⻚表项，⻚表- -般是放在连续的内存块中的
08 具有快表的地址变换机构
什么是快表（TLB）
快表，⼜称联想寄存器(TLB， translation lookaside buffer)，是⼀种访问速度⽐内存快
很多的⾼速缓存(TLB不是内存! )，⽤来存放最近访问的⻚表项的副本，可以加速地址
变换的速度。与此对应，内存中的⻚表常称为慢表。
引⼊快表后，地址的变换过程
①CPU给出逻辑地址，由某个硬件算得⻚号、⻚内偏移量，将⻚号与快表中的所有⻚
号进⾏⽐较。
②如果找到匹配的⻚号，说明要访问的⻚表项在快表中有副本，则直接从中取出该⻚
对应的内存块号，再将内存块号与⻚内偏移量拼接形成物理地址，最后，访问该物理
地址对应的内存单元。因此，若快表命中，则访问某个逻辑地址仅需⼀次访存即可。
③如果没有找到匹配的⻚号，则需要访问内存中的⻚表，找到对应⻚表项，得到⻚⾯
存放的内存块号，再将内存块号与⻚内偏移量拼接形成物理地址，最后，访问该物理
地址对应的内存单元。因此，若快表未命中，则访问某个逻辑地址需要两次访存(注
意:在找到⻚表项后，应同时将其存⼊快表，以便后⾯可能的再次访问。但若快表已
满，则必须按照⼀-定 的算法对旧的⻚表项进⾏替换)
局部性原理
时间局部性
如果执⾏了程序中的某条指令，那么不久后这条指令很有可能再次执⾏;如果某个
数据被访问过，不久之后该数据很可能再次被访问。( 因为程序中存在⼤量的循
环)
空间局部性
⼀旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访
问。(因为很 多数据在内存中都是连续存放的)
对⽐图
09 两级⻚表
单级⻚表存在什么问题?如何解决?
所有⻚表项必须连续存放，⻚表过⼤时需要很⼤的连续空间
在⼀段时间内并⾮所有⻚⾯都⽤得到，因此没必要让整个⻚表常驻内存
两级⻚表
将⻓⻓的⻚表再分⻚
逻辑地址结构: 【⼀级⻚号，⼆级⻚号，⻚内偏移量】
注意⼏个术语:⻚⽬录表/外层⻚表/顶级⻚表
如何实现地址变换?
①按照地址结构将逻辑地址拆分成三部分
②从PCB中读出⻚⽬录表始址，根据⼀级⻚号查⻚⽬录表，找到下⼀级⻚表在内存中
的存放位置
③根据⼆级⻚号查表，找到最终想访问的内存块号
④结合⻚内偏移量得到物理地址
两级⻚表问题需要注意的⼏个细节
多级⻚表中，各级⻚表的⼤⼩不能超过⼀个⻚⾯。若两级⻚表不够，可以分更多级
多级⻚表的访存次数(假设没有快表机构) ——N 级⻚表访问⼀个逻辑地址需要N+ 1次访
存
10 基本分段存储管理⽅式
什么是分段(类似于分⻚管理中的&amp;quot;分⻚&amp;rdquo;)
将地址空间按照程序⾃身的逻辑关系划分为若⼲个段，每段从0开始编址
每个段在内存中占据连续空间，但各段之间可以不相邻
逻辑地址结构：【段号， 段内地址】
什么是段表(类似于分⻚管理中的&amp;quot;⻚表&amp;quot;)
记录逻辑段到实际存储地址的映射关系
每个段对应-个段表项。各段表项⻓度相同，由段号(隐含)段⻓、基址组成
如何实现地址变换&lt;/li>
&lt;li>由逻辑地址得到段号、段内地址&lt;/li>
&lt;li>段号与段表寄存器中的段⻓度⽐较，检查是否越界&lt;/li>
&lt;li>由段表始址、段号找到对应段表项&lt;/li>
&lt;li>根据段表中记录的段⻓，检查段内地址是否越界&lt;/li>
&lt;li>由段表中的“基址+段内地址”得到最终的物理地址&lt;/li>
&lt;li>访问⽬标单元
分段、分⻚管理的对⽐
分⻚对⽤户不可⻅，分段对⽤户可⻅
分⻚的地址空间是⼀维的，分段的地址空间是⼆维的
分段更容易实现信息的共享和保护(纯代码可重⼊代码可以共享)
分⻚(单级⻚表)、 分段访问⼀个逻辑地址都需要两次访存，分段存储中也可以引⼊快
表机构
11 段⻚式管理⽅式
分⻚、分段管理⽅式中最⼤的优缺点
将地址空间按照程序⾃身的逻辑关系划分为若⼲个段，在将各段分为⼤⼩相等的⻚⾯
将内存空间分为与⻚⾯⼤⼩相等的⼀个个内存块，系统以块为单位为进程分配内存
逻辑地址结构:【段号，⻚号，⻚内偏移量】
分段 + 分⻚的结合——段⻚式管理⽅式
每个段对应⼀个段表项。各段表项⻓度相同，由段号(隐含)、⻚表⻓度、⻚表存放地
址组成
每个⻚对应⼀个⻚表项。各⻚表项⻓度相同，由⻚号(隐含)、⻚⾯存放的内存块号组
成
段表、⻚表&lt;/li>
&lt;li>由逻辑地址得到段号、⻚号、⻚内偏移量&lt;/li>
&lt;li>段号与段表寄存器中的段⻓度⽐较，检查是否越界&lt;/li>
&lt;li>由段表始址、段号找到对应段表项&lt;/li>
&lt;li>根据段表中记录的⻚表⻓度，检查⻚号是否越界&lt;/li>
&lt;li>由段表中的⻚表地址、⻚号得到查询⻚表，找到相应⻚表项&lt;/li>
&lt;li>由⻚⾯存放的内存块号、⻚内偏移量得到最终的物理地址&lt;/li>
&lt;li>访问⽬标单元
如何实现地址变换
第⼀次——查段表、第⼆次——查⻚表、第三次——访问⽬标单元
可引⼊快表机构，以段号和⻚号为关键字查询快表，即可直接找到
最终的⽬标⻚⾯存放位置。引⼊快表后仅需-次访存
12 虚拟内存的基本概念
传统存储管理⽅式的特征、缺点
⼀次性
作业必须⼀次性全部装⼊内存后才能开始运⾏。这会造成两个问题：
①作业很⼤时，不能全部装⼊内存，导致⼤作业⽆法运⾏；
②当⼤量作业要求运⾏时，由于内存⽆法容纳所有作业，因此只有少量作业能运
⾏，导致多道程序并发度下降。
驻留性
⼀旦作业被装⼊内存，就会⼀直驻留在内存中，直⾄作业运⾏结束。事实上，在
⼀个时间段内，只需要访问作业的⼀⼩部分数据即可正常运⾏，这就导致了内存
中会驻留⼤量的、暂时⽤不到的数据，浪费了宝贵的内存资源。
局部性原理
时间局部性
现在访问的指令、数据在不久后很可能会被再次访问
空间局部性
现在访问的内存单元周围的内存空间，很可能在不久后会被访问
⾼速缓存技术
使⽤频繁的数据放到更⾼速的存储器中
虚拟内存的定义和特征
定义
程序不需全部装⼊即可运⾏，运⾏时根据需要动态调⼊数据，若内存不够，还需
换出⼀些数据。
多次性：⽆需在作业运⾏时⼀次性全部装⼊内存，⽽是允许被分成多次调⼊内存。
对换性：在作业运⾏时⽆需⼀直常驻内存，⽽是允许在作业运⾏过程中，将作业换
⼊、换出。
虚拟性：从逻辑上扩充了内存的容量，使⽤户看到的内存容量，远⼤于实际的容量。
如何实现虚拟内存技术
借助离散分配的内存管理⽅式（基本分⻚存储管理、基本分段、基本段⻚式）
访问的信息不在内存时，由操作系统负责将所需信息从外存调⼊内存(请求调⻚功能)
内存空间不够时，将内存中暂时⽤不到的信息换出到外存(⻚⾯置换功能)
虚拟内存的实现
请求分⻚存储管理
请求调⻚
⻚⾯置换
请求分段存储管理
请求调段
段置换
请求段⻚式存储管理
13 请求分⻚管理⽅式
⻚表机制
在基本分⻚的基础上增加了⼏个表项
状态位：表示⻚⾯是否已在内存中
访问字段：记录最近被访问过⼏次，或记录上次访问的时间，供置换算法选择换出⻚
⾯时参考
修改位：表示⻚⾯调⼊内存后是否被修改过，只有修改过的⻚⾯才需在置换时写回外
存
外存地址：⻚⾯在外存中存放的位置
缺⻚中断机构
找到⻚表项后检查⻚⾯是否已在内存，若没在内存,产⽣缺⻚中断
缺⻚中断处理中，需要将⽬标⻚⾯调⼊内存，有必要时还要换出⻚⾯
缺⻚中断属于内中断，属于内中断中的“故障&amp;quot;，即可能被系统修复的异常
⼀条指令在执⾏过程中可能产⽣多次缺⻚中断
地址变换机构
找到⻚表项是需要检查⻚⾯是否在内存中
若⻚⾯不再内存中，需要请求调⻚
若内存空间不够，还需换出⻚⾯
⻚⾯调⼊内存后，需要修改相应⻚表项
14 ⻚⾯置换算法
最佳置换算法(OPT)
最佳置换算法(OPT, Optimal) :每次选择淘汰的⻚⾯将是以后永不使⽤，或者在最⻓时
间内不再被访问的⻚⾯，这样可以保证最低的缺⻚率。
最佳置换算法可以保证最低的缺⻚率，但实际上，只有在进程执⾏的过程中才能知道
接下来会访问到的是哪个⻚⾯。操作系统⽆法提前预判⻚⾯访问序列。因此，最佳置
换算法是⽆法实现的。
先进先出置换算法(FIFO)
先进先出置换算法(FIFO) ：每次选择淘汰的⻚⾯是最早进⼊内存的⻚⾯
实现⽅法:把调⼊内存的⻚⾯根据调⼊的先后顺序排成⼀⼀个队列， 需要换出⻚⾯时
选择队头⻚⾯即可。队列的最⼤⻓度取决于系统为进程分配了多少个内存块。
Belady异常——当为进 程分配的物理块数增⼤时，缺⻚次数不减反增的异常现象。
只有FIFO算法会产⽣Belady异常。另外，FIFO算法 虽然实现简单，但是该算法与进程
实际运⾏时的规律不适应，因为先进⼊的⻚⾯也有可能最经常被访问。因此，算法性
能差
最近最久未使⽤置换算法(LRU)
最近最久未使⽤置换算法(LRU， least recently used)：每次淘汰的⻚⾯是最近最久未
使⽤的⻚⾯
实现⽅法:赋予每个⻚⾯对应的⻚表项中，⽤访问字段记录该⻚⾯⾃上次被访问以来
所经历的时间t。
当需要淘汰：⼀个⻚⾯时，选择现有⻚⾯中t值最⼤的，即最近最久未使⽤的⻚⾯。
时钟置换算法(CLOCK)
时钟置换算法是⼀种性能和开销较均衡的算法，⼜称CLOCK算法，或最近未⽤算法
(NRU，Not Recently Used)
简单的CLOCK算法实现⽅法：为每个⻚⾯设置⼀个访问位，再将内存中的⻚⾯都通过
链接指针链接成⼀个循环队列。
当某⻚被访问时，其访问位置为1。
当需要淘汰⼀个⻚⾯时，只需检查⻚的访问位。
如果是0，就选择该⻚换出；
如果是1，则将它置为0，暂不换出，继续检查下⼀个⻚⾯，若第⼀轮扫描中
所有⻚⾯都是1，则将这些⻚⾯的访问位依次置为0后，再进⾏第⼆轮扫描(第
⼆轮扫描中⼀定会有访问位为0的⻚⾯，因此简单的CLOCK算法选择⼀个淘汰
⻚⾯最多会经过两轮扫描)
改进型的时钟置换算法
简单的时钟置换算法仅考虑到⼀个⻚⾯最近是否被访问过。事实上，如果被淘汰的⻚
⾯没有被修改过，就不需要执⾏I/0操作写回外存。只有被淘汰的⻚⾯被修改过时，才
需要写回外存。
因此，除了考虑⼀个⻚⾯最近有没有被访问过之外，操作系统还应考虑⻚⾯有没有被
修改过。在其他条件都相同时，应优先淘汰没有修改过的⻚⾯，避免I/O操作。这就
是改进型的时钟置换算法的思想。修改位=0，表示⻚⾯没有被修改过;修改位=1， 表
示⻚⾯被修改过。
为⽅便讨论，⽤(访问位，修改位)的形式表示各⻚⾯状态。如(1，1)表示⼀个⻚⾯近
期被访问过,且被修改过。
算法规则
⼏种置换算法的⽐较
15 ⻚⾯分配策略
驻留集
驻留集
指请求分⻚存储管理中给进程分配的物理块的集合。
在采⽤了虚拟存储技术的系统中，驻留集⼤⼩⼀般⼩于进程的总⼤⼩。
若驻留集太⼩，会导致缺⻚频繁，系统要花⼤量的时间来处理缺⻚，实际⽤于进
程推进的时间很少；
驻留集太⼤，⼜会导致多道程序并发度下降，资源利⽤率降低。所以应该选择⼀
个合适的驻留集⼤⼩。
固定分配：操作系统为每个进程分配- -组固定数⽬的物理块，在进程运⾏期间不再改
变。即，驻留集⼤⼩不变
可变分配：先为每个进程分配&amp;ndash;定数⽬的物理块，在进程运⾏期间，可根据情况做适
当的增加或减少。即，驻留集⼤⼩可变
局部置换：发⽣缺⻚时只能选进程⾃⼰的物理块进⾏置换。
全局置换：可以将操作系统保留的空闲物理块分配给缺⻚进程，也可以将别的进程持
有的物理块置换到外存，再分配给缺⻚进程。
⻚⾯分配、置换策略
固定分配局部置换
固定分配局部置换:系统为每个进程分配-⼀ 定数量的物理英,”在整个运⾏期向都不改
变。若进程在运外⾏中发⽣缺⻚，则只能从该进程在内存中的⻚⾯中选出⼀- ⻚换
出，然后再调⼊需要的⻚⾯。这种策略的缺点是:很难在刚开始就确定应为每个进程
分配多少个物理块才算合理。(采⽤这种策略的 系统可以根据进程⼤⼩、优先级、或
是根据程序员给出的参数来确定为- - 个进程分配的内存块数)
可变分配全局置换
刚开始会为每个进程分配⼀定数量的物理块。操作系统会保持- - 个空闲物理块队
列。当某进程发⽣缺⻚时，从空闲物理块中取出⼀块分配给该进程;若已⽆空闲物
理块，则可选择⼀个未锁定的⻚⾯换出外存，再将该物理块分配给缺⻚的进程。
采⽤这种策略时，只要某进程发⽣缺⻚，.都将获得新的物理块，仅当空闲物理块
⽤完时，系统才选择⼀个未锁定的⻚⾯调出。被选择调出的⻚可能是系统中任何
⼀个进程中的⻚，因此这个被选中的进程拥有的物理块会减少，缺⻚率会增加。
可变分配局部置换
刚开始会为每个进程分配⼀定数量的物理块。当某进程发⽣缺⻚时，只允许从该
进程⾃⼰的物理块中选出⼀个进⾏换出外存。如果进程在运⾏中频繁地缺⻚，系
统会为该进程多分配⼏个物理块，直⾄该进程缺⻚率趋势适当程度；反之，如果
进程在运⾏中缺⻚率特别低，则可适当减少分配给该进程的物理块。
区别
可变分配全局置换：只要缺⻚就给分配新物理块
可变分配局部置换：要根据发⽣缺⻚的频率来动态地增加或减少进程的物理块
调⼊⻚⾯的时机
预调⻚策略：⼀般⽤于进程运⾏前
请求调⻚策略：进程运⾏时，发现缺⻚再调⻚
从何处调⻚
对换区——采⽤连续存储⽅式，速度更快；⽂件区——采⽤离散存储⽅式，速度更
慢。
对换区⾜够⼤：运⾏将数据从⽂件区复制到对换区，之后所有的⻚⾯调⼊、调出都是
在内存与对换区之间进⾏
对换区不够⼤：不会修改的数据每次都从⽂件区调⼊；会修改的数据调出到对换区，
需要时再从对换区调⼊
抖动(颠簸)现象
⻚⾯频繁换⼊换出的现象。主要原因是分配给进程的物理块不够
⼯作集
在某段时间间隔⾥，进程实际访问⻚⾯的集合。驻留集⼤⼩⼀般不能⼩于⼯作集⼤
⼩。
第四章 ⽂件管理
01 初识⽂件管理
⽂件定义：⼀组有意义的信息的集合
⽂件的属性
⽂件名：由创建⽂件的⽤户决定⽂件名，主要是为了⽅便⽤户找到⽂件，同⼀⽬录下
不允许有重名⽂件。
标识符：⼀个系统内的各⽂件标识符唯-⼀，对⽤户来说毫⽆可读性,因此标识符只是
操作系统⽤于区分各个⽂件的⼀种内部名称。
类型：指明⽂件的类型.
位置：⽂件存放的路径(让⽤户使⽤)、在外存中的地址(操作系统使⽤，对⽤户不可
⻅)
⼤⼩：指明⽂件⼤⼩
创建时间、上次修改时间、⽂件所有者信息
保护信息：对⽂件进⾏保护的访问控制信息
操作系统向上提供哪些功能
创建⽂件(create系统调⽤)
删除⽂件(delete 系统调⽤)
读⽂件(read系统调⽤)
写⽂件(write系统调⽤)
打开⽂件(open系统调⽤)
关闭⽂件(close 系统调⽤)
⽂件内部应该如何被组织起来(⽂件的逻辑结构)
⽂件之间应该如何被组织起来(⽬录结构)
⽂件应如何存放在外存中(⽂件的物理结构)
操作系统如何管理外存中的空闲块(存储空间的管理)
操作系统需要提供的其他⽂件管理功能
⽂件共享
⽂件保护
02 ⽂件的逻辑结构
⽆结构⽂件
有结构⽂件
顺序⽂件
串结构：记录顺序与关键字⽆关
顺序结构：记录按关键字顺序排列
可变⻓记录的顺序⽂件⽆法实现随机存取，定⻓记录可以
定⻓记录、顺序结构的顺序⽂件可以快速检索(根据关键字快速找到记录)
最⼤缺点：不⽅便增加/删除记录
索引⽂件
建⽴⼀张索引表，每个记录对应-个表项。各记录不⽤保持顺序,⽅便增加删除记
录
索引表本身就是定⻓记录的顺序⽂件，⼀个索引表项就是⼀条定⻓记录， 因此索
引⽂件可⽀持随机存取
若索引表按关键字顺序排列，则可⽀持快速检索
解决了顺序⽂件不⽅便增/删记录的问题，同时让不定⻓记录的⽂件实现了随机存
取。但索引表可能占⽤很多空间
索引顺序⽂件
将记录分组，每组对应-⼀个索引表项
检索记录时先顺序查索引表，找到分组，再顺序查找分组
当记录过多时，可建⽴多级索引表
03 ⽂件⽬录
⽂件控制块(实现⽂件⽬录的关键数据结构)
⼀个⽂件对应⼀个FCB，个FCB就是⼀个⽬录项，多个FCB组成⽂件⽬录
对⽬录的操作:搜索、创建⽂件、删除⽂件、显示⽂件、修改⽂件
⽬录结构
单级⽬录结构
⼀个系统只有⼀张⽬录表，不允许⽂件重名
两级⽬录结构
不同⽤户的⽂件可以重名，但不能对⽂件进⾏分类
多级⽬录结构(树形⽬录结构)
不同⽬录下的⽂件可以重名，可以对⽂件进⾏分类，不⽅便⽂件共享
系统根据“⽂件路径&amp;quot;找到⽬标⽂件
从根⽬录出发的路径是“绝对路径&amp;quot; (&amp;quot;/照⽚/2015-08/⾃ 拍jipg&amp;quot;)
从&amp;quot;当前⽬录”出发的路径是&amp;quot;相对路径”(&amp;quot;/照⽚/201 5-08/⾃拍jpg&amp;quot;)
⽆环图⽬录结构
在树形⽬录结构的基础上，增加⼀些指向同⼀节点的有向边，使整个⽬录成为⼀
个有向⽆环图
为共享结点设置⼀个共享计数器，计数器为0时才真正删除该结点
索引结点(对⽂件控制块的优化)
除了⽂件名之外的所有信息都放到索引结点中，每个⽂件对应⼀个索引结点
⽬录项中只包含⽂件名、索引结点指针，因此每个⽬录项的⻓度⼤幅减⼩
由于⽬录项⻓度减⼩，因此每个磁盘块可以存放更多个⽬录项，因此检索⽂件时磁盘
I/0的次数就少了很多
04 ⽂件的物理结构（⽂件分配⽅式）
对⾮空闲磁盘块的管理（存放了⽂件数据的磁盘块）
连续分配
链接分配
链接分配采取离散分配的⽅式，可以为⽂件分配离散的磁盘块。分为隐式链接和
显式链接两种。
隐式链接
隐式链接——除⽂件的最后⼀个盘块之外，每个盘块中都存有指向下⼀个盘块
的指针。⽂件⽬录包括⽂件第⼀块的指针和最后⼀块的指针。
优点：很⽅便⽂件拓展，不会有碎⽚问题，外存利⽤率⾼。
缺点：只⽀持顺序访问，不⽀持随机访问，查找效率低，指向下⼀个盘块的
指针也需要耗费少量的存储空间。
题⽬中没有要求，默认是隐式链接的链接分配
显式链接
把⽤于链接⽂件各物理块的指针显式地存放在⼀张表中，即⽂件分配表
(FAT， File Allocation Table)。⼀个磁盘只会建⽴⼀张⽂件分配表。开机时⽂
件分配表放⼊内存，并常驻内存。
优点：很⽅便⽂件拓展，不会有碎⽚问题，外存利⽤率⾼，并且⽀持随机访
问。相⽐于隐式链接来说，地址转换时不需要访问磁盘，因此⽂件的访问效
率更⾼。
缺点：⽂件分配表的需要占⽤⼀定的存储空间。
索引分配
①链接⽅案：如果索引表太⼤，⼀个索引块装不下，那么可以将多个索引块链接
起来存放。缺点:若⽂件很⼤，索引表很⻓，就需要将很多个索引块链接起来。想
要找到i号索引块，必须先依次读⼊0~i-1号索引块，这就导致磁盘I/O次数过多，
查找效率低下。
②多层索引：建⽴多层索引(原理类似于多级⻚表)。使第⼀层索引块指向第⼆层
的索引块。还可根据⽂件⼤⼩的要求再建⽴第三层、第四层索引块。采⽤K层索
引结构，且顶级索引表未调⼊内存，则访问⼀个数据块只需要K+ 1次读磁盘操
作。
缺点：即使是⼩⽂件，访问⼀个数据块依然需要K+1次读磁盘。
③混合索引：多种索引分配⽅式的结合。例如，⼀个⽂件的顶级索引表中，既包
含直接地址索引(直接指向数据块)，⼜包含⼀级间接索引(指向单层索引表)、还包
含两级间接索引(指向两层索引表)。
优点：对于⼩⽂件来说，访问⼀个数据块所需的读磁盘次数更少。
超级超级超级重要考点:
①要会根据多层索引、混合索引的结构计算出⽂件的最⼤⻓度(Key：各级索
引表最⼤不能超过⼀个块) ；
②要能⾃⼰分析访问某个数据块所需要的读磁盘次数(Key：FCB中 会存有。
指向顶级索 引块的指针，因此可以根据FCB读⼊顶级索引块。每次读⼊下⼀
级的索引块都需要⼀次读磁盘操作。另外，要注意题⽬条件——顶级索引块是
否已调⼊内存)
各种⽂件分配⽅式的区别
对空闲磁盘块的管理
06 逻辑结构vs物理结构
逻辑结构
⽤户(⽂件创建者)的视⻆看到的亚⼦
在⽤户看来，整个⽂件占⽤连续的逻辑地址空间
⽂件内部的信息组织完全由⽤户⾃⼰决定，操作系统并不关⼼
物理结构
由操作系统决定⽂件采⽤什么物理结构存储
操作系统负责将逻辑地址转变为(逻辑块号， 块内偏移量)的形式，并负责实现逻辑块
号到物理块号的映射
07 ⽂件存储空间管理
存储空间的划分与初始化
⽂件卷(逻辑卷)的概念
为磁盘分区（C/D/E盘），分为逻辑磁盘
⽬录区与⽂件区
⽬录区，主要存放⽂件⽬录信息（FCB）、⽤与磁盘存储空间管理的信息
⽂件区，⽤于存放⽂件数据
多个物理磁盘也可以组成⼀个⽂件卷
初始化
将各个⽂件卷划分为⽬录区、⽂件去
⼏种管理⽅法
注意：
⽤什么⽅式记录、组织空闲块？
如何分配磁盘块
如何回收磁盘块
空闲表法
绿⾊为空闲块、橙⾊为⾮空闲块，适⽤于“连续分配⽅式”
如何分配磁盘块：与内存管理中的动态分区分配很类似，为⼀个⽂件分配连续的
存储空间。同样可采⽤⾸次适应、最佳适应、最坏适应等算法来决定要为⽂件分
配哪个区间。
如何回收磁盘块:与内存管理中的动态分区分配很类似，当回收某个存储区时需要
有四种情况
①回收区的前后都没有相邻空闲区;
②回收区的前后都是空闲区;
③回收区前⾯是空闲区;
④回收区后⾯是空闲区。
总之，回收时需要注意表项的合并问题。
空闲链表法
空闲盘块链
以盘块为单位组成⼀条空闲链
图示
空闲盘区链
以盘区为单位组成⼀条空闲链
图示
如何分配：如何分配:若某⽂件申请K个盘块，则可以采⽤⾸次适应、最佳适
应等算法，从链头开始检索，按照算法规则找到⼀个⼤⼩符合要求的空闲盘
区，分配给⽂件。若没有合适的连续空闲块，也可以将不同盘区的盘块同时
分配给⼀个⽂件，注意分配后可能要修改相应的链指针、盘区⼤⼩等数据。
如何回收：若回收区和某个空闲盘区相邻，则需要将回收区合并到空闲盘区
中。若回收区没有和任何空闲区相邻，将回收区作为单独的⼀个空闲盘区挂
到链尾。
离散分配、连续分配都适⽤。为⼀个⽂件分配多个盘块时效率更⾼。
两种分配⽅式的图示
位示图法
位示图：每个⼆进制位对应⼀⼀个盘块。在本例中，“0” 代表盘块空闲，“1”代表
盘块已分配。位示图⼀般⽤连续的“字”来表示，如本例中⼀个字的字⻓是16位，
字中的每- -位对应⼀⼀个盘块。因此可以⽤(字号，位号)对应⼀个盘块号。当然
有的题⽬中也描述为(⾏号，列号)
计算：
通过（字号，位号）=（i， j）定位得到盘块号b
b号盘块对应的字号i = b/n，位号j = b%n
区分从0开始还是从1开始
如何分配：若⽂件需要K个块，
①顺序扫描位示图，找到K个相邻或不相邻的“0”;
②根据字号、位号算出对应的盘块号，将相应盘块分配给⽂件;
③将相应位设置为“1”
如何回收：
①根据回收的盘块号计算出对应的字号、位号;
②将相应⼆进制位设为“0”
适⽤：连续分配和离散分配都适⽤
成组链接法
Unix系统中采⽤了成组链接法对磁盘空闲块进⾏管理
⽂件卷的⽬录区中专⻔⽤⼀个磁盘块作为“超级块”，当系统启动时需要将超级块
读⼊内存，并且要保证内存与外存的“超级块”数据⼀致
超级块
还有点&amp;hellip;笔者理解起来有点困难，先不写了&amp;hellip;
08 ⽂件的基本操作
向上提供的⼏个最基本的功能
创建⽂件 create系统调⽤
点击“新建”后，图形化交互进程在背后调⽤“create系统调⽤”
提供的参数
所需的外存空间⼤⼩：1KB
⽂件存放路径&amp;quot;D:/Demo&amp;quot;
⽂件名 test.txt
操作系统需要做的：
在外存找到⽂件所需的空间（⽤空闲链表法、位示图、成组链接法等管
理策略，找到空闲空间）
根据⽂件存放路径的信息找到该⽬录对应的⽬录⽂件(此处就是D:/Demo
⽬录)，在⽬录中创建该⽂件对应的⽬录项。⽬录项中包含了⽂件名、⽂
件在外存中的存放位置等信息。
删除⽂件 delete系统调⽤
读⽂件 read系统调⽤
写⽂件 write系统调⽤
打开⽂件open系统调⽤
关闭⽂件 close系统调⽤
0x&amp;hellip;
第五章 输⼊/输出(I/O)管理
后续会更新&amp;hellip;
稍安勿躁。&lt;/li>
&lt;/ol></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</guid><description>&lt;h1 id="操作系统基础">操作系统基础&lt;/h1>
&lt;h2 id="计算机系统概述">⼀、计算机系统概述&lt;/h2>
&lt;h3 id="11-基本概念">1.1 基本概念&lt;/h3>
&lt;p>OS指控制和管理整个计算机系统的硬件与软件资源，合理组织、调度计算机的⼯作与资源分配，进⽽为⽤户和其他软件提供⽅便接⼝与环境的程序集合；&lt;/p>
&lt;p>基本特征：&lt;/p>
&lt;ul>
&lt;li>并发: 两个或多个事件在同⼀时间间隔内发⽣；&lt;/li>
&lt;li>共享: 系统中的资源可供多个并发进程共同使⽤；&lt;/li>
&lt;li>虚拟: 通过某种技术将⼀个物理实体变为多个逻辑实体；&lt;/li>
&lt;li>异步: 事件以不可知的速度推进；&lt;/li>
&lt;/ul>
&lt;p>功能根据目标的划分:&lt;/p>
&lt;ul>
&lt;li>对硬件资源抽象（OS作为 扩充机器 ）
&lt;ul>
&lt;li>将裸机改造为功能更强、使⽤更⽅便的机器，因此把覆盖了软件的机器叫做 虚拟机 和 扩充机器；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>资源管理
&lt;ul>
&lt;li>处理机管理&lt;/li>
&lt;li>存储器管理&lt;/li>
&lt;li>⽂件管理&lt;/li>
&lt;li>设备管理&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>提供用户与硬件之间的接⼝
&lt;ul>
&lt;li>命令接⼝
&lt;ul>
&lt;li>联机命令接⼝（交互式命令接⼝）&lt;/li>
&lt;li>脱机命令接⼝（批处理命令接⼝）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>程序接⼝
&lt;ul>
&lt;li>由⼀组 作业控制命令 组成；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>功能从应用角度划分:&lt;/p>
&lt;ul>
&lt;li>进程管理&lt;/li>
&lt;li>存储管理(内/外存管理)&lt;/li>
&lt;li>⽂件管理&lt;/li>
&lt;li>设备管理(IO管理)&lt;/li>
&lt;/ul>
&lt;h3 id="12-发展与分类">1.2 发展与分类*&lt;/h3>
&lt;ul>
&lt;li>⼿⼯操作阶段：没有操作系统出现，每个操作都由⼈来控制；&lt;/li>
&lt;li>批处理阶段
&lt;ul>
&lt;li>将多个操作打包成作业使计算机进程批处理；&lt;/li>
&lt;li>单道批处理：操作是成批进⾏的（⼀份作业包含很多操作），内存只有⼀道作业；&lt;/li>
&lt;li>多道批处理：内存包含多道作业（等待事件发⽣时可以⾃动切换作业）；宏观并⾏，微观串⾏（ 并发执行 ）；&lt;/li>
&lt;li>ENIAC、GM-NAA I／O&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>分时操作系统：多⽤户通过终端同时共享⼀台主机（⼀般采⽤分时技术），提⾼ 交
互性 ；
&lt;ul>
&lt;li>Multics、UNIX、Linux&lt;/li>
&lt;li>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e5%9f%ba%e7%a1%80/2024-03-07-10-06-07.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>实时操作系统：提⾼ 及时性 和 可靠性 ；&lt;/li>
&lt;li>⽹络操作系统和分布式计算机系统&lt;/li>
&lt;li>个⼈计算机操作系统
&lt;ul>
&lt;li>macOS、Windows&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="13-硬件结构">1.3 硬件结构*&lt;/h3>
&lt;p>冯诺依曼结构&lt;/p>
&lt;ul>
&lt;li>中央处理器（CPU）：根据程序指令对数据进⾏处理；主要负责运算和逻辑控制；&lt;/li>
&lt;li>存储器：存放程序和数据。&lt;/li>
&lt;li>输入输出设备&lt;/li>
&lt;/ul>
&lt;p>CPU的指令集架构（Instruction Set Architecture，ISA）包含了CPU的指令集、特叹级、寄存器、执行模式｀安全扩展。&lt;/p>
&lt;p>指令集：&lt;/p>
&lt;ul>
&lt;li>精简指令集（RISC）
&lt;ul>
&lt;li>AArch64体系结构（ARMv8）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>复杂指令集（CISC）
&lt;ul>
&lt;li>x86体系结构&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>CPU运⾏状态&lt;/strong>
不同架构下CPU的特权级划分不一致&lt;/p>
&lt;p>如AArch64按如下划分：&lt;/p>
&lt;ul>
&lt;li>EL0: 最低的特权级，应用程序通常运行在该特权级，也称为&lt;strong>用户态&lt;/strong>。&lt;/li>
&lt;li>EL1:操作系统通常运行在该特权级，也称为&lt;strong>内核态&lt;/strong>。&lt;/li>
&lt;li>EL2:在虚拟化场景下需要，虚拟机监控器(VirtualMachine Monitor，VMM，也称为 Hypervisor)通常运行在该特权级。&lt;/li>
&lt;li>EL3:和安全特性 TrustZone相关，负责普通世界(normal world)和安全世界secure world)之间的切换。&lt;/li>
&lt;/ul>
&lt;p>x86按如下划分：&lt;/p>
&lt;ul>
&lt;li>Ring 0: 内核态&lt;/li>
&lt;li>Ring 1-3: 用户态&lt;/li>
&lt;li>Ring 0是最高特权级，Ring 3是最低特权级。&lt;/li>
&lt;/ul>
&lt;p>通常只需要区分内核态和用户态即可&lt;/p>
&lt;ul>
&lt;li>内核态（ 管态 ）
&lt;ul>
&lt;li>可以使⽤ &lt;strong>特权指令&lt;/strong> ；&lt;/li>
&lt;li>OS的 内核程序 运⾏在管态；&lt;/li>
&lt;li>内核态特权指令对应的实体为 内核 ；
&lt;blockquote>
&lt;p>系统调⽤相关位于⾼层，硬件相关位于底层；
内核是计算机上配置的 底层软件 ，是计算机功能的延伸；&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>系统调⽤相关；
&lt;blockquote>
&lt;p>引发⼴义中断⾥⾯的系统异常（⽤户执⾏陷⼊指令⽽触发的操作系统的系统调⽤引起的中断）；&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>进程管理&lt;/li>
&lt;li>存储器管理&lt;/li>
&lt;li>设备管理&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>硬件模块相关；
&lt;ul>
&lt;li>时钟管理&lt;/li>
&lt;li>中断机制
&lt;ul>
&lt;li>只有⼀⼩部分在内核（保护和恢复中断现场的信息，转移控制权到相关的处理程序）；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>原语&lt;/li>
&lt;li>设备驱动&lt;/li>
&lt;li>CPU切换&lt;/li>
&lt;li>进程通信&lt;/li>
&lt;li>…&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>⽤户态（ 目态 ）
&lt;ul>
&lt;li>&lt;strong>不可以使⽤特权指令&lt;/strong>；&lt;/li>
&lt;li>⽤户的⾃编程序（ 应用程序 ）运⾏在⽬态；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>用户态切换到内核态的三种方式&lt;/p>
&lt;ul>
&lt;li>系统调用(Trap)&lt;/li>
&lt;li>中断(Interrupt)&lt;/li>
&lt;li>异常(Exception)&lt;/li>
&lt;/ul>
&lt;p>中断和异常
异常（硬件故障：访管指令）&amp;gt; 中断（外部中断，程序性中断）&amp;gt;系统异常（重启）&lt;/p>
&lt;ul>
&lt;li>异常（不可屏蔽,缺⻚中断为内中断）
&lt;ul>
&lt;li>⾃愿中断（系统异常）
&lt;ul>
&lt;li>时钟中断&lt;/li>
&lt;li>特权指令&lt;/li>
&lt;li>切换核⼼态&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>强迫中断（狭义异常）
&lt;ul>
&lt;li>&lt;strong>CPU内部&lt;/strong> 硬件故障&lt;/li>
&lt;li>软中断&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>中断（分为可屏蔽中断和不可屏蔽中断）
&lt;ul>
&lt;li>硬中断（外设导致的中断）&lt;/li>
&lt;li>与程序运⾏⽆关的中断（⼈的⼲预）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>系统调⽤: ⽤户在程序中调⽤操作系统所提供的⼀些⼦功能；&lt;/p>
&lt;ol>
&lt;li>需先执⾏ &lt;strong>陷入指令Trap&lt;/strong> （⾮特权指令）切换为内核态。此时发生了&lt;/li>
&lt;li>再处理OS的系统调⽤，&lt;/li>
&lt;li>处理完成后,执⾏ 返回指令 （特权指令，⼀般为中断返回指令），切换为⽤户态；&lt;/li>
&lt;/ol>
&lt;h3 id="14-体系结构">1.4 体系结构&lt;/h3>
&lt;p>⼤内核（单内核）：将OS的主要功能模块作为⼀个紧密整体运⾏在核⼼态；&lt;/p>
&lt;p>微内核&lt;/p>
&lt;ul>
&lt;li>保留基本功能，其它服务移动到⽤户态；&lt;/li>
&lt;li>有效分离了内核与服务、服务与服务；&lt;/li>
&lt;/ul>
&lt;h2 id="进程管理">⼆、进程管理&lt;/h2>
&lt;h3 id="21-进程与线程">2.1 进程与线程*&lt;/h3>
&lt;h4 id="211-进程的概念和特征">2.1.1 进程的概念和特征&lt;/h4>
&lt;p>1）概念&lt;/p>
&lt;ul>
&lt;li>进程实体：程序段、数据段、进程控制块 PCB 组成 ；
&lt;ul>
&lt;li>PCB是进程存在的唯⼀标志；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>进程&lt;/strong>是&lt;strong>进程实体&lt;/strong>的运⾏过程，是系统进⾏ &lt;strong>资源分配&lt;/strong> 的独⽴单位；&lt;/li>
&lt;li>进程是 动态 的，进程实体是 静态 的；&lt;/li>
&lt;li>引⼊进程是为了&lt;strong>描述程序的动态执⾏过程&lt;/strong>，更好的⽀持和管理多道程序的并发执⾏（进程的异步性与进程同步机制）；&lt;/li>
&lt;/ul>
&lt;p>PCB包含：&lt;/p>
&lt;ul>
&lt;li>进程描述信息（PID，UID）&lt;/li>
&lt;li>进程控制和管理信息&lt;/li>
&lt;li>资源分配清单&lt;/li>
&lt;li>处理机相关信息&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e5%9f%ba%e7%a1%80/2024-03-07-16-41-37.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;blockquote>
&lt;p>c语⾔程序对内存分为正⽂段（代码和常量）、数据堆段（动态分配到存储区）、数据栈段（临时变量）；&lt;/p>
&lt;/blockquote>
&lt;p>对于有线程系统：&lt;/p>
&lt;ul>
&lt;li>进程是&lt;strong>资源分配&lt;/strong>的独立单位&lt;/li>
&lt;li>线程是&lt;strong>资源调度&lt;/strong>的独立单位
对于无线程系统：&lt;/li>
&lt;li>进程是资源调度、分配的独立单位&lt;/li>
&lt;/ul>
&lt;p>2）特点
动态性：具有⽣命周期，是动态变化的（进程最基本的特征）；
并发性: 多个进程并发执⾏.
独⽴性: 进程是系统资源分配的基本单位，是独⽴的实体；
异步性：进程以不可知速度推进，需要配置相应的 进程同步 机制；
结构性: 每个进程都配置一个PCB进行描述。&lt;/p>
&lt;h4 id="212-进程的状态和转换">2.1.2 进程的状态和转换&lt;/h4>
&lt;p>五种状态&lt;/p>
&lt;ul>
&lt;li>创建态：正在被创建，尚未到就绪状态。&lt;/li>
&lt;li>运⾏态：进程正在处理器上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)。&lt;/li>
&lt;li>就绪态：即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。&lt;/li>
&lt;li>阻塞态（等待态）：正在等待某一事件而暂停运行如&lt;strong>等待某资源为可用或等待 IO 操作&lt;/strong>完成。（即使处理器空闲，该进程也不能运行）&lt;/li>
&lt;li>结束态：进程正常结束或其他原因中断退出运行。&lt;/li>
&lt;/ul>
&lt;p>状态转换&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e5%9f%ba%e7%a1%80/%e8%bd%ac%e6%8d%a2%e5%9b%be.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;ul>
&lt;li>⼀个进程从运⾏态变成阻塞态是 主动 的⾏为&lt;/li>
&lt;li>从阻塞态变成就绪态是 被动 的⾏为，需要其他相关进程的协助。&lt;/li>
&lt;/ul>
&lt;h4 id="213-进程控制-">2.1.3 进程控制-&lt;/h4>
&lt;p>进程控制通过 原语 操作，在核⼼态运⾏；&lt;/p>
&lt;p>进程创建（ 创建原语 ）&lt;/p>
&lt;ol>
&lt;li>申请空⽩的PCB，申请失败（PCB有限）则创建失败；&lt;/li>
&lt;li>为进程分配资源，申请失败进⼊等待态；&lt;/li>
&lt;li>初始化PCB；&lt;/li>
&lt;li>等待被调度；&lt;/li>
&lt;/ol>
&lt;p>进程终⽌（ 撤销原语 ）&lt;/p>
&lt;ul>
&lt;li>由 正常结束 、 异常结束 、 外界干预 三种终⽌事件；&lt;/li>
&lt;li>根据被终⽌进程的 标识符 ，检索PCB，读取进程状态；&lt;/li>
&lt;li>处于执⾏状态则终⽌，归还 处理机资源 给其他进程；&lt;/li>
&lt;li>若该进程有⼦进程，则终⽌⼦进程；&lt;/li>
&lt;li>由进程创建的进程为该⽗进程的⼦进程；&lt;/li>
&lt;li>归还 其它资源 给⽗进程或OS；&lt;/li>
&lt;/ul>
&lt;p>进程阻塞&lt;/p>
&lt;ul>
&lt;li>系统⾃动执⾏ 阻塞原语 （主动）；&lt;/li>
&lt;li>找到被阻塞进程标识号对应的PCB；&lt;/li>
&lt;li>若为运⾏态，则保护现场，将其状态转为等待态；&lt;/li>
&lt;li>将该PCB插⼊ 等待队列 ，将处理机调度给其它就绪进程；&lt;/li>
&lt;/ul>
&lt;p>进程唤醒&lt;/p>
&lt;ul>
&lt;li>由有关进程调⽤ 唤醒原语 （被动）；&lt;/li>
&lt;li>与阻塞原语成对出现；&lt;/li>
&lt;li>在该事件的等待队列找到相应的PCB；&lt;/li>
&lt;li>从等待队列移除，置其状态转为就绪态；&lt;/li>
&lt;li>PCB插⼊ 就绪队列 ，等待调度；&lt;/li>
&lt;/ul>
&lt;p>进程切换&lt;/p>
&lt;blockquote>
&lt;p>进程切换和处理机模式切换不同，模式切换时，处理机逻辑上还在执⾏同⼀进程，所以进程环境不变，只需要 恢复CPU现场 ；但进程切换时，进程改变， 进程环境改变 （处理机上下⽂改变）；
调度和切换：调度决定资源分配的进程，是⼀种决策⾏为；切换是实际分配⾏为，是⼀种执⾏⾏为； 先有调度再有切换 ；&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>保存处理机上下⽂（PC和其它寄存器）；&lt;/li>
&lt;li>更新PCB信息；&lt;/li>
&lt;li>将PCB移⼊相应队列；&lt;/li>
&lt;li>选择另⼀进程执⾏，并更新其PCB；&lt;/li>
&lt;li>更新内存管理的数据结构；&lt;/li>
&lt;li>恢复处理机上下⽂；&lt;/li>
&lt;/ul>
&lt;h4 id="214-进程的组织-">2.1.4 进程的组织-&lt;/h4>
&lt;p>进程控制块&lt;/p>
&lt;blockquote>
&lt;p>通常采⽤ 链接方式 和 索引方式 来组织不同状态的PCB；&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>PCB结构&lt;/li>
&lt;li>程序段
&lt;ul>
&lt;li>程序段就是能被进程调度程序调度到CPU执⾏的程序代码段。注意，程序可被多个进程共享，即,多个进程可以运⾏同⼀个程序；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>数据段
&lt;ul>
&lt;li>⼀个进程的数据段，可以是进程对应的程序加⼯处理的原始数据，也可以是程序执⾏时产⽣的中间或最终结果。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="215-进程的通信">2.1.5 进程的通信&lt;/h4>
&lt;p>进程通信就是进程之间的数据交换。&lt;/p>
&lt;p>PV操作时低级通信方式，高级通信方式是指以较高的效率传输大量数据的通信方式。高级通信方法可分为共享存储、消息传递和管道通信三大类。&lt;/p>
&lt;p>&lt;a href="https://www.jianshu.com/p/c1015f5ffa74" target="_blank" rel="noopener">详细&lt;/a>&lt;/p>
&lt;p>管道（PIPE）&lt;/p>
&lt;ul>
&lt;li>无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统&lt;/li>
&lt;li>有名管道：一种半双工的通信方式，它允许无亲缘关系进程间的通信
&lt;ul>
&lt;li>优点：可以实现任意关系的进程间的通信&lt;/li>
&lt;li>缺点：
&lt;ul>
&lt;li>&lt;strong>名字以文件的形式&lt;/strong>长期存于系统中，使用不当容易出错&lt;/li>
&lt;li>缓冲区有限&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>无名管道：一种半双工的通信方式，只能在具有亲缘关系的进程间使用（父子进程/兄弟进程）
&lt;ul>
&lt;li>优点：简单方便&lt;/li>
&lt;li>缺点：
&lt;ul>
&lt;li>局限于&lt;strong>单向通信&lt;/strong>&lt;/li>
&lt;li>只能创建在它的进程以及其有亲缘关系的进程之间&lt;/li>
&lt;li>缓冲区有限&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>信号量（Semaphore）：一个计数器，可以用来控制多个线程对共享资源的访问，信号量的意图在于进程间同步。&lt;/p>
&lt;ul>
&lt;li>优点：可以同步进程&lt;/li>
&lt;li>缺点：信号量有限&lt;/li>
&lt;/ul>
&lt;p>信号（Signal）：一种比较复杂的通信方式，用于通知接收进程某个事件已经发生. 如SIGKILL：用户终止进程执行信号。shell下执行kill -9发送该信号。&lt;/p>
&lt;p>消息队列（Message Queue）：是消息的链表，存放在内核中并由消息队列标识符标识。&lt;/p>
&lt;ul>
&lt;li>与管道不同
&lt;ul>
&lt;li>消息队列&lt;strong>存放在内核中&lt;/strong>，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。&lt;/li>
&lt;li>消息队列在某个进程往一个队列写入消息之前，并不需要另外某个进程在该队列上等待消息的到达。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>优点：可以实现任意进程间的通信，并通过系统调用函数来实现消息发送和接收之间的同步，无需考虑同步问题，方便&lt;/li>
&lt;li>缺点：信息的复制需要额外消耗 CPU 的时间，不适宜于信息量大或操作频繁的场合&lt;/li>
&lt;/ul>
&lt;p>共享内存（Shared Memory）：映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问&lt;/p>
&lt;ul>
&lt;li>优点：无须复制，快捷，信息量大&lt;/li>
&lt;li>缺点：
&lt;ul>
&lt;li>通信是通过将共享空间缓冲区直接附加到进程的虚拟地址空间中来实现的，因此进程间的读写操作的同步问题&lt;/li>
&lt;li>利用内存缓冲区直接交换信息，内存的实体存在于计算机中，只能同一个计算机系统中的诸多进程共享，不方便网络通信&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>套接字（Socket）：可用于&lt;strong>不同计算机间&lt;/strong>的进程通信&lt;/p>
&lt;ul>
&lt;li>优点：
&lt;ul>
&lt;li>传输数据为字节级，传输数据可自定义，数据量小效率高传输数据时间短，性能高&lt;/li>
&lt;li>适合于客户端和服务器端之间信息实时交互&lt;/li>
&lt;li>可以加密,数据安全性强&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>缺点：需对传输的数据进行解析，转化成应用级的数据。&lt;/li>
&lt;/ul>
&lt;h4 id="216-线程的概念和多线程模型">2.1.6 线程的概念和多线程模型&lt;/h4>
&lt;p>1）线程和进程⽐较&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e5%9f%ba%e7%a1%80/2024-03-07-15-52-01.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>一个进程中可以有多个线程，多个线程共享进程的堆和方法区 (JDK1.8 之后的元空间)资源，但是每个线程有自己的程序计数器、虚拟机栈 和 本地方法栈。&lt;/p>
&lt;p>调度：线程是 处理机独立调度 的基本单位，进程是 资源分配 （除CPU外）的基本单位；&lt;/p>
&lt;p>资源：线程不拥有系统资源（有⼀点），但可以访问所属进程的资源；&lt;/p>
&lt;p>并发：线程也可以并发执⾏；&lt;/p>
&lt;p>通信：线程可以直接读写进程数据段（全局变量）来通信，进程需要使⽤同步互斥⼿段；&lt;/p>
&lt;p>系统开销：线程不拥有资源，因此切换的开销⼩；&lt;/p>
&lt;p>&lt;strong>线程的通信&lt;/strong>
线程间的通信目的&lt;strong>主要是用于线程同步&lt;/strong>，所以线程没有像进程通信中的用于数据交换的通信机制&lt;/p>
&lt;ul>
&lt;li>锁机制：包括互斥锁/量（mutex）、读写锁（reader-writer lock）、自旋锁（spin lock）、条件变量（condition）
&lt;ul>
&lt;li>互斥锁/量（mutex）：提供了以排他方式防止数据结构被并发修改的方法。&lt;/li>
&lt;li>读写锁（reader-writer lock）：允许多个线程同时读共享数据，而对写操作是互斥的。&lt;/li>
&lt;li>自旋锁（spin lock）与互斥锁类似，都是为了保护共享资源。互斥锁是当资源被占用，申请者进入睡眠状态；而自旋锁则循环检测保持者是否已经释放锁。&lt;/li>
&lt;li>条件变量（condition）：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>信号量机制(Semaphore)
&lt;ul>
&lt;li>无名线程信号量&lt;/li>
&lt;li>命名线程信号量&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>信号机制(Signal)：类似进程间的信号处理&lt;/li>
&lt;li>屏障（barrier）：屏障允许每个线程等待，直到所有的合作线程都达到某一点，然后从该点继续执行。&lt;/li>
&lt;/ul>
&lt;p>2）线程的实现
用户级线程和内核级线程&lt;/p>
&lt;p>⽤户级线程 ULT ；&lt;/p>
&lt;ul>
&lt;li>管理由应⽤程序通过 线程库 （最简单可以由的if语句构建）来完成，操作系统意识不到线程，在 用户态 下就可以完成；&lt;/li>
&lt;li>内核调度的还是进程，因此并发度低（⽆法利⽤多核处理机）；&lt;/li>
&lt;li>⼀个线程阻塞，进程就⽆法继续执⾏；&lt;/li>
&lt;/ul>
&lt;p>内核级线程 KLT ；&lt;/p>
&lt;ul>
&lt;li>管理由OS完成，需要切换为 内核态 （切换CPU态需要开销）；&lt;/li>
&lt;li>内核调度的是线程，并发度⾼（可以利⽤多核处理机）；
即使某⼀线程阻塞，其它线程也可以执⾏（内核线程都阻塞时才阻塞）；&lt;/li>
&lt;/ul>
&lt;p>多线程模型 （组合⽅式）；
多对⼀：等价于ULT；
⼀对⼀：等价于KLT；
多对多（ 内核级线程数少于用户级线程 ）：相⽐ULT提⾼了并发度；相⽐KLT节省了管理开销；&lt;/p>
&lt;h3 id="22-处理机调度">2.2 处理机调度*&lt;/h3>
&lt;p>为合理的处理计算机软硬件资源⽽进⾏调度；&lt;/p>
&lt;h4 id="221-三级调度">2.2.1 三级调度&lt;/h4>
&lt;p>⾼级调度（作业调度）&lt;/p>
&lt;ul>
&lt;li>内存与辅存之间的调度。创建态的调度；&lt;/li>
&lt;li>每个作业只调⼊⼀次；
中级调度（内存调度）&lt;/li>
&lt;li>将暂时不能运⾏的进程&lt;strong>调⾄外存&lt;/strong>等待， 挂起态的调度；&lt;/li>
&lt;li>为提⾼内存利⽤率和系统吞吐量；
低级调度（进程调度）&lt;/li>
&lt;li>就绪队列到 运行态的调度；&lt;/li>
&lt;/ul>
&lt;h4 id="222-调度和切换的时机-">2.2.2 调度和切换的时机-&lt;/h4>
&lt;p>进程切换在进程调度之后⽴刻发⽣；&lt;/p>
&lt;p>不调度的情况&lt;/p>
&lt;ul>
&lt;li>处理 中断 的过程中；&lt;/li>
&lt;li>进程在OS内核程序 临界区 中；&lt;/li>
&lt;li>原⼦操作（ 原语 ）过程中；&lt;/li>
&lt;/ul>
&lt;p>调度的情况&lt;/p>
&lt;ul>
&lt;li>非剥夺调度 （⾮抢占⽅式）：调度条件发送后，等进程运⾏结束或⽆法继续运⾏时，才进⾏调度与切换；&lt;/li>
&lt;li>剥夺调度 （抢占⽅式）：调度条件发送后，除遇到不能调度情况需等待结束后再调度外，其它情况⽴刻调度；&lt;/li>
&lt;/ul>
&lt;h4 id="223-调度的评价标准-">2.2.3 调度的评价标准-&lt;/h4>
&lt;ul>
&lt;li>CPU利⽤率&lt;/li>
&lt;li>系统吞吐量：单位时间完成作业的数量；&lt;/li>
&lt;li>周转时间：⽤户提交作业到作业完成经历的时间；包含所有调度的时间；&lt;/li>
&lt;li>响应时间：⽤户提交作业到⾸次响应的时间；包含作业调度和⼀部分中低级调度；&lt;/li>
&lt;li>等待时间：进程等待分配处理机的等待时间和进⼊内存却未被分配处理机的时间；&lt;/li>
&lt;/ul>
&lt;h4 id="224-调度算法">2.2.4 调度算法&lt;/h4>
&lt;p>优先级调度适⽤于 实时系统 ；&lt;/p>
&lt;p>⾼响应⽐调度、时间⽚轮转调度、多级反馈队列调度适⽤于 分时系统 ；&lt;/p>
&lt;p>1）先来先服务 FCFS 调度算法；
适⽤于进程调度和作业调度；&lt;/p>
&lt;p>2）优先级调度算法；
适⽤于进程调度和作业调度；
优先级：&lt;/p>
&lt;ul>
&lt;li>系统进程 &amp;gt; ⽤户进程&lt;/li>
&lt;li>交互型进程 &amp;gt; ⾮交互型进⾏&lt;/li>
&lt;li>I/O型进程 &amp;gt; 计算型进程
分类：&lt;/li>
&lt;li>静态优先级、动态优先级；&lt;/li>
&lt;li>剥夺式优先级、⾮剥夺式优先级；&lt;/li>
&lt;/ul>
&lt;p>3）短作业优先 SJF 调度算法；
适⽤于进程调度和作业调度；
SJF调度 的平均等待时间、平均周转时间最少；&lt;/p>
&lt;p>4）⾼响应比调度算法；
主要⽤于作业调度；
响应⽐⾼的先调度（取决于 已等待时间 与 需要服务时间 ）；
已等待时间越⻓响应⽐越⾼；
需要服务时间越⼩响应⽐越⾼；&lt;/p>
&lt;p>5）时间⽚轮转调度算法；
⽤于进程调度；&lt;/p>
&lt;p>6）多级反馈队列调度算法；
⽤于进程调度；
设置多个不同优先级的队列，优先级越⾼的队列对应的可执⾏时间⽚越⼩；
初始进程放⼊第⼀级队列队尾，按FCFS排队，在第⼀级未执⾏完后放⼊第⼆级；
知道前⼀级队列为空时，才执⾏下⼀级队列；&lt;/p>
&lt;h4 id="225-僵尸进程和孤儿进程">2.2.5 僵尸进程和孤儿进程&lt;/h4>
&lt;p>当一个进程调用 exit()系统调用结束自己的生命时，内核会释放该进程的所有资源，包括打开的文件、占用的内存等，但是该进程对应的 &lt;strong>PCB 依然存在于系统中&lt;/strong>。这些信息只有在父进程调用 wait()或 waitpid()系统调用时才会被释放，&lt;strong>以便让父进程得到子进程的状态信息&lt;/strong>&lt;/p>
&lt;p>僵尸进程：&lt;/p>
&lt;ul>
&lt;li>子进程已经终止，但是其父进程仍在运行，且父进程没有调用 wait()或 waitpid()等系统调用来获取子进程的状态信息，释放子进程占用的资源，导致子进程的 PCB 依然存在于系统中，但无法被进一步使用。&lt;/li>
&lt;li>这种情况下，子进程被称为“僵尸进程”。避免僵尸进程的产生，父进程需要及时调用 wait()或 waitpid()系统调用来回收子进程。&lt;/li>
&lt;/ul>
&lt;p>Linux 下可以使用 Top 命令查找，zombie 值表示僵尸进程的数量，为 0 则代表没有僵尸进程。
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e5%9f%ba%e7%a1%80/2024-03-08-08-43-12.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>定位僵尸进程以及该僵尸进程的父进程:
&lt;code>ps -A -ostat,ppid,pid,cmd |grep -e '^[Zz]'&lt;/code>&lt;/p>
&lt;p>孤儿进程：&lt;/p>
&lt;ul>
&lt;li>一个进程的父进程已经终止或者不存在，但是该进程仍在运行。这种情况下，该进程就是孤儿进程。&lt;/li>
&lt;li>孤儿进程通常是由于父进程意外终止或未及时调用 wait()或 waitpid()等系统调用来回收子进程导致的。&lt;/li>
&lt;li>为了避免孤儿进程占用系统资源，操作系统会&lt;strong>将孤儿进程的父进程设置为 init 进程（进程号为 1）&lt;/strong>，由 init 进程来回收孤儿进程的资源。&lt;/li>
&lt;/ul>
&lt;h3 id="23-进程同步">2.3 进程同步*&lt;/h3>
&lt;p>为了协调进程之间的相互制约关系；&lt;/p>
&lt;h4 id="231-基本概念-">2.3.1 基本概念-&lt;/h4>
&lt;p>临界资源: ⼀次仅允许⼀个进程使⽤；
临界区 （临界段）: 进程中访问临界资源的代码&lt;/p>
&lt;p>同步 （直接制约关系）：为完成某个任务，针对多个进程的⼯作次序⽽产⽣的制约；&lt;/p>
&lt;p>互斥 （间接制约关系）：当⼀个进程访问临界资源时，另⼀个进程必须等待；&lt;/p>
&lt;ul>
&lt;li>空闲让进：临界区空闲，则可以使⼀个进程进⼊；&lt;/li>
&lt;li>忙则等待：已有进程进⼊临界区则等待；&lt;/li>
&lt;li>有限等待：等待时间为有限时间；&lt;/li>
&lt;li>让权等待：等待时让出处理器（防⽌ 忙等待 ）；&lt;/li>
&lt;/ul>
&lt;h4 id="232-互斥实现法-">2.3.2 互斥实现⽅法-&lt;/h4>
&lt;p>1）软件⽅法&lt;/p>
&lt;ul>
&lt;li>单标志法&lt;/li>
&lt;li>双标志法先检查&lt;/li>
&lt;li>双标志法后检查&lt;/li>
&lt;li>Peterson&amp;rsquo;s Algorithm&lt;/li>
&lt;li>创建管程&lt;/li>
&lt;/ul>
&lt;p>2）硬件⽅法&lt;/p>
&lt;ul>
&lt;li>中断屏蔽⽅法&lt;/li>
&lt;li>硬件指令⽅法&lt;/li>
&lt;li>指令由硬件逻辑直接实现；&lt;/li>
&lt;li>指令均为原⼦操作；&lt;/li>
&lt;li>TestAndSet指令&lt;/li>
&lt;li>Swap指令&lt;/li>
&lt;li>PV指令&lt;/li>
&lt;/ul>
&lt;h4 id="233-同步实现法">2.3.3 同步实现⽅法&lt;/h4>
&lt;p>1）信号量&lt;/p>
&lt;ul>
&lt;li>整型信号量
&lt;ul>
&lt;li>P操作不遵从 让权等待 ，进程⼀直占⽤处理器查询是否可以进⼊临界区；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>记录型信号量
&lt;ul>
&lt;li>P操作：信号量减⼀，信号量 小于 0时，⾃动阻塞进程；&lt;/li>
&lt;li>V操作：信号量加⼀，信号量 小于等于 0时，唤醒⼀个等待进程；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>信号量实现互斥
&lt;ul>
&lt;li>信号 初值为1 ，在临界区前加上P操作，后加上V操作；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>信号量实现同步
&lt;ul>
&lt;li>信号量 初值为0 ，在前⼀进程后加上V操作，后⼀进程前加上P操作；&lt;/li>
&lt;li>每有⼀个前后关系设置⼀个信号量；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>2）管程&lt;/p>
&lt;ul>
&lt;li>管程把对共享资源的操作封装起来；&lt;/li>
&lt;li>只能通过管程的操作访问共享资源；&lt;/li>
&lt;li>每次只允许⼀个进程进⼊管程；&lt;/li>
&lt;li>管程的 条件变量 为没有值的信号量，仅实现 等待排队 功能；&lt;/li>
&lt;/ul>
&lt;h4 id="234-经典同步问题">2.3.4 经典同步问题&lt;/h4>
&lt;p>同步问题:&lt;/p>
&lt;ul>
&lt;li>⽣产者-消费者问题&lt;/li>
&lt;li>吸烟者问题：相当于⽣产者⽣成多种产品的⽣产者-消费者问题；&lt;/li>
&lt;/ul>
&lt;p>互斥问题:&lt;/p>
&lt;ul>
&lt;li>读者-写者问题：设置计数器；&lt;/li>
&lt;li>哲学家进餐问题：使⽤信号量数组；&lt;/li>
&lt;/ul>
&lt;h3 id="24-死锁">2.4 死锁*&lt;/h3>
&lt;h4 id="241-死锁的必要条件">2.4.1 死锁的必要条件&lt;/h4>
&lt;p>互斥条件 ：某资源⼀段时间内只允许⼀个进程进⾏访问；
不可剥夺条件 ：进程所获得的资源只能由进程⾃⼰释放；
请求并保持 ：已占有资源，并继续请求其他资源；
循环等待条件 ：存在⼀种进程资源的循环等待链；&lt;/p>
&lt;p>产生原因:&lt;/p>
&lt;ul>
&lt;li>系统资源不⾜；&lt;/li>
&lt;li>资源分配不当；&lt;/li>
&lt;li>进程推进顺序不当；&lt;/li>
&lt;/ul>
&lt;h4 id="242-死锁的处理策略">2.4.2 死锁的处理策略&lt;/h4>
&lt;p>1） 死锁预防 ；&lt;/p>
&lt;p>破坏死锁的必要条件；&lt;/p>
&lt;ul>
&lt;li>破环互斥条件：某些场合（打印机）应保持互斥性；&lt;/li>
&lt;li>破坏⾮剥夺条件：请求新资源得不到满⾜时， 释放已申请 的所有资源重新申请；(仅适用于 主存资源 和 处理器资源 的分配),会导致资源利用率下降&lt;/li>
&lt;li>破环请求并保持条件：使⽤ &lt;strong>静态分配 （运⾏前⼀次申请完毕）&lt;/strong>；&lt;/li>
&lt;li>破坏循环等待条件：采⽤ &lt;strong>顺序资源分配 （按资源编号申请资源）&lt;/strong>；&lt;/li>
&lt;/ul>
&lt;p>2） 死锁避免 ；&lt;/p>
&lt;p>资源动态分配过程中，防⽌系统进⼊不安全状态；&lt;/p>
&lt;p>每次分配都预先验证是否会使系统保持 安全状态 ；
并⾮所有不安全状态都是死锁状态；&lt;/p>
&lt;p>银⾏家算法：&lt;/p>
&lt;ul>
&lt;li>进程后续申请资源数和已占⽤资源数之和 与 最⼤需求量⽐较，超过则拒绝分配；&lt;/li>
&lt;li>系统将现存资源数量 与 进程请求量进⾏⽐较，如果超过则拒绝分配；&lt;/li>
&lt;li>执⾏安全性算法，检测此次分配后是否满⾜安全状态，满⾜则正式分配；&lt;/li>
&lt;/ul>
&lt;p>3） 死锁的检测和解除 ；&lt;/p>
&lt;p>系统采取措施检测死锁并解除；&lt;/p>
&lt;p>死锁检测： 死锁条件 是 &lt;strong>资源分配图 不可完全简化&lt;/strong>；&lt;/p>
&lt;ul>
&lt;li>既 不独立也不阻塞 （有有向边连接且申请资源数⼩于系统资源数）的进程点即可释放所有资源；
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e5%9f%ba%e7%a1%80/2024-03-08-08-50-34.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/li>
&lt;/ul>
&lt;p>死锁解除：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>撤销进程法：撤销进程；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>进程回退法：回退进程；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>立即结束所有进程的执行，重新启动操作系统：这种方法简单，但以前所在的工作全部作废，损失很大。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>撤销涉及死锁的所有进程，解除死锁后继续运行：这种方法能彻底打破死锁的循环等待条件，但将付出很大代价，例如有些进程可能已经计算了很长时间，由于被撤销而使产生的部分结果也被消除了，再重新执行时还要再次进行计算。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>逐个撤销涉及死锁的进程，回收其资源直至死锁解除。抢占资源：从涉及死锁的一个或几个进程中&lt;/p>
&lt;/li>
&lt;li>
&lt;p>抢占资源，把夺得的资源再分配给涉及死锁的进程直至死锁解除。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="25-作业程序进程的关系-">2.5 作业、程序、进程的关系-&lt;/h3>
&lt;p>⼀份作业包含多段程序；&lt;/p>
&lt;p>进程是程序的动态运⾏过程；&lt;/p>
&lt;blockquote>
&lt;p>⼀个程序可以形成⼏个进程，⼀个进程也可以执⾏多个程序（程序有⼤有⼩）；&lt;/p>
&lt;/blockquote>
&lt;p>每个作业动态转换为⼀个进程族；&lt;/p>
&lt;ul>
&lt;li>批处理系统 ，每个作业有⼀个 根进程 ，该进程执⾏作业控制命令解释程序，解释改作业说明书，根进程在运⾏过程中可以动态的创建多个⼦进程；&lt;/li>
&lt;li>分时系统 的作业为⽤户的⼀次 上机交互过程 ，根进程为 终端进程 ，执⾏命令解释程序；&lt;/li>
&lt;li>交互提交批作业 的操作系统中，可以交互式的提交批作业，动态转化为⼀个进程族；&lt;/li>
&lt;/ul>
&lt;h2 id="三内存管理">三、内存管理&lt;/h2>
&lt;h3 id="31-内存管理概念">3.1 内存管理概念&lt;/h3>
&lt;h4 id="311-内存管理功能">3.1.1 内存管理功能*&lt;/h4>
&lt;ul>
&lt;li>内存空间的分配和回收: 对进程所需的内存进行分配和释放，malloc 函数：申请内存，free 函数：释放内存。&lt;/li>
&lt;li>地址转换: 将程序中的虚拟地址转换成内存中的物理地址。&lt;/li>
&lt;li>空间扩充: 当系统没有足够的内存时，利用&lt;strong>虚拟内存技术或自动覆盖技术&lt;/strong>，从逻辑上扩充内存。&lt;/li>
&lt;li>内存保护: 保证进程之间使用内存互不干扰，避免一些恶意程序通过修改内存来破坏系统的安全性。&lt;/li>
&lt;/ul>
&lt;h4 id="312-程序执步骤">3.1.2 程序执⾏步骤&lt;/h4>
&lt;p>1）编译：由编译程序将源代码编译成各**⽬标模块的机器语⾔代码**；
2）链接：由链接程序按 各模块代码 与 库函数 的相对地址链接成从0开始编制的 &lt;strong>统一逻辑地址空间&lt;/strong> ，形成 装入模块 ；&lt;/p>
&lt;ul>
&lt;li>静态链接：装⼊之前就链接；&lt;/li>
&lt;li>装⼊时动态链接：装⼊时链接；&lt;/li>
&lt;li>运⾏时动态链接：程序执⾏时需要⽤到⽬标模块再链接；
3）装⼊：由装⼊程序将装⼊模块 分配地址 装⼊内存；&lt;/li>
&lt;li>绝对装⼊：由 程序员 直接赋予或由 编译程序 给出 绝对/物理地址 ；&lt;/li>
&lt;li>静态重定位： 装入前 为从0开始的 逻辑地址 ，装⼊后重定位为 绝对/物理地址 ；&lt;/li>
&lt;li>动态重定位： 运行时 将逻辑地址转为绝对/物理地址（需 重定位寄存器/基址寄存器 ）；&lt;/li>
&lt;/ul>
&lt;h4 id="313-逻辑地址和物理地址">3.1.3 逻辑地址和物理地址&lt;/h4>
&lt;p>每个⽬标模块都&lt;strong>从0开始编制，为其相对地址（逻辑地址）&lt;/strong>，
链接程序将 各模块和库函数 链接为同⼀的从0编制的逻辑地址空间，对程序员不透明；&lt;/p>
&lt;p>物理地址为内存的实际地址，对程序员时 透明 的；&lt;/p>
&lt;h3 id="32-地址分配和回收">3.2 地址分配和回收*&lt;/h3>
&lt;p>内部内存碎片(Internal Memory Fragmentation，简称为内存碎片)：已经&lt;strong>分配给进程使用但未被使用的内存&lt;/strong>。&lt;/p>
&lt;p>外部内存碎片(External Memory Fragmentation，简称为外部碎片)：由于未分配的连续内存区域太小，以至于&lt;strong>不能满足任意进程所需要的内存分配请求&lt;/strong>，这些小片段且不连续的内存空间被称为外部碎片。&lt;/p>
&lt;h4 id="321-连续分配-管理式">3.2.1 连续分配 管理⽅式&lt;/h4>
&lt;p>1）单⼀连续分配
仅分为低位的 系统区 和⾼位的 用户区 ；
内存只有⼀道程序， 无需系统保护 ；&lt;/p>
&lt;p>2）固定分区分配
每个分区装⼊⼀道作业；&lt;/p>
&lt;ul>
&lt;li>分为 分区⼤⼩相等、分区⼤⼩不等 两种划分⽅式；&lt;/li>
&lt;li>使⽤ 覆盖技术 扩⼤分区可容纳的程序⼤⼩；&lt;/li>
&lt;li>⽆外部碎⽚，易产⽣ 内部碎片 ；&lt;/li>
&lt;/ul>
&lt;p>3）动态分区分配（可变分区分配）&lt;/p>
&lt;ul>
&lt;li>根据装⼊进程的⼤⼩ 动态的 建⽴分区；&lt;/li>
&lt;li>易产⽣ 外部碎片 ，可采⽤ 紧凑技术 解决，需要动态重定位寄存器（ 基址寄存器 ）的⽀持；&lt;/li>
&lt;li>分区 分配策略 ：
&lt;ul>
&lt;li>⾸次适应算法
&lt;ul>
&lt;li>⽐其它三种都好；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>最佳适应算法
&lt;ul>
&lt;li>⽐最⼤适应好；&lt;/li>
&lt;li>最容易产⽣内部碎⽚；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>最坏/⼤适应算法&lt;/li>
&lt;li>临近适应算法（循环⾸次适应算法）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>块式管理 是早期计算机操作系统的一种连续内存管理方式，存在严重的内存碎片问题。&lt;/p>
&lt;p>在 Linux 系统中，连续内存管理采用了 伙伴系统（Buddy System）算法.一种经典的连续内存分配算法，可以有效解决外部内存碎片的问题。伙伴系统的主要思想是将内存按 2 的幂次划分（每一块内存大小都是 2 的幂次比如 2^6=64 KB），并将相邻的内存块组合成一对伙伴（注意：必须是相邻的才是伙伴）。&lt;/p>
&lt;ul>
&lt;li>当进行内存分配时，伙伴系统会尝试找到大小最合适的内存块。如果找到的内存块过大，就将其一分为二，分成两个大小相等的伙伴块。如果还是大的话，就继续切分，直到到达合适的大小为止。&lt;/li>
&lt;li>假设两块相邻的内存块都被释放，系统会将这两个内存块合并，进而形成一个更大的内存块，以便后续的内存分配。这样就可以减少内存碎片的问题，提高内存利用率。&lt;/li>
&lt;/ul>
&lt;p>对于内部内碎片问题, Linux采用SLAB解决.&lt;/p>
&lt;h4 id="322-非连续分配-管理式">3.2.2 非连续分配 管理⽅式&lt;/h4>
&lt;h5 id="1-基本-页式-存储管理">1 基本 页式 存储管理&lt;/h5>
&lt;p>分⻚是 &lt;strong>系统行为&lt;/strong> ，对程序员是 透明的 ；&lt;/p>
&lt;p>A）基本概念&lt;/p>
&lt;p>⻚⾯&lt;/p>
&lt;ul>
&lt;li>将进程的块称为 页/页面 ，内存中块称为 页框/页架 ，两者 一一对应 ；&lt;/li>
&lt;li>⻚⾯⼤⼩是2的整数次幂；&lt;/li>
&lt;li>每个进程有多个逻辑模块，⻚式存储每个⻚表对应进程的⼀个逻辑模块，因此 &lt;strong>页表内所有页为统一的逻辑地址空间&lt;/strong> ；&lt;/li>
&lt;/ul>
&lt;p>⻚表和⻚表项&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e5%9f%ba%e7%a1%80/%e2%bb%9a%e8%a1%a8%e5%9b%be.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;ul>
&lt;li>⻚表记录了对应进程每个⻚⾯在内存中所对应的 物理页号 ；&lt;/li>
&lt;li>⻚表由⻚表项构成；&lt;/li>
&lt;li>⻚表项分为 页号 （ 隐含 ，&lt;strong>因为定⻓且顺序存储&lt;/strong>）和 块号 ；&lt;/li>
&lt;/ul>
&lt;p>⻚式逻辑地址
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e5%9f%ba%e7%a1%80/%e2%bb%9a%e5%bc%8f%e9%80%bb%e8%be%91%e5%9c%b0%e5%9d%80%e5%9b%be.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;ul>
&lt;li>⾼位为 页号 ，低位为 页内偏移量 ；&lt;/li>
&lt;li>⻚内偏移量的位数决定了 页面大小 ；&lt;/li>
&lt;li>⻚式管理中地址空间是 &lt;strong>一维&lt;/strong> 的（只要知道逻辑地址,根据页面大小可以确定页号和偏移量）；&lt;/li>
&lt;/ul>
&lt;p>B）⻚式地址转换&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e5%9f%ba%e7%a1%80/%e2%bb%9a%e5%bc%8f%e8%bd%ac%e6%8d%a2%e6%b5%81%e7%a8%8b%e5%9b%be.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;ul>
&lt;li>根据进程号找到 页表基址寄存器PTR 内的⻚表基址；&lt;/li>
&lt;li>计算 页号和偏移量 ：⽤逻辑地址⼤⼩除以⻚⾯⼤⼩，整数部分为⻚号，余数部分为⻚内偏移量；&lt;/li>
&lt;li>当⻚号⼤于⻚表⻓度（表项个数）时，产⽣ 越界中断 ；&lt;/li>
&lt;li>取出⻚表内对应的物理⻚号，与偏移量组成物理地址；&lt;/li>
&lt;/ul>
&lt;p>C）快表（ &lt;strong>相联存储器TLB&lt;/strong> ）
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e5%9f%ba%e7%a1%80/%e5%bf%ab%e8%a1%a8%e5%9c%b0%e5%9d%80%e8%bd%ac%e6%8d%a2%e6%b5%81%e7%a8%8b%e5%9b%be.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;ul>
&lt;li>将常⽤的⻚表项存储到⾼速存储器；&lt;/li>
&lt;li>CPU给出逻辑地址后同时查找快表和内存⻚表（或先查快表再查⻚表）；&lt;/li>
&lt;li>快表的有效性取决于 &lt;strong>局部性原理&lt;/strong> （空间局部性、时间局部性）
&lt;ul>
&lt;li>空间局部性：活跃部分集中在临近空间；&lt;/li>
&lt;li>时间局部性：某部分在单位时间内多次使⽤；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>D）两级⻚表
地址转换过程和段⻚式存储相似；
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e5%9f%ba%e7%a1%80/%e4%b8%a4%e7%ba%a7%e2%bb%9a%e8%a1%a8%e5%9b%be.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;ul>
&lt;li>
&lt;p>由于进程⻚表过⼤占⽤多个⻚⾯，且不需要所有保存⻚表项的⻚⾯都调⼊内存，因此采⽤⼆级⻚表；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>⼀级⻚表（⻚⽬录表/顶级⻚表）负责 ⼆级⻚表逻辑地址和物理地址的映射关系；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>最底层⻚表负责 进程逻辑地址到物理地址的映射关系；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h5 id="2-基本-段式-存储管理">2 基本 段式 存储管理&lt;/h5>
&lt;p>分段是 &lt;strong>按用户进程&lt;/strong> 的⾃然段划分的逻辑空间；&lt;/p>
&lt;p>A）基本概念&lt;/p>
&lt;p>分段是 按用户进程 的⾃然段划分的逻辑空间；
分段的⻓度 不固定 ；
每个进程对应⼀个段表，每个逻辑模块对应⼀个段表项，因此 &lt;strong>段内逻辑地址连续，段间不连续&lt;/strong>；&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e5%9f%ba%e7%a1%80/%e6%ae%b5%e8%a1%a8.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>段式逻辑地址：段式逻辑地址空间是 二维 的，&lt;strong>因为段⻓不固定&lt;/strong>，因此需要段号和偏移量才能知道物理地址；&lt;/p>
&lt;p>B）段式地址转换
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e5%9f%ba%e7%a1%80/%e6%ae%b5%e5%bc%8f%e5%9c%b0%e5%9d%80%e8%bd%ac%e6%8d%a2%e6%b5%81%e7%a8%8b%e5%9b%be.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;ul>
&lt;li>根据进程号找到 段表基址寄存器 的基址；&lt;/li>
&lt;li>段号⼤于段表⻓则产⽣ 越界中断 ；&lt;/li>
&lt;li>根据段号找到段表项，如果取出的段⻓⼩于段内偏移量产⽣ 越界中断 ；&lt;/li>
&lt;li>最后取出物理段号，和偏移量组合成物理地址；&lt;/li>
&lt;/ul>
&lt;p>C）段的共享和保护&lt;/p>
&lt;ul>
&lt;li>段共享通过将两个作业的段表中相应表项指向同⼀个物理地址来实现；&lt;/li>
&lt;li>段保护为 存取控制保护 和 地址越界保护;
&lt;ul>
&lt;li>存取控制保护设置共享段的存取权限，地址越界保护和⻚保护相似（多了⼀个偏移量越界中断）；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>只有 纯代码/可重入代码 （不能修改的代码，因此 不属于临界资源 ）才可以共享；&lt;/li>
&lt;/ul>
&lt;h5 id="3-基本-段页式-管理式">3 基本 段页式 管理⽅式&lt;/h5>
&lt;p>A）基本概念
段⻚式逻辑地址结构
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e5%9f%ba%e7%a1%80/%e6%ae%b5%e8%a1%a8%e5%92%8c%e2%bb%9a%e8%a1%a8.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>段表和⻚表，⻚表和⻚式存储相同，段表与段式存储相⽐段始址换位 页表基址 ；&lt;/p>
&lt;p>每个进程有**⼀个段表，多个⻚表**；&lt;/p>
&lt;p>B）段⻚式地址转换
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e5%9f%ba%e7%a1%80/%e8%bd%ac%e6%8d%a2%e6%b5%81%e7%a8%8b%e5%9b%be.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
分别检测 段表越界 和 页表越界 （相当于段式存储中断偏移量越界）；&lt;/p>
&lt;h3 id="33-地址转换和内存保护">3.3 地址转换和内存保护&lt;/h3>
&lt;h4 id="331-地址转换-装入-">3.3.1 地址转换（ 装入 ）&lt;/h4>
&lt;p>连续分配管理&lt;/p>
&lt;ul>
&lt;li>单⼀连续分配：绝对装⼊、静态重定位、动态重定位；&lt;/li>
&lt;li>固定分区分配：绝对装⼊、静态重定位、动态重定位；&lt;/li>
&lt;li>可变分区分配：绝对装⼊、静态重定位、动态重定位；&lt;/li>
&lt;/ul>
&lt;p>⾮连续分配管理：动态重定位；&lt;/p>
&lt;h4 id="332-地址保护">3.3.2 地址保护&lt;/h4>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e5%9f%ba%e7%a1%80/2024-03-08-09-36-18.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="34-内存空间扩充">3.4 内存空间扩充*&lt;/h3>
&lt;h4 id="341-覆盖-和-交换">3.4.1 覆盖 和 交换&lt;/h4>
&lt;p>覆盖⽤于同⼀进程，⽽交换⽤于多个不同进程；&lt;/p>
&lt;p>1）覆盖&lt;/p>
&lt;ul>
&lt;li>不需要装⼊进程的全部信息；⽤于单⼀分配和固定分区；&lt;/li>
&lt;li>把⽤户空间分为⼀个&lt;strong>固定区和若⼲覆盖区&lt;/strong>；&lt;/li>
&lt;li>固定区存放进程中活跃的部分；&lt;/li>
&lt;li>覆盖区存放即将要访问的段(将不活跃的部分划分为永&lt;strong>远不会同时运⾏的段&lt;/strong>)；&lt;/li>
&lt;/ul>
&lt;p>2）交换&lt;/p>
&lt;ul>
&lt;li>就是 进程挂起 ；&lt;/li>
&lt;li>进程完全空闲时，将进程交换到辅存内独⽴于⽂件系统的 对换区 （采⽤连续分配⽅式因此读写速度更快）；&lt;/li>
&lt;/ul>
&lt;h4 id="342-虚拟内存-技术以-请求页式存储管理-为例">3.4.2 虚拟内存 技术（以 请求页式存储管理 为例）&lt;/h4>
&lt;p>虚拟内存(Virtual Memory) 是计算机系统内存管理非常重要的一个技术，本质上来说它&lt;strong>只是逻辑存在的，是一个假想出来的内存空间，主要作用是作为进程访问主存（物理内存）的桥梁并简化内存管理&lt;/strong>。&lt;/p>
&lt;p>虚拟内存的作用:&lt;/p>
&lt;ul>
&lt;li>隔离进程：物理内存通过虚拟地址空间访问，虚拟地址空间与进程一一对应。进程之间彼此隔离，一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。&lt;/li>
&lt;li>提升物理内存利用率：有了虚拟地址空间后，操作系统只需要将进程当前正在使用的部分数据或指令加载入物理内存。&lt;/li>
&lt;li>简化内存管理：进程都有一个一致且私有的虚拟地址空间，程序员不用和真正的物理内存打交道，而是借助虚拟地址空间访问物理内存，从而简化了内存管理。&lt;/li>
&lt;li>多个进程共享物理内存：进程在运行过程中，会加载许多操作系统的动态库。这些库对于每个进程而言都是公用的，它们在内存中实际只会加载一份，这部分称为共享内存。&lt;/li>
&lt;li>提高内存使用安全性：控制进程对物理内存的访问，隔离不同进程的访问权限，提高系统的安全性。&lt;/li>
&lt;li>提供更大的可使用内存空间：可以让程序拥有超过系统物理内存大小的可用内存空间。这是因为当物理内存不够用时，可以利用磁盘充当，将物理内存页（通常大小为 4 KB）保存到磁盘文件（会影响读写速度），数据或代码页会根据需要在物理内存与磁盘之间移动。&lt;/li>
&lt;/ul>
&lt;p>没有虚拟内存有什么问题？&lt;/p>
&lt;ul>
&lt;li>系统不安全: 用户程序可以访问任意物理内存，可能会不小心操作到系统运行必需的内存，进而造成操作系统崩溃，严重影响系统的安全。&lt;/li>
&lt;li>进程不稳定: 同时运行多个程序容易崩溃。比如你想同时运行一个微信和一个 QQ 音乐，微信在运行的时候给内存地址 1xxx 赋值后，QQ 音乐也同样给内存地址 1xxx 赋值，那么 QQ 音乐对内存的赋值就会覆盖微信之前所赋的值，这就可能会造成微信这个程序会崩溃。&lt;/li>
&lt;li>浪费内存: 程序运行过程中使用的所有数据或指令都要载入物理内存，根据局部性原理，其中很大一部分可能都不会用到，白白占用了宝贵的物理内存资源。&lt;/li>
&lt;/ul>
&lt;p>1）请求⻚式存储管理
2）请求段式存储管理
3）请求段⻚式存储管理&lt;/p>
&lt;p>A）⻚表项&lt;/p>
&lt;ul>
&lt;li>状态位/有效位：是否调⼊内存；&lt;/li>
&lt;li>访问字段/置换位：⼀段时间内被访问次数，配合⻚⾯置换算法使&lt;/li>
&lt;li>修改位/脏位：是否被修改&lt;/li>
&lt;li>外存地址：该⻚在外存的地址；&lt;/li>
&lt;/ul>
&lt;p>B）缺⻚中断&lt;/p>
&lt;ul>
&lt;li>缺⻚中断为 内中断 ；&lt;/li>
&lt;/ul>
&lt;p>C）⻚⾯置换策略/算法&lt;/p>
&lt;ul>
&lt;li>最佳置换 OPT 算法
&lt;ul>
&lt;li>无法实现, 用于评价其他算法&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>先进先出 FIFO 置换算法
&lt;ul>
&lt;li>会产⽣belady异常, 分配的页面数增多，但缺页率反而提高&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>最近不经常使⽤ LRU 算法&lt;/li>
&lt;li>时钟置换 CLOCK 算法（最近未使⽤ NRU 算法）
&lt;ul>
&lt;li>因LRU实现困难，开销⼤⽽设计；增加访问位和修改位；&lt;/li>
&lt;li>最近未被访问，也未被修改(u=0, m= 0)；&lt;/li>
&lt;li>最近未被访问，但被修改(u=0,m=1)；&lt;/li>
&lt;li>最近被访问，但未被修改(u= 1,m=0)；&lt;/li>
&lt;li>最近被访问，被修改(u=1,m= 1)；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>D）⻚⾯分配
反复的调⼊调出叫 抖动/颠簸 ；
驻留集: 是内存为进程分配的空间⼤⼩；
工作集: 为某段时间间隔内（⼯作集窗⼝），进程访问的⻚⾯集合（ 驻留集需要大于工作集 ）；&lt;/p>
&lt;p>分配策略/算法&lt;/p>
&lt;ul>
&lt;li>固定分配
&lt;ul>
&lt;li>驻留集⼤⼩不变；&lt;/li>
&lt;li>固定分配局部置换：驻留集⼤⼩不变，且只在分配的驻留集内进程⻚⾯置换；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>可变分配
&lt;ul>
&lt;li>驻留集⼤⼩可变；&lt;/li>
&lt;li>可变分配全局置换：驻留集⼤⼩可变，且将欲调⼊的⻚置换到OS的空闲块队列；&lt;/li>
&lt;li>可变分配局部置换：驻留集⼤⼩可变，将欲调⼊的⻚置换到驻留集，根据缺⻚率动态调整驻留集⼤⼩；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>⻚⾯调⼊时机&lt;/p>
&lt;ul>
&lt;li>预调页 策略/算法：运⾏前预测需要调⼊的⻚⾯，⼀次调⼊内存；&lt;/li>
&lt;li>请求调页 策略/算法：运⾏时根据请求来逐⻚的调⼊内存；
调⼊调出的位置&lt;/li>
&lt;li>当系统拥有⾜够对换区空间时，调⼊调出都使⽤对换区；&lt;/li>
&lt;li>当系统没有⾜够对换区空间时，从⽂件区调⼊，从对换区调出修改过的内容（未修改的不⽤调出，直接下次再从⽂件区调⼊）；&lt;/li>
&lt;li>UNIX方式 ：从⽂件区调⼊，从对换区调出（只要是从内存调出都放⼊对换区）；&lt;/li>
&lt;/ul>
&lt;h2 id="四件管理">四、⽂件管理&lt;/h2>
&lt;h3 id="41-件系统基础">4.1 ⽂件系统基础*&lt;/h3>
&lt;p>Windows：FCB 表 + FAT + 位图
Unix：inode + 混合索引 + 成组链接&lt;/p>
&lt;p>文件系统主要负责管理和组织计算机存储设备上的文件和目录，其功能包括以下几个方面：&lt;/p>
&lt;ul>
&lt;li>存储管理：将文件数据存储到物理存储介质中，并且管理空间分配，以确保每个文件都有足够的空间存储，并避免文件之间发生冲突。&lt;/li>
&lt;li>文件管理：文件的创建、删除、移动、重命名、压缩、加密、共享等等。&lt;/li>
&lt;li>目录管理：目录的创建、删除、移动、重命名等等。&lt;/li>
&lt;li>文件访问控制：管理不同用户或进程对文件的访问权限，以确保用户只能访问其被授权访问的文件，以保证文件的安全性和保密性&lt;/li>
&lt;/ul>
&lt;h4 id="411-录结构">4.1.1 ⽬录结构&lt;/h4>
&lt;p>1）⽂件控制块和索引结点&lt;/p>
&lt;p>A）⽂件控制块 FCB&lt;/p>
&lt;ul>
&lt;li>为实现 按名存取 ⽽设计，FCB的有序集合位⽬录，⼀个FCB为⼀个⽂件⽬录项；&lt;/li>
&lt;li>基本信息 （⽂件名、物理位置、逻辑结构、物理结构等）、 存取控制信息（存取权限等）、 使用信息 （建⽴时间、修改时间等）；&lt;/li>
&lt;/ul>
&lt;p>B） 索引结点&lt;/p>
&lt;ul>
&lt;li>将FCB的⽂件名和⽂件描述信息分离（使得磁盘块可以存储更多的FCB）；&lt;/li>
&lt;li>索引结点为 文件描述信息 ，FCB只包含⽂件名和索引结点指针；&lt;/li>
&lt;/ul>
&lt;p>2）⽬录结构&lt;/p>
&lt;ul>
&lt;li>单级⽬录结构：整个系统就⼀个⽬录；&lt;/li>
&lt;li>两级⽬录结构：每个⽤户有⼀个⽬录；&lt;/li>
&lt;li>多级⽬录结构（树形⽬录结构）：有多级⽬录，出现 绝对路径 和 相对路径 ；&lt;/li>
&lt;li>⽆环图⽬录结构：多个⽗结点指向同⼀个结点（实现 文件共享 ）；
&lt;ul>
&lt;li>某个⽗结点删除共享结点后不⼀定删除，需要所有指向共享结点的结点都断开才删除；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="412-件共享与保护">4.1.2 ⽂件共享与保护*&lt;/h4>
&lt;p>1）⽂件共享&lt;/p>
&lt;ul>
&lt;li>基于索引结点共享（ 硬链接 ）：直接使**⽬录项指向该⽂件的索引结点**；
&lt;ul>
&lt;li>只有删除了源文件和所有对应的硬链接文件，该文件才会被真正删除&lt;/li>
&lt;li>&lt;code>ln&lt;/code> 命令用于创建硬链接。&lt;/li>
&lt;li>限制
&lt;ul>
&lt;li>不能对目录以及不存在的文件创建硬链接&lt;/li>
&lt;li>硬链接不能跨越文件系统。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>基于符号链共享（ 软链接 ）：建⽴ &lt;strong>LINK文件&lt;/strong> 保存共享⽂件的绝对路径；
&lt;ul>
&lt;li>使⽤时根据绝对路径⼀级⼀级查找；&lt;/li>
&lt;li>&lt;code>ln -s&lt;/code> 命令用于创建软链接&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>2）⽂件保护&lt;/p>
&lt;p>A）访问控制：每个⽂件增加⼀个 访问控制列表ACL ，规定不同⽤户/⽤户组的访问权限；&lt;/p>
&lt;p>B）其它
⼝令：输⼊FCB上的⼝令来访问⽂件；
密码：保存的⽂件是加密过的不能正常读写，需要输⼊密码修改为正常⽂件&lt;/p>
&lt;h4 id="413-件的逻辑结构">4.1.3 ⽂件的逻辑结构&lt;/h4>
&lt;p>1）⽆结构⽂件（流式⽂件）
2）有结构⽂件（记录式⽂件）&lt;/p>
&lt;ul>
&lt;li>为实现 顺序查找 、 索引查找 、 索引顺序查找 、 哈希查找 ⽽设计；&lt;/li>
&lt;/ul>
&lt;p>A）顺序⽂件: 顺序存储&lt;/p>
&lt;ul>
&lt;li>定⻓顺序存储：可实现 随机存取 ；
&lt;ul>
&lt;li>定⻓串结构
&lt;ul>
&lt;li>记录⻓度相等，记录之间顺序与关键字⽆关（由时间决定）；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>定⻓顺序结构：可实现 随机存取 与 快速检索 ；
&lt;ul>
&lt;li>记录⻓度相等，记录之间按关键字排列；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>变⻓顺序存储
&lt;ul>
&lt;li>变⻓串结构&lt;/li>
&lt;li>变⻓顺序结构&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>B）索引⽂件：建⽴的索引表可以实现 随机存取 ；&lt;/p>
&lt;p>C）索引顺序⽂件：顺序⽂件分组，建⽴索引表，索引表每个表项指向其中⼀组；&lt;/p>
&lt;p>D）直接⽂件（散列⽂件）：根据散列函数存取；&lt;/p>
&lt;h3 id="42-件系统实现">4.2 ⽂件系统实现&lt;/h3>
&lt;p>⽂件区和⽬录区是分开的；&lt;/p>
&lt;h4 id="421-录实现">4.2.1 ⽬录实现&lt;/h4>
&lt;p>线性表: 顺序和链式均可；
哈希表&lt;/p>
&lt;h4 id="422-件的物理结构">4.2.2 ⽂件的物理结构&lt;/h4>
&lt;p>1）⽂件分配⽅式（⾮空闲磁盘块的管理）&lt;/p>
&lt;ul>
&lt;li>A）连续分配&lt;/li>
&lt;li>B）链接分配
&lt;ul>
&lt;li>显式链接：建⽴⽂件分配表 FAT ，使每个物理块号有指定的下⼀块指针；⽂件分配表FAT可以 随机访问 ；&lt;/li>
&lt;li>隐式链接：直接在块上⾯存放指针；
C）索引分配：每个⽂件建⽴ 索引表 ，使得⽂件的每个逻辑块号都有对应的物理块号；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>和⻚表相似；&lt;/li>
&lt;li>链接⽅案：为解决索引表⼤于磁盘块的问题，使⽤指针将多个索引块链接；&lt;/li>
&lt;li>多层索引：类⽐内存管理的多级⻚表；&lt;/li>
&lt;li>混合索引：建⽴包含直接地址、间接索引表地址的 &lt;strong>顶级索引表&lt;/strong> ；&lt;/li>
&lt;/ul>
&lt;p>2）⽂件存储空间管理（空闲磁盘块的管理）&lt;/p>
&lt;p>A）空闲表法&lt;/p>
&lt;p>B）空闲链表法&lt;/p>
&lt;ul>
&lt;li>空闲 盘块 链&lt;/li>
&lt;li>空闲 盘区 链：有下⼀盘区的指针与本盘区的⼤⼩；
C）位示图法
D）成组链表 法&lt;/li>
&lt;li>适⽤于⼤型⽂件系统；&lt;/li>
&lt;li>把空闲块依次填⼊其余空闲块的地址，从第⼀个块开始读取地址分配空间；&lt;/li>
&lt;li>第⼀个填⼊地址的空闲块叫做 超级块 ，需要预先读⼊主存；&lt;/li>
&lt;/ul>
&lt;h4 id="423-件系统的层次结构">4.2.3 ⽂件系统的层次结构&lt;/h4>
&lt;p>1）⽤户调⽤接⼝
2）⽂件⽬录系统: 管理⽂件⽬录；
3）存取控制验证模块: 通过⽂件⽬录的FCB实现 文件保护 ；
4）逻辑⽂件系统与⽂件信息缓冲区: 根据⽂件的逻辑结构将⽤户的要读写的逻辑记录转换成⽂件逻辑结构内的相应块号；
5）物理⽂件系统: 将逻辑记录所在的相应块号转换为实际的物理地址；
6）辅助分配模块: 管理辅存空间；
7）设备管理程序模块: 硬件相关 ；&lt;/p>
&lt;h4 id="424-提高文件系统性能的方式有哪些">4.2.4 提高文件系统性能的方式有哪些？*&lt;/h4>
&lt;ul>
&lt;li>优化硬件：使用高速硬件设备（如 SSD、NVMe）替代传统的机械硬盘，使用 RAID（Redundant Array of Inexpensive Disks）等技术提高磁盘性能。&lt;/li>
&lt;li>选择合适的文件系统选型：不同的文件系统具有不同的特性，对于不同的应用场景选择合适的文件系统可以提高系统性能。&lt;/li>
&lt;li>运用缓存：访问磁盘的效率比较低，可以运用缓存来减少磁盘的访问次数。不过，需要注意缓存命中率，缓存命中率过低的话，效果太差。&lt;/li>
&lt;li>避免磁盘过度使用：注意磁盘的使用率，避免将磁盘用满，尽量留一些剩余空间，以免对文件系统的性能产生负面影响。&lt;/li>
&lt;li>对磁盘进行合理的分区：合理的磁盘分区方案，能够使文件系统在不同的区域存储文件，从而减少文件碎片，提高文件读写性能。&lt;/li>
&lt;/ul>
&lt;h3 id="43-磁盘组织与管理">4.3 磁盘组织与管理&lt;/h3>
&lt;h4 id="431-磁盘的结构">4.3.1 磁盘的结构&lt;/h4>
&lt;p>组成:&lt;/p>
&lt;ul>
&lt;li>柱⾯&lt;/li>
&lt;li>磁头&lt;/li>
&lt;li>扇区&lt;/li>
&lt;/ul>
&lt;p>分类&lt;/p>
&lt;ul>
&lt;li>活动头磁盘、固定头磁盘&lt;/li>
&lt;li>固定盘磁盘、可换盘磁盘&lt;/li>
&lt;/ul>
&lt;h4 id="432-磁盘调度算法">4.3.2 磁盘调度算法*&lt;/h4>
&lt;p>标准：寻找时间（找磁道时间）、延迟时间（找扇区时间）、传输时间；&lt;/p>
&lt;ul>
&lt;li>先来先服务 FCFS 算法
&lt;ul>
&lt;li>按照请求到达磁盘调度器的顺序进行处理，先到达的请求的先被服务。FCFS 算法实现起来比较简单，不存在算法开销。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>最短寻找时间 SSTF 算法
&lt;ul>
&lt;li>也被称为最佳服务优先（Shortest Service Time First，SSTF）算法，优先选择距离当前磁头位置最近的请求进行服务。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>扫描 SCAN 算法：双向扫描；
&lt;ul>
&lt;li>可默认为LOOK算法，双向扫描到此⽅向最后⼀个柱⾯就转向；⼜称电梯调度算法；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>循环扫描 C-CSAN 算法：单向扫描；
&lt;ul>
&lt;li>可默认为C-LOOK算法，单向扫描到最后⼀个柱⾯就返回；&lt;/li>
&lt;li>只在磁盘的一侧进行扫描，并且只按照一个方向扫描，直到到达磁盘边界，然后回到磁盘起点，重新开始循环。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="433-磁盘的管理">4.3.3 磁盘的管理&lt;/h4>
&lt;p>1）磁盘初始化&lt;/p>
&lt;p>低级格式化 （物理分区）&lt;/p>
&lt;ul>
&lt;li>每个扇区分为头、尾和数据部分（头尾包含磁盘控制所⽤的信息）
逻辑格式化 （创建⽂件系统）&lt;/li>
&lt;/ul>
&lt;p>2）引导块&lt;/p>
&lt;p>磁盘上的引导块装⼊ 自举程序 （计算机启动时运⾏的初始化程序），在ROM硬件上只保留很⼩的 自居装入程序 （为了⽅便更改）；&lt;/p>
&lt;p>3）坏块&lt;/p>
&lt;p>简单磁盘会将坏扇区在FAT表中表明；&lt;/p>
&lt;p>复杂磁盘会使⽤控制器维护⼀个磁盘坏块链表，使⽤低级格式化时保留的备⽤块进⾏替换，这种⽅式对OS 透明 ；（ 扇区备用 ）&lt;/p>
&lt;h2 id="五输输出管理">五、输⼊/输出管理&lt;/h2>
&lt;h3 id="51-io管理概述">5.1 I/O管理概述&lt;/h3>
&lt;h4 id="511-io控制式">5.1.1 I/O控制⽅式&lt;/h4>
&lt;p>程序查询⽅式&lt;/p>
&lt;ul>
&lt;li>全程需要CPU参与；&lt;/li>
&lt;li>按字读写；&lt;/li>
&lt;/ul>
&lt;p>中断⽅式&lt;/p>
&lt;ul>
&lt;li>设备运⾏完成，准备就绪后发⽣中断使CPU参与；&lt;/li>
&lt;li>按字读写；&lt;/li>
&lt;/ul>
&lt;p>DMA⽅式&lt;/p>
&lt;ul>
&lt;li>DMA控制器为⼀种 块设备 的I/O控制器，且每个DMA仅对应⼀台设备；块设备可寻址；&lt;/li>
&lt;li>DMA控制器：命令/状态寄存器CR、数据寄存器DR、主存地址寄存器MAR、数据计数器DC；&lt;/li>
&lt;li>数据交换过程不需要经过CPU寄存器，CPU需最后读取DMA状态（还包括DMA启动时的预处理）；&lt;/li>
&lt;li>DMA⽅式下每条I/O指令，只能读写连续的数据块；&lt;/li>
&lt;li>按块读写；&lt;/li>
&lt;/ul>
&lt;p>通道控制⽅式&lt;/p>
&lt;ul>
&lt;li>CPU发送的I/O指令负责启动通道程序，最后CPU读取状态；&lt;/li>
&lt;li>通道执⾏内存中的通道程序（不必只操作连续数据块）；对⼀组块进程操作；&lt;/li>
&lt;/ul>
&lt;h4 id="512-io系统的层次结构">5.1.2 I/O⼦系统的层次结构&lt;/h4>
&lt;p>1）⽤户层I/O软件：实现与⽤户交互的接⼝；&lt;/p>
&lt;p>2）设备独⽴性软件&lt;/p>
&lt;p>A）执⾏所有设备的公有操作；&lt;/p>
&lt;ul>
&lt;li>I/O调度&lt;/li>
&lt;li>缓冲管理&lt;/li>
&lt;li>设备分配与回收&lt;/li>
&lt;li>设备保护&lt;/li>
&lt;li>SPOOLing技术
B）⾯向⽤户层提供接⼝；&lt;/li>
&lt;/ul>
&lt;p>3）设备驱动程序：与硬件相关；
4）中断处理程序：与硬件相关；
5）硬件设备&lt;/p>
&lt;h3 id="52-io核系统">5.2 I/O核⼼⼦系统&lt;/h3>
&lt;h4 id="521-io调度如磁盘调度">5.2.1 I/O调度：如磁盘调度；&lt;/h4>
&lt;h4 id="522-缓冲区">5.2.2 缓冲区&lt;/h4>
&lt;blockquote>
&lt;p>磁盘高速缓存 的缓冲区⼀般为内存，逻辑上属于磁盘，实际为内存；&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>单缓冲：
&lt;ul>
&lt;li>两次相同状态间的时间为：【CPU处理时间】与【I/O输⼊到缓存区的时间】取最⼤值，加上【缓存区传输到CPU的时间】；&lt;/li>
&lt;li>因为单缓冲区时，CPU和I/O设备都不能和缓存区冲突，因此最后【缓存区传输到CPU的时间】与其它相加；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>双缓冲：
&lt;ul>
&lt;li>【CPU处理时间】加上【缓存区传输到CPU的时间】，与【I/O输⼊到缓存区的时间】取最⼤值；&lt;/li>
&lt;li>因为双缓存时，缓存交替使⽤，所以I/O设备的传输可以和其它操作并⾏，所以【I/O输⼊到缓存区的时间】与其它操作时间取最⼤值；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>循环缓存&lt;/li>
&lt;li>缓冲池&lt;/li>
&lt;/ul>
&lt;h4 id="523-设备分配与回收">5.2.3 设备分配与回收&lt;/h4>
&lt;p>1）设备类型
独占式设备
分时共享设备
共享设备（SPOOLing技术）&lt;/p>
&lt;p>2）设备分配的数据结构&lt;/p>
&lt;p>从物理设备名依次按照SDT → DCT → COCT → CHCT的顺序查找并分配设备，所有部件都分配成功则设备分配完成；
⽤逻辑设备名查找时第⼀次使⽤SDT查找，并在LUT建⽴表项，以后基础使⽤LUT进程查找；&lt;/p>
&lt;p>通道控制表 CHCT ：描述通道状态，有 指向控制器 的指针；
控制器控制表 COCT ：描述控制器状态，有 指向通道 的指针；
设备控制表 DCT ：描述设备状态，有 指向控制器 的指针；
系统设备表 SDT ：⼀个系统只有⼀个，每个表项都有⼀个 DCT ；
逻辑设备表 LUT ：负责保存逻辑设备名（设备类型）到物理设备名的映射关系；
将常⽤设备名映射关系从⼤表SDT转移到⼩表LUT；&lt;/p>
&lt;p>3）分配策略
分配⽅式&lt;/p>
&lt;ul>
&lt;li>静态分配：⼀次性分配所有要求的设备；&lt;/li>
&lt;li>动态分配&lt;/li>
&lt;/ul>
&lt;p>分配算法：FCFS、优先级等
类似进程调度算法；&lt;/p>
&lt;p>4）分配安全性（设备保护？）&lt;/p>
&lt;ul>
&lt;li>安全分配⽅式：发出I/O请求后就阻塞进程，直到I/O操作完成；&lt;/li>
&lt;li>不安全分配⽅式：发出I/O请求后也不阻塞，可以继续申请；&lt;/li>
&lt;/ul>
&lt;h4 id="524-spooling技术-假脱机技术">5.2.4 SPOOLing技术 （假脱机技术）&lt;/h4>
&lt;p>1）组成&lt;/p>
&lt;ul>
&lt;li>输⼊井和输出井&lt;/li>
&lt;li>输⼊缓冲区和输⼊缓冲区&lt;/li>
&lt;li>输⼊进程和输出进程&lt;/li>
&lt;/ul>
&lt;p>2）特点（空间换时间）&lt;/p>
&lt;ul>
&lt;li>提⾼I/O速度；&lt;/li>
&lt;li>将独占设备改为共享设备；&lt;/li>
&lt;li>实现了虚拟设备功能；&lt;/li>
&lt;/ul></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/</guid><description>&lt;h1 id="redis">Redis&lt;/h1>
&lt;h2 id="redis基础知识">Redis基础知识：&lt;/h2>
&lt;h3 id="redis是什么有什么用">Redis是什么？有什么用？&lt;/h3>
&lt;p>Redis是一个开源的内存数据结构存储系统。&lt;/p>
&lt;ol>
&lt;li>Redis最常用来做缓存，是实现分布式缓存的首先中间件；&lt;/li>
&lt;li>Redis可以作为数据库，实现诸如点赞、关注、排行等对性能要求极高的互联网需求；&lt;/li>
&lt;li>Redis可以作为计算工具，能用很小的代价，统计诸如PV/UV、用户在线天数等数据；&lt;/li>
&lt;li>Redis还有很多其他的使用场景，例如：可以实现分布式锁，可以作为消息队列使用。&lt;/li>
&lt;/ol>
&lt;h3 id="使用redis的好处是什么">使用Redis的好处是什么？&lt;/h3>
&lt;p>使用Redis的好处包括高性能、高可用性、支持多种数据结构、支持事务和Lua脚本等。&lt;/p>
&lt;h3 id="redis与其他key-value存储的不同之处在哪里">Redis与其他key-value存储的不同之处在哪里？&lt;/h3>
&lt;p>Redis与其他key-value存储的不同之处在于，Redis支持多种数据结构，包括字符串、哈希、列表、集合和有序集合等，而其他key-value存储通常只支持字符串类型。&lt;/p>
&lt;h3 id="比较redis与memcache">比较Redis与Memcache&lt;/h3>
&lt;ul>
&lt;li>Redis支持多种数据结构，包括字符串、哈希、列表、集合和有序集合，支持事务和Lua脚本、支持持久化和复制等。&lt;/li>
&lt;li>Memcache只支持字符串类型。&lt;/li>
&lt;/ul>
&lt;h3 id="redis是单进程单线程的吗">Redis是单进程单线程的吗&lt;/h3>
&lt;p>是的，Redis是单进程单线程的，主要是指Redis的网络IO和键值对读写是由一个线程来完成的。&lt;/p>
&lt;p>而Redis的其他功能，如持久化、异步删除、集群数据同步等，则是依赖其他线程来执行的。所以，说Redis是单线程的只是一种习惯的说法，事实上它的底层不是单线程的。&lt;/p>
&lt;ol>
&lt;li>对服务端程序来说，线程切换和锁通常是性能杀手，而单线程避免了线程切换和竞争所产生的消耗；&lt;/li>
&lt;li>Redis的大部分操作是在内存上完成的，这是它实现高性能的一个重要原因；&lt;/li>
&lt;li>Redis采用了IO多路复用机制，使其在网络IO操作中能并发处理大量的客户端请求，实现高吞吐率。&lt;/li>
&lt;/ol>
&lt;h2 id="redis-命令">Redis 命令&lt;/h2>
&lt;h3 id="redis中的watch命令">Redis中的watch命令&lt;/h3>
&lt;p>很多时候，要确保事务中的数据没有被其他客户端修改才执行该事务。&lt;/p>
&lt;p>Redis提供了watch命令来解决这类问题，这是一种乐观锁的机制。&lt;/p>
&lt;p>客户端通过watch命令，要求服务器对一个或多个key进行监视，如果在客户端执行事务之前，这些key发生了变化，则服务器将拒绝执行客户端提交的事务，并向它返回一个空值。&lt;/p>
&lt;h2 id="redis数据类型">Redis数据类型&lt;/h2>
&lt;h3 id="redis的数据类型有哪些">Redis的数据类型有哪些？&lt;/h3>
&lt;ol>
&lt;li>Redis支持5种核心的数据类型，分别是字符串、哈希、列表、集合(set)、有序集合(zset)；&lt;/li>
&lt;li>Redis还提供了Bitmap、HyperLogLog、Geo类型，但这些类型都是基于上述核心数据类型实现的；&lt;/li>
&lt;li>Redis在5.0新增加了Streams数据类型，它是一个功能强大的、支持多播的、可持久化的消息队列。&lt;/li>
&lt;/ol>
&lt;h3 id="set和zset有什么区别">set和zset有什么区别？&lt;/h3>
&lt;p>set：&lt;/p>
&lt;ul>
&lt;li>集合中的元素是无序、不可重复的，一个集合最多能存储232-1个元素；&lt;/li>
&lt;li>集合除了支持对元素的增删改查之外，还支持对多个集合取交集、并集、差集。&lt;/li>
&lt;/ul>
&lt;p>zset：&lt;/p>
&lt;ul>
&lt;li>有序集合保留了集合元素不能重复的特点；&lt;/li>
&lt;li>有序集合会给每个元素设置一个分数，并以此作为排序的依据；&lt;/li>
&lt;li>有序集合不能包含相同的元素，但是不同元素的分数可以相同。&lt;/li>
&lt;/ul>
&lt;h3 id="一个字符串类型的值能存储的最大容量是多少">一个字符串类型的值能存储的最大容量是多少？&lt;/h3>
&lt;p>一个字符串类型的值能存储的最大容量是512MB。&lt;/p>
&lt;h3 id="redis中list结构的相关操作">Redis中List结构的相关操作&lt;/h3>
&lt;p>列表是线性有序的数据结构，它内部的元素是可以重复的，并且一个列表最多能存储2^32-1个元素。列表包含如下的常用命令：&lt;/p>
&lt;ul>
&lt;li>lpush/rpush：从列表的左侧/右侧添加数据；&lt;/li>
&lt;li>lrange：指定索引范围，并返回这个范围内的数据；&lt;/li>
&lt;li>lindex：返回指定索引处的数据；&lt;/li>
&lt;li>lpop/rpop：从列表的左侧/右侧弹出一个数据；&lt;/li>
&lt;li>blpop/brpop：从列表的左侧/右侧弹出一个数据，若列表为空则进入阻塞状态。&lt;/li>
&lt;/ul>
&lt;h2 id="redis持久化">Redis持久化&lt;/h2>
&lt;h3 id="redis的持久化机制有哪些">Redis的持久化机制有哪些？&lt;/h3>
&lt;p>RDB和AOF是Redis的两种持久化机制，它们都可以将Redis的数据保存到磁盘上，以便在Redis重启时恢复数据。但是它们的实现方式和适用场景有所不同。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>RDB是一种快照机制，它可以将Redis的内存数据保存到磁盘上。&lt;/p>
&lt;ul>
&lt;li>RDB的实现方式是在指定的时间间隔内，将Redis的内存数据快照保存到磁盘上。快照文件的格式是二进制的，可以通过配置文件指定保存的文件名和路径。&lt;/li>
&lt;li>RDB的优点是快速、简单、可靠，适合用于备份和恢复数据。缺点是可能会丢失最近一次快照之后的数据，因为快照是定期保存的。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>AOF是一种追加日志机制，它可以将Redis的写操作记录到磁盘上。&lt;/p>
&lt;ul>
&lt;li>AOF的实现方式是将Redis的写操作以追加的方式记录到一个日志文件中，日志文件的格式是文本的。&lt;/li>
&lt;li>AOF有三种同步方式：always、everysec和no。always表示每次写操作都会同步到磁盘上，保证数据的完整性和一致性，但是会影响性能；everysec表示每秒钟同步一次，可以平衡性能和数据安全；no表示不同步，性能最好，但是数据安全性最差。&lt;/li>
&lt;li>AOF的优点是可以保证数据的完整性和一致性，适合用于数据持久化和灾备。缺点是日志文件可能会很大，需要定期进行压缩和重写。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>在实际应用中，可以根据实际情况选择RDB和AOF中的一种或两种持久化机制。如果数据的安全性和一致性比较重要，可以选择AOF；如果数据的恢复速度比较重要，可以选择RDB；如果两者都比较重要，可以同时使用两种持久化机制。&lt;/p>
&lt;h3 id="缓存雪崩缓存穿透缓存预热缓存更新和缓存降级是什么">缓存雪崩、缓存穿透、缓存预热、缓存更新和缓存降级是什么？&lt;/h3>
&lt;h4 id="缓存穿透">缓存穿透&lt;/h4>
&lt;p>客户端查询根本不存在的数据，使得请求直达存储层，导致其负载过大，甚至宕机。出现这种情况的原因，可能是业务层误将缓存和库中的数据删除了，也可能是有人恶意攻击，专门访问库中不存在的数据。&lt;/p>
&lt;p>解决方案：&lt;/p>
&lt;ol>
&lt;li>缓存空对象：存储层未命中后，仍然将空值存入缓存层，客户端再次访问数据时，缓存层会直接返回空值。&lt;/li>
&lt;li>布隆过滤器：将数据存入布隆过滤器，访问缓存之前以过滤器拦截，若请求的数据不存在则直接返回空值。&lt;/li>
&lt;/ol>
&lt;h4 id="缓存击穿">缓存击穿&lt;/h4>
&lt;p>一份热点数据，它的访问量非常大。在其缓存失效的瞬间，大量请求直达存储层，导致服务崩溃。&lt;/p>
&lt;p>解决方案：&lt;/p>
&lt;ol>
&lt;li>永不过期：热点数据不设置过期时间，所以不会出现上述问题，这是“物理”上的永不过期。或者为每个数据设置逻辑过期时间，当发现该数据逻辑过期时，使用单独的线程重建缓存。&lt;/li>
&lt;li>加互斥锁：对数据的访问加互斥锁，当一个线程访问该数据时，其他线程只能等待。这个线程访问过后，缓存中的数据将被重建，届时其他线程就可以直接从缓存中取值。&lt;/li>
&lt;/ol>
&lt;h4 id="缓存雪崩">缓存雪崩&lt;/h4>
&lt;p>在某一时刻，缓存层无法继续提供服务，导致所有的请求直达存储层，造成数据库宕机。可能是缓存中有大量数据同时过期，也可能是Redis节点发生故障，导致大量请求无法得到处理。&lt;/p>
&lt;p>解决方案：&lt;/p>
&lt;ol>
&lt;li>避免数据同时过期：设置过期时间时，附加一个随机数，避免大量的key同时过期。&lt;/li>
&lt;li>启用降级和熔断措施：在发生雪崩时，若应用访问的不是核心数据，则直接返回预定义信息/空值/错误信息。或者在发生雪崩时，对于访问缓存接口的请求，客户端并不会把请求发给Redis，而是直接返回。&lt;/li>
&lt;li>构建高可用的Redis服务：采用哨兵或集群模式，部署多个Redis实例，个别节点宕机，依然可以保持服务的整体可用。&lt;/li>
&lt;/ol>
&lt;h3 id="redis过期键的删除策略有哪些">Redis过期键的删除策略有哪些？&lt;/h3>
&lt;p>Redis过期键的删除策略包括定期删除和惰性删除。&lt;/p>
&lt;p>惰性删除：客户端访问一个key的时候，Redis会先检查它的过期时间，如果发现过期就立刻删除这个key。&lt;/p>
&lt;p>定期删除：Redis会将设置了过期时间的key放到一个独立的字典中，并对该字典进行每秒10次的过期扫描，&lt;/p>
&lt;p>过期扫描不会遍历字典中所有的key，而是采用了一种简单的贪心策略。该策略的删除逻辑如下：&lt;/p>
&lt;ol>
&lt;li>从过期字典中随机选择20个key；&lt;/li>
&lt;li>删除这20个key中已过期的key；&lt;/li>
&lt;li>如果已过期key的比例超过25%，则重复步骤1。&lt;/li>
&lt;/ol>
&lt;h3 id="redis的回收策略有哪些">Redis的回收策略有哪些？&lt;/h3>
&lt;p>Redis的回收策略包括noeviction、allkeys-lru、volatile-lru、allkeys-random和volatile-random等。&lt;/p>
&lt;h3 id="redis的持久化机制的优缺点有哪些">Redis的持久化机制的优缺点有哪些？&lt;/h3>
&lt;p>Redis的持久化机制包括RDB和AOF两种方式，各自的优缺点包括数据恢复速度、数据安全性、数据一致性等方面。&lt;/p>
&lt;h3 id="保证缓存与数据库的双写一致性--">保证缓存与数据库的双写一致性&amp;ndash;&lt;/h3>
&lt;p>四种同步策略：&lt;/p>
&lt;p>想要保证缓存与数据库的双写一致，一共有4种方式，即4种同步策略：&lt;/p>
&lt;ol>
&lt;li>先更新缓存，再更新数据库；&lt;/li>
&lt;li>先更新数据库，再更新缓存；&lt;/li>
&lt;li>先删除缓存，再更新数据库；&lt;/li>
&lt;li>先更新数据库，再删除缓存。&lt;/li>
&lt;/ol>
&lt;p>从这4种同步策略中，我们需要作出比较的是：&lt;/p>
&lt;ol>
&lt;li>更新缓存与删除缓存哪种方式更合适？&lt;/li>
&lt;li>应该先操作数据库还是先操作缓存？&lt;/li>
&lt;/ol>
&lt;p>更新缓存还是删除缓存：&lt;/p>
&lt;p>下面，我们来分析一下，应该采用更新缓存还是删除缓存的方式。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>更新缓存&lt;/p>
&lt;p>优点：每次数据变化都及时更新缓存，所以查询时不容易出现未命中的情况。&lt;/p>
&lt;p>缺点：更新缓存的消耗比较大。如果数据需要经过复杂的计算再写入缓存，那么频繁的更新缓存，就会影响服务器的性能。如果是写入数据频繁的业务场景，那么可能频繁的更新缓存时，却没有业务读取该数据。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>删除缓存&lt;/p>
&lt;p>优点：操作简单，无论更新操作是否复杂，都是将缓存中的数据直接删除。&lt;/p>
&lt;p>缺点：删除缓存后，下一次查询缓存会出现未命中，这时需要重新读取一次数据库。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>从上面的比较来看，一般情况下，删除缓存是更优的方案。&lt;/p>
&lt;p>先操作数据库还是缓存：&lt;/p>
&lt;p>下面，我们再来分析一下，应该先操作数据库还是先操作缓存。&lt;/p>
&lt;p>首先，我们将先删除缓存与先更新数据库，在出现失败时进行一个对比：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="https://uploadfiles.nowcoder.com/images/20220224/4107856_1645695077865/A8EAB406CDF2717DDC4C9AB91E37092E" alt="img" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>如上图，是先删除缓存再更新数据库，在出现失败时可能出现的问题：&lt;/p>
&lt;ol>
&lt;li>进程A删除缓存成功；&lt;/li>
&lt;li>进程A更新数据库失败；&lt;/li>
&lt;li>进程B从缓存中读取数据；&lt;/li>
&lt;li>由于缓存被删，进程B无法从缓存中得到数据，进而从数据库读取数据；&lt;/li>
&lt;li>进程B从数据库成功获取数据，然后将数据更新到了缓存。&lt;/li>
&lt;/ol>
&lt;p>最终，缓存和数据库的数据是一致的，但仍然是旧的数据。而我们的期望是二者数据一致，并且是新的数据。&lt;/p>
&lt;h3 id="你要如何设计redis的过期时间">你要如何设计Redis的过期时间？&lt;/h3>
&lt;ol>
&lt;li>热点数据不设置过期时间，使其达到“物理”上的永不过期，可以避免缓存击穿问题；&lt;/li>
&lt;li>在设置过期时间时，可以附加一个随机数，避免大量的key同时过期，导致缓存雪崩。&lt;/li>
&lt;/ol>
&lt;h2 id="redis性能优化">Redis性能优化：&lt;/h2>
&lt;h3 id="redis常见性能问题有哪些">Redis常见性能问题有哪些？&lt;/h3>
&lt;p>Redis常见性能问题包括内存使用过高、网络延迟过高、持久化性能不佳等。&lt;/p>
&lt;h3 id="redis的操作是原子性的吗">Redis的操作是原子性的吗？&lt;/h3>
&lt;p>Redis的操作是原子性的，是因为它采用了单线程模型，每个操作都是原子性的，保证了数据的一致性。&lt;/p>
&lt;h3 id="redis事务包括哪些命令">Redis事务包括哪些命令？&lt;/h3>
&lt;p>Redis事务包括MULTI、EXEC、DISCARD和WATCH等命令。&lt;/p>
&lt;h3 id="redis常见性能问题的解决方案有哪些">Redis常见性能问题的解决方案有哪些？&lt;/h3>
&lt;p>Redis常见性能问题的解决方案包括优化数据结构、优化网络配置、优化持久化配置等。&lt;/p>
&lt;h3 id="redis的同步机制有哪些">Redis的同步机制有哪些？&lt;/h3>
&lt;p>Redis的同步机制包括主从复制和哨兵机制。&lt;/p>
&lt;p>20、Pipeline的好处是什么？&lt;/p>
&lt;p>Pipeline的好处包括减少网络延迟、提高吞吐量等，需要使用时可以将多个命令打包发送到Redis服务器上执行。&lt;/p>
&lt;p>Redis集群：&lt;/p>
&lt;p>21、Redis需要把所有数据放到内存中吗？&lt;/p>
&lt;p>是的，Redis需要把所有数据放到内存中，是因为它采用了基于内存的数据存储方式，可以快速读写数据。&lt;/p>
&lt;p>22、Redis集群的原理是什么？&lt;/p>
&lt;p>Redis集群的原理是将数据分散到多个节点上存储，通过主从复制和哨兵机制保证数据的可用性和一致性。&lt;/p>
&lt;p>23、Redis集群会导致整个集群不可用的情况有哪些？&lt;/p>
&lt;p>Redis集群会导致整个集群不可用的情况包括节点故障、网络分区等。&lt;/p>
&lt;p>24、Redis支持的Java客户端有哪些？&lt;/p>
&lt;p>Redis支持的Java客户端包括Jedis、Lettuce、Redisson等，官方推荐使用Lettuce。&lt;/p>
&lt;p>25、Jedis与Redisson对比的优缺点有哪些？&lt;/p>
&lt;p>Jedis与Redisson对比的优缺点包括性能、功能、易用性等方面。&lt;/p>
&lt;p>26、Redis的密码可以通过哪些方式设置和验证？&lt;/p>
&lt;p>Redis的密码可以通过配置文件设置，验证密码可以使用AUTH命令。&lt;/p>
&lt;p>27、Redis哈希槽的概念是什么？&lt;/p>
&lt;p>Redis哈希槽的概念是将所有的key分散到不同的槽中存储，每个槽对应一个节点，通过哈希算法计算key所在的槽。&lt;/p>
&lt;p>28、Redis集群的主从复制模型是什么？&lt;/p>
&lt;p>Redis集群的主从复制模型是将数据分散到多个节点上存储，每个节点都可以作为主节点或从节点，通过主从复制保证数据的可用性和一致性。&lt;/p>
&lt;p>29、Redis集群不会有写操作丢失吗？&lt;/p>
&lt;p>Redis集群不会有写操作丢失，因为它采用了主从复制和哨兵机制，可以保证数据的可用性和一致性。&lt;/p>
&lt;p>30、Redis集群之间如何进行数据复制和故障转移？&lt;/p>
&lt;p>Redis集群之间通过主从复制和哨兵机制进行数据复制和故障转移。&lt;/p>
&lt;p>31、Redis集群最大节点个数是多少？&lt;/p>
&lt;p>Redis集群最大节点个数是16384。&lt;/p>
&lt;p>32、Redis集群可以选择不同的数据库吗？&lt;/p>
&lt;p>Redis集群可以选择不同的数据库，通过SELECT命令进行切换。&lt;/p>
&lt;p>33、如何测试Redis的连通性？&lt;/p>
&lt;p>可以使用PING命令测试Redis的连通性。&lt;/p>
&lt;p>Redis其他问题：&lt;/p>
&lt;p>34、Redis事务是什么？&lt;/p>
&lt;p>Redis事务是一组命令的集合，可以保证这组命令的原子性。&lt;/p>
&lt;p>35、Redis key的过期时间可以通过哪些命令设置？&lt;/p>
&lt;p>Redis key的过期时间可以通过EXPIRE命令设置，永久有效可以通过PERSIST命令设置。&lt;/p>
&lt;p>36、如何进行内存优化？&lt;/p>
&lt;p>可以通过优化数据结构、设置合理的过期时间、使用持久化机制等方式进行内存优化。&lt;/p>
&lt;p>37、Redis回收进程是什么？&lt;/p>
&lt;p>Redis回收进程会定期扫描内存中的数据，将过期的数据删除。&lt;/p>
&lt;p>38、Redis的内存用完了会导致什么问题？&lt;/p>
&lt;p>Redis的内存用完了会导致写操作失败，读操作仍然可以正常进行。&lt;/p>
&lt;p>39、一个Redis实例最多能存放多少个keys？&lt;/p>
&lt;p>一个Redis实例最多能存放约43亿个keys，List、Set、Sorted Set它们最多能存放约21亿个元素。&lt;/p>
&lt;p>40、如何保证Redis中的数据都是热点数据？&lt;/p>
&lt;p>可以使用热点数据分析和缓存预热等方式保证Redis中的数据都是热点数据。&lt;/p>
&lt;p>41、Redis最适合的场景是什么？&lt;/p>
&lt;p>Redis最适合的场景包括高并发、高性能、高可用性的应用场景，如电商、社交、游戏等。&lt;/p>
&lt;p>42、如何扫描所有的key？&lt;/p>
&lt;p>可以使用SCAN命令扫描所有的key，然后通过字符串匹配找出以某个固定的已知的前缀开头的key。&lt;/p>
&lt;p>43、大量的key需要设置同一时间过期时需要注意什么？&lt;/p>
&lt;p>需要注意的是，大量的key需要设置同一时间过期时，需要合理设置过期时间，避免过期时间集中在同一时间点。&lt;/p>
&lt;p>44、如何使用Redis做异步队列？&lt;/p>
&lt;p>我使用过Redis做异步队列，可以通过LIST数据结构实现。&lt;/p>
&lt;p>45、Redis分布式锁是什么？&lt;/p>
&lt;p>Redis分布式锁是一种基于Redis实现的分布式锁，可以通过SETNX命令实现。&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/</guid><description/></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/</guid><description>&lt;h1 id="数据库">数据库&lt;/h1>
&lt;h3 id="列数据库是什么">&lt;strong>列数据库是什么&lt;/strong>&lt;/h3>
&lt;p>&lt;strong>列数据库&lt;/strong>是将传统的表格形式拆分为单列存储，&lt;strong>存储方式&lt;/strong>是列数据库与传统数据库的最大差别。这个差别同时&lt;strong>带给了列数据库高效的查询性能&lt;/strong>。&lt;/p>
&lt;p>即每一列的数据的存储在一个连续空间的,且有序,因此只要找到了主键在第几个位置,就可以快速找到其他属性的元素.&lt;/p>
&lt;h3 id="redismemcachemongodb特点和区别">&lt;strong>Redis、memcache、mongoDb特点和区别&lt;/strong>&lt;/h3>
&lt;p>&lt;strong>Redis&lt;/strong>&lt;/p>
&lt;p>内存型KV数据库，适合&lt;strong>读多写少&lt;/strong>的业务场景。很适合做缓存。&lt;/p>
&lt;p>优点：&lt;/p>
&lt;ul>
&lt;li>支持&lt;strong>多种数据类型&lt;/strong> string、list、set、zset、hash&lt;/li>
&lt;li>&lt;strong>读写性能优异&lt;/strong>。&lt;/li>
&lt;li>数据可以&lt;strong>持久化&lt;/strong>保持（AOF、快照），写入硬盘，&lt;/li>
&lt;li>支持&lt;strong>灾难恢复，主从复制&lt;/strong>。主机会自动将数据同步到从机，可以进行读写分离。&lt;/li>
&lt;/ul>
&lt;p>缺点：&lt;/p>
&lt;ul>
&lt;li>redis较&lt;strong>难支持在线扩容&lt;/strong>，当集群数据达到上限在线扩容变得复杂。&lt;/li>
&lt;li>&lt;strong>主从宕机&lt;/strong> 会导致前端读写失败，主从数据复制过程中，数据未完全复制到从机，会出现数据不一致。&lt;/li>
&lt;/ul>
&lt;p>应用场景：&lt;/p>
&lt;ul>
&lt;li>在程序和关系型数据库&lt;strong>中间做高速缓存&lt;/strong>&lt;/li>
&lt;li>缓存&lt;strong>高频数据,降低IO次数&lt;/strong>&lt;/li>
&lt;li>分布式架构中做&lt;strong>session共享&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>例子：&lt;/p>
&lt;ul>
&lt;li>比如微信token每两小时刷新一次，就比较适合用redis存储，读也比较方便；&lt;/li>
&lt;li>在线游戏排行榜；计时达到一定时间后显示相关广告；按照用户投票和时间排序，更新新闻；&lt;/li>
&lt;li>统计在某段特点时间里有多少特定用户访问了某个特定资源，统计哪些特定用户访问了某篇的文章；&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Memcache&lt;/strong>&lt;/p>
&lt;p>高性能的&lt;strong>分布式内存对象缓存&lt;/strong>系统，基于一个&lt;strong>存储键/值对&lt;/strong>的hashmap&lt;/p>
&lt;p>优点, 基于其&lt;strong>分布式特性&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>均衡请求&lt;/strong>&lt;/li>
&lt;li>增加&lt;strong>缓存容量&lt;/strong>&lt;/li>
&lt;li>&lt;strong>部分容灾&lt;/strong>:多台MC服务器使用哈希一致性算法,当有一台挂掉时,能保留部分请求.&lt;/li>
&lt;/ul>
&lt;p>缺点&lt;/p>
&lt;ul>
&lt;li>只支持&lt;strong>简单的key/value数据&lt;/strong>结构，不像Redis可以支持丰富的数据类型。&lt;/li>
&lt;li>&lt;strong>无法进行持久化&lt;/strong>，数据不能备份，只能用于缓存使用，且重启后数据全部丢失。&lt;/li>
&lt;/ul>
&lt;p>应用场景：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>分布式缓存&lt;/strong>&lt;/li>
&lt;li>数据库前段缓存&lt;/li>
&lt;li>服务器间数据共享&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>MongoDB&lt;/strong>&lt;/p>
&lt;p>是&lt;strong>文档型&lt;/strong>的非关系型数据库，使用&lt;strong>json结构&lt;/strong>。&lt;/p>
&lt;p>优点&lt;/p>
&lt;ul>
&lt;li>&lt;strong>查询功能&lt;/strong>强大：json文档结构的存储方式，能够更便捷的获取数据&lt;/li>
&lt;li>能存储&lt;strong>海量数据&lt;/strong>&lt;/li>
&lt;li>&lt;strong>海量数据下性能优越&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>缺点&lt;/p>
&lt;ul>
&lt;li>占用&lt;strong>内存过大&lt;/strong> 。&lt;/li>
&lt;li>&lt;strong>不支持事务&lt;/strong>。&lt;/li>
&lt;li>模式自由,自由灵活的文件存储&lt;strong>格式带来的数据错误&lt;/strong>&lt;/li>
&lt;li>MongoDB没有成熟的&lt;strong>维护工具&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>应用场景:&lt;/p>
&lt;ul>
&lt;li>存放&lt;strong>评论等半结构化数据&lt;/strong>&lt;/li>
&lt;li>适合&lt;strong>存储json&lt;/strong>类型数据&lt;/li>
&lt;li>&lt;strong>不经常变化&lt;/strong>,朋友圈,日志,直播礼物&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>应用场景&lt;/strong>&lt;/p>
&lt;p>redis: 数据量较&lt;strong>小的更性能操作和运算&lt;/strong>上。&lt;/p>
&lt;p>memcache: 用于在&lt;strong>动态系统中减少数据库负载&lt;/strong>，提升性能;做缓存，提高性能（适合读多写少，对于数据量比较大，可以采用sharding）。&lt;/p>
&lt;p>MongoDB:主要解决&lt;strong>海量数据的访问效率&lt;/strong>问题。&lt;/p>
&lt;h3 id="数据仓库">&lt;strong>数据仓库&lt;/strong>&lt;/h3>
&lt;p>主要功能是 将OLTP经年累月所累积的大量数据，通过&lt;strong>数据仓库特有的数据储存架构进行 OLAP&lt;/strong>，最终帮助决策者能快速有效地从大量数据中，分析出有价值的信息，提供决策支持. &lt;strong>仍然是结构化数据&lt;/strong>&lt;/p>
&lt;p>与数据库的区别: 数据库面向的是OLTP.，数据仓库面向OLAP&lt;/p>
&lt;p>数据仓库是一个用以更好地支持企业决策分析处理的、面向主题的、集成的、不可更新的、随时间不断变化的数据集合&lt;/p>
&lt;ul>
&lt;li>&lt;strong>面向主题&lt;/strong>：主题是个抽象的概念，是&lt;strong>在较高层次上将企业信息系统中的数据综合、归类并进行分析利用&lt;/strong>的抽象，比如对于商场而言，主题就包括供应商、商品、顾客等&lt;/li>
&lt;li>&lt;strong>集成&lt;/strong>的：数据仓库的数据是&lt;strong>从原有分散的数据库数据中抽取的&lt;/strong>，因此数据在进入前必然经过加工与集成，同一与综合&lt;/li>
&lt;li>&lt;strong>不可更新&lt;/strong>的：所涉及的数据操作主要是数据查询，一般不会修改操作&lt;/li>
&lt;li>随&lt;strong>时间变化&lt;/strong>：不可更新是指数据仓库的&lt;strong>用户&lt;/strong>进行分析处理是&lt;strong>不进行数据更新操作&lt;/strong>的，但不代表数据仓库的&lt;strong>整个生存周期中数据集合&lt;/strong>是不变的&lt;/li>
&lt;/ul>
&lt;h3 id="数据湖">&lt;strong>数据湖&lt;/strong>:&lt;/h3>
&lt;p>企业希望把**所有数据(结构化与非结构化)**都完整保存下来，进行有效管理与集中治理，挖掘和探索数据价值。&lt;/p>
&lt;p>数据湖是一个集中存储各类&lt;strong>结构化和非结构化&lt;/strong>数据的大型数据仓库，它可以存储来自&lt;strong>多个数据源、多种数据类型&lt;/strong>的&lt;strong>原始数据&lt;/strong>，数据&lt;strong>无需经过结构化处理&lt;/strong>，就可以进行存取、处理、分析和传输。&lt;/p>
&lt;p>对于数据仓库与数据湖的不同之处，可以类比为仓库和湖泊的区别：仓库存储着来自特定来源的货物；而湖泊的水来自河流、溪流和其他来源，&lt;strong>并且是原始数据&lt;/strong>。&lt;/p>
&lt;h3 id="sql中使用绑定变量的优点与缺点">&lt;strong>Sql中使用绑定变量的优点与缺点&lt;/strong>&lt;/h3>
&lt;p>&lt;strong>绑定变量实质就是变量&lt;/strong>。类似于我们是用过的替代变量（占位符）。就是在sql语句中使用变量，通过改变变量的值来得到不同的结果。&lt;/p>
&lt;p>sql语句是分为动态部分和静态部分的。而动态部分在一般的情况下，对执行计划的影响是微乎其微的。&lt;/p>
&lt;p>&lt;strong>同一个sql语句有不同动态部分生成的执行计划是相同的。&lt;/strong>&lt;/p>
&lt;p>优点：&lt;/p>
&lt;ul>
&lt;li>使用动态绑定，可以&lt;strong>减少sql的解析&lt;/strong>，从而减少了数据库引擎在sql解析上资源的消耗。&lt;/li>
&lt;li>提高了&lt;strong>执行效率和可靠性&lt;/strong>。减少对数据库的访问实际上就是减少了数据库的工作量&lt;/li>
&lt;/ul>
&lt;p>缺点：&lt;/p>
&lt;ul>
&lt;li>可能长时间使用动态sql，由于参数的不同。可能sql的&lt;strong>执行效率不同&lt;/strong>；&lt;/li>
&lt;li>&lt;strong>使用不当会有安全问题 sql注入&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h3 id="实现数据安全性控制的常用方法和技术">&lt;strong>实现数据安全性控制的常用方法和技术&lt;/strong>&lt;/h3>
&lt;p>数据库管理系统提供的安全措施主要包括&lt;/p>
&lt;ul>
&lt;li>用户&lt;strong>身份鉴别&lt;/strong>&lt;/li>
&lt;li>自主存取控制 Discretionary Access Control&lt;/li>
&lt;li>强制存取控制 Mandatory Access Control&lt;/li>
&lt;li>&lt;strong>视图&lt;/strong>机制&lt;/li>
&lt;li>&lt;strong>审计&lt;/strong>&lt;/li>
&lt;li>数据&lt;strong>加密&lt;/strong>存储和加密传输等&lt;/li>
&lt;/ul>
&lt;h3 id="登记日志的原则运行记录优先原则是什么为什么">&lt;strong>登记日志的原则（运行记录优先原则）是什么，为什么&lt;/strong>&lt;/h3>
&lt;p>&lt;strong>运行记录优先原则&lt;/strong>:&lt;/p>
&lt;ol>
&lt;li>&lt;strong>登记的次序严格按并发事务执行的时间次序&lt;/strong>&lt;/li>
&lt;li>必须&lt;strong>先写日志文件，后写数据库&lt;/strong>&lt;/li>
&lt;/ol>
&lt;p>如果先写了数据库修改，而在运行记录中没有登记下这个修改，则以后就&lt;strong>无法恢复这个修改&lt;/strong>了。&lt;/p>
&lt;p>如果先写日志，但没有修改数据库，按日志文件恢复时只不过是多执行一次&lt;strong>不必要的UNDO操作&lt;/strong>，并&lt;strong>不会影响数据库的正确性&lt;/strong>。&lt;/p>
&lt;p>所以为了安全，一定要先写日志文件，即首先把日志记录写到日志文件中，然后写数据库的修改。这就是**“先写日志文件”的原则**&lt;/p>
&lt;h3 id="sql-语句的执行过程并简单对各个步骤的所花费的代价大小进行描述和比较">SQL 语句的执行过程，并简单对各个步骤的所花费的代价大小进行描述和比较。&lt;/h3>
&lt;ol>
&lt;li>语法分析：确保语句的正确性和有效性。代价很小，语法分析器已预先定义了所有合法的 SQL 语法。&lt;/li>
&lt;li>语义分析：需要检查语句中的&lt;strong>对象是否存在&lt;/strong>、&lt;strong>用户是否有访问权限&lt;/strong>等信息。代价比语法分析高一些。&lt;/li>
&lt;li>解析（软解析和硬解析）：将 SQL 语句转换成执行计划，比语义分析高。需要进行语法转换、查询优化等复杂操作。
&lt;ol>
&lt;li>在软解析过程中，DBMS 会查找已经编译好的执行计划缓存，如果找到了对应的执行计划就直接使用.&lt;/li>
&lt;li>否则会进行硬解析，生成新的执行计划，此时代价最大。&lt;/li>
&lt;li>执行计划生成：生成最优的执行计划，以最小化查询的代价。代价最高，需要进行大量的计算和查询优化。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>查询执行：按照执行计划执行查询，并从磁盘中读取数据、对数据进行排序、过滤和聚合等操作，可能还需要进行大量的磁盘和内存交换。代价取决于查询本身的复杂度以及所涉及的数据量。&lt;/li>
&lt;/ol>
&lt;p>综合来看，SQL 语句的执行过程中，查询优化和查询执行往往是代价最大的两个步骤。在实际应用中，可以通过&lt;strong>优化查询语句的结构&lt;/strong>、&lt;strong>创建合适的索引&lt;/strong>、&lt;strong>优化查询计划&lt;/strong>等手段来提高查询性能，从而减少查询优化和查询执行所需的代价。&lt;/p>
&lt;h3 id="sql-优化原理是什么优化的逻辑是怎样的对此经验之谈">&lt;strong>SQL 优化原理是什么？优化的逻辑是怎样的？对此经验之谈&lt;/strong>&lt;/h3>
&lt;p>SQL 优化的原理：&lt;/p>
&lt;ul>
&lt;li>通过&lt;strong>优化查询的执行计划&lt;/strong>&lt;/li>
&lt;li>&lt;strong>减少查询的时间和资源消耗&lt;/strong>&lt;/li>
&lt;li>提高数据库系统的&lt;strong>性能&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>SQL 优化的逻辑一般可以分为以下几个步骤：&lt;/p>
&lt;ol>
&lt;li>优化&lt;strong>查询语句&lt;/strong>：对查询语句进行优化，包括&lt;strong>重写查询语句&lt;/strong>、&lt;strong>使用索引&lt;/strong>、&lt;strong>避免全表扫描&lt;/strong>等。&lt;/li>
&lt;li>优化&lt;strong>数据库结构&lt;/strong>：根据业务需求优化数据库中表的&lt;strong>结构、索引、分区&lt;/strong>等，以提高查询和更新操作的性能。&lt;/li>
&lt;li>优化&lt;strong>硬件环境&lt;/strong>：优化数据库所在的硬件环境，包括 CPU、内存、磁盘、网络等，以提高数据库系统的整体性能。&lt;/li>
&lt;/ol>
&lt;p>对于 SQL 优化的经验之谈，以下是一些常见的建议：&lt;/p>
&lt;ol>
&lt;li>将&lt;strong>过滤条件进行排序&lt;/strong>,好的过滤条件先做&lt;/li>
&lt;li>使用&lt;strong>join来暗示表连接顺序&lt;/strong>，当有多表连接操作时，考虑使用&lt;strong>exists和in操作来优化&lt;/strong>&lt;/li>
&lt;li>&lt;strong>避免过度连接表&lt;/strong>，将多维度的查询进行降维处理，一次连接的表不要超过3张，超过就将非关联子查询变成内嵌视图。
&lt;ul>
&lt;li>聚合子查询转化为JOIN&lt;/li>
&lt;li>非关联子查询变成内嵌视图&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>避免在高层使用distinct&lt;/strong>，用exists和in来处理&lt;/li>
&lt;li>*&lt;em>避免在高层使用select &lt;em>&lt;strong>, 这样会产生&lt;/strong>冗余的结果集，降低性能&lt;/em>&lt;/em>&lt;/li>
&lt;li>&lt;strong>不要滥用子查询&lt;/strong>. 子查询有如下好处,除这些好处外,不要用
&lt;ol>
&lt;li>分辨过滤条件的好坏&lt;/li>
&lt;li>避免顶层的distinct&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>总之，SQL 优化需要根据具体的情况进行分析和优化，需要综合考虑查询的复杂度、数据的规模和类型、硬件环境等因素。&lt;/p>
&lt;h3 id="sql有什么优化策略从硬件系统应用上分析">&lt;strong>SQL有什么优化策略，从硬件、系统、应用上分析&lt;/strong>&lt;/h3>
&lt;p>这个优化法则归纳为5个层次：&lt;/p>
&lt;ul>
&lt;li>减少数据访问（&lt;strong>减少磁盘访问&lt;/strong>）系统上
&lt;ul>
&lt;li>正确使用&lt;strong>索引&lt;/strong>&lt;/li>
&lt;li>&lt;strong>优化执行计划&lt;/strong>&lt;/li>
&lt;li>尽量使用&lt;strong>自带函数&lt;/strong>,慎用自定义函数.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>减少服务器CPU开销（&lt;strong>减少CPU&lt;/strong>及内存开销）
&lt;ul>
&lt;li>使用&lt;strong>绑定变量&lt;/strong>&lt;/li>
&lt;li>合理使用&lt;strong>排序&lt;/strong>&lt;/li>
&lt;li>减少&lt;strong>模糊查找&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>返回&lt;strong>更少数据&lt;/strong>（减少网络传输或磁盘访问）应用上
&lt;ul>
&lt;li>数据&lt;strong>分页&lt;/strong>处理&lt;/li>
&lt;li>返回&lt;strong>只需要的字段&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>减少交互次数（减少网络传输）应用上
&lt;ul>
&lt;li>一次连接批量处理数据&lt;/li>
&lt;li>使用存储过程.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>利用更多资源（硬件上）
&lt;ul>
&lt;li>扩大内存&lt;/li>
&lt;li>增加CPU&lt;/li>
&lt;li>更快的硬盘&lt;/li>
&lt;li>更高速的网络&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="b树与b树的结构">&lt;strong>B树与B+树的结构&lt;/strong>&lt;/h3>
&lt;p>B树是&lt;strong>多关键字平衡树&lt;/strong>,且节点内的关键字是有序的.每个节点都存储其关键字指向的具体数据地址.&lt;/p>
&lt;p>B+树是在B树的基础上, 非叶子节点仅指向其多个子节点的地址 , 只有叶子节点指向具体以堆文件形式存放的数据块地址. 相邻叶子节点也通过指针连接. 方便快速范围查询.&lt;/p>
&lt;p>不同之处:&lt;/p>
&lt;ul>
&lt;li>层数更低: 相比于B树, B+树的非叶子节点全部用于索引,使得B+树的层数更低,&lt;/li>
&lt;li>效率稳定, B+树一定只能在叶子节点找到数据的具体地址, 每次查询的路径长度基本一致.&lt;/li>
&lt;li>范围查询: B+树的叶子节点有next指针, 使得范围查询效率更高.&lt;/li>
&lt;/ul>
&lt;h3 id="为什么不用其他数据结构做索引而用b树或b树">&lt;strong>为什么不用其他数据结构做索引，而用B树或B+树&lt;/strong>&lt;/h3>
&lt;ul>
&lt;li>链表, 链表的查询速度是O（N），每次查询都得从链表头开始查询，例如上面查询“xiaxia”，如果xiaxia在1000的位置，那么需要遍历1000次才能查找到。&lt;/li>
&lt;li>数组:查询速度O（1），但删除插入是O(n), 且数据必须存在于内存, 索引过大时无法存储.&lt;/li>
&lt;li>平衡二叉树
&lt;ul>
&lt;li>二叉查找树查询的时间复杂度是O（logN），查找速度最快和比较次数最少. 但在树形结构下,影响查询效率的因素主要是树的深度, B树的深度远比平衡二叉树小。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="b树索引的适用范围">&lt;strong>B树索引的适用范围&lt;/strong>:&lt;/h3>
&lt;ul>
&lt;li>全键值匹配&lt;/li>
&lt;li>匹配最左前缀
匹配列前缀&lt;/li>
&lt;li>匹配范围值
精确匹配某一列并范围匹配另外一列
只访问索引的查询&lt;/li>
&lt;/ul>
&lt;h3 id="什么时候使用b树索引--b树的索引可用性">&lt;strong>什么时候使用B树索引 / B树的索引可用性&lt;/strong>:&lt;/h3>
&lt;p>1、只需要获取少量的行;(确保使用索引比不使用索引更高效)&lt;/p>
&lt;p>2、即便获取很多行，但是可以只使用索引不使用基本表。(索引中包含整个表)&lt;/p>
&lt;h3 id="索引分类">&lt;strong>索引分类&lt;/strong>&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>聚簇索引&lt;/p>
&lt;ul>
&lt;li>按照数据存放的&lt;strong>物理位置为顺序&lt;/strong>的索引结构，聚集索引的叶子节点包含了整个数据行。&lt;/li>
&lt;li>每个表&lt;strong>只能有一个聚集索引&lt;/strong>，它对应的索引键值也是表的主键或唯一约束条件。&lt;/li>
&lt;li>通过聚集索引，我们可以快速地按照主键或唯一约束条件查询和排序表中的数据, &lt;strong>提高多行检索速度&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>非聚簇索引&lt;/p>
&lt;ul>
&lt;li>索引顺序与数据&lt;strong>物理列排序无关&lt;/strong>，&lt;strong>叶节点仍然是索引节点(指向主键)&lt;/strong>&lt;/li>
&lt;li>每个表可以有&lt;strong>多个非聚集索引&lt;/strong>，这些索引可以覆盖&lt;strong>多个数据列&lt;/strong>，以满足不同的查询需求。&lt;/li>
&lt;li>通过非聚集索引，快速地&lt;strong>定位表中符合查询条件的记录的主键&lt;/strong>，然后进行(回表查询)。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>覆盖索引&lt;/strong>: 如果&lt;strong>非聚簇符合索引&lt;/strong>已经能够得到&lt;strong>查询的所有信息&lt;/strong>了，就&lt;strong>无需再回表&lt;/strong>，即只按照条件&lt;strong>找主键&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>联合索引&lt;/strong>：同时对&lt;strong>多列创建索引&lt;/strong>，&lt;strong>叶子节点会同时包含每个索引列的值&lt;/strong>，并且同时&lt;strong>根据多列排序&lt;/strong>，这个排序和我们所理解的字典序类似。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>哈希索引&lt;/strong>&lt;/p>
&lt;p>所有的数据类型，通过哈希函数变成一个&lt;strong>等长的哈希值&lt;/strong>。&lt;/p>
&lt;p>将这个&lt;strong>等长的哈希值&lt;/strong>作为&lt;strong>组织成索引的结构 —— 哈希链表&lt;/strong>。&lt;/p>
&lt;p>哈希链表的结点上，&lt;strong>储存哈希值&lt;/strong> 和 &lt;strong>指向记录哈希值的地址 uid（索引行的地址）&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>哈希索引能做什么不能做什么？&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>哈希索引只能用来进行&lt;strong>全键值&lt;/strong>的查询
&lt;ul>
&lt;li>不能前缀查询&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>哈希索引只支持&lt;strong>击中运算符&lt;/strong>
&lt;ul>
&lt;li>击中运算符：= , != , in&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>哈希索引&lt;strong>不支持范围查询&lt;/strong>&lt;/li>
&lt;li>哈希索引&lt;strong>不支持对字段排序&lt;/strong>(因为只支持击中运算符)&lt;/li>
&lt;li>哈希索引&lt;strong>读取效率高于B树索引&lt;/strong>
&lt;ul>
&lt;li>哈希索引结构非常&lt;strong>紧凑&lt;/strong>.&lt;/li>
&lt;li>哈希索引&lt;strong>使用数值的比较&lt;/strong>,远&lt;strong>高于字符串比较&lt;/strong>速度.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>函数索引&lt;/strong>&lt;/p>
&lt;p>B树索引是对一个字段构建索引,而函数索引是对&lt;strong>这个字段上的一个函数值&lt;/strong>构建索引.&lt;/p>
&lt;p>&lt;strong>结构同样是B+树索引,只是节点的关键字是函数的值而不是字段值.&lt;/strong>&lt;/p>
&lt;p>是最具创造力的索引结构,用得好可用解决并发冲突,优化存储结构.等很多事情.&lt;/p>
&lt;p>&lt;strong>能用在哪&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>不区分大小写&lt;/strong>查询&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>T、F比例巨大差异&lt;/strong>的查询&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>有选择的唯一性&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>项目表有两个状态, active和inactive.&lt;/p>
&lt;p>要求active的项目,必须要有唯一名. 而inactive没有这个要求.&lt;/p>
&lt;p>解决方法: &lt;strong>函数索引上构建唯一索引&lt;/strong>.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>位图索引&lt;/strong>&lt;/p>
&lt;p>用一个&lt;strong>索引键条目（01图）存储指向多行&lt;/strong>的指针。&lt;/p>
&lt;p>&lt;strong>位图索引适合&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>相异基数(distinct cardinality)低&lt;/strong>的字段进行快速查询 (复合查询)
&lt;ul>
&lt;li>可以取的值的范围小: 性别、真假,年龄段 等.&lt;/li>
&lt;li>使用B树索引,需要复合索引时 组合数多. 且共同的值多, 可能使得叶子结点远少于索引结点.&lt;/li>
&lt;li>使用哈希索引,碰撞率贼高.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>大量&lt;strong>临时查询的聚合&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>位图索引对于写操作非常不友好&lt;/strong>/位图索引&lt;strong>不能应用在OLTP&lt;/strong>应用中的原因&lt;/p>
&lt;p>&lt;strong>原因&lt;/strong>: 位图索引的&lt;strong>键值指向多行&lt;/strong>, 如果一个session修改了一个索引的数据,则&lt;strong>该索引指向的所有行都会被查找到&lt;/strong>.无法锁定单独一个条目,&lt;strong>可能在修改时要锁住整个目录&lt;/strong>,导致并发性下降严重 几乎变成串行化.&lt;/p>
&lt;p>&lt;strong>位图连结索引&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>允许使用&lt;strong>另外某个表的列&lt;/strong> 对 &lt;strong>一个给定表&lt;/strong> 建立索引。&lt;/li>
&lt;li>实际上，这就是允许&lt;strong>对一个索引结构&lt;/strong>(而不是表本身)中的数据进行&lt;strong>逆规范化&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>位图联结索引的&lt;strong>前提条件&lt;/strong>:&lt;/p>
&lt;p>&lt;strong>必须连接到另一张表的主键/唯一键&lt;/strong>&lt;/p>
&lt;p>&lt;strong>反向键索引或叫避向索引“eseindex)&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>将键值反向插入，以免并发插入时都插入到同一个块。&lt;/li>
&lt;li>此时进程将竞争同一个索引页,插入并发性大幅度下降&lt;/li>
&lt;/ol>
&lt;h3 id="索引的5种优点">&lt;strong>索引的5种优点&lt;/strong>&lt;/h3>
&lt;ul>
&lt;li>可以大大加快数据的&lt;strong>检索&lt;/strong>速度&lt;/li>
&lt;li>可以加速表和表之间的&lt;strong>连接&lt;/strong>，特别是在实现数据的参照完整性方面特别有意义&lt;/li>
&lt;li>在使用分组和排序子句进行数据检索式，同样可以显著减少查询中&lt;strong>分组和排序&lt;/strong>的时间&lt;/li>
&lt;li>通过创建&lt;strong>唯一性&lt;/strong>索引，可以保证数据库表中每一行数据的唯一性&lt;/li>
&lt;li>通过使用索引，可以在查询的过程中，使用&lt;strong>优化隐藏器&lt;/strong>，提高系统的性能&lt;/li>
&lt;/ul>
&lt;h3 id="系统对外键建立索引很普遍为什么要对外键建立索引">&lt;strong>系统对外键建立索引很普遍。为什么要对外键建立索引？&lt;/strong>&lt;/h3>
&lt;ul>
&lt;li>加快对于父表和子表的&lt;strong>连接查询&lt;/strong>.&lt;/li>
&lt;li>&lt;strong>删除操作&lt;/strong>时，可以快速通过外键的索引找到&lt;strong>主表中&lt;/strong>要删除的行。&lt;/li>
&lt;li>&lt;strong>避免死锁&lt;/strong>, 有外键时会导致两个表都要上锁.
&lt;ul>
&lt;li>添加索引能够让&lt;strong>上锁后操作的时间变短&lt;/strong>, .并发时需要 A表加锁/B表加锁。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="不加索引的外键情况">&lt;strong>不加索引的外键情况&lt;/strong>&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>子表不容易&lt;/strong>修改
&lt;ul>
&lt;li>不从子表中删除记录&lt;/li>
&lt;li>是一个字典表,不容易被修改.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>一般&lt;strong>不进行父表和子表的连接查询&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h3 id="建立索引的条件--请解释数据库管理员如何为数据库建立一组好的索引">&lt;strong>建立索引的条件 / 请解释数据库管理员如何为数据库建立一组好的索引&lt;/strong>&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>经常搜索&lt;/strong>的列&lt;/li>
&lt;li>经常&lt;strong>使用where子句&lt;/strong>的列上，加快条件的判断速度&lt;/li>
&lt;li>经常进行&lt;strong>范围搜索&lt;/strong>的列上，因为索引已经排序了，其指定的范围是连续的.&lt;/li>
&lt;li>&lt;strong>唯一性&lt;/strong>的列:在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构&lt;/li>
&lt;li>经常&lt;strong>需要排序&lt;/strong>的列上，因为索引已经排序了，查询可以利用索引的排序，加速排序查询时间.&lt;/li>
&lt;li>&lt;strong>经常用在连接的列&lt;/strong>，这些列&lt;strong>主要是外键&lt;/strong>，可以加快连接速度&lt;/li>
&lt;li>&lt;strong>数据分布较广的列&lt;/strong>:&lt;/li>
&lt;/ul>
&lt;h3 id="哪些列上不应该加索引">&lt;strong>哪些列上不应该加索引&lt;/strong>&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>很少使用&lt;/strong>或者参考的列不应该创建索引。&lt;/li>
&lt;li>&lt;strong>很少的数据值&lt;/strong>列不应该创建索引。&lt;/li>
&lt;li>&lt;strong>text,image,bit数据类型&lt;/strong>的列不应该加索引。
&lt;ul>
&lt;li>比较和排序的开销大.&lt;/li>
&lt;li>因为这些列要么数据量很大，要么很小，不利于使用索引&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>修改需求大&lt;/strong>的列.&lt;/li>
&lt;/ul>
&lt;h3 id="为什么数据库管理员一般不会给所有单个属性都建立索引请写出两条原因">&lt;strong>为什么数据库管理员一般不会给所有单个属性都建立索引，请写出两条原因&lt;/strong>&lt;/h3>
&lt;ul>
&lt;li>过多的索引会&lt;strong>加重优化器&lt;/strong>查找最优查询计划的负担&lt;/li>
&lt;li>会增加数据库&lt;strong>维护索引的负担&lt;/strong>.&lt;/li>
&lt;li>一旦聚集索引改变，&lt;strong>所有非聚集索引都会跟着改变&lt;/strong>&lt;/li>
&lt;li>该列是&lt;strong>属于不该建立索引&lt;/strong>的列时.&lt;/li>
&lt;/ul>
&lt;h3 id="为什么没有使用我的索引">&lt;strong>为什么没有使用我的索引&lt;/strong>&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>使用B+树索引&lt;/strong>，但&lt;strong>没有使用索引的最前列&lt;/strong>&lt;/li>
&lt;li>&lt;strong>不能为NULL建立索引条目&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>COUNT(*)&lt;/strong>， 包括NULL, t会引起&lt;strong>全表扫描&lt;/strong>，&lt;/li>
&lt;li>is not NULL&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>函数查询&lt;/strong>时不使用索引&lt;/li>
&lt;li>&lt;strong>隐形函数查询&lt;/strong>，比如**&amp;lt;&amp;gt;不等于符**，会&lt;strong>引起全表扫描&lt;/strong>&lt;/li>
&lt;li>&lt;strong>隐式类型转换&lt;/strong>，如字符串转成数值来比较&lt;/li>
&lt;li>如果用了我的索引，实际反而会更慢。
&lt;ul>
&lt;li>即查询&lt;strong>优化器发现有比使用你的索引更快的访问方式&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>没有正确的统计信息&lt;/strong>，造成CBO无法做出正确的选择&lt;/li>
&lt;li>两个条件用 &lt;strong>or 连接&lt;/strong>，一个有索引一个没索引&lt;/li>
&lt;/ul>
&lt;p>总结成两条：&lt;/p>
&lt;ul>
&lt;li>“不能使用索引，使用索引会返回不正确的结果”&lt;/li>
&lt;li>“不该使用索引，如果使用了索引就会变得更慢”&lt;/li>
&lt;/ul>
&lt;h3 id="索引带来的问题负面的使用索引会降低查询效率的情况">&lt;strong>索引带来的问题（负面的）,使用索引会降低查询效率的情况&lt;/strong>：&lt;/h3>
&lt;ul>
&lt;li>总是&lt;strong>存在索引不被使用&lt;/strong>的情况。
&lt;ul>
&lt;li>存在索引时, 创建索引会带来系统的维护和空间的开销.&lt;/li>
&lt;li>因此索引如果不被使用反而会降低效率.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>当&lt;strong>一次查询的结果集较大&lt;/strong>时，索引会影响效率。
&lt;ul>
&lt;li>因为&lt;strong>索引是针对点查询&lt;/strong>的，而不是针对某个范围查询的。此时有可能不使用索引反而效率更高.&lt;/li>
&lt;li>一般结果集在10%以下可以考虑使用索引。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>对于&lt;strong>修改需求大的表&lt;/strong>中，使用索引会严重影响数据库更新操作的效率。&lt;/li>
&lt;li>太多索引会让&lt;strong>设计不稳定&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h3 id="设计索引时需要考虑的主要因素">&lt;strong>设计索引时需要考虑的主要因素&lt;/strong>&lt;/h3>
&lt;ul>
&lt;li>在&lt;strong>适合加&lt;/strong>索引的列上加索引&lt;/li>
&lt;li>不在&lt;strong>不应该加&lt;/strong>索引的列上加索引&lt;/li>
&lt;li>不要加&lt;strong>过多&lt;/strong>的索引&lt;/li>
&lt;li>确保建立该索引后&lt;strong>能够被使用&lt;/strong>&lt;/li>
&lt;li>确保索引带来的&lt;strong>好处大于索引带来的问题&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h3 id="请描述oracle中iot的物理存储结构和读取数据的方式并与堆文件的物理存储结构和读取数据的方式进行比较后解释iot的适用范围">&lt;strong>请描述Oracle中IOT的物理存储结构和读取数据的方式，并与堆文件的物理存储结构和读取数据的方式进行比较后解释IOT的适用范围。&lt;/strong>&lt;/h3>
&lt;p>IOT（&lt;strong>Index-Organized&lt;/strong> Table）索引组织表 是一种基于B+树的索引类型，它的索引键包括表的主键和数据列。IOT的数据访问和索引访问是一体化的。&lt;/p>
&lt;p>IOT通常用于&lt;strong>需要频繁地使用主键查询&lt;/strong>的表，因为IOT将主键值和对应的数据行存储在同一个B+树节点中，可以减少磁盘I/O操作的次数，从而提高查询性能。&lt;/p>
&lt;p>与堆文件的存储结构相比。&lt;/p>
&lt;ul>
&lt;li>堆文件的存储是&lt;strong>随机存储&lt;/strong>的，而IOT使用的B树结构是&lt;strong>根据主键按照一定顺序存储&lt;/strong>的。&lt;/li>
&lt;li>堆文件的读取是需要&lt;strong>遍历整个堆文件数据&lt;/strong>的，而IOT则可以&lt;strong>通过主键的信息&lt;/strong>快速定位到相关节点，读取数据。&lt;/li>
&lt;/ul>
&lt;p>IOT适用范围：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>主键很少更新&lt;/strong>。因为主键更新会导致B树结构的重新调整。&lt;/li>
&lt;li>&lt;strong>多用主键查询&lt;/strong>。因为IOT是以主键为节点构造B树的，以主键信息查询能较快找到对应节点。&lt;/li>
&lt;li>&lt;strong>很少插入新数据&lt;/strong>。插入新数据会导致B树重新调整。&lt;/li>
&lt;li>希望数据已某种特定的&lt;strong>顺序物理存储&lt;/strong>，那也适合用IOT&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>IOT的优点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>记录排序&lt;/strong>，查询效率贼强&lt;/li>
&lt;li>&lt;strong>节约磁盘空间开销&lt;/strong>，主键没有空间开销，索引就是数据&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>IOT缺点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>插入效率也许低于堆文件&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对于&lt;strong>经常更新的表不适合用IOT&lt;/strong>，因为维护的索引代价大，更何况是多字段索引&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="聚簇索引--clustered-index-或者--clustering-index">&lt;strong>聚簇索引 -clustered index 或者 -clustering index&lt;/strong>&lt;/h3>
&lt;p>为了使得&lt;strong>表中数据有序&lt;/strong>, 很多数据库使用了&lt;strong>聚簇索引&lt;/strong>.&lt;/p>
&lt;p>聚簇索引就是按照每张表的主键构造一颗B+树，同时叶子节点中存放的就是整张表的行记录数据，这个叶子节点也被称为数据页。每张表只能拥有一个聚簇索引。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>范围查询效率非常高&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>代价: &lt;strong>非范围查询也要进行范围扫描&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>主键更新会导致记录的重新排序，从而导致记录物理位置的变化&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>为了更加安全, 聚簇索引可以和索引组织表一样，根据主键来定义. 因为主键被更新的概率小,或者说不应该被更新.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>聚簇索引&lt;strong>也可以是非主键索引,这是和索引组织表不一样的地方&lt;/strong>.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>聚簇索引和IOT的区别在于索引键的选择和存储方式。&lt;/p>
&lt;ul>
&lt;li>聚簇索引只包括表的主键，并将表的数据按照主键值的顺序存储在硬盘上；&lt;/li>
&lt;li>IOT包括表的主键和数据列，并将数据和索引存储在同一个结构中。&lt;/li>
&lt;/ul>
&lt;h3 id="分区的作用与类型">分区的作用与类型&lt;/h3>
&lt;p>&lt;strong>分区的作用&lt;/strong>: 提高&lt;strong>并发性和并行性&lt;/strong>，从而增强系统架构的&lt;strong>可伸缩性&lt;/strong>&lt;/p>
&lt;p>&lt;strong>分区的类型&lt;/strong>（不一定是方式）&lt;/p>
&lt;p>循环分区：&lt;strong>不受数据影响&lt;/strong>的内部机制。分区定义为各个磁盘的存储区域；可以看作是随意散布数据的机制；保持更改带来的磁盘I/O操作的平衡&lt;/p>
&lt;p>数据驱动分区：根据**一个或多个字段中的值(分区键)**来定义分区。是一种手工分区，一般叫分区视图.&lt;/p>
&lt;h3 id="数据驱动分区的实现方式">&lt;strong>数据驱动分区的实现方式&lt;/strong>&lt;/h3>
&lt;p>&lt;strong>哈希分区(Hash-partitioning)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>对&lt;strong>分区键进行哈希运算&lt;/strong>，根据运算结果进行分区.&lt;/li>
&lt;li>能保证&lt;strong>根据分区键可以快速找到记录&lt;/strong>，但对范围搜索没有任何帮助。&lt;/li>
&lt;li>其实更接近与循环分区, 只是它还能&lt;strong>负载均衡提高并发&lt;/strong>的能力.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>范围分区(Range- partitioning)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>滑动窗口，就是范围分区，&lt;strong>根据连续数据的范围&lt;/strong>对数据进行分区。&lt;/li>
&lt;li>&lt;strong>非常适合处理历史数据&lt;/strong>，每一个分区专门用来存储&lt;strong>特定范围内的数据&lt;/strong>。&lt;/li>
&lt;li>一般系统还会设定&lt;strong>else分区&lt;/strong>,来存储所有&lt;strong>可能漏网的数据&lt;/strong>(其他)&lt;/li>
&lt;li>应用: 时间范围, 字母范围&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>列表分区(List-partitioning)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>是一种最具手工风格的分区类型，适合&lt;strong>定制某种特殊的解决方案&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>分区键必须明确指定&lt;/strong>，但&lt;strong>分区键只能有一列&lt;/strong>，不能像范围或者哈希分区那样同时指定多个列做为分区键，但它的&lt;strong>单个分区对应值可以是多个&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>一旦插入的列值不在分区范围内，则插入/更新就会失败.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>因此
通常建议使用列表分区时，要创建一个&lt;strong>default分区&lt;/strong>存储那些&lt;strong>不在指定列表内的记录&lt;/strong>。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>复合分区&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>很多数据库中分区可以嵌套，即分区可以再建立子分区，叫sub partition.子分区是分区内的分区。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>一种二位分区处理的方法，比如在时间的分区中，建立哈希分区,范围-哈希分区、范围-列表分区等&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>OB把它叫做二级分区&lt;/strong>，再举个例子，&lt;strong>类似于用户账单领域，会按照user id做哈希分区，按照账单创建时间做范围分区&lt;/strong>。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>数据驱动的分区是最常使用的分区方式，用数据值本身作为分区的基础，这时候&lt;strong>数据分区最具有开发使用的价值&lt;/strong>。&lt;/p>
&lt;h3 id="分区是如何提高查询效率">&lt;strong>分区是如何提高查询效率&lt;/strong>&lt;/h3>
&lt;p>分区后，逻辑上表仍然是一张完整的表，只是将表中的数据在物理上存放到多个表空间（物理文件上），利于高速检索，&lt;strong>查询数据时，不至于每次都扫描整张表&lt;/strong>.&lt;/p>
&lt;h3 id="分区的优点和缺点">&lt;strong>分区的优点和缺点&lt;/strong>&lt;/h3>
&lt;p>&lt;strong>优点&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>增强&lt;strong>可用性&lt;/strong>：如果表的某个分区出现故障，表在其他分区的数据仍然可用；&lt;/li>
&lt;li>&lt;strong>维护&lt;/strong>方便：如果表的某个分区出现故障，需要修复数据，只修复该分区即可；&lt;/li>
&lt;li>&lt;strong>均衡I/O&lt;/strong>：可以把不同的分区映射到磁盘以平衡I/O，改善整个系统性能；&lt;/li>
&lt;li>改善&lt;strong>查询性能&lt;/strong>：对分区对象的查询可以仅搜索自己关心的分区，提高检索速度。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>缺点&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>除了堆文件之外的任何存储方法，都会&lt;strong>带来复杂性&lt;/strong>&lt;/li>
&lt;li>&lt;strong>选错存储方式&lt;/strong>会带来大幅度的性能降低&lt;/li>
&lt;li>降低了并发个数，但如果&lt;strong>涉及数据量非常庞大&lt;/strong>，&lt;strong>降低并发所带来的缺陷远远小于分区所带来的性能提高&lt;/strong>&lt;/li>
&lt;li>由于&lt;strong>强制的部分数据聚合&lt;/strong>可能会&lt;strong>导致其他数据的分散&lt;/strong>，所以不同的查询请求也可能会形成性能上的矛盾&lt;/li>
&lt;/ul>
&lt;h3 id="数据分区的最佳方法">&lt;strong>数据分区的最佳方法&lt;/strong>&lt;/h3>
&lt;ul>
&lt;li>当&lt;strong>数据分区键均匀分布时&lt;/strong>，分区表查询收益最大&lt;/li>
&lt;li>&lt;strong>避免更新分区键&lt;/strong>, 更新分区键会影响数据移动&lt;/li>
&lt;li>&lt;strong>不在更新数据频繁时使用分区&lt;/strong>.&lt;/li>
&lt;li>&lt;strong>考虑整体&lt;/strong>,当有多个处理执行时，解决方案就不应该过度偏袒其中任何一个&lt;/li>
&lt;/ul>
&lt;h3 id="面向对象中可持久化类的父类子类继承关系如何映射到关系数据库中有哪几种情况-每种情况下的表结构设计是怎姓的层次结构">&lt;strong>面向对象中可持久化类的父类子类继承关系，如何映射到关系数据库中，有哪几种情况, 每种情况下的表结构设计是怎姓的。(层次结构)&lt;/strong>&lt;/h3>
&lt;p>例子:&lt;/p>
&lt;p>指挥官和士兵&lt;/p>
&lt;p>每人都有唯一的ID, 名字(name), 描述(description)&lt;/p>
&lt;p>&lt;strong>邻接模型&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>层次中&lt;strong>父记录ID&lt;/strong>作为子记录(childrow) 的一个属性。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>设计直观简单,但会导致&lt;strong>递归的查询&lt;/strong>。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>原理&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>在邻接表中&lt;/strong>，所有的数据均拥有一个Parent字段，用来存储它的父节点。&lt;/li>
&lt;li>当前节点为根节点的话，它的父节点则为NULL。&lt;/li>
&lt;li>在遍历的时候，可以使用递归来实现查询整棵树，从根节点开始，不断寻找子节点（父节点-&amp;gt;子节点-&amp;gt;父节点-&amp;gt;子节点）&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>优点：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>快速获取直接父子节点&lt;/strong>，很容易&lt;strong>插入新节点&lt;/strong>。&lt;/li>
&lt;li>容易实现
&lt;ul>
&lt;li>使用Connect by容易实现&lt;/li>
&lt;li>递归实现，用oracle的with，表示出树的层次&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>三种树状模型中&lt;strong>性能最高&lt;/strong>，每秒返回的查询记录最多；只需要遍历一次，&lt;strong>但不是基于关系的处理&lt;/strong>，性能最好&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>缺点：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>为了避免多次交互,&lt;strong>每次获得整张表&lt;/strong>
&lt;ul>
&lt;li>比如查询后代节点树，需要用到递归，要发送多次的请求，与数据库交互多次。&lt;/li>
&lt;li>一般&lt;strong>为了避免递归给数据库发送sql&lt;/strong>，采用&lt;strong>一次性读取整个表&lt;/strong>的数据，然后在应用端构建树的方法。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>查询子树性能不好&lt;/strong>
&lt;ul>
&lt;li>只需要某一个子树，仍然要把整个树加载出来，性能上并不好；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>删除中间节点&lt;/strong>
&lt;ul>
&lt;li>要删除中间层结点时，需要同时删除该节点下的所有节点，否则会出现孤立节点；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>举例&lt;/strong>:&lt;/p>
&lt;p>表结构定义 : model(&lt;strong>id&lt;/strong>,parent_id,description,commander)&lt;/p>
&lt;p>&lt;strong>自顶向下SQL&lt;/strong>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">select level,* from model
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">connect by parent_id = prior.id
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">start with commander = &amp;#34;Root Commander&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>不用connect by时，需要使用with as来递归&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="o">//&lt;/span>&lt;span class="err">定义起点&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">select&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">level&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">from&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">model&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">where&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">commader&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;Root Commander&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="o">//&lt;/span>&lt;span class="err">定义递归体&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">select&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">parant&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">level&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">child&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">child&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">description&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">child&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">commander&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">from&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">query&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">parent&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">model&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">child&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">where&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">child&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">parent_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">parent&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">with&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">recursive_query&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">level&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">description&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">commander&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">as&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">select&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">as&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">level&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">from&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">model&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">where&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">commader&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;Root Commander&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">union&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">all&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">select&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">parant&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">level&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">child&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">child&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">description&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">child&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">commander&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">from&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">recursive_query&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">parent&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">model&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">child&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">where&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">child&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">parent_id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">parent&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="o">//&lt;/span>&lt;span class="err">但这是层次遍历&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">select&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">level&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">from&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">recursive_query&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>自底向上SQL&lt;/strong>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">select&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">level&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">from&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">model&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">connect&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">by&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">prior&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">parent_id&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">start&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">with&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">description&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">like&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;%Highland%&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="err">无法看到树&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="err">因为无法存储中间结果集&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>物化路径模型&lt;/strong>&lt;/p>
&lt;p>每一个节点都存储节点的&lt;strong>完整路径&lt;/strong>，一般用字符串存，它允许节点之间有顺序.&lt;/p>
&lt;p>每个节点保存的结构信息里包括&lt;/p>
&lt;ul>
&lt;li>祖先各节点的路径&lt;/li>
&lt;li>后代节点路径的一部分&lt;/li>
&lt;li>兄弟节点路径的长度&lt;/li>
&lt;li>节点所在层次等等。&lt;/li>
&lt;/ul>
&lt;p>1代表第一章;&lt;/p>
&lt;p>1.2代表第一章第二节;
1.2.3代表第一章第二节
第三小节。&lt;/p>
&lt;p>&lt;strong>优点：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>性能良好&lt;/strong>，借助了unix文件目录的思想，主要是&lt;strong>以空间换时间&lt;/strong>；&lt;/li>
&lt;li>&lt;strong>可靠性&lt;/strong>（&lt;strong>容易实现&lt;/strong>，不容易出bug）&lt;/li>
&lt;li>&lt;strong>可维护性&lt;/strong>（简单、不需要依赖大量额外的处理逻辑）&lt;/li>
&lt;li>并且通过&lt;strong>比较路径字符串长度&lt;/strong>也容易知道树的深浅&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>缺点：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>不能实现无限深度的树&lt;/strong>，每个节点的子节点数有上限；&lt;/li>
&lt;li>而且深度越大，路径越长，还要解决操作过程中&lt;strong>节点路径的唯一性&lt;/strong>；&lt;/li>
&lt;li>树的深度要自己&lt;strong>写函数计算&lt;/strong>&lt;/li>
&lt;li>&lt;strong>物化路径不应该是KEY&lt;/strong>，即使他们有唯一性，因为主键最好不更新原则。&lt;/li>
&lt;li>数据库&lt;strong>无法确保路径格式正确&lt;/strong>，只能&lt;strong>由应用程序来验证&lt;/strong>&lt;/li>
&lt;li>查询&lt;strong>复杂度主要在路径字符串的处理&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>与邻接模型的差别&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>邻接模型的&lt;strong>子节点是平等&lt;/strong>的,且可以&lt;strong>无限扩展&lt;/strong>。&lt;/li>
&lt;li>物化路径模型可以指出&lt;strong>兄弟的排名&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>影响物化路径模型的因素&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>计算&lt;strong>深度&lt;/strong>
计算两个&lt;strong>字符串函数的差&lt;/strong>，所带来的代价;&lt;/li>
&lt;li>&lt;strong>缩排&lt;/strong>函数
物化路径模型需&lt;strong>不断地处理字符串&lt;/strong>，在where子句中不断的执行字符串操作，处理速度比邻接模型更慢。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>表结构定义&lt;/strong> : model(&lt;strong>path&lt;/strong>,description,commander)&lt;/p>
&lt;p>&lt;strong>自顶向下查询&lt;/strong>:&lt;/p>
&lt;p>自定义函数&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">create&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">function&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">m_depth&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">varchar&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">returns&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">begin&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">length&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">length&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">replace&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="s1">&amp;#39;.&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="s1">&amp;#39;&amp;#39;&lt;/span>&lt;span class="p">))&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">end&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">select&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">lpad&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">description&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="k">length&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">description&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">mp_depth&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="p">))&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">description&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">commander&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">from&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">model&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">model&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">where&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">like&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">||&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;%&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">and&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">commander&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;Root Commander&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">order&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">by&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>自底向上查询&lt;/strong>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">select&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">lpad&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">description&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="k">length&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">description&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">mp_depth&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">mp_depth&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="p">))&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">description&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">commander&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">from&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">model&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">model&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">where&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">like&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">||&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;%&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">and&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">decription&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">like&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;%Highland%&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">order&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">by&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">desc&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>嵌套集合模型&lt;/p>
&lt;ul>
&lt;li>
&lt;p>每一个节点都有一个左编号(left_num)和右编号(right_num)，包含其所有的子节点的左右数字.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>确定这二个值的方法是对树进行一次深度优先遍历，在逐层深入的过程中依次递增地分配left_num的值，并在返回时依次递增地分配right_num的值&lt;/p>
&lt;/li>
&lt;li>
&lt;p>数据元素之间不再是点和线的关系，而是以&lt;strong>容纳和被容纳&lt;/strong>的方式&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>优点：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>易理解&lt;/strong>&lt;/li>
&lt;li>&lt;strong>查找某一个节点的子节点很容易&lt;/strong>，&lt;/li>
&lt;li>删除一个非叶子节点时，它的&lt;strong>后代会自动替代被删除的节点&lt;/strong>，成为其直接祖先节点的直接后代；&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>缺点：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>但是对&lt;strong>结果集排序不好操作&lt;/strong>，缩排无法处理&lt;/li>
&lt;li>数据&lt;strong>更新、插入、删除&lt;/strong>开销大&lt;/li>
&lt;li>&lt;strong>计算量大，对存储程序要求高&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>影响嵌套集合模型性能的因素&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>找后代方面胜于其他两个模型&lt;/strong>，但为&lt;strong>缩排付出更大代价&lt;/strong>&lt;/li>
&lt;li>&lt;strong>额外的连接&lt;/strong>，以及group by所做的&lt;strong>深度&lt;/strong>有关&lt;/li>
&lt;li>&lt;strong>改善嵌套集合模型性能代价巨大,但引入冗余&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>应用场景：&lt;/strong>&lt;/p>
&lt;p>如果&lt;strong>简单快速的查询是最重要的功能&lt;/strong>，那么可以使用嵌套集合。&lt;/p>
&lt;p>然而，在嵌套集中&lt;strong>插入和移动节点是复杂&lt;/strong>的，因为需要&lt;strong>重新分配左右值&lt;/strong>，因此嵌套集不适合需要频繁插入和删除节点的应用场景&lt;/p>
&lt;p>&lt;strong>表结构定义&lt;/strong>: model(&lt;u>left_num&lt;/u>,&lt;u>right_num&lt;/u>,commander,description)&lt;/p>
&lt;p>&lt;strong>自顶向下查询&lt;/strong>:&lt;/p>
&lt;p>找后代直接,找范围就可以. 排序不可以&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">select&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">from&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">model&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">model&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">where&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">commander&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;Root Commander&amp;#34;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">and&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">left_num&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">between&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">left_num&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">and&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">right_num&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>找level,需要再加一个 a b中间加一个c&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">select&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">lpad&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">description&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="k">length&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">description&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">depth&lt;/span>&lt;span class="p">))&lt;/span>&lt;span class="k">from&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">select&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">count&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">left_num&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">depth&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">description&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">commander&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">left_num&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">from&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">model&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">model&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">model&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">c&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">where&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">commander&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;Root Commander&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">and&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">c&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">left_num&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">between&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">left_num&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">and&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">right_num&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">and&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">left_num&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">between&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">c&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">left_num&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">and&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">c&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">right_num&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">group&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">by&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">description&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">commander&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">left_num&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">order&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">by&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">left_num&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>自底向上查询&lt;/strong>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="n">b是a的父亲&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="err">通过&lt;/span>&lt;span class="n">b找包括自己的所有父亲数量来定义深度&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">select&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">lpad&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">description&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">length&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">description&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">6&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">depth&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">commander&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">from&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">select&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">distinct&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">description&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">commander&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">left_num&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">select&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">count&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">c&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">left_num&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">from&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">model&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">c&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">where&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">left_num&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">between&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">c&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">left_num&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">and&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">c&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">right_num&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">depth&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">from&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">model&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">where&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">description&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">like&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;%Highland%&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">and&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">left_num&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">between&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">left_num&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">and&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">right_num&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">and&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">left_num&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">order&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">by&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">left_num&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">desc&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>动态计算深度依旧是个问题·&lt;/li>
&lt;li>不要显示人造根节点&lt;/li>
&lt;li>硬编码最大深度 (为了缩排显示)&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>嵌套间隔模型(nested interval)&lt;/strong>&lt;/p>
&lt;p>思想是以两个数字为特定节点的&lt;strong>路径编码&lt;/strong>，这两个数字被解释成有理数(就是分数)的&lt;strong>分子和分母&lt;/strong>。 太复杂了不讲.&lt;/p>
&lt;p>多父节点模型?&lt;/p>
&lt;p>**闭包表模型：**闭包表是一个简单、优雅模型，它记录了树中所有节点的关系，将树中任何具有祖先与后代关系的节点对，都存储在 TreePaths 中，同时我们也把指向节点自身的关系也存储在这张表；为了方便查询某个节点直接父节点或直接子节点，我们还增加一个 path_length 字段，自我引用的节点该值为 0，直接子节点为 1&lt;/p>
&lt;p>**优点：**它需要一张额外的表来存储关系，是一种典型的采用空间来换时间的方案，查询、插入、删除都比较简单&lt;/p>
&lt;p>&lt;strong>缺点&lt;/strong>：占用太多空间；&lt;/p>
&lt;p>&lt;strong>三种层次模型的查询效率比较&lt;/strong>&lt;/p>
&lt;p>自顶向下查询：Vandamme查询&lt;/p>
&lt;p>效率：邻接模型&amp;gt;物化模型&amp;gt;嵌套集合模型&lt;/p>
&lt;ul>
&lt;li>邻接模型
&lt;ul>
&lt;li>利用了&lt;strong>递归&lt;/strong>&lt;/li>
&lt;li>内部connect by是用&lt;strong>过程化方法&lt;/strong>实现的，&lt;strong>未利用关系模型实现&lt;/strong>。&lt;/li>
&lt;li>是进行&lt;strong>字符比较&lt;/strong>，并且置于内存中进行计算，比较快速;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>物化路径
&lt;ul>
&lt;li>利用&lt;strong>关系模型进行表联接&lt;/strong>，通过字符串前缀比较确定是否是父子关系。&lt;/li>
&lt;li>效率低下的主要原因是&lt;strong>字符串操作，比如字符串拆分&lt;/strong>（物化路径如果解决了用&lt;strong>字符型代替字符串型表示目录时，效率会大大提高&lt;/strong>）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>嵌套模型
&lt;ul>
&lt;li>&lt;strong>虽然找出子节点很容易&lt;/strong>，&lt;/li>
&lt;li>但确定子节点的&lt;strong>深度&lt;/strong>，对子节点&lt;strong>排序&lt;/strong>以及缩排比较&lt;strong>复杂&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>自底向上访问：Highland查询&lt;/p>
&lt;ul>
&lt;li>邻接表模型&lt;/li>
&lt;li>不管是自底向上的查询还是自顶向下查询，效率都是一样的。&lt;/li>
&lt;li>物化路径
&lt;ul>
&lt;li>因为&lt;strong>自底向上需要遍历很多节点&lt;/strong>，而&lt;strong>自顶向下只需要遍历一个节点&lt;/strong>，自底向上查询远远低于自定上下查询&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>嵌套集合模型
&lt;ul>
&lt;li>自顶向下查询与自底向上查询效率&lt;strong>差不多&lt;/strong>&lt;/li>
&lt;li>但多了排序过程，&lt;strong>排序比较耗时&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>效率：邻接模型&amp;gt;物化模型&amp;gt;嵌套集合模型&lt;/p>
&lt;p>&lt;strong>物化路径模型&lt;/strong>是&lt;strong>最通用的最均衡&lt;/strong>的树状结构设计方案&lt;/p>
&lt;p>&lt;strong>自底向上查询慢于自顶向下查询的原因&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>自顶向下查询只有一个起点;,&lt;strong>自底向上查询可能有多个出发点&lt;/strong>。
·多个记录都包含highland查询。&lt;/li>
&lt;li>&lt;strong>不能使用索引&lt;/strong>,导致完整地表扫描&lt;/li>
&lt;/ul>
&lt;h3 id="反范式与打破范式要考虑的因素">反范式与打破范式要考虑的因素&lt;/h3>
&lt;p>&lt;strong>反范式&lt;/strong>: 引入&lt;strong>受控的冗余&lt;/strong>，通过放松规范化规则来&lt;strong>提高系统的性能,降低数据模型的复杂度&lt;/strong>. 通常包括将多个表合并成一个表，增加冗余数据，以及创建复合索引等技术手段。&lt;/p>
&lt;p>&lt;strong>打破范式需要考虑的三因素&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>规范弱化使得&lt;strong>实现变得更加复杂&lt;/strong>，因为需要&lt;strong>手动保持数据的完整性&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>规范弱化会&lt;strong>降低灵活性&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>规范弱化会加快元组检索的速度，但却会&lt;strong>使更新速度变慢&lt;/strong>。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="判断是否应该使用逆范式的条件什么时候可以不遵守范式">&lt;strong>判断是否应该使用逆范式的条件/什么时候可以不遵守范式&lt;/strong>：&lt;/h3>
&lt;ul>
&lt;li>数据&lt;strong>表非常大&lt;/strong>或&lt;strong>查询非常频繁&lt;/strong>，导致查询性能严重下降；
&lt;ul>
&lt;li>大型电商网站, 订单读取非常频繁,把订单和订单详细信息合并提高效率&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>存在大量连接操作&lt;/strong>，导致查询复杂度极高；
&lt;ul>
&lt;li>社交媒体软件,用户的关系复杂. 经常需要使用用户的关系信息.把关系信息合并到用户信息中.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>需要&lt;strong>快速读取大量数据&lt;/strong>，而&lt;strong>不需要强制保证数据的实时性&lt;/strong>；&lt;/li>
&lt;li>&lt;strong>修改频率非常低&lt;/strong>，数据更新的代价相对较小。
&lt;ul>
&lt;li>博客网站,文章和评论都很多时,只需要最新的数据,且不容易修改.&lt;/li>
&lt;li>可以把新的播客信息和评论合并成一个表.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="打破范式的步骤">&lt;strong>打破范式的步骤&lt;/strong>:&lt;/h3>
&lt;ol>
&lt;li>画好ER模型&lt;/li>
&lt;li>分辨一对一、一对多和多对多关系&lt;/li>
&lt;li>构建三范式表结构设计。&lt;/li>
&lt;li>考虑打破范式&lt;/li>
&lt;/ol>
&lt;h3 id="七大反范式pattern">&lt;strong>七大反范式Pattern&lt;/strong>&lt;/h3>
&lt;p>&lt;strong>Pattern 1&lt;/strong> &lt;strong>合并一对一关系&lt;/strong>&lt;/p>
&lt;p>合并：基于全部参与的实体为主，引入部分参与的表。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>会产生大量空值&lt;/p>
&lt;/li>
&lt;li>
&lt;p>若两边都部分参与则不能合并&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>如，将“员工”和“员工地址”表合并为一个表，其中包含员工和他们的地址信息。&lt;/p>
&lt;p>&lt;strong>Pattern 2&lt;/strong> &lt;strong>一对N的关系复制非键值减少连接&lt;/strong>&lt;/p>
&lt;p>适用条件：两表连接时最主要的事务都与某非键值相关&lt;/p>
&lt;ul>
&lt;li>最需要关注更新，可能需要&lt;strong>使用触发器&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>如：查询学生信息以及学生所在学院&lt;/p>
&lt;p>例如，在“订单”和“订单行项目”表之间的一对多关系中，将订单头信息（如客户名称、订单日期等）复制到订单行项目表中。&lt;/p>
&lt;p>&lt;strong>Pattern 3&lt;/strong> &lt;strong>在一对N关系中复制外键来减少JOIN表数量&lt;/strong>&lt;/p>
&lt;p>为减少或删除常用或关键查询的连接，复制关系中一个或多个外键列来提高
查询的效率。&lt;/p>
&lt;p>例如，在“订单”和“订单行项目”表之间的一对多关系中，将订单表的外键（如客户id）复制到订单行项目表中。&lt;/p>
&lt;p>&lt;strong>Pattern 4&lt;/strong> &lt;strong>多对多关系中复制属性来减少JOIN表数量&lt;/strong>&lt;/p>
&lt;p>把两张表中经常需要的属性都拷贝到同一关系表中&lt;/p>
&lt;p>在“学生”和“课程”之间的多对多关系中，将学生和课程的属性（如姓名、课程名称等）复制到“选课”关联表中&lt;/p>
&lt;p>&lt;strong>Pattern 5&lt;/strong> &lt;strong>引入重复组&lt;/strong>&lt;/p>
&lt;p>通常对于一个多值属性，值不太多（小于等于10），且不会经常变，可以在表中见多个有关属性列&lt;/p>
&lt;p>如一个人有地址一、地址二、地址三&lt;/p>
&lt;p>将学生的多个地址存储在一个单一字段中，并将其标记为重复组。&lt;/p>
&lt;p>&lt;strong>Pattern 6&lt;/strong> &lt;strong>建立提取表&lt;/strong>&lt;/p>
&lt;p>将查询慢的表需要连接成大表并储存下来。&lt;/p>
&lt;p>查询可以访问派生数据并在同一组基表上执行多表联接。&lt;/p>
&lt;p>不能做实时计算，得到数据可能是&lt;strong>相对静态&lt;/strong>
的，也可能不一定是最新的。&lt;/p>
&lt;p>好处大，缺点非常大&lt;/p>
&lt;p>带来非常大的复杂性，导致数据库中存在各种同步的、异步的、有用的没用的提取表。
数据更新耗费后续人员极长时间.&lt;/p>
&lt;p>&lt;strong>Pattern 7&lt;/strong> &lt;strong>分区&lt;/strong>&lt;/p>
&lt;p>将大型表分割为更小的逻辑部分，以便更好地管理和查询数据。&lt;/p>
&lt;p>例如，将“销售记录”表分成按日期、地理区域或销售代表等逻辑分区。&lt;/p>
&lt;h3 id="范式的价值或者作用">&lt;strong>范式的价值或者作用&lt;/strong>&lt;/h3>
&lt;p>1NF 每个属性不可再分， 确保&lt;strong>原子性&lt;/strong>，具有原子性的价值&lt;/p>
&lt;p>2NF 主键可以唯一标识记录. 非主属性完全依赖候选键.检查对键的完全依赖，价值在于&lt;strong>控制数据冗余和查询性能&lt;/strong>&lt;/p>
&lt;p>3NF 消除对主属性的传递依赖,非主键属性之间不能相互依赖，检查&lt;strong>属性的独立性&lt;/strong>&lt;/p>
&lt;p>BCNF: 每一个函数依赖的决定因素都包含候选键&lt;/p>
&lt;p>四范式:消除多值依赖.&lt;/p>
&lt;p>所以范式的价值在于：&lt;/p>
&lt;ul>
&lt;li>降低&lt;strong>冗余&lt;/strong>&lt;/li>
&lt;li>消除&lt;strong>操作异常&lt;/strong>&lt;/li>
&lt;li>合理规范化的模式&lt;strong>可应对需求变更&lt;/strong>；&lt;/li>
&lt;/ul>
&lt;h3 id="为什么要加锁">&lt;strong>为什么要加锁&lt;/strong>&lt;/h3>
&lt;ul>
&lt;li>多个应用程序&lt;strong>同时对相同数据进行访问&lt;/strong>。&lt;/li>
&lt;li>&lt;strong>保证数据库的完整性和一致性&lt;/strong>，就必须要有一定的机制用于控制数据记录的读取、插入、删除和更新。&lt;/li>
&lt;li>通过对数据库对象加锁，我们可以&lt;strong>避免由于并发更改造成数据的丢失&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h3 id="加锁与提交">&lt;strong>加锁与提交&lt;/strong>&lt;/h3>
&lt;ul>
&lt;li>想要使加锁时间最短，必须&lt;strong>频繁的提交&lt;/strong>&lt;/li>
&lt;li>但如果每个逻辑单元完成后都提交&lt;strong>会增加大量开销&lt;/strong>&lt;/li>
&lt;li>对于批处理程序，并发控制不是问题，&lt;strong>避免频繁提交才是明智的做法&lt;/strong>。&lt;/li>
&lt;li>对于用户交互程序，则需要&lt;strong>高频提交，加快释放锁&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;h3 id="加锁与可伸缩性">&lt;strong>加锁与可伸缩性&lt;/strong>&lt;/h3>
&lt;ul>
&lt;li>与表级锁相比，行级锁能产生更佳的&lt;strong>吞吐量&lt;/strong>&lt;/li>
&lt;li>&lt;strong>行级锁大都性能曲线很快达到极限&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h3 id="加锁处理的原则">&lt;strong>加锁处理的原则&lt;/strong>&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>不要随便使用表级锁&lt;/strong>&lt;/li>
&lt;li>尽量&lt;strong>缩短加锁时间&lt;/strong>&lt;/li>
&lt;li>&lt;strong>索引也需要维护&lt;/strong>&lt;/li>
&lt;li>编程上的原则(语句性能高，未必程序性能高（下面有4点）)
&lt;ul>
&lt;li>避免SQL语句上的&lt;strong>循环处理&lt;/strong>&lt;/li>
&lt;li>减少程序和数据库之间的&lt;strong>交互次数&lt;/strong>&lt;/li>
&lt;li>充分利用DBMS提供的机制，使&lt;strong>跨机器交互的次数&lt;/strong>降至最少&lt;/li>
&lt;li>把所有&lt;strong>不重复不必要的SQL语句放在逻辑工作单元&lt;/strong>之外&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="锁的分类">锁的分类&lt;/h3>
&lt;p>悲观锁：&lt;/p>
&lt;ul>
&lt;li>指在读写数据时，认为&lt;strong>数据很可能会被其他并发操作所修改&lt;/strong>.
&lt;ul>
&lt;li>因此在**进行操作之前，先加锁，**确保数据不会被其他操作修改。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>悲观锁适用于并发写操作多，&lt;strong>读操作少&lt;/strong>的场景
&lt;ul>
&lt;li>例如&lt;strong>银行转账等涉及到账户余额变动&lt;/strong>的场景。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>悲观锁的缺点是在&lt;strong>并发量高时，会导致大量的阻塞和等待&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>乐观锁：&lt;/p>
&lt;ul>
&lt;li>指在读写数据时，认为&lt;strong>数据不会被其他并发操作所修改.&lt;/strong>
&lt;ul>
&lt;li>因此在进行操作之前，不加锁，但在&lt;strong>提交数据时，检查数据是否被其他操作所修改，如果没有修改，则提交成功，否则返回错误信息&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>乐观锁适用于并发读操作多，&lt;strong>写操作少&lt;/strong>的场景.
&lt;ul>
&lt;li>例如商品库存等只需要查询不需要修改的场景。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>乐观锁的优点是可以&lt;strong>大大降低阻塞和等待&lt;/strong>，但是需要在提交数据时进行额外的校验，&lt;strong>增加了程序开发和维护的难度&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>共享锁（Shared Lock）：&lt;/p>
&lt;ul>
&lt;li>共享锁适用于多个事务&lt;strong>只读同一份数据&lt;/strong>的场景。&lt;/li>
&lt;li>适用于读多写少的场景，例如在线图书馆、新闻网站等需要大量读取数据的应用，可以使用共享锁来&lt;strong>提高并发读取的能力，避免写操作的阻塞&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>排他锁（Exclusive Lock）：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>只允许一个事务进行写操作&lt;/strong>，其他事务&lt;strong>不能进行读写操作&lt;/strong>。&lt;/li>
&lt;li>适用于写多读少的场景，&lt;/li>
&lt;li>例如银行转账、在线购物等需要对数据进行修改的应用，可以使用排他锁来保证操作的原子性，&lt;strong>避免读写冲突和数据不一致性&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>行级锁（Row Lock）：&lt;/p>
&lt;ul>
&lt;li>针对数据表中的某一行数据进行加锁，&lt;strong>只有在访问该行数据时才会加锁&lt;/strong>，这样可以&lt;strong>提高并发性能&lt;/strong>。&lt;/li>
&lt;li>例如社交网络、在线游戏等需要&lt;strong>频繁更新数据,高并发&lt;/strong>的应用，可以使用行级锁来控制并发更新，提高系统的并发能力和性能。&lt;/li>
&lt;/ul>
&lt;p>间隙锁（Gap Lock）：&lt;/p>
&lt;ul>
&lt;li>针对数据表中&lt;strong>不存在的数据进行加锁&lt;/strong>，可以防止其他事务在这个间隙中插入数据。&lt;/li>
&lt;li>适用于对数据表中不存在的数据进行加锁的场景，例如对于需要&lt;strong>进行范围查询或者范围删除的应用&lt;/strong>，可以使用间隙锁来避免其他事务在查询或删除操作中插入数据，保证数据的一致性和正确性。(避免幻读)&lt;/li>
&lt;/ul>
&lt;p>意向锁（Intention Lock）：&lt;/p>
&lt;ul>
&lt;li>在加行级锁和表级锁&lt;strong>之前，先进行意向锁的判断&lt;/strong>，以&lt;strong>提高加锁效率&lt;/strong>。&lt;/li>
&lt;li>例如在多个事务同时请求对同一数据行进行更新时，可以使用意向锁来提前判断需要加的锁类型，&lt;strong>避免不必要的锁竞争和死锁问题&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;h3 id="必须由程序员利用程序语言控制并发更新的情况">&lt;strong>必须由程序员利用程序语言控制并发更新的情况:&lt;/strong>&lt;/h3>
&lt;ul>
&lt;li>业务规则&lt;strong>复杂的更新&lt;/strong>：如果更新操作需要依赖多个表或者多个条件，并且需要保证操作的原子性，就需要使用事务来控制并发更新。&lt;/li>
&lt;li>&lt;strong>分布式系统中的数据更新&lt;/strong>：在分布式系统中，不同节点之间可能会同时更新同一份数据，如果不加控制，就会导致数据的不一致性。因此，在分布式系统中，需要使用分布式锁来控制并发更新。&lt;/li>
&lt;li>&lt;strong>批量数据更新&lt;/strong>：如果需要批量更新数据，而且更新的数据量很大，可能会导致数据库锁表或者死锁等问题。因此，需要&lt;strong>将批量更新操作分批进行&lt;/strong>，或者&lt;strong>使用分布式锁&lt;/strong>来控制并发更新。&lt;/li>
&lt;li>&lt;strong>大量并发更新&lt;/strong>：如果并发更新的请求数量非常大，可能会导致数据库性能下降或者崩溃。因此，&lt;strong>需要使用连接池、缓存等技术来优化数据库性能，或者使用分布式锁来分散并发更新的压力。&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h3 id="资源竞争解决方案有哪些">&lt;strong>资源竞争解决方案有哪些&lt;/strong>&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>DBA解决方案：针对事务空间、可用列表&lt;/p>
&lt;ul>
&lt;li>增加分配给储物条目的空间缓解冲突&lt;/li>
&lt;li>让&lt;strong>insert分配到不同的物理块&lt;/strong>.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>架构解决方案：分区、逆序索引、索引组织表&lt;/p>
&lt;/li>
&lt;li>
&lt;p>开发解决方案：&lt;/p>
&lt;ul>
&lt;li>调节&lt;strong>并发数&lt;/strong>
&lt;ul>
&lt;li>限制session个数为最高性能的session个数，使周转更快&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>不使用系统产生值&lt;/strong>
&lt;ul>
&lt;li>连续值只在范围查询中使用，在连续值本身毫无现实意义的情况下，范围查询的场景也不多见;&lt;/li>
&lt;li>可以只使用随机数来做主键，遇到随机数碰撞，就再生成一个随机数.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>总结：&lt;strong>与加锁不同，数据库竞争是可以改善的&lt;/strong>。架构师、开发者和DBA都可以从各自的角度改善竞争&lt;/p>
&lt;h3 id="并发操作主要解决哪三个问题">&lt;strong>并发操作主要解决哪三个问题&lt;/strong>&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>丢失修改&lt;/strong>：T1和T2读入同一数据并修改，T2提交的结果破坏了T1的提交，导致T1修改被丢失&lt;/li>
&lt;li>&lt;strong>读脏数据&lt;/strong>：T1修改某一数据并将其写回磁盘，T2读取同一数据后，T1由于某种原因被撤销，数据也做了恢复，此时T2读的数据和数据库里的数据不一致，T2读到脏数据，即不正确数据&lt;/li>
&lt;li>&lt;strong>不可重复读&lt;/strong>：T1读数据后，T2对其修改，T1无法再现前一次读取结果&lt;/li>
&lt;/ul>
&lt;h3 id="事务的隔离级别">事务的隔离级别&lt;/h3>
&lt;p>未提交读（Read Uncommitted）：事务可以读取未提交的数据，也称作脏读（Dirty Read）。一般很少使用。&lt;/p>
&lt;p>提交读（Read Committed）：是大都是 DBMS （如：Oracle, SQLServer）默认事务隔离。执行两次同意的查询却有不同的结果，也叫不可重复读。&lt;/p>
&lt;p>可重复读（Repeable Read）：是 MySQL 默认事务隔离级别。能确保同一事务多次读取同一数据的结果是一致的。可以解决脏读的问题，但理论上无法解决幻读（Phantom Read）的问题。&lt;/p>
&lt;p>可串行化（Serializable）：是最高的隔离级别。强制事务串行执行，会在读取的每一行数据上加锁，这样虽然能避免幻读的问题，但也可能导致大量的超时和锁争用的问题。很少会应用到这种级别，只有在非常需要确保数据的一致性且可以接受没有并发的应用场景下才会考虑。&lt;/p>
&lt;p>MySql实现的哪种隔离级别&lt;/p>
&lt;p>可重复读&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/sql%E5%AE%9E%E4%BE%8B%E8%A7%A3%E6%9E%90%E4%B8%8E%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/sql%E5%AE%9E%E4%BE%8B%E8%A7%A3%E6%9E%90%E4%B8%8E%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F/</guid><description>&lt;p>示例表：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230309100013301.png" alt="image-20230309100013301" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h2 id="1sql实例处理字符串">1.SQL实例处理：字符串&lt;/h2>
&lt;p>SQL不专门用于处理复杂的字符串，但内置了很多有用的字符串。&lt;/p>
&lt;h3 id="11遍历字符串">1.1遍历字符串&lt;/h3>
&lt;p>SQL没有Loop功能, 需要使用数据透视表&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227163824652.png" alt="image-20230227163824652" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>循环的次数是字符串的长度, 用where来终止.&lt;/p>
&lt;h3 id="12嵌入引号">1.2嵌入引号&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227163859353.png" alt="image-20230227163859353" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="13统计字符出现的次数">1.3统计字符出现的次数&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227163927154.png" alt="image-20230227163927154" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>sql server 是用len&lt;/p>
&lt;h3 id="14删除不想要的字符">1.4删除不想要的字符&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227164016283.png" alt="image-20230227164016283" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>替换多个字符时可以使用: &lt;strong>translate&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227164049652.png" alt="image-20230227164049652" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>先全部一致替换为a,再把a给删除.&lt;/p>
&lt;p>但mysql中没有translate.&lt;/p>
&lt;p>阿里的OceanBase同时支持replace和translate&lt;/p>
&lt;h3 id="15判断是否只含有字母和数字">1.5判断是否只含有字母和数字&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227164123913.png" alt="image-20230227164123913" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>Mysql可以直接使用正则表达式. [] 内表示范围 ^ 表示否定&lt;/p>
&lt;p>OceanBase 的0 1相反&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230309101159648.png" alt="image-20230309101159648" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>思考题&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227164306073.png" alt="image-20230227164306073" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>​&lt;/p>
&lt;h2 id="2sql实例解析-数值处理">2.SQL实例解析 数值处理&lt;/h2>
&lt;p>虽然SQL不容易处理，但硬要在SQL中完成比如字符串，比如日期，比如今天的数值计算。&lt;/p>
&lt;p>数值处理在数据库完成，可以减少数据库和服务器的交互。&lt;/p>
&lt;p>能在数据库中，写个&lt;strong>完整功能的SQL&lt;/strong>，让查询优化器统一优化，一般来说对整个系统的吞吐量会有非常大的提升.&lt;/p>
&lt;h3 id="21计算平均值">2.1计算平均值&lt;/h3>
&lt;p>空值默认是忽略&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227164534143.png" alt="image-20230227164534143" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>coalesce 空值设置为0&lt;/strong>&lt;/p>
&lt;p>当使用聚合函数时通常要考虑空值的处理.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227164603887.png" alt="image-20230227164603887" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>不能把group by 子句中没有的列放到select语句中.&lt;/p>
&lt;h3 id="22查找最大值和最小值">2.2查找最大值和最小值&lt;/h3>
&lt;p>空值没有影响.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227164620369.png" alt="image-20230227164620369" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="23求和">2.3求和&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227164639158.png" alt="image-20230227164639158" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="24计算行数">2.4计算行数&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227164719491.png" alt="image-20230227164719491" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>count(*)计算了空值.&lt;/strong>&lt;/p>
&lt;p>&lt;strong>针对某一列时会跳过空值&lt;/strong>&lt;/p>
&lt;h3 id="25累计求和-running-total">2.5累计求和 Running Total&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227164847493.png" alt="image-20230227164847493" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>Sum( ) over ()&lt;/p>
&lt;p>over 中的 order by 需要具有唯一性.&lt;/p>
&lt;p>否则, WARD 会和 MARTIN一样是5350&lt;/p>
&lt;p>即建立&lt;strong>唯一的排他序列得到正确的累加值&lt;/strong>.&lt;/p>
&lt;p>在以前的mysql不支持窗口函数,所以要使用标量子查询.&lt;/p>
&lt;h3 id="26计算众数">2.6计算众数&lt;/h3>
&lt;p>oracle 使用 max + keep&lt;/p>
&lt;p>如果max相同,则按照keep中的排序规则保留其最大的.&lt;/p>
&lt;p>keep从右向左执行, 先对每一个cnt降序排序,然后执行rank函数,保留rank1的值.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227164934043.png" alt="image-20230227164934043" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>mysql只能用通用做法.group by + having&lt;/p>
&lt;p>思考题:&lt;/p>
&lt;p>累计乘法和累计减法&lt;/p>
&lt;h2 id="3sql实例分析-日期处理">3.SQL实例分析 日期处理&lt;/h2>
&lt;h3 id="31日期加减法">3.1日期加减法&lt;/h3>
&lt;p>Oracle中，对天数来说，对天数来说可以直接加减，如果要加减若干月或者年，需要用一个函数，add months.&lt;/p>
&lt;p>MySQL日期加减法类似，使用&lt;strong>INTERVAL关键字&lt;/strong>指定要加上或者减去时间
的单位，不必使用单引号。
第二种方法: 使用date add函数，一样的作用。&lt;/p>
&lt;p>OceanBase的add和mysql一模一样&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230309103225068.png" alt="image-20230309103225068" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="32计算两个日期之间的天数">3.2计算两个日期之间的天数&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227165217187.png" alt="image-20230227165217187" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>mysql 和 OceanBase datediff(较晚的日期,较早的日期)&lt;/p>
&lt;p>sql server 是datediff(较早的,较晚的)&lt;/p>
&lt;h3 id="33两个日期的工作日天数">3.3两个日期的工作日天数&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227165324649.png" alt="image-20230227165324649" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>这样统计天数就变成了计算行数的问题.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230309103757837.png" alt="image-20230309103757837" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>1.计算出开始日期和结束日期之间相隔多少天。 x视图&lt;/p>
&lt;p>2.排除掉周末，统计有多少个工作日，计算满足条件的记录。&lt;/p>
&lt;p>Oracle 和 mysql的差异是函数使用的不同.&lt;/p>
&lt;h3 id="34判断闰年">3.4判断闰年&lt;/h3>
&lt;p>判断闰年的最简单方式&lt;/p>
&lt;p>检查2月份最后一天，如
果是29号，就是闰年;如
果是28号，就不是闰年;
如果既不是28号，也不是
29号，程序写错。&lt;/p>
&lt;p>orcale 有trunc函数找到&lt;strong>当前年份的第一天&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230309104059402.png" alt="image-20230309104059402" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>先算出当前日期是当前年份的第几天, 找到当前年的第一天.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227165617940.png" alt="image-20230227165617940" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="35识别重叠的日期区间">3.5识别重叠的日期区间&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227165658575.png" alt="image-20230227165658575" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>自连接方法, 复制出另一份表,然后找到重叠的项目&lt;/p>
&lt;p>窗口比自联结快,但需要限定项目的个数.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227165731407.png" alt="image-20230227165731407" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>思考题: 当前月份的第一个和最后一个星期一&lt;/p>
&lt;h2 id="4常见的sql连接模式">4.常见的SQL连接模式&lt;/h2>
&lt;p>查询有时候并不只需要等值连接.&lt;/p>
&lt;p>4.1叠加行集(Union &amp;amp;Union all)&lt;/p>
&lt;p>4.2查找只存在于一张表的数据 (差)&lt;/p>
&lt;p>4.3从一个表检索另一个不相关的行(外连接&lt;/p>
&lt;p>4.4从多个表中返回缺失值 (全外连接)&lt;/p>
&lt;p>4.5连接与聚合函数的使用&lt;/p>
&lt;h3 id="41叠加行集union--union-all">4.1叠加行集(Union &amp;amp; Union all)&lt;/h3>
&lt;p>使用连接的情况，就是想返回保存至多个表中的数据
理论上需要将一个结果集叠加到另一个之上，甚至这些表&lt;strong>可以没有相同的键&lt;/strong>，有一个前提条件是，它们&lt;strong>列的数据类型必须相同&lt;/strong>。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227165935617.png" alt="image-20230227165935617" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>Union all是将多个表中的行并入结果集. 列的数目和类型必须匹配,名字可以不一样. Union all 会包括重复项, union会去除重复项.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227170009502.png" alt="image-20230227170009502" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>union的问题 : &lt;strong>有排序操作&lt;/strong>以删除重复项,慎用.&lt;/p>
&lt;p>排序是非关系操作,大数据量的排序对性能是一个灾难.&lt;/p>
&lt;h3 id="42查找只存在于一张表的数据差">4.2查找只存在于一张表的数据(差)&lt;/h3>
&lt;p>使用差函数, 但不同数据库的差函数关键字不一样.&lt;/p>
&lt;p>minus限制条件, 列必须相同个数和数据类型,且不返回重复值. 空值不问产生任何问题.&lt;/p>
&lt;p>except 对结果进行去重.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227170147073.png" alt="image-20230227170147073" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>使用not in时用空值的问题,一遍要加上exists 或 not exists&lt;/p>
&lt;h3 id="43从一个表检索另一个不相关的行外连接">4.3从一个表检索另一个不相关的行(外连接)&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227170229988.png" alt="image-20230227170229988" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>outer可写可不写&lt;/p>
&lt;h3 id="44从多个表中返回每个表的缺失值全外连接">4.4从多个表中返回每个表的缺失值(全外连接)&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227170250386.png" alt="image-20230227170250386" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="45连接与聚合函数的使用">4.5连接与聚合函数的使用&lt;/h3>
&lt;p>确保表之间的连接查询不会干扰到聚合操作.&lt;/p>
&lt;p>左边是员工奖金表,&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227170339432.png" alt="image-20230227170339432" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>奖金总额正确,但工资总额是错的.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230309105955183.png" alt="image-20230309105955183" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>是因为连接查询导致某行的工资出现两次.&lt;/p>
&lt;p>解决方法, 使用distinct.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227170437389.png" alt="image-20230227170437389" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>如果表中, 部门编号为10的人只有部分人有奖金.此时计算总额会少算.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227170454013.png" alt="image-20230227170454013" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>提示: 需要选择连接方式.用&lt;strong>外连接把员工全包括&lt;/strong>.&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/sql%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/sql%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/</guid><description>&lt;p>4.1关系代数&lt;/p>
&lt;p>4.2查询优化器&lt;/p>
&lt;p>4.3使用SQL需要考虑的因素&lt;/p>
&lt;p>4.4查询的过滤条件&lt;/p>
&lt;p>4.5高效过滤条件举例&lt;/p>
&lt;p>4.6 SQL优化的其它问题-where子的比较运算符&lt;/p>
&lt;p>4.7 SQL优化的其它问题-SQL连接&lt;/p>
&lt;h2 id="1关系代数">1.关系代数&lt;/h2>
&lt;p>代数的作用： 表达式的等价代换&lt;/p>
&lt;p>2、3、4 这些数字对应的就是 关系(表)&lt;/p>
&lt;p>+-x/这些运算符对应的就是 关系操作&lt;/p>
&lt;p>SQL语句的本质是关系表达式&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309153407418.png" alt="image-20230309153407418" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>查询优化器 的作用 ： 就是在数据库中间进行关系表达式等价变化后找到最优路径&lt;/p>
&lt;p>关系代数是&lt;strong>以数学为基础&lt;/strong>的，是一个科学
在写代码时，像一个工匠。
关系数据库不一样，写的SQL只是向数据库提出取什么样数据的要求，具体怎么找到最快速的执行方式，是数据库的查询优化器的事情。&lt;/p>
&lt;p>关系数据库还有一个科学的地方，它&lt;strong>存在简单模式，实现冗余最小的设计&lt;/strong>。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>没有简单通用的规则，实现数据库冗余最小。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>windows的资源管理器的目录结构、XML这种树形结构，这种文件组织方式是最习惯但不科学的&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>no sql 是 not only sql&lt;/p>
&lt;h2 id="2查询优化器">2.查询优化器&lt;/h2>
&lt;p>&lt;strong>sql 关系理论 查询优化器的关系&lt;/strong>：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309153946870.png" alt="image-20230309153946870" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>关系理论适用于理论意义上无限大的集合。&lt;/p>
&lt;p>在不同大小的数据集在不同物理环境中间，如何实现更有效率地读取，&lt;strong>将无限收缩到有限的环境中&lt;/strong>，这就是查询优化器干的事情。&lt;/p>
&lt;p>优化器借助关系理论提供的&lt;strong>语义无误的原始查询进行有效的等价变换&lt;/strong>。&lt;/p>
&lt;p>优化器的工作：&lt;/p>
&lt;ul>
&lt;li>优化是在数据真正要被执行的时候才发生的;&lt;/li>
&lt;li>有相同结果，但写法不同的关系表达式在实际环境下执行的效率相差很大:&lt;/li>
&lt;li>OceanBase的查询优化则是一个&lt;strong>规则优化和代价优化相结合&lt;/strong>的过程，其主体是基于成本进行查询优化，并在查询优化过程中通过规则进行启发和剪枝。
&lt;ul>
&lt;li>以前更多是基于规则的优化器 RBO, 现在大多数用的是基于成本的优化器 CBO&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>sql的执行顺序&lt;/strong>&lt;/p>
&lt;p>&lt;strong>解析是SQL优化是最消耗资源的过程.&lt;/strong>&lt;/p>
&lt;p>从解析中选择执行计划&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309155255554.png" alt="image-20230309155255554" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;ul>
&lt;li>你的&lt;strong>SQL仍然是它优化的起点&lt;/strong>，是它选择优化路径的提示，不同的SQL写法，会对查询优化器最终选择的路径产生影响。&lt;/li>
&lt;li>查询优化器不知道一些&lt;strong>影响实际执行效率的重要的信息&lt;/strong>，而这只有写SOL的程序员知道。&lt;/li>
&lt;/ul>
&lt;h3 id="21查看查询优化器的执行计划">2.1查看查询优化器的执行计划&lt;/h3>
&lt;p>&lt;strong>Oracle的执行计划&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309155531599.png" alt="image-20230309155531599" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>在使用explain plan for语句时，跟在后面的SQL并不真正执行，执行计划表中的数据和操作都是预估的，&lt;/p>
&lt;p>好处是，方便快捷，不影响数据库数据.&lt;/p>
&lt;p>缺点是，没有输出相关统计信息。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309155611613.png" alt="image-20230309155611613" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>MySql的执行计划&lt;/strong>:&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309155731369.png" alt="image-20230309155731369" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>第七列key:实际使用的索引;&lt;/p>
&lt;p>第十列rows:估算的找到所需数据需读取的行数:&lt;/p>
&lt;p>第十一列filtered:返回结果的行数占读取行数的百分比，值越大越好:&lt;/p>
&lt;p>&lt;strong>OceanBase的执行计划&lt;/strong>:&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309155810560.png" alt="image-20230309155810560" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="22查询优化器的有效范围">2.2查询优化器的有效范围&lt;/h3>
&lt;ol>
&lt;li>&lt;strong>1优化器需要借助数据库中找到的信息&lt;/strong>。&lt;/li>
&lt;/ol>
&lt;p>一是&lt;strong>普通统计数据&lt;/strong>，二是数据定义中重要的&lt;strong>声明信息&lt;/strong>&lt;/p>
&lt;p>尽量要把数据约束的语义信息在&lt;strong>数据库的声明中体现&lt;/strong>，这样优化器就可以利用数据取值范围这样的语义信息来做优化决策.&lt;/p>
&lt;ol start="2">
&lt;li>
&lt;p>只有能够进行数学意义上的&lt;strong>等价变换&lt;/strong>，优化效果才最佳。&lt;/p>
&lt;p>对于查询中的非关系部分优化器可借助的理论基础不多，优化结果和原始语句写法所指定的方式相差无几&lt;/p>
&lt;/li>
&lt;li>
&lt;p>一个独立执行的查询，优化效果可能很好，但把它嵌入一个更为复杂的查询内部，可能优化的效果就变差了&lt;/p>
&lt;p>优化器需要考虑&lt;strong>整体响应时间&lt;/strong>&lt;/p>
&lt;p>&lt;strong>预计需要查询越久的,查询优化器会花更多的时间去找优化路径.&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>优化器改善的是&lt;strong>独立查询&lt;/strong>&lt;/p>
&lt;p>优化器无法使独立的查询联系在一起进行统一优化，所以，如果通过过程化的编程提取了数据，再将数据传递到后续查询中，优化器是没有办法进行统一优化的&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="3使用sql需要考虑的因素">3.使用SQL需要考虑的因素&lt;/h2>
&lt;p>需要考虑的五大要素:&lt;/p>
&lt;ul>
&lt;li>获得结果集所需访问的数据量&lt;/li>
&lt;li>定义结果集所需的查询条件&lt;/li>
&lt;li>结果集的大小获得&lt;/li>
&lt;li>结果集所涉及的表的数量&lt;/li>
&lt;li>同时修改这些数据用户的多少&lt;/li>
&lt;/ul>
&lt;h3 id="31数据总量">3.1数据总量&lt;/h3>
&lt;p>SQL考虑&lt;strong>最重要因素:必须访问的数据总量&lt;/strong>&lt;/p>
&lt;p>没有&lt;strong>确定目标数据容量&lt;/strong>之前，很难断定查询执行的效率,这是后续所有工作的基础.&lt;/p>
&lt;h3 id="32定义结果集的查询条件">3.2定义结果集的查询条件&lt;/h3>
&lt;p>一个或几个数据表，经过Join操作，再通过查询条件的选择，会产生一个SQL查询的结果集，完成我们的查询。&lt;/p>
&lt;p>&lt;strong>从数据表到 结果集 发生的变化就是 查询条件&lt;/strong>&lt;/p>
&lt;p>查询条件是SQL优化的关键因素，也是写SQL的重要部分&lt;/p>
&lt;p>过滤条件的效率有高有低，受到其它因素的影响很大&lt;/p>
&lt;p>如果一个查询条件能剔除掉更多的数据，也就是满足这个查询条件的记录数很少，我们就称之为&lt;strong>高效的过滤条件&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>寻找高效的过滤条件是程序员写SQL需要重点考虑的问题&lt;/strong>&lt;/p>
&lt;h3 id="33结果集的大小">3.3结果集的大小&lt;/h3>
&lt;p>查询所返回的数据量，重要而被忽略&lt;/p>
&lt;p>取决于表的大小和&lt;strong>过滤条件的细节&lt;/strong>&lt;/p>
&lt;p>例外是 若干个&lt;strong>独立使用效率不高的条件结合起来效率非常高&lt;/strong>, 如双学位&lt;/p>
&lt;p>从技术角度来看，查询结果集的&lt;strong>大小并不重要&lt;/strong>，&lt;strong>重要的是用户的感觉&lt;/strong>&lt;/p>
&lt;p>熟练的开发者应该努力使&lt;strong>响应时间与返回的记录数成正比&lt;/strong>.&lt;/p>
&lt;h3 id="34表的数量">3.4表的数量&lt;/h3>
&lt;p>from中间连接表的数量对性能有很大影响,尽管现在的DBMS都可以高效地连接多个表.&lt;/p>
&lt;p>表的 join连接&lt;/p>
&lt;ul>
&lt;li>(太)多表连接该质疑设计的正确性了&lt;/li>
&lt;li>对于&lt;strong>优化器&lt;/strong>，随着表数量的增加，复杂度将呈指数增长&lt;/li>
&lt;li>编写 (太)多表的复杂查询时，&lt;strong>多种方式连接的选择失误的几率很高&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>在一个查询中间, 避免连接太多的表&lt;/p>
&lt;h3 id="35并发用户数">3.5并发用户数&lt;/h3>
&lt;p>设计sql时,随时&lt;strong>要关注并发性&lt;/strong>, 并发量大会导致原先并发量小时效率高的设计变得极低.&lt;/p>
&lt;ul>
&lt;li>数据块访问争用(block-accesscontention)&lt;/li>
&lt;li>阻塞(locking)&lt;/li>
&lt;li>闩定(latching)&lt;/li>
&lt;li>保证读取一致性(read consistency)&lt;/li>
&lt;/ul>
&lt;p>警惕多米诺骨牌一样的现象, 如内存不够用导致硬盘资源争夺, 进而导致其他cpu负载过重.&lt;/p>
&lt;p>也会有反例:&lt;/p>
&lt;p>DBA增加物理I/0操作，反而会使任务执行效率更高，因为某些计算密集型操作的并发执行程度很高，一个进程刚刚因等待I/O操作而阻塞，它释放出来的CPU就被另一个进程占用了，这样CPU的资源反而被充分利用了。&lt;/p>
&lt;p>必须要&lt;strong>考虑整体吞吐量,而不是个人响应时间&lt;/strong>.&lt;/p>
&lt;h2 id="4查询的过滤条件">4.查询的过滤条件&lt;/h2>
&lt;h3 id="41过滤条件的分类">4.1过滤条件的分类&lt;/h3>
&lt;p>如何限定结果集是最为关键的因素.&lt;/p>
&lt;p>过滤条件主要是指Where子句中的各种各样的条件 也包括having&lt;/p>
&lt;p>有些过滤条件直接作用于select运算符. 如某字段是否满足条件.&lt;/p>
&lt;p>还有其他用于连接表的. 可以分成如下两种:&lt;/p>
&lt;ul>
&lt;li>Join过滤条件&lt;/li>
&lt;li>Select过滤条件&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309162132327.png" alt="image-20230309162132327" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>不一定哪个效率快, 运行效率和优化器有关系，不同的写法首先是影响了优化器&lt;strong>进行路径选择的起始点&lt;/strong>.&lt;/p>
&lt;p>在没有效率问题的情况下，SQL的写法无关紧要，但是在&lt;strong>有效率问题的情况下，SQL的写法就会导致效率有很大差别。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>其他类型的条件&lt;/strong>:&lt;/p>
&lt;p>检查另一个表内是否存在特定数据的条件&lt;/p>
&lt;p>sql语法上类似,但语义上完全不同.&lt;/p>
&lt;h3 id="42过滤条件的含义">4.2过滤条件的含义&lt;/h3>
&lt;p>过滤条件的计算顺序有时候会影响效率.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309162532396.png" alt="image-20230309162532396" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>此时计算顺序无关紧要,但再加入一个条件:&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309162644909.png" alt="image-20230309162644909" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>在有些数据库中，试图把非数字字符串转化为整数的时候，会造成运行错误的问题.&lt;/p>
&lt;p>一般来说，数据库有一个基本的原则，就是对于where子句的条件如果优化器在优化的过程中没有什么理由和原因的话，一般是&lt;strong>按照顺序执行的&lt;/strong>&lt;/p>
&lt;p>&lt;strong>mysql是从左到右, Oracle 是从右到左.&lt;/strong>&lt;/p>
&lt;p>where&lt;strong>的顺序是很重要的&lt;/strong>&lt;/p>
&lt;h3 id="43基本原则">4.3基本原则&lt;/h3>
&lt;p>好的过滤条件要先做&lt;/p>
&lt;p>能过滤掉更多数据的条件也就是满足这个条件的记录越少，这个条件越好&lt;/p>
&lt;p>因为中间结果集的大小会不一样, 会影响性能.&lt;/p>
&lt;p>在复杂的高并发大数据量的系统中，一个查询的执行计划往往要做很多步骤，&lt;strong>中间结果集的大小&lt;/strong>，会从整体上影响整个系统的吞吐量中间结果集过大，会对缓存、硬盘、CPU都造成压力。&lt;/p>
&lt;p>更重要的是，哪个过滤条件好，哪个过滤条件坏，查询优化器不一定知道，这是只有知道业务需求的程序员才知道的事情。&lt;/p>
&lt;p>写SQL前要对过滤条件排序，去寻找高效的过滤条件&lt;/p>
&lt;p>真正高效的过滤条件是查询的主要驱动力，低效条件只是为了业务要求的正确性对高效的过滤条件起到辅助筛选的作用。&lt;/p>
&lt;p>定义高效过滤条件的准则:是否能够尽快减少必须处理的数据总量&lt;/p>
&lt;p>思考题:你能列举出哪些where字句中用于过滤的关键字呢?&lt;/p>
&lt;h2 id="5高效过滤条件的举例">5.高效过滤条件的举例&lt;/h2>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309163212559.png" alt="image-20230309163212559" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309163223970.png" alt="image-20230309163223970" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>和join on指定的条件相关,也和过滤条件的顺序相关.&lt;/p>
&lt;p>古老的方式:&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309163403832.png" alt="image-20230309163403832" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>没有适用于所有情况的解决方案.&lt;/p>
&lt;p>但上面的用了distinct,会把同名的人给合并.&lt;/p>
&lt;p>避免在最高层distinct应该是一条基本规则; 因为即便遗漏了连接的条件,仍然会正常允许.&lt;/p>
&lt;p>现实中,应该返回具有唯一性的客户ID和客户名，以保证得到BMW买家的完整清单&lt;/p>
&lt;p>&lt;strong>摆脱distinct的方法&lt;/strong>&lt;/p>
&lt;p>&lt;strong>关联子查询&lt;/strong>:&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309163645545.png" alt="image-20230309163645545" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>缺点, 子查询执行很多次. 取决于 第一个过滤条件的好坏.&lt;/p>
&lt;p>&lt;strong>非关联子查询&lt;/strong>:&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309163825049.png" alt="image-20230309163825049" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>找到分辨率最强的条件&lt;/p>
&lt;ul>
&lt;li>解决方案不止一种，查询和数据隐含的假设密切相关&lt;/li>
&lt;li>预先考虑优化器的工作，以确定它能找到所需要的数据&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309163932229.png" alt="image-20230309163932229" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h2 id="6sql优化的其他问题">6.SQL优化的其他问题&lt;/h2>
&lt;h3 id="61sql的连接问题">6.1SQL的连接问题&lt;/h3>
&lt;p>第一个问题是&lt;strong>滥用子查询&lt;/strong>,&lt;/p>
&lt;p>子查询有两个好处:&lt;/p>
&lt;ul>
&lt;li>分辨过滤条件的好坏&lt;/li>
&lt;li>避免顶层的distinct&lt;/li>
&lt;/ul>
&lt;p>但如果没有以上两个好处,不如把选择权交给查询优化器.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309164152188.png" alt="image-20230309164152188" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>但还有一种情况,&lt;strong>杜绝使用子查询&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309164315664.png" alt="image-20230309164315664" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>以上方法性能很差.,因为是要选择没有分配的.&lt;/p>
&lt;p>应该用out join&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309164344992.png" alt="image-20230309164344992" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="把聚合子查询转化为join或内嵌视图">把聚合子查询转化为JOIN或内嵌视图&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309164543277.png" alt="image-20230309164543277" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309164638238.png" alt="image-20230309164638238" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>上面orderstatus被访问了多次&lt;/p>
&lt;p>可以做成非关联嵌套子查询&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309164738725.png" alt="image-20230309164738725" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>但性能还有问题.&lt;/p>
&lt;p>要告诉优化器,先获得子查询的结果集再连接这个表.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309164849679.png" alt="image-20230309164849679" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>最好是使用内嵌的视图.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309164936407.png" alt="image-20230309164936407" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>虽然做了一次大表遍历,但省了连接.&lt;/p>
&lt;p>但如果状态很多,还需要用OLAP或者SQL引擎来进行优化.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309165102184.png" alt="image-20230309165102184" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">select&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">from&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">select&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">max&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">totalitems&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">as&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">mx&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">custid&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">from&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">orders&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">group&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">by&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">custid&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">o1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">join&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">orders&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">o2&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">where&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">o1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">mx&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">o2&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">totalitems&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">and&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">o1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">custid&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">o2&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">custid&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%A4%84%E7%90%86%E5%8F%8A%E5%8F%8D%E8%8C%83%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%A4%84%E7%90%86%E5%8F%8A%E5%8F%8D%E8%8C%83%E5%BC%8F/</guid><description>&lt;p>数据库表结构设计&lt;/p>
&lt;ul>
&lt;li>不同设计对相同的查询会产生什么样不同的效率影响。&lt;/li>
&lt;li>打破范式可以提高效率.&lt;/li>
&lt;/ul>
&lt;h2 id="1处理层次结构">1.处理层次结构&lt;/h2>
&lt;p>以人类最熟悉的数据存储组织的方式最早出现
层次数据库存储数据存在一种逻辑嵌套，不是一种对数据的线性排列. 后续还出现了多重层次连接的网状数据库.&lt;/p>
&lt;p>直到关系理论出现, 使得操控的灵活性，数据的组织，以及数据访问的效率上，找到了一个非常好的平衡&lt;/p>
&lt;p>但层次组织数据的方式还是有很多的使用. 如:XML,LDAP都是基于树状结构的层次组织.&lt;/p>
&lt;p>&lt;strong>层次结构复杂的原因&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>访问数据的方式，本质是一个访问树的方式，需要访问树的全部或者
部分节点。&lt;/li>
&lt;li>通常需要按照访问顺序返回这些数据.&lt;/li>
&lt;li>&lt;strong>过程化的访问方式，是违背关系理论&lt;/strong>的，造成了一种&lt;strong>mismatch&lt;/strong>。&lt;/li>
&lt;li>在关系结构中，构建层次数据的存储和访问都很困难。&lt;/li>
&lt;/ul>
&lt;p>树状结构有三种表结构的设计方式，都是满足三范式三种完全不同的设计方式&lt;/p>
&lt;h3 id="11邻接模型">1.1邻接模型&lt;/h3>
&lt;p>层次中父记录ID作为子记录(childrow) 的一个属性，树中两个相邻的节点&lt;/p>
&lt;p>因而被明确关联在一一起。&lt;/p>
&lt;p>设计直观简单,但会导致&lt;strong>递归的查询&lt;/strong>。&lt;/p>
&lt;h3 id="12物化路径模型">1.2物化路径模型&lt;/h3>
&lt;p>把树中的每个节点、与它
在树中的位置的描述数据相结合。&lt;/p>
&lt;p>1代表第一章;&lt;/p>
&lt;ol>
&lt;li>2代表第一章第二节;
1.2.3代表第一章第二节
第三小节。&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>与邻接模型的差别&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>邻接模型的子节点是平等的&lt;/li>
&lt;li>物化路径模型可以指出&lt;strong>兄弟的排名&lt;/strong>。&lt;/li>
&lt;li>且可以无限扩展,扩展很多层。&lt;/li>
&lt;/ul>
&lt;h3 id="13嵌套集合模型">1.3嵌套集合模型&lt;/h3>
&lt;p>每个节点被赋予了一对数字，其中父节点的两个数字包含其所有的子节点的左右数字，然后一层一层
这样包含下去。&lt;/p>
&lt;h3 id="14嵌套间隔模型nested-interval">1.4嵌套间隔模型(nested interval)&lt;/h3>
&lt;p>思想是以两个数字为特定节点的&lt;strong>路径编码&lt;/strong>，这两个数字被解释成有理数(就是分数)的&lt;strong>分子和分母&lt;/strong>。 太复杂了不讲.&lt;/p>
&lt;h3 id="15树状结构的三种方式访问的比较">1.5树状结构的三种方式访问的比较&lt;/h3>
&lt;p>例子 &lt;strong>军队结构&lt;/strong>.&lt;/p>
&lt;p>&lt;strong>邻接模型&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230309190604145.png" alt="image-20230309190604145" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230227192057736.png" alt="image-20230227192057736" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>物化路径模型&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230309190631784.png" alt="image-20230309190631784" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230227192122633.png" alt="image-20230227192122633" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>嵌套集合模型&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230227192142928.png" alt="image-20230227192142928" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>特征:节点[left_num,right_num]值必定介于其任一个祖先的[left_num,right_num]值之间，这就是“嵌套集合”的由来。(nested set)&lt;/p>
&lt;p>叶子结点即right_num = left_num + 1&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230227192211959.png" alt="image-20230227192211959" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h2 id="2层次结构的自顶向下查询">2.层次结构的自顶向下查询&lt;/h2>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230227192330951.png" alt="image-20230227192330951" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230309190847607.png" alt="image-20230309190847607" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>以下用oracle&lt;/p>
&lt;h3 id="邻接模型">邻接模型&lt;/h3>
&lt;p>oracle专有关键词：ocean base也支持&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230309190953499.png" alt="image-20230309190953499" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>使用了虚拟的level字段。&lt;/p>
&lt;p>不用connect by时，需要使用with as来递归&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230309191109258.png" alt="image-20230309191109258" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230309191120429.png" alt="image-20230309191120429" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230227192536512.png" alt="image-20230227192536512" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>with as 实现。但是层次遍历，不是深度优先遍历。&lt;/p>
&lt;p>需要&lt;strong>定义层次&lt;/strong>来进行重新的排序。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230309191243402.png" alt="image-20230309191243402" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>便捷的方法是用connectted by&lt;/p>
&lt;p>&lt;strong>mysql的问题&lt;/strong>&lt;/p>
&lt;p>MySQL8.0添加了CTE支持with as&lt;/p>
&lt;p>8.0之前版本;两个方法手动union在一个查询中多次连接&lt;/p>
&lt;h3 id="物化路径模型">物化路径模型&lt;/h3>
&lt;ul>
&lt;li>查询编写不困难&lt;/li>
&lt;li>计算由路径导出的&lt;/li>
&lt;li>层次不方便假设&lt;/li>
&lt;li>mp_depth(函数返回当前节点深度) 用字符串处理&amp;quot;.&amp;quot;&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230227192847984.png" alt="image-20230227192847984" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="嵌套集合模型">嵌套集合模型&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230309191511744.png" alt="image-20230309191511744" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>兄弟节点要排序就很复杂。&lt;/p>
&lt;p>计算节点数量无法从leftnum和right_num导出.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230309191542150.png" alt="image-20230309191542150" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="比较性能的方法">比较性能的方法&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230227193009108.png" alt="image-20230227193009108" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>影响物化路径模型的因素&lt;/strong>&lt;/p>
&lt;p>1.计算深度
计算两个字符串函数的差，所带来的代价;&lt;/p>
&lt;p>2.缩排函数
物化路径模型需&lt;strong>不断地处理字符串&lt;/strong>，在where子句中不断的执行字符
串操作，处理速度比邻接模型更慢。&lt;/p>
&lt;p>&lt;strong>嵌套集合模型&lt;/strong>&lt;/p>
&lt;p>找后代方面胜于其他两个模型，但为&lt;strong>缩排&lt;/strong>付出更大代价;&lt;/p>
&lt;p>性能的降低和额外连接，以及group by所做的深度有关&lt;/p>
&lt;p>改善嵌套集合模型性能,其代价巨大&lt;/p>
&lt;h2 id="5自底向上的查询-hightland查询">5.自底向上的查询 Hightland查询&lt;/h2>
&lt;p>&lt;strong>自底向上查询的特点&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>自顶向下查询只有一个起点; 而自底向上查询&lt;strong>可能有多个出发点&lt;/strong>。
·多个记录都包含highland查询。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在description字段中查找“Highland”字符,
必然&lt;strong>导致完整表扫描&lt;/strong>.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>自底向上查询效率慢于自顶向下查询&lt;/strong>&lt;/p>
&lt;h3 id="51邻接模型">5.1邻接模型&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230309192326051.png" alt="image-20230309192326051" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>connect by 不是关系操作, 是基于过程的关键词,&lt;strong>不存储中间结果集&lt;/strong>,&lt;/p>
&lt;h3 id="52物化路径模型">5.2物化路径模型&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230309192441538.png" alt="image-20230309192441538" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>重复项和记录顺序的问题的解决方式&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230309192517555.png" alt="image-20230309192517555" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>另一种方式把节点的物化路径分解成路径列表，即列转行的方式.&lt;/p>
&lt;p>树状结构表增加到千行以上，like比较方法性能风险可能会大大提升&lt;/p>
&lt;h3 id="53嵌套集合查询">5.3嵌套集合查询&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230227193634675.png" alt="image-20230227193634675" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="54比较效率">5.4比较效率&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230227193659877.png" alt="image-20230227193659877" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>结果 connect by 查询效果依旧卓越.&lt;/p>
&lt;p>物化路径和嵌套集合模型都只有邻接模型的一半的效率。&lt;/p>
&lt;ul>
&lt;li>物化路径不该是主键，即使它们有唯一性。字符串不适合做主键且主键最好不要更新.&lt;/li>
&lt;li>所选择的编码方式不需要完全中立
&lt;ul>
&lt;li>F.3.1.1 变成 F030101&lt;/li>
&lt;li>但这种方法不通用.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="4聚合来自树的值">4.聚合来自树的值&lt;/h2>
&lt;p>一.对保存于&lt;strong>叶节点中的值做聚合&lt;/strong>; 简单的树,单一父节点&lt;/p>
&lt;p>二.计算某个值散布在树中各层次的百分比。&lt;/p>
&lt;h3 id="41第一个查询">4.1第一个查询&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230309193055261.png" alt="image-20230309193055261" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>对于邻接模型&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230227194121906.png" alt="image-20230227194121906" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>对于物化路径模型&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230309193243048.png" alt="image-20230309193243048" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>性能差异&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230309193319263.png" alt="image-20230309193319263" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="42第二个问题-多父节点时无法在一张表中解决">4.2第二个问题 多父节点时,无法在一张表中解决&lt;/h3>
&lt;p>邻接模型和物化路径模型设计仍然存在局限性;&lt;/p>
&lt;p>物料单位问题 BOM问题&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230227194421886.png" alt="image-20230227194421886" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>出现的问题&lt;/strong>:&lt;/p>
&lt;p>一、龙蛋壳成分有多个父
节点，5号魔药和9号基础魔药都是它的父亲节点。&lt;/p>
&lt;p>二、计算龙蛋壳在5号魔
药中占比，不仅要计算5号魔药本身的龙蛋壳的百
分比，还要加上9号魔药
中龙蛋壳的含量。&lt;/p>
&lt;p>&lt;strong>解决方案:&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230227194512062.png" alt="image-20230227194512062" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>一个components包含多个composition，一个处方，也包含多个composition。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230309193629175.png" alt="image-20230309193629175" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>用with as 做递归&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230309193641103.png" alt="image-20230309193641103" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="43树状结构问题">4.3树状结构问题&lt;/h3>
&lt;p>关系型数据库非常难处理树状结构&lt;/p>
&lt;p>因为性能非常差，处理层次型数据很困难。
SQL缺乏处理树结构的
强大的、可伸缩的手段。&lt;/p>
&lt;p>不同的表结构设计，在相同的查询下，性能也会差距甚大.&lt;/p>
&lt;p>不建议对关系模型不建议对屡遭诟病的缓慢本性 反规范化，这很容易遮掩程序设计中的问题&lt;/p>
&lt;h2 id="5对冗余的控制反范式">5.对冗余的控制（反范式）&lt;/h2>
&lt;h3 id="51范式的概念">5.1范式的概念&lt;/h3>
&lt;p>1NF:一个字段，只有一
个值。&lt;/p>
&lt;p>2NF:一条记录，可以被唯一的主键所区分，是一个实体有唯一的标识。&lt;/p>
&lt;p>3NF :字段和字段之间不存在函数依赖。&lt;/p>
&lt;p>设置范式的原因： &lt;strong>控制冗余&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>如果一个值，在关系型数据库中存在多个地方，那么他们应该一起被修改，否则数据完整性就没有办法保障了&lt;/li>
&lt;li>但数据访问压力大，需从数据库设计入手，通过打破三范式提高数据库访问的性能。&lt;/li>
&lt;/ul>
&lt;p>打破范式的根本逻辑在于&lt;strong>降低表连接数量&lt;/strong>。
提升了查询效率，降低了SQL优化器的优化难度。&lt;/p>
&lt;h3 id="52第一范式">5.2第一范式&lt;/h3>
&lt;p>含义：一个字段只有一个值;
不仅仅是存储的要求，也同样是&lt;strong>使用的要求&lt;/strong>。&lt;/p>
&lt;p>满足一范式的本质:把这个字段&lt;strong>只当成一个值&lt;/strong>来使用，不能拆散使用。&lt;/p>
&lt;p>如：身份证号码不和 生日 产生依赖。&lt;/p>
&lt;p>&lt;strong>判断三范式&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>一个字段的全部，不能和其它字段产生函数依赖。&lt;/li>
&lt;li>而不是一个字段的一-部分是不是和其它字段产生函数依赖。&lt;/li>
&lt;li>任何拆分字段的使用方式，本质上都是打破了一范式。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>三范式的实践基础&lt;/strong>&lt;/p>
&lt;p>一个字段只当成一个值使用。
生日和年龄是函数依赖关系，身份证号码和生日在实践意义上并不构成函数依赖。&lt;/p>
&lt;h3 id="53打破范式的本质">5.3打破范式的本质&lt;/h3>
&lt;p>引入&lt;strong>受控的冗余&lt;/strong>，确定是否通过放松规范化规则来提高系统的性能。&lt;/p>
&lt;p>规范化的结果是一个结构上拥有&lt;strong>一致且最少冗余&lt;/strong>的逻辑数据库设计。&lt;/p>
&lt;p>有必要放弃完全规范化而得到某些性能上的好处。&lt;/p>
&lt;p>&lt;strong>一旦打破范式需要考虑的三因素&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>规范弱化使得&lt;strong>实现变得更加复杂&lt;/strong>，因为需要&lt;strong>手动保持数据的完整性&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>规范弱化会&lt;strong>降低灵活性&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>规范弱化会加快元组检索的速度，但却会&lt;strong>使更新速度变慢&lt;/strong>。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>通常的经验&lt;/strong>：&lt;/p>
&lt;p>80%的性能问题来自于开发和对数据库的使用不当，&lt;/p>
&lt;p>&lt;strong>但如果系统具有低修改性和高查询率，规范弱化可能是提高数据库&lt;/strong>
&lt;strong>查询效率一种可行的选择。&lt;/strong>&lt;/p>
&lt;p>用复制的方式打破范式，比如将某些属性或者将某些关系连
接起来，以&lt;strong>减少执行查询时所需要的连接操作&lt;/strong>。&lt;/p>
&lt;p>规范弱化取决于系统具体情况。&lt;/p>
&lt;h3 id="规范弱化模式">规范弱化模式&lt;/h3>
&lt;p>了解打破范式的几种手段，按照相应模式需求，构建手动的方式保证数据的完整性&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230227195347207.png" alt="image-20230227195347207" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>打破范式的步骤：&lt;/p>
&lt;p>画好ER模型→分辨一对一、一对多和多对多关系→构建三范式表结构设计。&lt;/p>
&lt;h2 id="6反范式的实现">6.反范式的实现&lt;/h2>
&lt;h3 id="61合并一对一关系">6.1合并一对一关系&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230309194735438.png" alt="image-20230309194735438" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>合并：基于全部参与的实体为主，引入部分参与的表。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230227195601373.png" alt="image-20230227195601373" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>产生空值。&lt;/p>
&lt;h3 id="62复制一对多关系中的非键列来减少连接">6.2复制一对多关系中的非键列来减少连接&lt;/h3>
&lt;p>在子表中复制一个或更多的&lt;strong>父表中非键列来减少或删除链接&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230227195721370.png" alt="image-20230227195721370" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>此时最需要关注更新，可能需要&lt;strong>使用触发器&lt;/strong>。&lt;/p>
&lt;h3 id="3复制一对多关系中的外键列来减少连接">3.复制一对多关系中的外键列来减少连接&lt;/h3>
&lt;p>为减少或删除常用或关键查询的连接，复制关系中一个或多个外键列来提高
查询的效率。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230309194939656.png" alt="image-20230309194939656" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230227195815024.png" alt="image-20230227195815024" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="64复制多对多的列">6.4复制多对多的列&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230227195834238.png" alt="image-20230227195834238" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="65引入重复组">6.5引入重复组&lt;/h3>
&lt;p>重复组：一组地址，一组电话号码，用户有多个。&lt;/p>
&lt;p>满足范式要求:单独建一张地址或者电话的表，做连接查询。&lt;/p>
&lt;p>打破方法：&lt;/p>
&lt;ul>
&lt;li>把重复组全部打包放在主表中，增加n列
&lt;ul>
&lt;li>1)重复组的绝对数量是已知的&lt;/li>
&lt;li>2该数量是静态的，不会改变&lt;/li>
&lt;li>
&lt;ol start="3">
&lt;li>该数量并不是很大，通常不大于10&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>主表中存储缺省的电话和地址，所有地址和电话都单独存在地址表和电
话表中。
&lt;ul>
&lt;li>大部分查询，只需要缺省值。&lt;/li>
&lt;li>优点:通用性和效率都可以达到很好的平衡&lt;/li>
&lt;li>缺点：需要在UI中分开&lt;/li>
&lt;li>缺省值的读取和全部值的读取都在不同页面。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="66创建提取表">6.6创建提取表&lt;/h3>
&lt;p>将查询慢需要的表连接成
大表并储存下来。&lt;/p>
&lt;p>查询可以访问派生数据并
在同一组基表上执行多表联接。&lt;/p>
&lt;p>不能做实时计算，得到数据可能是&lt;strong>相对静态&lt;/strong>
的，也可能不一定是最新的。&lt;/p>
&lt;p>好处大，缺点非常大&lt;/p>
&lt;p>带来非常大的复杂性，导致数据库中存在各种同步的、异步的、有用的没用的提取表。
数据更新耗费后续人员极长时间&lt;/p>
&lt;h3 id="67关于打破范式">6.7关于打破范式&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230227200214330.png" alt="image-20230227200214330" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>受控的冗余引入，冗余不可怕，但需要受控。&lt;/p>
&lt;h3 id="68总结">6.8总结&lt;/h3>
&lt;p>四个角度讨论查询优化的问题：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230309195507718.png" alt="image-20230309195507718" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E9%97%AE%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E9%97%AE%E9%A2%98/</guid><description>&lt;h2 id="1黑盒问题">1.黑盒问题&lt;/h2>
&lt;p>不能当作黑盒。&lt;/p>
&lt;p>因为数据库其实不存在独立性。&lt;/p>
&lt;h3 id="11体系结构的巨大差异">1.1体系结构的巨大差异&lt;/h3>
&lt;p>会导致数据库的连接，数据库并发处理等差异&lt;/p>
&lt;p>数据库迁移会出现很多问题。&lt;/p>
&lt;h3 id="12黑盒与数据库独立性的问题">1.2黑盒与数据库独立性的问题&lt;/h3>
&lt;p>数据库有脱离实现级别的使用方法。&lt;/p>
&lt;ul>
&lt;li>要构建一个完全的数据库独立应用，而且是高度可扩展的应用是极其-
&lt;ul>
&lt;li>困难不依赖于任何一个数据库，既可在Oracle上运行，也可在MySQL上运行实际上几乎不可能&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>要构建一个完全独立的数据库应用:
&lt;ul>
&lt;li>必须真正了解每个数据库具体如何工作&lt;/li>
&lt;li>如果清楚每个数据库工作的具体细节，数据库独立性可能并不满足&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>如&lt;strong>Null值&lt;/strong>造成的&lt;strong>数据库迁移障碍&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>在Sybase中间（is NULL）返回的是true&lt;/li>
&lt;li>在Oracle中间返回的仍然是空&lt;/li>
&lt;/ul>
&lt;h2 id="2不同数据库中的差异--并发控制">2.不同数据库中的差异 —— 并发控制&lt;/h2>
&lt;p>并发控制是用于保护数据库完整性的技术&lt;/p>
&lt;ul>
&lt;li>产生并发问题主要原因: 事务的隔离性没控制好，一致性不能得到保证&lt;/li>
&lt;li>并发机制不正确可能导致脏读、幻读和不可重复读等此类问题&lt;/li>
&lt;/ul>
&lt;h3 id="21不同数据库的并发控制不同">2.1不同数据库的并发控制不同&lt;/h3>
&lt;p>如果不了解数据库如何实现并发控制，就没有办法做&lt;strong>性能优异的并发系统&lt;/strong>，就&lt;strong>一定会有不好的结果&lt;/strong>。&lt;/p>
&lt;p>车辆排队时间随着数量增加，后续会呈现&lt;strong>指数增长&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>一方面要花费更大的额外时间来管理，需要划线，需要维持现场秩序。&lt;/li>
&lt;li>另一方面，收费站问题，最终可能引起整个&lt;strong>高速公路连锁反应&lt;/strong>。&lt;/li>
&lt;li>在数据库中间把它称之为&lt;strong>上下文切换&lt;/strong>。&lt;/li>
&lt;li>现实存在并发，需保持&lt;strong>数据一致性&lt;/strong>，所以要做并发控制。‘&lt;/li>
&lt;/ul>
&lt;h3 id="22当前数据库系统如何使用锁机制">2.2当前数据库系统如何使用锁机制&lt;/h3>
&lt;p>数据库通过锁机制来处理并发问题。&lt;/p>
&lt;p>行级锁：乐观锁、二段锁。&lt;/p>
&lt;p>不同数据库的&lt;strong>锁机制不一致&lt;/strong>、&lt;strong>差异性&lt;/strong>将极大程度地影响数据库的并发控制机制。&lt;/p>
&lt;ul>
&lt;li>有些数据可能有页级锁、另外一些有行级锁，有些实现会把行级锁升级为页级锁，另外一些则不然; 有些使用读锁，另外一些不使用。&lt;/li>
&lt;li>有些通过锁定实现&lt;strong>串行化事务&lt;/strong>，另外一些则通过数据库的**“读一致”视图**来实现(没有锁）。&lt;/li>
&lt;/ul>
&lt;p>不了解锁机制有时将导致致命的bug。&lt;/p>
&lt;h3 id="23orcale数据库的锁机制有时无法读正确数据-特别地">2.3Orcale数据库的锁机制有时无法读正确数据。 特别地&lt;/h3>
&lt;p>Orcale的多版本控制、读一致性模型：&lt;/p>
&lt;ul>
&lt;li>读一致性：对一个时间点的查询结果是一致的。&lt;/li>
&lt;li>非阻塞性读：读不会被写阻塞。//但其他数据库可能会&lt;/li>
&lt;/ul>
&lt;p>Orcale锁机制的好处：&lt;/p>
&lt;ul>
&lt;li>因为没有读锁，读和写可以并发，并发效率提高。&lt;/li>
&lt;li>&lt;strong>其他数据库&lt;/strong>使用了&lt;strong>读共享锁&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%bc%80%e5%8f%91%e4%b8%ad%e7%9a%84%e6%95%b0%e6%8d%ae%e5%ba%93%e9%97%ae%e9%a2%98/image-20230308141957218.png" alt="image-20230308141957218" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>充分了解锁机制、才能发挥数据库管理系统的最大潜能。&lt;/p>
&lt;h2 id="3数据库的并发控制对程序员影响">3.数据库的并发控制——对程序员影响&lt;/h2>
&lt;h3 id="31-orcale的读一致性">3.1 Orcale的读一致性&lt;/h3>
&lt;p>特点：对一个时间点的查询结果是一致的。读和写可以并发，并发效率提高。&lt;/p>
&lt;p>Orcale的无阻塞设计的&lt;strong>副作用&lt;/strong>：&lt;/p>
&lt;p>当要保证一次最多只有一个用户访问一行数据，需要开发人员做工作。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%bc%80%e5%8f%91%e4%b8%ad%e7%9a%84%e6%95%b0%e6%8d%ae%e5%ba%93%e9%97%ae%e9%a2%98/image-20230308142438375.png" alt="image-20230308142438375" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>因为where中查询时，两条数据都是合法的，都能插入，此时会出现业务逻辑错误。&lt;/p>
&lt;p>&lt;strong>修改方式&lt;/strong>：&lt;/p>
&lt;p>使用FOR UPDATE关键字，表示这个读是用来修改的，此时有个共享锁机制。&lt;/p>
&lt;h3 id="32-不能把数据库当成黑盒使用">3.2 不能把数据库当成黑盒使用&lt;/h3>
&lt;p>HIBERNATE
·对可持续化的类直接连接数据库，进行可持续化的存储。&lt;/p>
&lt;ul>
&lt;li>Hibernate并不会为 sqlserver，DB2，oracle生成不同的代码，而每个数据库的特征又是如此的不一样。&lt;/li>
&lt;li>数据库有时跟编译器一样，只能做语法检查&lt;/li>
&lt;li>很难对一个数据库的操作进行对错的判断，&lt;strong>很难debug&lt;/strong>&lt;/li>
&lt;li>因此需要在每个环节尽量&lt;strong>避免引入bug&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>oracle mysql SqlServer数据库上差异，导致了并发处理上的差别&lt;/p>
&lt;h3 id="33程序员通过程序来考虑并发问题的情况">3.3程序员通过程序来考虑并发问题的情况：&lt;/h3>
&lt;p>回答：不知道、看情况。&lt;/p>
&lt;ul>
&lt;li>并发控制
90%的情况下，
并发都是完全透明，无需担心。&lt;/li>
&lt;li>10%的情况下，必须清楚哪些情况下需要自己考虑
并发控制。&lt;/li>
&lt;/ul>
&lt;p>需要做什么：&lt;/p>
&lt;ul>
&lt;li>了解每个feature的
结构和实现，避免犯错。&lt;/li>
&lt;li>测试，而且要&lt;strong>学会在多用户环境下&lt;/strong>对代码进行不断的测试。&lt;/li>
&lt;/ul>
&lt;h2 id="4为性能而设计">4.为性能而设计&lt;/h2>
&lt;h3 id="41-性能调优">4.1 性能调优&lt;/h3>
&lt;p>避免依赖专家调优。因为专家调优不靠谱。&lt;/p>
&lt;h3 id="性能调优的两种方式">性能调优的两种方式：&lt;/h3>
&lt;ul>
&lt;li>根据当前CPU能力、可用内存、I/O子系统等资源情况来设置相应参数。数据库管理员（专家）要做的事情，大概提高20-30%。&lt;/li>
&lt;li>通过索引、物理结构、SQL的优化，具体提高某&amp;ndash;个查询的性能。本身是程序员要做的事情。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>决定性能的根本原因—— 设计（提高性能的基础）&lt;/strong>&lt;/p>
&lt;p>体系结构设计决定了数据库系统的性能上限（&lt;strong>性能级别&lt;/strong>）。&lt;/p>
&lt;p>比如：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>动态页面：对于百万量级访问负担重。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>静态页面：还需要额外的内容管理系统。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>修改对顺序文件是极大的性能障碍，所以这些系统都不提供修改功能。&lt;/p>
&lt;p>&lt;strong>设计决定了性能指标&lt;/strong>，性能拙劣的罪魁祸首都是错误的设计。&lt;/p>
&lt;p>性能指标都是有成本的，性能设计是在安全和优化中寻找平衡&lt;/p>
&lt;h3 id="42性能指标--要考虑整体性">4.2性能指标 —— 要考虑整体性&lt;/h3>
&lt;ul>
&lt;li>以前的，查询事务，多少s能够返回数据&lt;/li>
&lt;li>以&lt;strong>吞吐量&lt;/strong>为核心。每秒&lt;strong>处理多少事务&lt;/strong>。（&lt;strong>整体性&lt;/strong>）&lt;/li>
&lt;li>数据库环境，web服务器的环境，只能支持3000个并发&lt;/li>
&lt;li>比如OceanBase的成绩单上写，它承载了双十一峰值6100万次/秒的数据库访问这就是针对访问吞吐量的指标&lt;/li>
&lt;/ul>
&lt;p>一个&lt;strong>具体的sql的性能提升&lt;/strong>，也许会&lt;strong>导致其它操作性能的下降&lt;/strong>，使整个&lt;strong>系统吞吐量&lt;/strong>下降。‘性能指标要考虑整体性：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>任何一个技术可以解决一个问题，但必然存在另一个问题的风险&lt;/p>
&lt;/li>
&lt;li>
&lt;p>debug能力和使用优化工具的能力，是每个数据库工程师应该有的。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%bc%80%e5%8f%91%e4%b8%ad%e7%9a%84%e6%95%b0%e6%8d%ae%e5%ba%93%e9%97%ae%e9%a2%98/image-20230201115754595.png" alt="image-20230201115754595" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="43-整体层面考虑性能优化">4.3 整体层面考虑性能优化&lt;/h3>
&lt;p>数据的&lt;strong>性能直接指标&lt;/strong>就是&lt;strong>CPU或者是I/O的负载&lt;/strong>的问题.所以要监控CPU，IO负载。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>CPU负载高，I/O负载低&lt;/p>
&lt;ul>
&lt;li>内存不够&lt;/li>
&lt;li>磁盘性能差(磁盘问题、RAID设计不好，
RAID降级)&lt;/li>
&lt;li>&lt;strong>SQL的问题&lt;/strong>&lt;/li>
&lt;li>&lt;strong>并发锁机制的问题&lt;/strong>&lt;/li>
&lt;li>&lt;strong>事务设计问题，大量小数据I/O&lt;/strong>&lt;/li>
&lt;li>&lt;strong>大量的全表扫描&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>I/O负载高，CPU负载低&lt;/p>
&lt;ul>
&lt;li>&lt;strong>大量小的I/O执行写操作&lt;/strong>&lt;/li>
&lt;li>**Autocommit，产生大量小/0 **自动提交&lt;/li>
&lt;li>&lt;strong>大量大的I/O执行写操作&lt;/strong>&lt;/li>
&lt;li>&lt;strong>SQL的问题&lt;/strong>&lt;/li>
&lt;li>IOPS: 磁盘每秒的读写次数&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>都高&lt;/p>
&lt;ul>
&lt;li>硬件不够用&lt;/li>
&lt;li>&lt;strong>SQL存在明显问题&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>性能问题 90%是程序员问题，开发环境到生产环境容易出问题。&lt;/p>
&lt;p>&lt;strong>数据库应用要从自己身上找原因&lt;/strong>&lt;/p>
&lt;p>sql优化的方向：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%bc%80%e5%8f%91%e4%b8%ad%e7%9a%84%e6%95%b0%e6%8d%ae%e5%ba%93%e9%97%ae%e9%a2%98/image-20230201120131053.png" alt="image-20230201120131053" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E5%92%8C%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E5%92%8C%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8F/</guid><description>&lt;p>并发问题: 单独一个session执行的时候，很多问题不会暴露，但多个
session一起访问的时候，就会遇到问题。&lt;/p>
&lt;p>并发用户遇到最多的是更新问题，即&lt;strong>多个用户更新相同资源的时候&lt;/strong>，会
产生数据冲突的问题，以及随后会采用的各种级别的锁的问题。&lt;/p>
&lt;p>并发也会涉及&lt;strong>读取问题&lt;/strong> （各种资源竞争）&lt;/p>
&lt;p>一、并发读取和并发修改的常见问题和解决方案;&lt;/p>
&lt;p>二、数据库事务隔离级别:&lt;/p>
&lt;p>三、大数据量的一些处理手段。&lt;/p>
&lt;h2 id="1处理并发和大数据量">1.处理并发和大数据量&lt;/h2>
&lt;h3 id="11并发读取问题">1.1并发读取问题&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227200500826.png" alt="image-20230227200500826" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>有索引和没索引对数据访问的差距&lt;/strong>：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227200620323.png" alt="image-20230227200620323" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>5000数据量太少，所以单次查询的测试感觉不明显。&lt;/p>
&lt;p>单位时间内，随机间隔执行若干次。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230309200022761.png" alt="image-20230309200022761" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230309200051642.png" alt="image-20230309200051642" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227200824602.png" alt="image-20230227200824602" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="12排队">1.2排队&lt;/h3>
&lt;p>单个查询的时间慢，队会越排越长，性能也越来越差。&lt;/p>
&lt;p>队伍的增长速度与查询的执行频率和查询所需平均时间之间的比例有关,比例拉高，查询越来越快，&lt;strong>队伍就越拉越长&lt;/strong>。&lt;/p>
&lt;p>即&lt;strong>阈值效应&lt;/strong>。数据库是非常典型的具备闯值效应的东西.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230309200313192.png" alt="image-20230309200313192" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h2 id="2并发修改数据-加锁">2.并发修改数据-加锁&lt;/h2>
&lt;p>&lt;strong>并发真正影响的是写&lt;/strong>。&lt;/p>
&lt;p>保证每个sesssion，:每个事务，都有不被别人影响的写的权力，此时要使用锁。&lt;/p>
&lt;p>并发过程中，有多少用户会相互产生影响&lt;strong>取决于锁的粒度&lt;/strong>。&lt;/p>
&lt;h3 id="21看锁的粒度">2.1看锁的粒度&lt;/h3>
&lt;p>不同的DBMS支持不同的锁类型。支持何种粒度的锁，在大型系统和小规模系统之间
存在极大的差异。&lt;/p>
&lt;p>大型系统对于锁的粒度选择非常谨慎，而在小规模系统中往往不是那么计较锁的粒度。&lt;/p>
&lt;p>加锁的数据量小的锁，称之为细粒度锁。&lt;/p>
&lt;p>行锁是粒度很细的锁，只锁一条记录行。
在行锁的环境下，多个并发进程就可能同时修改同一表中的不同行的数据,
而不会造成阻塞。&lt;/p>
&lt;p>&lt;strong>行锁不同进程之间可以有一定的重叠&lt;/strong>，不一定要等到一个进程执行的事务结束才可以执行。&lt;/p>
&lt;p>而&lt;strong>表锁则必须等到上一个对本表执行操作的事务执行结束后才能执行&lt;/strong>，粒度较大;所以一般选择粒度更小的锁。&lt;/p>
&lt;p>更小的锁意味着处理器有更多的工作要做，从而提高硬件资源的利用率。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230309200551574.png" alt="image-20230309200551574" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227201240507.png" alt="image-20230227201240507" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>加锁处理的原则&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>不要随便使用表级锁&lt;/li>
&lt;li>尽量缩短加锁时间&lt;/li>
&lt;li>缩小事务的大小&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>编程上的处理原则&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>尽可能&lt;strong>避免&lt;/strong>SQL语句上的&lt;strong>循环处理&lt;/strong>，在程序体中，不能有一个循环体，循环体中
包含一个SQL语句。
&lt;ul>
&lt;li>SQL本身就是集合读取的过
程，不需要放在循环中。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>尽可能&lt;strong>减少程序和数据库之间的交互次数&lt;/strong>，尽可
能一个SQL就能完成所有的工作，或者一-次查询就读
到尽量多的数据，再本地
处理;&lt;/li>
&lt;li>&lt;strong>跨机器的交互次数越少越好&lt;/strong>。&lt;/li>
&lt;li>未来工作中读取或更新了错误信息，错误处理顺序应该是，&lt;strong>先rolIback，&lt;/strong>
&lt;strong>结束事务，再去查询错误信息表。&lt;/strong>
&lt;ul>
&lt;li>先结束事务，可以先解锁。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="22加锁与提交">2.2加锁与提交&lt;/h3>
&lt;p>这里的频繁提交，是指可以减小事务的大小。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227201458385.png" alt="image-20230227201458385" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>这个和物理组织形式有关。&lt;/p>
&lt;ul>
&lt;li>事务越大，提交越不频繁，资源被锁住的时间越少，&lt;strong>并发出现冲突的概率就越小&lt;/strong>。&lt;/li>
&lt;li>事务越小，提交越频繁，处理事务付出的平均代价就越大&lt;/li>
&lt;/ul>
&lt;p>对于批处理程序，并发控制不是问题，&lt;strong>避免频繁提交才是明智的做法&lt;/strong>。&lt;/p>
&lt;p>对于用户交互程序，则需要&lt;strong>高频提交，加快释放锁&lt;/strong>。&lt;/p>
&lt;h2 id="3资源竞争">3.资源竞争&lt;/h2>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227201626952.png" alt="image-20230227201626952" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230309201216936.png" alt="image-20230309201216936" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230309201243791.png" alt="image-20230309201243791" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>真正的问题是“是否可以更好地利用这些资源。&lt;/p>
&lt;p>进程之间仍然会发生资源竞争，竞争发生在两个地方: 表和索引。&lt;/p>
&lt;p>系统层次也可能发生资源竞争，但通常由数据库层面的竞争引起。&lt;/p>
&lt;p>数据库层面资源竞争消耗CPU，因为处理竞争问题要执行一些代码在等待另一个处理器上执行的进程释放资源时，还可能出现“活动等待”或“闲置循环”&lt;/p>
&lt;p>解决资源竞争的手段，比解决锁的方法多。除了降低锁的粒度外，还可以：&lt;/p>
&lt;p>DBA、架构、开发三方法&lt;/p>
&lt;h3 id="31dba解决方案">3.1DBA解决方案&lt;/h3>
&lt;p>DBA——数据库管理员的解决方案。&lt;/p>
&lt;p>DBA的解决方案，是解决插入的问题，对其它事务的影响比较少&lt;/p>
&lt;p>手段针对对象：事务空间](Transaction space. 可用列表(Freelist)&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227201851918.png" alt="image-20230227201851918" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227201904695.png" alt="image-20230227201904695" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="32架构解决方案">3.2架构解决方案&lt;/h3>
&lt;ul>
&lt;li>分区(Partitioning)&lt;/li>
&lt;li>逆序索引(Reverseindex )&lt;/li>
&lt;li>索引组织表 (Indexorganized table)&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227201930658.png" alt="image-20230227201930658" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="33开发解决方案">3.3开发解决方案&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>调节并发数&lt;/p>
&lt;ul>
&lt;li>限制session个数为最高性能的session个数，使周转更快&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>不使用系统产生值&lt;/p>
&lt;ul>
&lt;li>连续值只在范围查询中使用，在连续值本身毫无现实意义的情况下，范围查询的场景也不多见;&lt;/li>
&lt;li>可以只使用随机数来做主键，遇到随机数碰撞，就再生成一个随机数。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="34比较">3.4比较&lt;/h3>
&lt;p>&lt;strong>session比较多时&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227202036432.png" alt="image-20230227202036432" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230309201842351.png" alt="image-20230309201842351" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>违反主键约束必须到插入主键值之时才可发现，索引保存的是物理地址此时记录已被插入表中，所以需要undo，产生额外的时间成本。&lt;/p>
&lt;p>产生随机数的范围比最糟情况大100倍时，&lt;strong>性能显著改善&lt;/strong>。&lt;/p>
&lt;p>如果要设置随机值作为主键来解决资源竞争的问题，只要range足够大效率就会得到足够的改善。&lt;/p>
&lt;p>&lt;strong>session比较少时&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227202207498.png" alt="image-20230227202207498" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227202235452.png" alt="image-20230227202235452" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h2 id="4事务的隔离级别">4.事务的隔离级别*&lt;/h2>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230309202246087.png" alt="image-20230309202246087" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227202341188.png" alt="image-20230227202341188" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227202437445.png" alt="image-20230227202437445" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>另一个事务是修改但没成果提交，读到错误数据&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227202506641.png" alt="image-20230227202506641" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>另一个事务是修改后并提交，两次读到的数据不同&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227203100328.png" alt="image-20230227203100328" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>另一个事务是插入后并提交，第二次读的时候数据量不一样&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227202536809.png" alt="image-20230227202536809" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>对应MySql四种事务隔离级别&lt;/p>
&lt;p>未提交读(READ UNCOMMITTED)：脏读&lt;/p>
&lt;p>已提交读(READ COMMITTED)：解决脏读产生不可重复读&lt;/p>
&lt;p>可重复读(REPEATABLE READS)：解决不可重复读，产生幻读&lt;/p>
&lt;p>可串行化(Serializable )：解决幻读&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227202730759.png" alt="image-20230227202730759" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>更新时只加了个读锁。其他人不能写但还可以读，会读到自己产生的脏数据。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227202800296.png" alt="image-20230227202800296" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>加了个写锁。自己写完后（即使失败），别人才能读。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227203130428.png" alt="image-20230227203130428" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>提交后锁解开了，仍能有不可重复读。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227203156244.png" alt="image-20230227203156244" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227203250209.png" alt="image-20230227203250209" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>此时情况，既防重复读也防止了幻读。&lt;/p>
&lt;p>&lt;strong>它是怎么做到的&lt;/strong>?&lt;/p>
&lt;p>MVCC(多版本并发控制)&lt;/p>
&lt;p>在InnoDB中，会在每行数据后&lt;strong>添加两个额外的隐藏的值来实现MVCC&lt;/strong>,&lt;/p>
&lt;p>这两个值一
个记录这行数据&lt;strong>何时被创建&lt;/strong>，另外一个记录这行数据&lt;strong>何时过期(或者被删除)。&lt;/strong>&lt;/p>
&lt;p>在实际操作中，存储的不是时间，而是&lt;strong>事务版本号&lt;/strong>，每开启一个新事务，&lt;strong>事务版本号就会递增。&lt;/strong> 用一个乐观锁实现。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230309203313708.png" alt="image-20230309203313708" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>此外，Mysql还有&lt;strong>邻键锁&lt;/strong>。&lt;/p>
&lt;h3 id="42next-key锁">4.2Next-Key锁&lt;/h3>
&lt;p>也属于行锁的一种，且&lt;strong>是INNODB的行锁默认算法&lt;/strong>，临键锁会把查询出
的记录锁住，也会把&lt;strong>该范围查询内的所有间隙空间也会锁住&lt;/strong>，再之它会&lt;strong>把相邻的下一个区间也会锁住&lt;/strong>。&lt;/p>
&lt;p>临键锁避免了在范围查询时出现脏读、重复读、幻读问题。
加了临键锁之后，&lt;strong>在范围区间内数据不允许被修改和插入。&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227203503925.png" alt="image-20230227203503925" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227203452959.png" alt="image-20230227203452959" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h2 id="5数据量增加的不同影响">5.数据量增加的不同影响&lt;/h2>
&lt;p>如何高效搜索庞大的表。&lt;/p>
&lt;p>如何避免数据量稍有增长就可能出现的性能下降。&lt;/p>
&lt;p>5.1应用面临 “要处理的数据量会大幅度增长&amp;quot;的问题。&lt;/p>
&lt;ul>
&lt;li>某一个应用突然火了，数据量暴增，或者业务时间很长，数据库存放了好多年的不经常被用到的数据。&lt;/li>
&lt;li>很多原本能快速处理批处理程序，消耗的时间越来越大，甚至会干扰其它正常操作的查询速度。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>不同的sql操作对于数据量增加的敏感性不同&lt;/strong>&lt;/p>
&lt;h3 id="51影响不大的情况">5.1影响不大的情况&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227203832407.png" alt="image-20230227203832407" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227203924260.png" alt="image-20230227203924260" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230309204022976.png" alt="image-20230309204022976" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="52常见是线性影响">5.2&lt;strong>常见是线性影响&lt;/strong>&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227204139562.png" alt="image-20230227204139562" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="53非线性影响">5.3非线性影响&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227204203453.png" alt="image-20230227204203453" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>现代数据库的处理方式&lt;/strong>：&lt;/p>
&lt;p>比如聚簇索引，比如很多有序的索引，除了为了快速检索，也同样为了简单的排序逻辑依照索引读出数据的顺序就是有序的。&lt;/p>
&lt;p>注意：排序性能降低常间歇发生，时快时慢，较小型排序全部在内存中执行，较大型排序(涉及多个有序子集的合并) 则需将有序子集临时存储到硬盘中&lt;/p>
&lt;p>通过调整&lt;strong>分配排序内存大小&lt;/strong>，
来改善排序密集型操作的性能
是&lt;strong>常见有效的调优技巧。&lt;/strong>&lt;/p>
&lt;h2 id="6大数据量的处理逻辑">6.大数据量的处理逻辑&lt;/h2>
&lt;p>是否需要在需求之外，添加一个格外的查询条件，来限制需要查询的数据规模。这是一个普遍的原则。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227204418997.png" alt="image-20230227204418997" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>排序主要是读写硬盘的影响。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227204526760.png" alt="image-20230227204526760" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227204539957.png" alt="image-20230227204539957" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>SQL优化中： 必须限制SQL查询中&lt;strong>非关系层部分&lt;/strong>，因为非关系层与操作数据数
量、复杂度有关，排序、limit
都是非关系层操作。&lt;/p>
&lt;p>遇到非关系操作，SQL会把一个查询，在关系和非关系操作边界上切一刀，内层是一个sql进行优化，外层是另一个sql进行优化，这样避免查询优化器对语义理解的错误。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227204629339.png" alt="image-20230227204629339" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="消除关联子查询">消除关联子查询&lt;/h3>
&lt;p>exists是关联嵌套子查询&lt;/p>
&lt;p>它和非关联嵌套子查询in的最大的差异:子查询要执行多次。&lt;/p>
&lt;p>它想效率高只有一个方式: 外层查询的条件足够的好，否则有风险。&lt;/p>
&lt;p>关联嵌套子查询在计算每一条返回记录时，&lt;strong>都被调用一次&lt;/strong>。&lt;/p>
&lt;p>死亡sql：但常见&lt;/p>
&lt;p>随数据量增加，减少关联子查询，否则风险很大。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227204741869.png" alt="image-20230227204741869" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/%E7%B4%A2%E5%BC%95%E5%8F%8A%E7%89%A9%E7%90%86%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/%E7%B4%A2%E5%BC%95%E5%8F%8A%E7%89%A9%E7%90%86%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84/</guid><description>&lt;p>索引概述&lt;/p>
&lt;p>&lt;strong>索引与目录&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>目录和索引是两种不同的机制&lt;/li>
&lt;li>索引是一种以原子粒度访问数据的手段，而不是为
了检索大量数据的&lt;/li>
&lt;/ul>
&lt;h2 id="1b树索引的结构和应用">1.B+树索引的结构和应用&lt;/h2>
&lt;h3 id="11b树的结构">1.1B+树的结构&lt;/h3>
&lt;p>必须关注关键数据的读取，并为它们提供&lt;strong>最高效的访问路径&lt;/strong>，而&lt;strong>建立索引可能是你第一个能想到的策略&lt;/strong>。&lt;/p>
&lt;p>几乎所有关系型数据库的缺省索引都是B+树索引，OceanBase也用了。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e7%b4%a2%e5%bc%95%e5%8f%8a%e7%89%a9%e7%90%86%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84/image-20230308150235556.png" alt="image-20230308150235556" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>数据库引擎&lt;strong>读取的方式&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>是从硬盘上&lt;strong>整块整块地读取&lt;/strong>数据到内存里&lt;/p>
&lt;/li>
&lt;li>
&lt;p>接着在内存中把块中的某一条记录提取出来
再进行使用。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>一个块大概4k，存多条记录。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>数据库引擎的某次读取&lt;strong>只是为了读取一条记录&lt;/strong>，但是它&lt;strong>会首先读一个完整的块&lt;/strong>而这个过程就叫&lt;strong>物理IO读取&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>数据库性能最大的消耗，就是在物理IO上。一个查询的物理IO次数越多，这个查询的速度就越慢&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>B+树索引为什么能够降低物理IO次数&lt;/p>
&lt;ul>
&lt;li>索引结构是一个树状结构，一个层次化的结构。&lt;/li>
&lt;li>根节点，会把节点上的数值分成几个区间，每个区间用指针指向下一层节点，在下一层节点上也划分成几个区间，再指向下一层，直到最下层的叶节点。&lt;/li>
&lt;li>叶节点会记录索引字段的值，以及这个值所对应的记录&lt;strong>在基本表上的存放地址&lt;/strong>，我们把这个地址叫作rowid。&lt;/li>
&lt;li>物理IO次数 = 经过的结点数量 + 1次基本表查询。&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e7%b4%a2%e5%bc%95%e5%8f%8a%e7%89%a9%e7%90%86%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84/image-20230308150733243.png" alt="image-20230308150733243" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;ul>
&lt;li>&lt;strong>叶节点到根节点的距离叫深度&lt;/strong>，例子深度是3，一般B树索引的深度都是3，有些是4&lt;/li>
&lt;li>B树索引要提高查询效率&lt;strong>首先要控制的就是树的深度&lt;/strong>&lt;/li>
&lt;li>本质上B树索引通常意味着数据存储是有序的，每个叶子页到根的距离都是一样的&lt;/li>
&lt;li>B树索引的&lt;strong>叶节点&lt;/strong>就构成了一个&lt;strong>顺序存储的数据结构&lt;/strong>它们对于范围查询，也就是&lt;strong>搜索范围数据很有用&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;h3 id="12b树索引的应用-能做什么">1.2B树索引的应用 能做什么&lt;/h3>
&lt;p>1、&lt;strong>全键值查询&lt;/strong>&lt;/p>
&lt;p>比如&lt;strong>字段x上有索引&lt;/strong>，where子 句中的条件是&lt;strong>x=123&lt;/strong>，就可以使用B树索引做高速的查询。&lt;/p>
&lt;p>2、&lt;strong>键值范围查询&lt;/strong>&lt;/p>
&lt;p>比如x在45-123之间，先进行x==45这个等值查询，查询到相关的地址,
是顺序存储，&lt;strong>横向直接顺序读取叶节点&lt;/strong>，直到找到最右侧x=123对应的地址。&lt;/p>
&lt;p>&lt;strong>读完索引之后，再去基本表去读那些地址相关的块&lt;/strong>。&lt;/p>
&lt;p>3、键值的前缀查询 与键值类似&lt;/p>
&lt;h3 id="13索引的另一面">1.3索引的另一面&lt;/h3>
&lt;p>B+树索引是最典型的索引结构。&lt;/p>
&lt;p>索引可以大幅提高查询的速度; 但与此同时，我们也不能忽略&lt;strong>索引带来的沉重的成本&lt;/strong>&lt;/p>
&lt;p>&lt;strong>存储的成本&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>很多业务系统，&lt;strong>索引数据量远大于被索引的实际数据量&lt;/strong>，也就是基本表的数据量。&lt;/li>
&lt;li>索引&lt;strong>通常是镜像的&lt;/strong>，还需要在热备、灾备、甚至是物理备份中存储，&lt;strong>存储成本非常高&lt;/strong>。&lt;/li>
&lt;li>当需要备份恢复的时候，索引还大大地增加了从备份中&lt;strong>恢复的停机时间&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>而最大的问题&lt;strong>不在于存储&lt;/strong>，&lt;strong>在于处理的开销&lt;/strong>&lt;/p>
&lt;p>基本表数据更改时，索引也需要更新。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e7%b4%a2%e5%bc%95%e5%8f%8a%e7%89%a9%e7%90%86%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84/image-20230308151320663.png" alt="image-20230308151320663" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>在并发访问的环境中，更多的索引将意味着&lt;strong>更多的并发冲突&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>更新操作&lt;strong>需要更新数据本身和更新索引数据&lt;/strong>&lt;/li>
&lt;li>索引通常是一种比数据库表&lt;strong>更紧凑&lt;/strong>的结构。&lt;/li>
&lt;li>在更新索引时，在更小的区间中&lt;strong>并发操作产生冲突的概率就会更大&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>索引在&lt;strong>物理存储上&lt;/strong>、在&lt;strong>更新处理开销上&lt;/strong>以及&lt;strong>在并发冲突的概率&lt;/strong>上，都会大幅度地影响系统的效率&lt;/p>
&lt;p>但索引仍然是最重要的组成部分，因为在实际业务中，&lt;strong>查询的次数一般比更新次数要多得多&lt;/strong>。&lt;/p>
&lt;p>索引也&lt;strong>不一定能提高查询效率&lt;/strong>&lt;/p>
&lt;h2 id="2建立索引的基础--让索引发挥作用">2.建立索引的基础 —— 让索引发挥作用&lt;/h2>
&lt;h3 id="21索引发挥作用的指标">2.1索引发挥作用的指标&lt;/h3>
&lt;p>基本表很小的时候，B+树索引还不如全表查询。&lt;/p>
&lt;ul>
&lt;li>索引只是一种特殊的访问数据的方式，它并不是一定会提高查询效率，要看具体的情况&lt;/li>
&lt;li>这种访问数据的手段是一种&lt;strong>原子粒度的，直接读取记录的&lt;/strong>，它&lt;strong>不是为了检索大量数据而存在的技术&lt;/strong>.&lt;/li>
&lt;li>如果数据是沙滩中的沙子，全表遍历是一把铲子，用来大块大块地读取数据，那么索引就像一个小勺子，一勺一勺地取数据&lt;/li>
&lt;/ul>
&lt;p>每建立一个索引，都需要这个索引能发挥所需要的作用，否则就不该建立，这是&lt;strong>建立索引的基本原则&lt;/strong>.&lt;/p>
&lt;p>判断建立一个&lt;strong>索引到底有没有作用的指标&lt;/strong>，最常用的就是&lt;strong>检索比例&lt;/strong>，
也就是查询检索到的数据占总数据的百分比，往往这个百分比被设
置为10%。&lt;/p>
&lt;ul>
&lt;li>也就是说,如果你查询到的结果集占整个源数据集的10%以下，
那么&lt;strong>在这个查询中使用索引是有效的&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>这也称之为索引的选择性，检索出来的&lt;strong>数据占总数据的百分比越低&lt;/strong>、&lt;strong>索引越有选择性&lt;/strong>。&lt;/p>
&lt;p>这里是&lt;strong>从索引的有效性来说&lt;/strong>.&lt;/p>
&lt;h3 id="22胖表和瘦表的问题">2.2胖表和瘦表的问题&lt;/h3>
&lt;p>胖表是一条记录很长的表，长的原因，很可能是字段数量很多，也可能是每个字段的长度很长&lt;/p>
&lt;p>瘦表的特点与胖表相反它的字段很少，每个字段长度很短。&lt;/p>
&lt;ul>
&lt;li>它们决定了基本表中一个块，能存储的记录的数量。&lt;/li>
&lt;li>瘦表中，一个块能存储更多的行，而胖表中，&lt;strong>一个块能存储的行数就少于瘦表&lt;/strong>。&lt;/li>
&lt;li>原则上，瘦表的&lt;strong>检索比例会更低一些&lt;/strong>，比如5%，而胖表相对来说索引的&lt;strong>检索比例会更高&lt;/strong>，对索引的使用更宽容。（低于检索比例，索引才被认为是有效的）&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>检索比例没有明确的分界线&lt;/strong>，判断索引是否可以被使用，只能&lt;strong>进行实际的测试与验证&lt;/strong>。即只访问基本表中的&lt;strong>少量行是适合使用索引&lt;/strong>的。&lt;/p>
&lt;h3 id="23只使用索引不使用表">2.3只使用索引不使用表&lt;/h3>
&lt;p>即使你需要访问基本表中的&lt;strong>很多行也可以使用索引&lt;/strong>，这种情况就是&lt;strong>只使用索引不使用表&lt;/strong>。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>单键值索引：只对一个字段建立索引。如B+树索引就是典型。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>复合键索引，本质上&lt;strong>是按照第一个字段构建的索引&lt;/strong>，区别是&lt;strong>页节点上增加y的顺序存储&lt;/strong>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e7%b4%a2%e5%bc%95%e5%8f%8a%e7%89%a9%e7%90%86%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84/image-20230308153818080.png" alt="image-20230308153818080" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>●虽然要检索很多行，
但是可以只使用索引不使用基本表。&lt;/p>
&lt;p>●即&lt;strong>只查询索引的值&lt;/strong>，此时&lt;strong>不需要读取基本表&lt;/strong>。&lt;/p>
&lt;p>以上可以总结&lt;strong>使用B+树索引的两个条件（索引可用性）&lt;/strong>:&lt;/p>
&lt;p>1、只需要获取少量的行;&lt;/p>
&lt;p>2、即便获取很多行，但是可以只使用索引不使用基本表。&lt;/p>
&lt;p>但索引读取是复杂的事情，记录的位置也会导致索引效率的不同。&lt;/p>
&lt;p>下图是5条记录在同一块，和不在同一块的索引次数对比：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e7%b4%a2%e5%bc%95%e5%8f%8a%e7%89%a9%e7%90%86%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84/image-20230308154251969.png" alt="image-20230308154251969" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>为什么很多查询在开发环境中运行效率都比生产环境高呢?&lt;/strong>&lt;/p>
&lt;p>因为往往生成的记录是按顺序一起插入的，&lt;strong>记录的存储顺序和索引的顺序非常相似&lt;/strong>，所以当读完索引后就能用最小的代价读取所检索到的记录。&lt;/p>
&lt;p>但是&lt;strong>生产环境下&lt;/strong>，由于并发、修改以及各种情况的产生，真实的数据很可能是&lt;strong>混乱地分散在硬盘的不同块中&lt;/strong>的，这时查询效率必然会下降。&lt;/p>
&lt;p>&lt;strong>解决办法：&lt;/strong>&lt;/p>
&lt;p>只有在&lt;strong>开发环境测试并且远超过需求的性能标准&lt;/strong>，这样才能在&lt;strong>生产环境达到需求的性能指标&lt;/strong>&lt;/p>
&lt;p>&lt;strong>总结&lt;/strong>&lt;/p>
&lt;p>索引是一个非常复杂的存在。虽然它的结构很简单，但是使用中会&lt;strong>受到很多复杂因素的影响&lt;/strong>。&lt;/p>
&lt;p>因为索引的成本很大，所以我们要&lt;strong>谨慎地选择构建索引&lt;/strong>，务必让索引变得可用。&lt;/p>
&lt;h2 id="3哈希索引和函数索引">3.哈希索引和函数索引&lt;/h2>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e7%b4%a2%e5%bc%95%e5%8f%8a%e7%89%a9%e7%90%86%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84/image-20230308154630283.png" alt="image-20230308154630283" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>学习索引的方法：&lt;/p>
&lt;ol>
&lt;li>学习结构&lt;/li>
&lt;li>根据结构找出特点和作用&lt;/li>
&lt;/ol>
&lt;h3 id="31哈希索引">3.1哈希索引&lt;/h3>
&lt;p>&lt;strong>哈希索引的结构&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e7%b4%a2%e5%bc%95%e5%8f%8a%e7%89%a9%e7%90%86%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84/image-20230308154825502.png" alt="image-20230308154825502" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>所有的数据类型，通过哈希函数变成一个&lt;strong>等长的哈希值&lt;/strong>。&lt;/p>
&lt;p>将这个&lt;strong>等长的哈希值&lt;/strong>作为&lt;strong>组织成索引的结构 —— 哈希链表&lt;/strong>。&lt;/p>
&lt;p>哈希链表的结点上，储存哈希值 和 指向记录哈希值的地址 uid（索引行的地址）。&lt;/p>
&lt;p>&lt;strong>哈希索引能做什么不能做什么？&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>哈希索引只能用来进行&lt;strong>全键值&lt;/strong>的查询
&lt;ul>
&lt;li>不能前缀查询&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>哈希索引只支持&lt;strong>击中运算符&lt;/strong>
&lt;ul>
&lt;li>击中运算符：= , != , in&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>哈希索引&lt;strong>不支持对字段排序&lt;/strong>&lt;/li>
&lt;li>哈希索引&lt;strong>不支持范围查询&lt;/strong>&lt;/li>
&lt;li>哈希索引&lt;strong>读取效率高于B树索引&lt;/strong>
&lt;ul>
&lt;li>哈希索引结构非常紧凑.&lt;/li>
&lt;li>哈希索引&lt;strong>使用数值的比较&lt;/strong>,远高于字符串比较速度.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>碰撞率的问题&lt;/strong>&lt;/p>
&lt;p>碰撞指不同的字段值，通过计算得到了相同的哈希值，而碰撞发生的频繁程度就是碰撞率。&lt;/p>
&lt;p>当发生碰撞时，存储引擎必须访问链表中相同哈希值的&lt;strong>每一个行&lt;/strong>指针，然后&lt;strong>逐行进行数据比较&lt;/strong>，以确定正确的数据。&lt;/p>
&lt;ul>
&lt;li>如果有很多碰撞，一些索引维护操作就有可能会变慢。如果在一个&lt;strong>选择性很低的列&lt;/strong>(&lt;strong>列的基数占总行数&lt;/strong>的比例低) 上创建哈希索引就会产生很多碰撞.&lt;/li>
&lt;li>这时假如从表中删除一行,那么从索引中&lt;strong>找到这一行的代价会很高&lt;/strong>。存储引擎将&lt;strong>不得不检查哈希键链表中的每一行&lt;/strong>，以找到和移除被删除行的索引。&lt;/li>
&lt;/ul>
&lt;p>数据仓库层面中的&lt;strong>星型结构&lt;/strong>, 在查找很多表的连接时, 哈希索引正是其所需要的.&lt;/p>
&lt;p>&lt;strong>mysql中不同引擎 对哈希索引的支持&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>只有Memory引擎有显式的哈希索引&lt;/li>
&lt;li>NBD cluster存储引擎支持唯一的哈希索引&lt;/li>
&lt;li>InnoDB引擎有&lt;strong>自适应哈希索引&lt;/strong>
&lt;ul>
&lt;li>当存储引擎发现一些索引值被频率很高访问时,将自动在B+树的顶端构建哈希索引.&lt;/li>
&lt;li>这时的B+树索引有哈希索引的特征 &amp;mdash;- 很快的哈希索引.&lt;/li>
&lt;li>但是自动的过程,不能控制也不能配置.&lt;/li>
&lt;li>即&lt;strong>越使用某个查询, 查询越快&lt;/strong>.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="32函数索引">3.2函数索引&lt;/h3>
&lt;p>B树索引是对一个字段构建索引,而函数索引是对&lt;strong>这个字段上的一个函数值&lt;/strong>构建索引.&lt;/p>
&lt;p>&lt;strong>结构同样是B+树索引,只是叶节点的值是函数的值而不是字段值.&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>B+树索引 , B+树上对X构建索引,&lt;/li>
&lt;li>函数索引, B+树上对F(x)的值构建索引&lt;/li>
&lt;li>但他们叶子结点指向的地址,&lt;strong>都是字段对应的地址&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>是最具创造力的索引结构,用得好可用解决并发冲突,优化存储结构.等很多事情.&lt;/p>
&lt;p>&lt;strong>能用在哪&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>不区分大小写&lt;/strong>查询&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>T、F比例巨大差异&lt;/strong>的查询&lt;/p>
&lt;blockquote>
&lt;p>有一个事务处理的表，处理过的事务记录，flag取值为T或者Y,而没有处理的
就是F或者N。时间一久，表中大部分记录都是T,而少部分记录是F。&lt;/p>
&lt;p>怎么才能在
索引中不记录T的记录，只把flag的值 等于F的记录记在索引结构中呢?&lt;/p>
&lt;p>答案:给flag做&amp;ndash;个函数索引。&lt;/p>
&lt;p>解析:编写一个函数，如果是T，就返回NULL;如果是F，就返回一个非NULL的
值。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>有选择的唯一性&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e7%b4%a2%e5%bc%95%e5%8f%8a%e7%89%a9%e7%90%86%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84/image-20230308161603917.png" alt="image-20230308161603917" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>项目表有两个状态, active和inactive.&lt;/p>
&lt;p>要求active的项目,必须要有唯一名. 而inactive没有这个要求.&lt;/p>
&lt;p>解决方法: &lt;strong>函数索引上构建唯一索引&lt;/strong>.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="4位图索引和位图连续索引">4.位图索引和位图连续索引&lt;/h2>
&lt;h3 id="41-位图索引-oracle独有的">4.1 位图索引 oracle独有的&lt;/h3>
&lt;p>结构: 用一个&lt;strong>索引键条目存储指向多行&lt;/strong>的指针。01图&lt;/p>
&lt;ul>
&lt;li>B树索引中，索引键和表中的行存在着对应关系，-一个索引就指向一行;&lt;/li>
&lt;li>位图索引中，可能&lt;strong>只有很少的索引条目&lt;/strong>，但&lt;strong>每个索引指向多行&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e7%b4%a2%e5%bc%95%e5%8f%8a%e7%89%a9%e7%90%86%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84/image-20230227155733844.png" alt="image-20230227155733844" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>统计行数非常快&lt;/strong>.压缩地很紧凑&lt;/p>
&lt;p>&lt;strong>位图索引适合&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>相异基数(distinct cardinality)低&lt;/strong>的字段进行快速查询 (复合查询)
&lt;ul>
&lt;li>可以取的值的范围小: 性别、真假,年龄段 等.&lt;/li>
&lt;li>使用B树索引,需要复合索引时 组合数多. 且共同的值多, 可能使得叶子结点远少于索引结点.&lt;/li>
&lt;li>使用哈希索引,碰撞率贼高.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>大量临时查询的聚合&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e7%b4%a2%e5%bc%95%e5%8f%8a%e7%89%a9%e7%90%86%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84/image-20230308162526006.png" alt="image-20230308162526006" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>缺点&lt;/strong>: &lt;strong>对于写操作非常不友好&lt;/strong>&lt;/p>
&lt;p>&lt;strong>原因&lt;/strong>: 位图索引的&lt;strong>键值指向多行&lt;/strong>, 如果一个session修改了一个索引的数据,则&lt;strong>该索引指向的所有行都会被查找到&lt;/strong>.无法锁定单独一个条目,&lt;strong>可能在修改时要锁住整个目录&lt;/strong>,导致并发性下降严重 几乎变成串行化.&lt;/p>
&lt;p>这就是位图索引&lt;strong>不能应用在OLTP&lt;/strong>应用中的原因.&lt;/p>
&lt;h3 id="42-位图连结索引--bitmap-join-index">4.2 位图连结索引 bitmap join index&lt;/h3>
&lt;p>oracle 九代? 之后,出现的.&lt;/p>
&lt;p>一般情况下,我们都是在 &lt;strong>一张表上建立索引,且只使用这个表上的列&lt;/strong>.&lt;/p>
&lt;p>而位图联结索引:&lt;/p>
&lt;ul>
&lt;li>允许使用&lt;strong>另外某个表的列&lt;/strong> 对 &lt;strong>一个给定表&lt;/strong> 建立索引。&lt;/li>
&lt;li>实际上，这就是允许&lt;strong>对一个索引结构&lt;/strong>(而不是表本身)中的数据进行&lt;strong>逆规范化&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>下图的例子,常常需要对多个表进行联结后进行查询.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e7%b4%a2%e5%bc%95%e5%8f%8a%e7%89%a9%e7%90%86%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84/image-20230308164014658.png" alt="image-20230308164014658" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>一般的索引方法:&lt;/p>
&lt;ul>
&lt;li>在部门表的部门名称上构建一个索引,,&lt;/li>
&lt;li>并用它来查询 部门名称为&amp;quot;销售&amp;quot; 的所有部门编号id&lt;/li>
&lt;li>再回到员工表使用索引 查找根据部门编号匹配的行.&lt;/li>
&lt;/ul>
&lt;p>位图联结索引:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>对部门名称建立索引后,指向员工表&lt;/strong>.&lt;/li>
&lt;/ul>
&lt;p>位图联结索引的&lt;strong>前提条件&lt;/strong>:&lt;/p>
&lt;p>&lt;strong>必须连接到另一张表的主键/唯一键&lt;/strong>&lt;/p>
&lt;h3 id="43mysql没有位图索引该怎么办">&lt;strong>4.3Mysql没有位图索引,该怎么办&lt;/strong>&lt;/h3>
&lt;p>1.优化替代&lt;strong>索引组合&lt;/strong>:(&lt;strong>传统办法&lt;/strong>)&lt;/p>
&lt;ul>
&lt;li>Select * from profiles where sex= &amp;lsquo;M’ order by rating limit 10;
可以添加sex，rating列上的&lt;strong>复合索引&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>2.&lt;strong>低选择性添加特殊索引&lt;/strong> 最重要的手段&lt;/p>
&lt;ul>
&lt;li>select * from profiles wheresex= &amp;lsquo;M’ order by rating limit 100000, 10;
依旧很慢，更好的策略是&lt;strong>限制用户查看的页数&lt;/strong>。&lt;/li>
&lt;li>也可以: Select * from t inner join (
Select id from t
Where x.sex = &amp;rsquo;m&amp;rsquo; order by rating limit 100000, 10) AS x USING id;&lt;/li>
&lt;/ul>
&lt;p>Google刚发布时用了limit限制, 如果看很后面的页数还是会很卡. 后面直接最多限制20页.&lt;/p>
&lt;h2 id="5索引使用的典型问题">5.索引使用的典型问题&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>使不使用索引大部分情况&lt;/strong>由数据库引擎自己决定&lt;/li>
&lt;li>程序员&lt;strong>只负责构建索引&lt;/strong>，数据库&lt;strong>引擎判断是否应该使用索引&lt;/strong>&lt;/li>
&lt;li>&lt;strong>如果索引不被查询使用&lt;/strong>，将产生巨大的负担，就不该被构建&lt;/li>
&lt;/ul>
&lt;p>索引使用的典型问题&lt;/p>
&lt;ul>
&lt;li>函数和类型转化对索引的影响&lt;/li>
&lt;li>索引和外键&lt;/li>
&lt;li>同一个字段，多个索引&lt;/li>
&lt;li>系统生成键&lt;/li>
&lt;/ul>
&lt;h3 id="51函数和类型转化对索引的影响">5.1函数和类型转化对索引的影响&lt;/h3>
&lt;p>Where f(indexed_col)=some value&lt;/p>
&lt;p>这种检索条件会使索引无法发挥作用&lt;/p>
&lt;ul>
&lt;li>&lt;strong>函数&lt;/strong>&lt;/li>
&lt;li>&lt;strong>隐式类型转化&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>例:&lt;strong>字符串列和数字比较时&lt;/strong>，大多数数据库引擎不会立即生成运行时错误，
而是&lt;strong>隐式地将字符串列转换为数字&lt;/strong>。此时会&lt;strong>跳过索引&lt;/strong>。&lt;/p>
&lt;h3 id="52外键索引的问题">5.2外键索引的问题&lt;/h3>
&lt;p>系统对外键建立索引很&lt;strong>普遍&lt;/strong>。&lt;/p>
&lt;p>为什么要对外键建立索引？&lt;/p>
&lt;ul>
&lt;li>删除操作时，可以快速通过外键的索引找到要删除的行。&lt;/li>
&lt;li>并发时需要 A表加锁/B表加锁。 添加索引能够让上锁后操作的时间边短。&lt;/li>
&lt;li>&lt;strong>例外&lt;/strong>：表B只是一个字典表，就不需要对表A的外键建立索引。
&lt;ul>
&lt;li>因为字典表不容易被修改。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>建立索引必须有理由
, 无论是对外键，或是其他字段都是如此.&lt;/p>
&lt;h3 id="53同一字段多个索引">5.3同一字段，多个索引&lt;/h3>
&lt;p>索引中字段顺序影响大，但表中顺序无影响。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e7%b4%a2%e5%bc%95%e5%8f%8a%e7%89%a9%e7%90%86%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84/image-20230308193218951.png" alt="image-20230308193218951" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>如这个Order_details是由两个外键构成. 且Article是字典表,因此article_id不需要构建索引.&lt;/p>
&lt;p>如果Order_id 在前面,article_id在后, 则自动构建的索引是复合索引(Order_id,article_id),此时只需要一个索引.&lt;/p>
&lt;p>如果article_id在前,Order_id 在后, 则自动构建的索引是复合索引(article_id,order_id),此时还需要一个外键索引order_id, 共有两个索引.性能下降.&lt;/p>
&lt;h3 id="54系统生成键">5.4系统生成键&lt;/h3>
&lt;p>构建数据库时经常使用&lt;strong>系统提供自增字段&lt;/strong>,作为主键 它性能也最高。&lt;/p>
&lt;p>系统生成键:&lt;/p>
&lt;ul>
&lt;li>系统生产序列号远好于
寻找当前最大值并加1
并 用一个专用表保存“下一个值”且加锁更新&lt;/li>
&lt;/ul>
&lt;p>但系统生成键作为主键仍然存在并发的问题:&lt;/p>
&lt;ul>
&lt;li>主键索引的主要用途是&lt;strong>确保主键的唯一性&lt;/strong>.&lt;/li>
&lt;li>并发插入时 &lt;strong>生成的序列号非常接近&lt;/strong>,将&lt;strong>键值插入到主键索引中同一个块&lt;/strong>的可能性变大了.&lt;/li>
&lt;li>此时进程将竞争同一个索引页,插入并发性大幅度下降.&lt;/li>
&lt;/ul>
&lt;p>解决方案：反向键索引,此时属于同一个结点的块几率更小.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e7%b4%a2%e5%bc%95%e5%8f%8a%e7%89%a9%e7%90%86%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84/image-20230227161032966.png" alt="image-20230227161032966" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="总结为什么查询优化器没有使用我创建的索引">总结:为什么查询优化器没有使用我创建的索引?&lt;/h3>
&lt;p>情况1:&lt;strong>索引列不在使用的最前列(复合索引时)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>假设: T, T(X,Y)上有索引，做SELECT * FROM T WHERE Y=5&lt;/li>
&lt;/ul>
&lt;p>情况2: B树索引&lt;strong>不能为NULL建立索引条目&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>使用SELECT COUNT(*) FROMT,而且T上有索引，但是优化器仍然全表扫描&lt;/li>
&lt;/ul>
&lt;p>情况3:函数值问题&lt;/p>
&lt;p>情况4:隐形函数转化&lt;/p>
&lt;p>情况5:使用索引，实际反而会更慢.&lt;/p>
&lt;ul>
&lt;li>当做了测试后,证明索引确实能提高查询效率时,才建立索引.&lt;/li>
&lt;/ul>
&lt;p>情况6:查询优化器做出了错误的判断&lt;/p>
&lt;ul>
&lt;li>优化器根据统计信息来判断索引的使用.&lt;/li>
&lt;li>没有正确的统计信息，造成查询优化器无法做出正确的选择&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>不使用索引原因&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>不能使用索引，使用索引会返回不正确的结果&lt;/li>
&lt;li>不该使用索引，如果使用了索引就会变得更慢&lt;/li>
&lt;/ul>
&lt;p>总结: 根据索引访问的不同特点, 充分理解要处理的数据做出合理的判断，才能获得高效方案。&lt;/p>
&lt;h2 id="6数据库的物理组织形式">6.数据库的物理组织形式&lt;/h2>
&lt;p>这里的物理实现是讲基本概念, cmu15-445更详细.&lt;/p>
&lt;p>&lt;strong>关系型数据库的核心特点: 读写冲突&lt;/strong>&lt;/p>
&lt;p>在并发用户数很大的系统时,选择&lt;/p>
&lt;ul>
&lt;li>尽量以紧凑的方式存储数据,利于读&lt;/li>
&lt;li>尽量将数据分散存储,利于并发写入&lt;/li>
&lt;/ul>
&lt;p>数据库基本的物理存储细节&lt;/p>
&lt;ul>
&lt;li>数据查询要快, 要建立索引&lt;/li>
&lt;li>数据更新要快, 不要建立索引&lt;/li>
&lt;/ul>
&lt;p>但没有两全其美的&lt;strong>并发的修改密集型&lt;/strong>, 即不能做到 查询快时更新也快.&lt;/p>
&lt;p>核心思想：&lt;/p>
&lt;p>所有&lt;strong>有利于读的技术一定不利于写&lt;/strong>，&lt;strong>有利于写的技术一定不利于读&lt;/strong>.&lt;/p>
&lt;p>如果都有利于,则会丧失一些特征. 如 NoSOL放弃的是关系型数据库的强一致性的特点.&lt;/p>
&lt;h3 id="61-页模式">6.1 页模式&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e7%b4%a2%e5%bc%95%e5%8f%8a%e7%89%a9%e7%90%86%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84/image-20230227161540696.png" alt="image-20230227161540696" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>行迁移&lt;/strong>: 块被填满 且 修改记录变大时, 一个块会分裂成两个块.也就是一条记录存在两个块中. 物理IO读次数增加到2.&lt;/p>
&lt;p>如果记录继续变大填满了两个块, 则数据库会找一个非常大的块来容纳该条记录 并 删除原来两个块. 以防多次行迁移.&lt;/p>
&lt;p>多次行迁移的发生,是数据库使用越久越慢的原因.&lt;/p>
&lt;p>&lt;strong>为了避免行迁移&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>数据库使用更为冗余的策略:
保持大概30%的空间来处理未来的更新。&lt;/p>
&lt;ul>
&lt;li>也就是说, 块被填满70%的空间时，对数据库引擎来说，不能再插入记录。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>每一页将通过前后指针, 将块组织成链表模式, 其目的是优化全表查询效率&lt;/p>
&lt;/li>
&lt;li>
&lt;p>目录页的本质也是页，普通页中存的数据是项目数据，而目录页中
存的数据是普通页的地址。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>表的物理存储是一一个树状的结构。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>所有的叶节点都是&lt;strong>随机文件&lt;/strong>，是&lt;strong>堆文件的组织形式&lt;/strong>。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>以上也是数据库基本的物理存储细节.&lt;/p>
&lt;h3 id="62把索引当成数据仓库">6.2把索引当成数据仓库&lt;/h3>
&lt;p>把尽量在索引中多存储数据的原则扩展到极限，构建一个&lt;strong>以主键为首位的索引&lt;/strong>，&lt;strong>存储表中所有的数据&lt;/strong>。 即(复合索引包括所有列)&lt;/p>
&lt;p>即索引本身就是表.&lt;/p>
&lt;p>Oracle中的对应的数据存储模式: IOT， &lt;strong>索引组织表&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>比较索引组织表与只有主键索引的表插入的开销&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e7%b4%a2%e5%bc%95%e5%8f%8a%e7%89%a9%e7%90%86%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84/image-20230308200056061.png" alt="image-20230308200056061" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;ul>
&lt;li>IOT是一种&lt;strong>顺序文件&lt;/strong>，麻烦的两件事是&lt;strong>宽表的随机插入(复合索引字段多)&lt;strong>和&lt;/strong>数据包含长字符串&lt;/strong>。&lt;/li>
&lt;li>对于正常的事务型数据库使用IOT是得不偿失的.&lt;/li>
&lt;/ul>
&lt;p>IOT最大的优点：&lt;strong>内部已经排好序&lt;/strong>，利于范围的查询 如时间范围搜寻.&lt;/p>
&lt;h3 id="记录强制排序">记录强制排序&lt;/h3>
&lt;p>为了使得&lt;strong>表中数据有序&lt;/strong>, 很多数据库使用了&lt;strong>聚簇索引&lt;/strong>.&lt;/p>
&lt;p>聚簇索引
-clustered index
或者 -clustering index&lt;/p>
&lt;ul>
&lt;li>
&lt;p>范围查询效率非常高&lt;/p>
&lt;/li>
&lt;li>
&lt;p>代价:非范围查询也要进行范围扫描&lt;/p>
&lt;/li>
&lt;li>
&lt;p>主键更新会导致记录的重新排序，从而导致记录物理位置的变化&lt;/p>
&lt;/li>
&lt;li>
&lt;p>为了更加安全, 聚簇索引可以和索引组织表一样，根据主键来定义. 因为主键被更新的概率小,或者说不应该被更新.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>聚簇索引也可以是非主键索引,这是和索引组织表不一样的地方.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e7%b4%a2%e5%bc%95%e5%8f%8a%e7%89%a9%e7%90%86%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84/image-20230227162104411.png" alt="image-20230227162104411" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>一旦出现&lt;strong>范围查询&lt;/strong>,聚簇索引的性能是非聚簇索引的二十倍.&lt;/p>
&lt;h3 id="总结">总结&lt;/h3>
&lt;p>聚簇索引, 索引组织表, 这种从物理结构上的优化, 必然存在明显的缺点.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e7%b4%a2%e5%bc%95%e5%8f%8a%e7%89%a9%e7%90%86%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84/image-20230227162152856.png" alt="image-20230227162152856" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>聚簇结构&lt;/strong>&lt;/p>
&lt;p>优点:某些情况下能成倍地，一个数量级地提高效率。&lt;/p>
&lt;p>缺点:会使其它操作的效率降低。&lt;/p>
&lt;p>&lt;strong>优化方案&lt;/strong>:&lt;/p>
&lt;p>可以和社交网络, nosql一样.&lt;/p>
&lt;p>用顺序文件实现数据组织, 同时需要禁止一切更新操作.&lt;/p>
&lt;h2 id="7分区的介绍">7.分区的介绍&lt;/h2>
&lt;p>分区(partition)也是一种最常用的物理组织技术. 也是数据分组的方式.&lt;/p>
&lt;p>可以很好的应对大数据量和高并发.&lt;/p>
&lt;p>分区，简单地讲，就是将一个大型的表，在物理上分成多个小型的表。但借助数据库引擎，看到的仍是一张完整的表.&lt;/p>
&lt;p>分区使得查询效率和并发(concurrency)效率在很多情况下得到提升. 并且这种方式是可以自然扩充的. 即系统架构的可伸缩性 (scalable)&lt;/p>
&lt;p>分区采用的是分而治之思想, 但分而治之不一定对所有事情有帮助, 比如对于售后来说基本上没有什么差别.&lt;/p>
&lt;p>要从以下几点了解分区:&lt;/p>
&lt;ul>
&lt;li>分区的底层逻辑是什么?&lt;/li>
&lt;li>有哪几种分区的方式?&lt;/li>
&lt;li>每种分区方式能解决什么样的问题?&lt;/li>
&lt;li>不同的分区方式对项目会带来怎么样的影响?&lt;/li>
&lt;/ul>
&lt;h3 id="71循环分区">7.1循环分区&lt;/h3>
&lt;p>分区技术的由来&lt;/p>
&lt;p>最早由sybase提出分区这个概念，把60G的数据分成10个区，也就是10个
物理文件。这样，每次备份，相当于顺序备份十个文件，每个文件6分钟。&lt;/p>
&lt;p>因此分区最早&lt;strong>用于数据库高效管理&lt;/strong>的而不是数据管理.&lt;/p>
&lt;p>那个时候使用的是&lt;strong>循环分区&lt;/strong>, 不受数据影响的内部机制。&lt;/p>
&lt;ul>
&lt;li>分区定义为各个磁盘的存储区域，插入数据时，数据会按照某种方法循环的加载到各个分区上，以保持插入时磁盘IO操作的平衡。&lt;/li>
&lt;li>对并发的随机查询很有帮助(&lt;strong>即越分散越适合并发&lt;/strong>)，循环分区可以看作是随机分布数据的一
种机制。&lt;/li>
&lt;/ul>
&lt;p>和循环分区很像, 分布式，也是一种分散的方式，也是一种&lt;strong>透明分散&lt;/strong>的逻辑。&lt;/p>
&lt;p>循环分区是为了方便管理,但开发者发现了分区的好处, 为了方便开发者, 出现了数据驱动分区.&lt;/p>
&lt;h3 id="72-数据驱动分区">7.2 数据驱动分区&lt;/h3>
&lt;p>数据驱动的分区，最核心的一个概念是&lt;strong>分区键(partition key)&lt;/strong>,&lt;/p>
&lt;p>也就是说, 分区时根据&lt;strong>一个或多个字段的值&lt;/strong>，来决定这条记录应该放入哪个分区中。此时不同分区的数据有 或强或弱的联系.&lt;/p>
&lt;blockquote>
&lt;p>就像范围查询一样: 如果某一个&lt;strong>范围的数据都集中在一个页&lt;/strong>中，那么&lt;strong>查询的效率将大幅度提高&lt;/strong>。&lt;/p>
&lt;/blockquote>
&lt;p>分区也一样，只不过粒度从页扩展到了分区。&lt;/p>
&lt;p>&lt;strong>滑动窗口&lt;/strong>是 &lt;strong>最早数据驱动分区&lt;/strong>方式。&lt;/p>
&lt;p>最大的数据库一般都是金融业, 电信, 移动互联网, 社交网络.&lt;/p>
&lt;p>&lt;strong>大量的历史数据&lt;/strong> 就是其数据库庞大的主要原因.&lt;/p>
&lt;p>但现实往往对&lt;strong>最新的数据比较感兴趣&lt;/strong>, 随着数据的增加, 对历史数据的兴趣会消退.&lt;/p>
&lt;p>&lt;strong>最常被查询的往往是那些可把比较新的数据&lt;/strong>。&lt;/p>
&lt;p>因此，&lt;strong>以根据日期/时间进行分区&lt;/strong>，&lt;strong>常用的数据和不常用的数据分别放在不同的分区当中.&lt;/strong>&lt;/p>
&lt;p>&lt;strong>总结&lt;/strong>:&lt;/p>
&lt;p>分区实现的本质: 逻辑上是一张表，物理上是多个物理文件，甚至是多个物理环境.&lt;/p>
&lt;p>&lt;strong>OB的表分区就是生成多个副本，存储在不同区域的OB服务器中&lt;/strong>&lt;/p>
&lt;h2 id="8分区的方式和应用">8.分区的方式和应用&lt;/h2>
&lt;h3 id="81数据驱动分区的实现方式">8.1数据驱动分区的实现方式&lt;/h3>
&lt;p>用数据值来划分分区&lt;/p>
&lt;p>&lt;strong>哈希分区(Hash-partitioning)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>对&lt;strong>分区键进行哈希运算&lt;/strong>，根据运算结果进行分区.&lt;/li>
&lt;li>能保证&lt;strong>根据分区键可以快速找到记录&lt;/strong>，但对范围搜索没有任何帮助。&lt;/li>
&lt;li>其实更接近与循环分区, 只是它还能 负载均衡提高并发的能力.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>范围分区(Range- partitioning)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>滑动窗口，就是范围分区，根据连续数据的范围对数据进行分区。&lt;/li>
&lt;li>&lt;strong>非常适合处理历史数据&lt;/strong>，每一个分区专门用来存储特定范围内的数据。&lt;/li>
&lt;li>一般系统还会设定else分区,来存储所有&lt;strong>可能漏网的数据&lt;/strong>(其他)&lt;/li>
&lt;li>应用: 时间范围, 字母范围&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>列表分区(List-partitioning)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>是一种最具手工风格的分区类型，适合&lt;strong>定制某种特殊的解决方案&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>分区键必须明确指定&lt;/strong>，但&lt;strong>分区键只能有一列&lt;/strong>，不能像范围或者哈希分区那样同时指定多个列做为分区键，但它的&lt;strong>单个分区对应值可以是多个&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>一旦插入的列值不在分区范围内，则插入/更新就会失败.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>因此
通常建议使用列表分区时，要创建一个&lt;strong>default分区&lt;/strong>存储那些&lt;strong>不在指定列表内的记录&lt;/strong>。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>很多数据库中分区可以嵌套，即分区可以再建立子分区，叫sub partition.子分区是分区内的分区。&lt;/p>
&lt;ul>
&lt;li>一种二位分区处理的方法，比如在时间的分区中，建立哈希分区等&lt;/li>
&lt;li>&lt;strong>OB把它叫做二级分区&lt;/strong>，再举个例子，&lt;strong>类似于用户账单领域，会按照user id做哈希分区，按照账单创建时间做范围分区&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>数据驱动的分区是最常使用的分区方式，用数据值本身作为分区的基础，这时候&lt;strong>数据分区最具有开发使用的价值&lt;/strong>。&lt;/p>
&lt;h3 id="82分区是把双刃剑">8.2分区是把双刃剑&lt;/h3>
&lt;p>&lt;strong>数据驱动的分区并没有全部地解决并发问题&lt;/strong>.&lt;/p>
&lt;p>例如，一个表如果按照时间分区，把一年的数据按星期分入五十二个不同的分区中，&lt;strong>查询起来确实非常快&lt;/strong>, &lt;strong>但更新呢?&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>如果滑动窗口是52个星期, 则每个星期的事务将&lt;strong>涌入同一个分区&lt;/strong> 来插入新数据库.&lt;/li>
&lt;li>此时,并发开销，内存争用都会大幅度提升，因为大型表中的其它数据都不访问&lt;strong>只访问最近的区域&lt;/strong>.&lt;/li>
&lt;/ul>
&lt;p>有时候，52个分区这样的滑动窗口也没有任何问题，比如数据仓库中，所有的数据都是通过单一进程进行插入，根本毫无并发压力。&lt;/p>
&lt;p>按照地理分区来方便插入时, 一旦进行时间范围查询, 反而此时数据分散, 效率很低.&lt;/p>
&lt;p>但最常使用的方式是多层分区的方式, 先时间分区,再地区分区.&lt;/p>
&lt;p>&lt;strong>IOT类似的问题:“冲突”&lt;/strong>&lt;/p>
&lt;p>A.通过分区键将数据聚集，利于高速检索;&lt;/p>
&lt;p>B.对于并发执行的插入操作，分散的数据可以避免访问过于集中的问题。&lt;/p>
&lt;p>在时间空间中, AB目标可能是相互矛盾的. 所以需要搞清楚主要问题是什么,并且根据主要问题进行分区. 同时计算两方面的得失,看看结果是否可以接受.&lt;/p>
&lt;p>因为&lt;strong>数据库的性能是以吞吐量为指标,而不是某一类型的操作效率.&lt;/strong>&lt;/p>
&lt;h3 id="83分区与数据分布">8.3分区与数据分布&lt;/h3>
&lt;p>表非常大，且希望避免并发写入数据的冲突就一定要用分区吗?&lt;/p>
&lt;ul>
&lt;li>假设有一个客户订单明细表，该表中大部分数据都来自于同一个客户20%的客户贡献了80%的销量，&lt;/li>
&lt;li>那么&lt;strong>按照客户的ID对数据进行分区&lt;/strong>，就&lt;strong>不会有太大的帮助&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>查询小客户数据: 在客户ID上的索引可选择性就会很高，因此查询效率也会很高。&lt;/p>
&lt;ul>
&lt;li>此时&lt;strong>完全不需要分区&lt;/strong>.&lt;/li>
&lt;li>聪明的查询优化器在获得关于键值分布的统计数据
之后，就可以检测到数据分布的不均衡，&lt;strong>而选择使用索引&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>查询大客户数据:&lt;/p>
&lt;ul>
&lt;li>优化器也知道&lt;strong>扫描表是效率最高的处理方式&lt;/strong>，由于
大客户的数据在表中占很大的比例，比如80%， 仅仅扫描该客户所在的分区&lt;strong>并不比全表扫描快多少&lt;/strong>，
所以性能提升也不大。&lt;/li>
&lt;/ul>
&lt;p>对分区表进行查询时，当&lt;strong>数据按分区键均匀分布时，&lt;/strong>
&lt;strong>收益最大&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>比如时间分区，往往一年
中多个分区的数据相对比较&lt;strong>均衡&lt;/strong>，&lt;strong>均衡分布，使用分区的收益才是最大的&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;h3 id="84数据分区的最佳方法">8.4数据分区的最佳方法&lt;/h3>
&lt;p>整体改善业务处理的操作,才是&lt;strong>选择分区的目标&lt;/strong>. 也就是说,改善不合理的业务流程,才是设计的重中之重.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>当有多个处理执行时，解决方案就不应该过度偏袒其中任何一个.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>只要是&lt;strong>根据数据值决定物理位置的存储方式&lt;/strong>，如聚簇索引、分区, &lt;strong>更新数据的代价都非常高&lt;/strong>。&lt;/p>
&lt;ul>
&lt;li>对普通表的更新，几乎是&lt;strong>在物理地址不变&lt;/strong>的情况下进行，最多只是修改和移动表中的一些字节。&lt;/li>
&lt;li>但&lt;strong>如果选择了索引和分区&lt;/strong>，更新很可能导致一系列的删除、插入和
相关的索引、分区的维护工作。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>一旦更新分区键，就像更新索引键值一样，都会&lt;strong>引起数据的移动&lt;/strong>。&lt;/p>
&lt;ul>
&lt;li>分区数据移动的代价更大,因为不同分区的数据移动&lt;strong>可能是不同物理区域,甚至是不同机器的传输和拷贝&lt;/strong>, 一般来说,要&lt;strong>避免不同分区的数据移动&lt;/strong>.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>除了**默认存储方式(堆文件, 单库单表)**外，都会带来复杂性。如果复杂性超过好处,就坚决避免.&lt;/p>
&lt;p>选错存储方式会带来大幅度的性能降低.&lt;/p>
&lt;p>任何需求都会有变化，任何商业的流程都会发生改变，&lt;strong>任何计划周详数据库设计都可能被推倒重来.&lt;/strong>&lt;/p>
&lt;p>在表不段变大的过程中,分区基本上是必然的处理手段,但还是谨慎地选择物理模式 并且小心地测试. 由于最初物理设计不佳而导致大型数据库推倒重来的代价是巨大的.&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/%E9%AB%98%E6%80%A7%E8%83%BD%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E5%8E%9F%E5%88%99/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/%E9%AB%98%E6%80%A7%E8%83%BD%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E5%8E%9F%E5%88%99/</guid><description>&lt;p>计算机程序首要目标完成业务需求。&lt;/p>
&lt;p>容易只重视技术手段，忽略了商业活动的数据质量，仅仅想按期交付完成需求功能的程序。&lt;/p>
&lt;p>&lt;strong>需要关注的问题：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>数据代表了什么&lt;/li>
&lt;li>数据之间有什么关系&lt;/li>
&lt;li>数据能推导出什么有价值的结论&lt;/li>
&lt;li>数据的质量到底怎么样&lt;/li>
&lt;li>怎么提高数据质量&lt;/li>
&lt;/ul>
&lt;p>未来是数据的世界。&lt;/p>
&lt;p>强调良好的模型和合理的数据库设计是任何信息系统的基础，是互联网企业的钱袋子&lt;/p>
&lt;h2 id="1规范化设计">1.规范化设计&lt;/h2>
&lt;p>学习任何数据库产品，无论是关系的，还是非关系的，本质上是对现实世界的一种模型。&lt;/p>
&lt;p>不同类型的数据库，本质上存储数据的模型是不一样。&lt;/p>
&lt;p>和任何模型一样，数据库也不是精确的模型，而仅仅是对纷繁复杂的现实世界有限的描述，对特定的一个业务活动的描述往往不止一种方法。这些在技术上都可以是语义正确的。&lt;/p>
&lt;p>但通常只有一种办法最贴近业务需求。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227205706284.png" alt="image-20230227205706284" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>被接受为真理不需要证明的事实，就是公理体系，其它学科叫原理而推演出来的新事实，就是定理。&lt;/p>
&lt;p>关系表中的一行，就是一个对事实的描述。&lt;/p>
&lt;p>表就相当于公理，通过一张表或者多张表的join操作，获得的其它事实，就是从公理推导出的定理。&lt;/p>
&lt;p>&lt;strong>表是公理系统，视图和查询是定理系统&lt;/strong>。&lt;/p>
&lt;p>保证数据的一致性，即保证基于数据库的任何查询与原始数据具有同样有效性。&lt;/p>
&lt;p>NoSql 无法在数学上保持一致性。&lt;/p>
&lt;h3 id="11关系理论与实现的差异">1.1关系理论与实现的差异&lt;/h3>
&lt;ul>
&lt;li>关系理论中，&lt;strong>关系是不包含重复数据&lt;/strong>的。
&lt;ul>
&lt;li>现实中间结果集包含重复数据。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>关系是处理&lt;strong>无限数据集&lt;/strong>的
&lt;ul>
&lt;li>关系数据库再大，它也是处理有限数据集的，有限数据集不仅要保证正确，
还要提高效率。&lt;/li>
&lt;li>中间结果集的产生，就是不需要把多个表完整的做完笛卡尔积再进行条件的筛选和投影，而是一步一步进行，以提高效率，&lt;strong>中间结果集未必包含全部的字段或者记录&lt;/strong>，有可能出现重复数据。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>关系理论中，&lt;strong>记录之间没有顺序的&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>规范化的原理&lt;/strong>：按照严格的逻辑要求，将不同的数据项组织在一起，变成结构化信息。&lt;/p>
&lt;p>数据库设计的三大范式：为了建立冗余较小、结构合理的数据库，设计数据库时必须遵循一定的规则。&lt;/p>
&lt;p>数据库领域的理想主义者认为数据的分析应超越三范式，至少要满足BC范式，甚至是五范式。&lt;/p>
&lt;p>规范化为什么重要：规范化能让混沌变得有序
数据库的表经过规范化之后，结构非常自然。&lt;/p>
&lt;p>严格逻辑规则的三范式：为清晰地获得常识，提供清单指南。&lt;/p>
&lt;p>&lt;strong>表结构如果没有规范化就会面临天大的风险?&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>主要是数据的不一致性&lt;/li>
&lt;li>不满足规范化，或者模型出现一些问题，会导致数据处理的代码在性能很庞大的数据库应用中犯错率大大提高&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227210328227.png" alt="image-20230227210328227" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h2 id="2字段设计---地址和空值处理">2.字段设计 - 地址和空值处理&lt;/h2>
&lt;p>第一范式
数据库表中的所有字段都是&lt;strong>单一属性，不可再分&lt;/strong>。&lt;/p>
&lt;p>第二范式
数据库的表中不存在非关键字段对任一候选关键字段的&lt;strong>部分函数依赖&lt;/strong>。&lt;/p>
&lt;p>第三范式
在第二范式的基础之上定义的。如果数据表中不存在非关键字段对任意候选关键字段的传递函数依赖则符合第三范式。&lt;/p>
&lt;h3 id="21地址">2.1地址&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227210531541.png" alt="image-20230227210531541" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>把地址拆分成什么程度，取决于要如何使用地址，&lt;strong>业务需求决定原子级的地址属性&lt;/strong>。&lt;/p>
&lt;p>拆分不是凭空揣测，也不是根据书上的或者其它组织项目的拆分的方式，而&lt;strong>只取决于项目的实际情况&lt;/strong>。&lt;/p>
&lt;p>如果将地址继续拆分为小区、楼栋、门牌号等原子型数据项，很多时候会无法处理，甚至需要合并几个字段，会制造麻烦&lt;/p>
&lt;h3 id="22空值的处理">2.2空值的处理&lt;/h3>
&lt;p>空值的核心含义是 &lt;strong>我不知道&lt;/strong>&lt;/p>
&lt;p>一般认为，数据表中，存在空值意味着关系模型设计上存在问题,
因为它会动摇查询优化的基础。&lt;/p>
&lt;p>本质上，关系模型的&lt;strong>完备性是以二值逻辑为基础&lt;/strong>。真或者假。&lt;/p>
&lt;p>如where需要。&lt;/p>
&lt;p>数据库不得不处理这种三值模型，T，F，再加上is null&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230309210351915.png" alt="image-20230309210351915" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>如果在需求中间，有80%的客户，这&lt;strong>三个地址都是一种&lt;/strong>公冒，一个，不是那种公司、是在一起的小公司，那该如何处理？&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227210853582.png" alt="image-20230227210853582" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>隐含逻辑会导致程序逻辑变复杂，代码出错风险提高。&lt;/p>
&lt;p>几乎没有任何十全十美的设计，每一种设计都有麻烦
根据数据的情况，不同类型公司的比例，查询和更新事务的比例，一定存在一个可能最适合的方案，但一定不存在一个一定适合的方案。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227211013862.png" alt="image-20230227211013862" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>空值对程序逻辑是危险的，如果必须使用空值，要清楚它在特定情况的影响，做出最佳性能的设计。&lt;/strong>&lt;/p>
&lt;h2 id="3布尔类型和历史数据">3.布尔类型和历史数据&lt;/h2>
&lt;h3 id="31限用布尔类型">3.1限用布尔类型&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227211205919.png" alt="image-20230227211205919" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>还可以用不同的表来跟踪订单。&lt;/p>
&lt;p>追求数据密度极端的例子:四个属性取值都是T/F， 可以用0-15这16个数值代表
四个属性所有组合状态。但可能违反了原子性的原则。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227211351061.png" alt="image-20230227211351061" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>只有程序员知道，优化器不知道。&lt;/p>
&lt;p>特别是若字符串型的字段&lt;strong>有时包含字符有时包含数字&lt;/strong>，对数据库设计来说不是技巧，而是说明最初的数据库设计，对领域的定义比较混乱。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227211434846.png" alt="image-20230227211434846" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>用更通用的表，然后建立子类型。&lt;/p>
&lt;p>例如:“如果账单寄送地址是null，就是用总部地址
” 不好&lt;/p>
&lt;p>尽可能多的&lt;strong>定义约束&lt;/strong>，把语义的约束通过字段类型
和字段长度放在DBMS中去
检查去约束。&lt;/p>
&lt;p>提高健壮性、可读性扩展性，&lt;strong>数据的语义属于DBMS，别放到应用程序&lt;/strong>中&lt;/p>
&lt;h3 id="32历史数据">3.2历史数据&lt;/h3>
&lt;p>关系设计的真正难题：处理&lt;strong>时间段&lt;/strong>的数据。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227211559404.png" alt="image-20230227211559404" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>可以设置&lt;strong>价值终止时间&lt;/strong>。当前价值有效，终止时间为空。&lt;/p>
&lt;p>但在查询方面有根本缺陷。&lt;/p>
&lt;p>如双十一的价格自动变化。&lt;/p>
&lt;p>当前的价格由当前日期之前的最大日期决定。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230309211503210.png" alt="image-20230309211503210" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>也可用非规范化建模&lt;/p>
&lt;p>当前价格的选择，是每一个产品页面刷新的必须进行的一个数据库操作，操
作非常频繁，为了提高这
个操作的效率，非规范化
打破范式是一个好的选择。&lt;/p>
&lt;p>同时&lt;strong>保存价格失效和生效日期，或者同时保存价格生效日期和有效天数&lt;/strong>。&lt;/p>
&lt;p>此时可以在数据插入或者更新时，增加更多检查以维护数据的完整性，但代价是性能下降。&lt;/p>
&lt;p>&lt;strong>另一种方式&lt;/strong>&lt;/p>
&lt;p>分别创建当前价格表和历史价格表，并定义一个操作触发器，当价格改变时
将数据从当前价格表移到历史价格表。 适合特定应用，但不适合预设价格。&lt;/p>
&lt;p>也可以通过分区的方式
把失效的历史价格丢到历史的分区中，然后所谓的
price_ history表就客观上小多了，查询更快。&lt;/p>
&lt;h2 id="4数据的处理模式和存储设计">4.数据的处理模式和存储设计&lt;/h2>
&lt;h3 id="41处理模式操作模式">4.1处理模式（操作模式）&lt;/h3>
&lt;p>操作模式：指数据应该以&lt;strong>异步模式&lt;/strong>处理(例如批处理系统)
，
还是&lt;strong>同步模式处理&lt;/strong>(例如
实时交易系统)&lt;/p>
&lt;p>操作模式&lt;/p>
&lt;ul>
&lt;li>
&lt;p>异步模式处理(批处理) :是所有数据处理方式的先驱。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>同步模式处理(实时交易)&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>处理数据的方式会影响物理结构的设计&lt;/p>
&lt;ul>
&lt;li>如果某些操作过于复杂，要跨很多系统很多物理环境时，等待同步实时交易，不可控因素会很大，这时需采用异步方式，放弃实时性的好处，而追求更直接的健壮和稳定性&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>大规模的批处理，我们需要关注吞吐量&lt;/strong>&lt;/p>
&lt;p>&lt;strong>如何选择异步和同步&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>选择不同模式，是整个系统需求，以及所处理数据所在的&lt;strong>物理结构所决定&lt;/strong>的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>从性能的角度来说，如果&lt;strong>无需必要，可以不选择同步&lt;/strong>的方式。&lt;/p>
&lt;p>比如网络爬虫，天生就应该使用异步的方式，数据库多库之间的数据传输，也大概率应该采用异步的方式。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>往往采用批处理这种异步方式时，&lt;strong>很容易发现某些事情&lt;/strong>花的时间太长，也
就是异步的批处理方式，比较&lt;strong>容易发现问题&lt;/strong>，批处理系统一-直在压榨系统的
性能。&lt;/p>
&lt;p>&lt;strong>同步不容易发现问题&lt;/strong>，只有在高并发和大数据量时暴露，在最糟的时候才会暴露，会极大影响业务。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>尽量只在必须要同步的时候，才设计成同步，否则都可尝试使用异步模式&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="42存储层面的设计">4.2存储层面的设计&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227212319650.png" alt="image-20230227212319650" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>不需要考虑节点的协调问题。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227212331338.png" alt="image-20230227212331338" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>网格集群包括现在最重要的云计算等皆是采用数据分布式的模式，
经常提到的&lt;strong>OB数据库就是典型的分布式数据库&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>结构越复杂，健壮性越低&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>性能的杀手:对远程数据的透明访问&lt;/strong>&lt;/p>
&lt;p>原因:&lt;/p>
&lt;ul>
&lt;li>无论看起来有多透明，跨多个软件层或者网络层的代价都很高&lt;/li>
&lt;li>试试执行一个在本地数据表中插入几千行数据的代码，相对比的是，执行另一个跨机器的同样程序通过指向连接进行操作。差异是几倍的。&lt;/li>
&lt;li>来自不同数据源的分布式数据结合起来非常困难。比较数据源A和数据源B的数据，必须&lt;strong>拷贝A的数据到B&lt;/strong>，或者反过来，拷贝B的数据到A，无论怎样都要面对开销很大的数据传输的代价。&lt;/li>
&lt;/ul>
&lt;p>远程的数据拷贝，&lt;strong>脱离了数据源环境&lt;/strong>，就&lt;strong>不能从数据规划中获益&lt;/strong>&lt;/p>
&lt;p>理论上来说，查询本地数据最有效的方式是嵌套的循环，程序员知道最佳过滤条件分布，
优化器能快速定位和找到最好的查询计划。&lt;/p>
&lt;p>但如果部分数据位于远程，只能选择：&lt;/p>
&lt;ul>
&lt;li>使用嵌套的循环，每次循环开销很大&lt;/li>
&lt;li>建立远程数据的本地副本，然后操作该副本，但此副本没有任何索引&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>数据库该如何部署？&lt;/strong>&lt;/p>
&lt;p>&lt;strong>平衡&lt;/strong>，离数据越近，访问越快。&lt;/p>
&lt;p>&lt;strong>那为什么说分布式比集中式更快？&lt;/strong>&lt;/p>
&lt;p>因为&lt;strong>吞吐量&lt;/strong>，分布式吞吐量的上限高于集中式。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227212606684.png" alt="image-20230227212606684" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>分布式吞吐量优&lt;/p>
&lt;p>&lt;strong>总结&lt;/strong>&lt;/p>
&lt;p>讨论了进行数据库规划的基础知识，包括数据建模的基本原则，特别是规范化、字段设计、历史数据等等问题。&lt;/p>
&lt;p>以及在不同情况下，错误的设计是如何导致各种后果的。&lt;/p>
&lt;p>忽视基本设计原则，会导致性能问题，而解决这些问题会浪费惊人的精力和智慧。&lt;/p>
&lt;h2 id="81大尺度的问题">8.1大尺度的问题&lt;/h2>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227212741617.png" alt="image-20230227212741617" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>如果一个系统很大，可是还使用过去小尺度下的规则，就会出问题。&lt;/p>
&lt;p>一旦尺度变大，&lt;strong>就需要用工程化的方式去组织，花费更多的成本去协调。&lt;/strong>&lt;/p>
&lt;p>不可能用没有并发的系统，去应付高并发、大数据量场景。&lt;/p>
&lt;p>绝大多数人的编程技术和数据处理能力，都需要在更大的项目中去领悟去提高。&lt;/p>
&lt;p>一个软件系统，一个复杂的数据库，太容易出错。系统越复杂，出错的频率就不成比例地增加。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227212917499.png" alt="image-20230227212917499" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>timestamp不确定&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227212937661.png" alt="image-20230227212937661" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>一个数据库系统整体的工作如果是100%，实现业务需求，所需要的工作大概只有20%，剩下80%的工作是性能、监控、审计、备份、恢复、错误处理安全机制等一系列的工作。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227213016939.png" alt="image-20230227213016939" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227213036444.png" alt="image-20230227213036444" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227213052829.png" alt="image-20230227213052829" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227213106792.png" alt="image-20230227213106792" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227213124961.png" alt="image-20230227213124961" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227213214194.png" alt="image-20230227213214194" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227213226552.png" alt="image-20230227213226552" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>棘手问题
棘手问题不是用来解决的，它也许根本解决不了，只能应付。&lt;/p>
&lt;p>好的判断来自经验
而经验来自坏的判断&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227213342294.png" alt="image-20230227213342294" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E7%AE%97%E6%B3%95/acmer%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E7%AE%97%E6%B3%95/acmer%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98/</guid><description>&lt;h1 id="写在前面">写在前面&lt;/h1>
&lt;p>笔试上机题型基本是经典算法题，且难度最多leetcode hard。但面试的题目类型很多，如场景题、NP问题等没有最优解的问题。&lt;/p>
&lt;p>以下对求职面试算法题做整理，主要面向ACMer，是对比赛中不常见的算法题的补充。&lt;/p>
&lt;p>篇幅有限，仅给出简要思路，正解代码可选择该篇，或者自行搜索。背代码没用，经过思考后自己写一遍，面试时才能写出来。&lt;/p>
&lt;h1 id="经典算法题">经典算法题&lt;/h1>
&lt;h2 id="链表">链表&lt;/h2>
&lt;h3 id="链表翻转-空间o1-时间on">链表翻转 空间O(1) 时间O(n)&lt;/h3>
&lt;h3 id="归并排序链表on-时间onlogn">归并排序链表O(n) 时间O(nlogn)&lt;/h3>
&lt;h2 id="排序">排序&lt;/h2>
&lt;h3 id="手写快排">手写快排&lt;/h3>
&lt;h3 id="无序数组中找第k大数httpsleetcodecnproblemskth-largest-element-in-an-array--on">&lt;a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">无序数组中找第k大数&lt;/a> O(n)&lt;/h3>
&lt;p>补充: 第K大数,而不是第K个不同的数.&lt;/p>
&lt;p>和求排序后的第k个数本质一致,转换一下即可.&lt;/p>
&lt;h4 id="思路">思路&lt;/h4>
&lt;p>回忆一下二分法和快排:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>二分法形成一棵二叉树. 每层所有序列长度总和为n, 二叉树高度为h, 时间复杂度为 O(n*h)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>最优的情况: 每个结点的左儿子和右儿子序列长度相等. h = logn, 时间复杂度为O(n*logn)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>因此快排最优是O(n*logn)&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h4 id="如何优化到on">如何优化到O(n)&lt;/h4>
&lt;p>显然, 对于求排序后第k个数. 在二分时,每次可以只选择一个儿子继续搜索.&lt;/p>
&lt;p>即在最优情况下,每次二分结果为 l,mid,r&lt;/p>
&lt;ul>
&lt;li>mid == k ,答案就是a[mid]&lt;/li>
&lt;li>mid &amp;gt; k, 只需要继续在 (l,mid-1)中搜&lt;/li>
&lt;li>mid &amp;lt; k, 只需要继续在 (mid+1,r)中搜&lt;/li>
&lt;/ul>
&lt;p>因此与快排形成的二叉树不同. 该方法每层的搜索总长度是递减的.&lt;/p>
&lt;p>即 n + n/2 + n/4 + n/8 + &amp;hellip;&lt;/p>
&lt;p>易得上述公式的近似为 2*n, 时间复杂度O(n)&lt;/p>
&lt;h2 id="串">串&lt;/h2>
&lt;h3 id="字符串全排列httpsleetcodecnproblemszi-fu-chuan-de-pai-lie-lcof">&lt;a href="https://leetcode.cn/problems/zi-fu-chuan-de-pai-lie-lcof/" target="_blank" rel="noopener">字符串全排列&lt;/a>&lt;/h3>
&lt;h3 id="最长回文子串---on">最长回文子串&amp;ndash; O(n)&lt;/h3>
&lt;p>思路:&lt;a href="https://blog.csdn.net/qq_51116518/article/details/117370554" target="_blank" rel="noopener">马拉车算法&lt;/a>&lt;/p>
&lt;h4 id="证明on">证明O(n):&lt;/h4>
&lt;p>即证while内的p[i]++ 执行次数总和为O(n)级别&lt;/p>
&lt;p>首先考虑什么情况下才需要进入while循环&lt;/p>
&lt;ul>
&lt;li>i &amp;lt; mx, 且 i 为 id 所在回文串的右四等分点之后.
&lt;ul>
&lt;li>此时p[i]是以mx-i 开始增加, 即i + p[i] &amp;gt;= mx&lt;/li>
&lt;li>也就是while内的操作每执行一次 mx++&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>i &amp;gt; mx, 无法使用之前的预处理.
&lt;ul>
&lt;li>while内的操作没执行一次 mx++&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>可知while的操作次数等于 mx从0加到n-1的次数, 因此while内操作次数的总和为n&lt;/p>
&lt;p>总时间复杂度 O(n)&lt;/p>
&lt;h2 id="动态规划非背包">动态规划(非背包)&lt;/h2>
&lt;h3 id="最长公共连续子序列-onm">最长公共连续子序列 O(nm)&lt;/h3>
&lt;h3 id="最长上升子序列-onlogn">最长上升子序列 O(nlogn)&lt;/h3>
&lt;p>思路:动态规划+二分&lt;/p>
&lt;h2 id="背包类">背包类&lt;/h2>
&lt;p>货币面值组成&lt;/p>
&lt;h3 id="砝码称重httpswwwacwingcomproblemcontentdescription3420-on--s">&lt;a href="https://www.acwing.com/problem/content/description/3420/" target="_blank" rel="noopener">砝码称重&lt;/a> O(n * s)&lt;/h3>
&lt;p>题意：有天平和 N 个砝码重量是 Wi。可以称出多少种不同的重量？砝码可以放在天平两边。&lt;/p>
&lt;p>N&amp;lt;100 ,Σwi &amp;lt; 1e5&lt;/p>
&lt;p>思路：&lt;/p>
&lt;p>01背包， 称重为i的可以从 abs(i-w) ， i+w 中转移。 不过要注意开个滚动数组防止重复放砝码。&lt;/p>
&lt;h2 id="数学题">数学题&lt;/h2>
&lt;h4 id="小凯的疑惑">小凯的疑惑&lt;/h4>
&lt;h1 id="思维题">思维题&lt;/h1>
&lt;h4 id="小球称重问题">小球称重问题&lt;/h4>
&lt;h1 id="np问题">NP问题&lt;/h1>
&lt;h2 id="集合覆盖问题">集合覆盖问题&lt;/h2>
&lt;h1 id="杂项">杂项&lt;/h1>
&lt;h3 id="随机加权采样算法-aliashttpsleetcodecnproblemsrandom-pick-with-weight">&lt;a href="https://leetcode.cn/problems/random-pick-with-weight/" target="_blank" rel="noopener">随机加权采样算法 alias&lt;/a>&lt;/h3>
&lt;p>&lt;a href="https://www.cnblogs.com/Lee-yl/p/12749070.html" target="_blank" rel="noopener">https://www.cnblogs.com/Lee-yl/p/12749070.html&lt;/a>&lt;/p>
&lt;h1 id="杂谈后话">杂谈后话&lt;/h1>
&lt;p>写一点求职的经验和所见所闻吧！&lt;strong>不保证时效性和真实性，参考与否自行斟酌&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>面评记录对求职的影响&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>针对人群：想&lt;strong>刷面试经验&lt;/strong>，而&lt;strong>不是真正急着找工作的&lt;/strong>。&lt;/li>
&lt;li>请&lt;strong>珍惜每次面试机会&lt;/strong>，尤其是面试喜欢的公司时。&lt;/li>
&lt;li>面试一般都会有记录和面试评价。&lt;/li>
&lt;li>所见所闻：大佬A大二时投递了理想公司的实习，意图刷该公司的面试经验。结果表现不佳，导致在真正需要找实习的时候，因之前的面评太差，导致没过简历/排序靠后（记不太清了）&lt;/li>
&lt;/ul></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E7%AE%97%E6%B3%95/%E7%AC%94%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E7%AE%97%E6%B3%95/%E7%AC%94%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98/</guid><description>&lt;p>1.已知平面上的一个圆和若干点 快速求出包含点数最少的多边形使得圆在多边形中&lt;/p>
&lt;p>预处理：圆内的点删去&lt;/p>
&lt;p>点排序，按照射线的角度排序。O(nlogn)&lt;/p>
&lt;p>如黑色的三个点要排序，就是按与圆相切的射线的角度排序。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="%e7%ac%94%e8%af%95%e7%ae%97%e6%b3%95%e9%a2%98/img/image-20230414155250711.png" alt="image-20230414155250711" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>把每一个点当作起点贪心。&lt;/p>
&lt;p>每次贪心：&lt;/p>
&lt;p>​ 从一个S出发，选择一个点T ，点T角度最大，且满足ST与圆不相交 且 圆心在ST射线的右侧。（即顺时针）然后再以T点出发，选择下一个点，直到遍历过的角度大于360度。每次选择 logn，最多选择n次，因此每次贪心是nlogn。&lt;/p>
&lt;p>做n次贪心，总时间复杂度是n^2logn&lt;/p>
&lt;p>给出一无序数组 求所有长度大于等于k的连续子序列的中位数的最大值 定义中位数为第&lt;a href="%e5%90%91%e4%b8%8a%e5%8f%96%e6%95%b4">l/2&lt;/a>(l为数组长度)个数&lt;/p>
&lt;p>二分答案，从小到大排序后二分，选择X为中位数。判断是否有大于等于X的中位数满足条件。&lt;/p>
&lt;p>预处理数组为 -1 ， 0 ， 1（小于X，等于X，大于X），On跑一遍找是否有长度大于K的和大于等于0。 求前缀和并维护最小前缀和即可。&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/</guid><description/></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</guid><description/></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E7%BC%93%E5%AD%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E7%BC%93%E5%AD%98/</guid><description/></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F/hadoop/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F/hadoop/</guid><description/></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F/rpc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F/rpc/</guid><description/></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/</guid><description>&lt;h2 id="经典问题">经典问题&lt;/h2>
&lt;p>拜占庭将军问题
描述： 一组将军围攻一座城市，他们需要达成一致的决策，但是其中一些将军可能是叛徒，他们会向其他将军发送错误的信息。这个问题的目标是找到一种算法，使得所有忠诚的将军能够达成一致的决策，即使有叛徒存在。
经典设置：&lt;/p>
&lt;ol>
&lt;li>每个将军都是一个节点，他们之间通过消息进行通信。&lt;/li>
&lt;li>每个将军都有一个二值的决策，即攻击或者撤退。&lt;/li>
&lt;li>每个将军都知道自己是不是叛徒，但是不知道其他将军是不是叛徒。&lt;/li>
&lt;li>叛徒将军可以发送错误的消息。&lt;/li>
&lt;li>总共有m个将军，其中n个是忠诚的，m-n个是叛徒。&lt;/li>
&lt;li>问题的目标是找到一种算法，使得所有忠诚的将军能够达成一致的决策，即使有叛徒存在。&lt;/li>
&lt;/ol></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/</guid><description/></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</guid><description/></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/</guid><description>&lt;h1 id="分布式计算">分布式计算&lt;/h1>
&lt;ul>
&lt;li>MapReduce&lt;/li>
&lt;li>Spark&lt;/li>
&lt;li>Flink&lt;/li>
&lt;/ul>
&lt;h2 id="mapreduce">MapReduce&lt;/h2>
&lt;p>MapReduce是一种编程模型，用于处理大规模数据集的并行计算。它由两个主要阶段组成：Map阶段和Reduce阶段。在Map阶段，输入数据集被划分为多个独立的数据块，然后由Map函数处理。在Reduce阶段，Map阶段的输出被分组，然后由Reduce函数处理。&lt;/p>
&lt;p>相关论文：&lt;a href="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/mapreduce-osdi04.pdf" target="_blank" rel="noopener">MapReduce: Simplified Data Processing on Large Clusters&lt;/a>&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%9F%BA%E7%A1%80/</guid><description/></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%AE%89%E5%85%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%AE%89%E5%85%A8/</guid><description/></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E9%9B%86%E7%BE%A4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E9%9B%86%E7%BE%A4/</guid><description/></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E8%AE%A1%E7%BD%91/http/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E8%AE%A1%E7%BD%91/http/</guid><description>&lt;h1 id="http">HTTP&lt;/h1>
&lt;h2 id="基础">基础&lt;/h2>
&lt;p>请求报文结构&lt;/p>
&lt;p>客户端发送一个请求报文给服务器，服务器根据请求报文中的信息进行处理，并将处理结果放入响应报文中返回给客户端。&lt;/p>
&lt;p>请求报文结构：&lt;/p>
&lt;p>第一行是包含了请求方法、URL、协议版本；
接下来的多行都是请求首部 Header，每个首部都有一个首部名称，以及对应的值。
一个空行用来分隔首部和内容主体 Body
最后是请求的内容主体&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-md" data-lang="md">&lt;span class="line">&lt;span class="cl">GET http://www.example.com/ HTTP/1.1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Accept-Encoding: gzip, deflate
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Accept-Language: zh-CN,zh;q=0.9,en;q=0.8
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Cache-Control: max-age=0
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Host: www.example.com
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">If-Modified-Since: Thu, 17 Oct 2019 07:18:26 GMT
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">If-None-Match: &amp;#34;3147526947+gzip&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Proxy-Connection: keep-alive
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Upgrade-Insecure-Requests: 1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">User-Agent: Mozilla/5.0 xxx
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">param1=1&lt;span class="err">&amp;amp;&lt;/span>param2=2
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>响应报文结构&lt;/p>
&lt;p>第一行包含协议版本、状态码以及描述，最常见的是 200 OK 表示请求成功了
接下来多行也是首部内容
一个空行分隔首部和内容主体
最后是响应的内容主体&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-md" data-lang="md">&lt;span class="line">&lt;span class="cl">HTTP/1.1 200 OK
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Age: 529651
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Cache-Control: max-age=604800
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Connection: keep-alive
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Content-Encoding: gzip
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Content-Length: 648
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Content-Type: text/html; charset=UTF-8
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Date: Mon, 02 Nov 2020 17:53:39 GMT
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Etag: &amp;#34;3147526947+ident+gzip&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Expires: Mon, 09 Nov 2020 17:53:39 GMT
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Keep-Alive: timeout=4
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Last-Modified: Thu, 17 Oct 2019 07:18:26 GMT
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Proxy-Connection: keep-alive
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Server: ECS (sjc/16DF)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Vary: Accept-Encoding
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">X-Cache: HIT
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&amp;lt;!doctype html&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">html&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">head&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">title&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>Example Domain&lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">title&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // 省略...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">body&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">html&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E8%AE%A1%E7%BD%91/qa/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E8%AE%A1%E7%BD%91/qa/</guid><description>&lt;h3 id="tcp和udp的区别">TCP和UDP的区别&lt;/h3>
&lt;p>TCP:
User Datagram Protocol 用户数据报协议&lt;/p>
&lt;ul>
&lt;li>提供一种面向连接的、可靠交付的面向字节流服务&lt;/li>
&lt;li>TPDU: TCP 报文段(segment)&lt;/li>
&lt;li>传输开销大、报文头部大&lt;/li>
&lt;li>全双工&lt;/li>
&lt;/ul>
&lt;p>UDP：
User Datagram Protocol 用户数据报协议&lt;/p>
&lt;ul>
&lt;li>提供面向事务的简单不可靠信息传送服务&lt;/li>
&lt;li>TPDU: UDP 报文或用户数据报。&lt;/li>
&lt;li>传输开销小、报文头部小 8字节&lt;/li>
&lt;li>不面向连接没有双工的说法&lt;/li>
&lt;/ul>
&lt;h3 id="tcp握手">TCP握手&lt;/h3>
&lt;p>三次握手为什么不是四次呢&lt;/p>
&lt;p>服务器的回复和请求可以并成一次。&lt;/p>
&lt;p>第三次可以携带数据吗&lt;/p>
&lt;p>可以&lt;/p>
&lt;p>TCP四次挥手可以三次吗&lt;/p>
&lt;p>不可以，服务器那个时候可能还要发送数据。&lt;/p>
&lt;p>最后一次要等两个ttl，&lt;/p>
&lt;p>14.tcp为什么慢&lt;/p>
&lt;p>如重传机制，确认机制，拥塞控制机制&lt;/p>
&lt;p>15.udp的切包&lt;/p>
&lt;p>IP分片的概念
在TCP/IP分层中，数据链路层用MTU（Maximum Transmission Unit，最大传输单元）来限制所能传输的数据包大小，MTU是指一次传送的数据最大长度，不包括数据链路层数据帧的帧头，如以太网的MTU为1500字节，实际上数据帧的最大长度为1514字节，其中以太网数据帧的帧头为14字节&lt;/p>
&lt;p>当发送的IP数据包的大小超过了MTU时，IP层就需要对数据进行分片，否则数据将无法发送成功&lt;/p>
&lt;p>IP层是没有超时重传机制的，如果IP层对一个数据包进行了分片，只要有一个分片丢失了，只能依赖于传输层进行重传，结果是所有的分片都要重传一遍，这个代价有点大；公网传输，需要经过多个网络设备，IP分片容易造成丢包&lt;/p>
&lt;p>由此可见，IP分片会大大降低传输层传送数据的成功率，所以我们要避免IP分片&lt;/p>
&lt;p>33.了解一些常用的RPC框架吗&lt;/p>
&lt;p>RPC（Remote Procedure Call，远程服务调用），用来实现部署在不同机器之间系统的方法调用，使程序像当问本地系统资源一样，通过网络传出资源.&lt;/p>
&lt;p>dubbo：基于Netty的高性能RPC框架，是阿里巴巴开源的&lt;/p>
&lt;p>Netty介绍
Netty是一个异步的、基于事件驱动的网络应用框架，用以快速开发高性能、高可靠性的网络IO程序。
Netty主要针对在TCP协议下，面向Clients端的高并发应用，或者Peer-to-Peer场景下的大量数据持续传输的应用。
Netty本质是一个NIO框架，适用于服务器通讯相关的多种应用场景。&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E8%AE%A1%E7%BD%91/socketio%E6%A8%A1%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E8%AE%A1%E7%BD%91/socketio%E6%A8%A1%E5%9E%8B/</guid><description>&lt;h1 id="io模型">I/O模型&lt;/h1>
&lt;h2 id="一什么是io模型-及-io模型的分类">一、什么是I/O模型 及 I/O模型的分类&lt;/h2>
&lt;h2 id="二io-多路复用">二、I/O 多路复用&lt;/h2>
&lt;h2 id="三实际应用">三、实际应用&lt;/h2>
&lt;h3 id="reactor模式">Reactor模式&lt;/h3>
&lt;h3 id="proactor模式">Proactor模式&lt;/h3>
&lt;h3 id="事件驱动模式">事件驱动模式&lt;/h3></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E8%AE%A1%E7%BD%91/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E8%AE%A1%E7%BD%91/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</guid><description>&lt;h1 id="计算机网络基础">计算机网络基础&lt;/h1>
&lt;h2 id="1概述">1.概述&lt;/h2>
&lt;p>LAN：Local Area Network，局域网&lt;/p>
&lt;p>WAN：Wide Area Network，广域网&lt;/p>
&lt;p>&lt;strong>ISP&lt;/strong> Internet Service Provider 因特网服务提供商&lt;/p>
&lt;h3 id="1服务与协议">&lt;strong>1.服务与协议&lt;/strong>&lt;/h3>
&lt;p>&lt;strong>协议&lt;/strong>是&lt;strong>水平&lt;/strong>的，&lt;strong>对等实体&lt;/strong>之间的&lt;strong>通信规则&lt;/strong>。&lt;strong>对等实体&lt;/strong>是指&lt;strong>同一层&lt;/strong>级&lt;strong>可发送接收&lt;/strong>信息的硬件或软件进程.&lt;/p>
&lt;p>&lt;strong>服务&lt;/strong>是&lt;strong>垂直&lt;/strong>的，是由下层为上层通过&lt;strong>层间接口&lt;/strong>提供的. 下层实现的&lt;strong>所有功能不都是服务&lt;/strong>,只有能够&lt;strong>被上层看得见的&lt;/strong>功能才是服务. 上层使用下层的&lt;strong>SAP&lt;/strong>访问下层的服务.&lt;/p>
&lt;p>&lt;strong>SAP Service Access Point&lt;/strong>:服务接入点.同⼀节点相邻两层交换信息的连接点.数据链路层的SAP是MAC地址，网络层的SAP是IP地址，传输层的SAP是端口.&lt;/p>
&lt;p>SDU(服务数据单元):为完成⽤户所要求的功能⽽应传送的数据。&lt;/p>
&lt;p>PCI(协议控制信息):控制协议操作的信息。&lt;/p>
&lt;p>PDU(协议数据单元):n-PDU = n-SDU + n-PCI。 n-PDU = (n-1)-SDU。&lt;/p>
&lt;p>&lt;strong>协议三要素：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>语法: 规定信息格式&lt;/li>
&lt;li>语义: 说明通信双方应当怎么做;用于协调与差错处理的控制信息&lt;/li>
&lt;li>规则: (时序)定义了何时进行通信，先讲什么，后讲什么，讲话的速度等。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>服务的类型&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>面向连接服务与无连接服务
&lt;ul>
&lt;li>面向连接服务：双方通信前要&lt;strong>事先建立&lt;/strong>一条&lt;strong>通信线路&lt;/strong>. 该线路包括建立连接、使用连接(通信)、释放连接这三个过程。&lt;/li>
&lt;li>无连接服务: 双方通信前不需要建立通信线路.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>可靠服务与不可靠服务
&lt;ul>
&lt;li>可靠服务:通过具有&lt;strong>检错,纠错,应答&lt;/strong>机制,保证&lt;strong>数据正确,可靠地&lt;/strong>传送到目的地.&lt;/li>
&lt;li>不可靠服务: 不保证数据正确,可靠地传送到目的地.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>应答服务与不应答服务&lt;/li>
&lt;/ul>
&lt;h3 id="2模型">2.模型&lt;/h3>
&lt;p>&lt;strong>层次模型的好处：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>降低复杂度；&lt;/li>
&lt;li>标准化接口；&lt;/li>
&lt;li>灵活性好;&lt;/li>
&lt;li>易于实现和维护&lt;/li>
&lt;/ol>
&lt;h4 id="21-osi七层模型">&lt;strong>2.1 OSI七层模型&lt;/strong>&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>任务&lt;/th>
&lt;th>功能&lt;/th>
&lt;th>协议&lt;/th>
&lt;th>传输单位&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>物理层&lt;/td>
&lt;td>在物理媒介上为数据端设备执行任务&lt;/td>
&lt;td>&lt;strong>透明&lt;/strong>地传输比特流&lt;/td>
&lt;td>&lt;/td>
&lt;td>比特&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>数据链路层&lt;/td>
&lt;td>将网络层传来的&lt;strong>数据报&lt;/strong>组装成帧&lt;/td>
&lt;td>封装成帧,&lt;strong>差错控制&lt;/strong>,&lt;strong>流量控制&lt;/strong>,传输管理&lt;/td>
&lt;td>SDLC,HDLC,PPP,STP,帧中继&lt;/td>
&lt;td>帧&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>网络层&lt;/td>
&lt;td>将分组传输到目的端,为分组交换网上的&lt;strong>主机&lt;/strong>提供通信服务.&lt;/td>
&lt;td>1.将传输层产⽣的&lt;strong>报⽂段&lt;/strong>或⽤户数据报封装成分组&lt;br />2.路由选择 3.&lt;strong>流量控制&lt;/strong> 4.拥塞控制 5.&lt;strong>差错控制&lt;/strong>&lt;/td>
&lt;td>IP, IPX.ICMP, IGMP,ARP,RARP,OSPF&lt;/td>
&lt;td>数据报,IP分组&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>传输层&lt;/td>
&lt;td>负责主机中两个&lt;strong>进程&lt;/strong>之间的通信(端到端)&lt;/td>
&lt;td>&lt;strong>流量控制, 差错控制&lt;/strong>,服务质量,数据传输管理&lt;/td>
&lt;td>TCP, UDP&lt;/td>
&lt;td>报文段TCP,用户数据报UDP&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>会话层&lt;/td>
&lt;td>&lt;strong>管理主机之间&lt;/strong>的会话&lt;strong>进程&lt;/strong>&lt;/td>
&lt;td>建立,管理,终止会话.也称建立同步SYN&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>表示层&lt;/td>
&lt;td>处理&lt;strong>两个通信系统&lt;/strong>之间&lt;strong>交换信息&lt;/strong>的&lt;strong>表现方式&lt;/strong>&lt;/td>
&lt;td>抽象的标准方法定义数据结构,数据压缩,加密,解密&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>应用层&lt;/td>
&lt;td>提供系统与⽤户的接口&lt;/td>
&lt;td>为特定类型的网络应用提供接入到OSI模型的手段&lt;/td>
&lt;td>FTP.SMTP,HTTP,DNS,Telnet,SNMP&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="22tcpip四层模型">2.2TCP/IP四层模型&lt;/h4>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/2024-03-06-16-25-32.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>网络接入层&lt;/strong>:物理层 + 数据链路层&lt;/p>
&lt;p>&lt;strong>网际互联层&lt;/strong>:网络层&lt;/p>
&lt;p>&lt;strong>传输层&lt;/strong>&lt;/p>
&lt;p>&lt;strong>应用层&lt;/strong>&lt;/p>
&lt;h4 id="23五层模型">2.3五层模型&lt;/h4>
&lt;p>①物理层:物理层&lt;/p>
&lt;p>②数据链路层:数据链路层。&lt;/p>
&lt;p>③⽹络层:⽹络层&lt;/p>
&lt;p>④传输层:传输层&lt;/p>
&lt;p>⑤应⽤层:会话层+表⽰层+应⽤层。&lt;strong>处理高级协议，显示问题，编码和会话控制等问题&lt;/strong>&lt;/p>
&lt;h4 id="25各层设备">2.5各层设备&lt;/h4>
&lt;p>&lt;strong>物理层设备&lt;/strong>:集线器Hub、中继器&lt;/p>
&lt;p>&lt;strong>数据链路层设备&lt;/strong>: 网卡、交换机、网桥&lt;/p>
&lt;p>&lt;strong>网络层设备&lt;/strong>:路由&lt;/p>
&lt;h3 id="3物理网络拓扑结构">3.物理网络拓扑结构&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/2024-03-06-16-25-54.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>总线拓扑&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>优点:所有的节点都能通信&lt;/li>
&lt;li>缺点:一旦总线上的&lt;strong>一点断开&lt;/strong>,会影响到所有&lt;strong>两边的节点&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>双环型拓扑&lt;/strong>: 在环型拓扑基础上增加了一个冗余环路,增加了可靠性和灵活性.&lt;/p>
&lt;p>&lt;strong>星型&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>优点:允许所有的节点方便的交流&lt;/li>
&lt;li>缺点:中间节点崩溃会导致整个网络的崩溃.传输冲突也是一个严重的问题.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>网络型&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>优点:连通性和可靠性好&lt;/li>
&lt;li>缺点:介质的连接和数量无法控制.&lt;/li>
&lt;/ul>
&lt;h2 id="2物理层">2.物理层&lt;/h2>
&lt;p>&lt;strong>传输介质&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>UTP Unshielded Twisted Pair 非屏蔽双绞线&lt;/li>
&lt;li>STP Shielded Twisted Pair 屏蔽双绞线 抗电磁干扰能力强&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>设备&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>中继器：用于放大数字信号&lt;/li>
&lt;li>集线器：多个端口的中继器&lt;/li>
&lt;li>特点：物理层设备既不能隔离冲突域也不能隔离广播域&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>三种通信方式&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>单⼯/ &lt;strong>simple&lt;/strong> Transmission:单向信号只能在⼀个⽅向上传播。(收⾳机)&lt;/li>
&lt;li>半双⼯/ &lt;strong>half-Duplex&lt;/strong> Transmission：信号可双向传播，但不能同时传播。(对讲机)&lt;/li>
&lt;li>全双⼯/ &lt;strong>full-Duplex&lt;/strong> Transmission：信号可以同时在两个⽅向上传播。(电话)&lt;/li>
&lt;/ul>
&lt;p>通道复用技术：&lt;/p>
&lt;ul>
&lt;li>频分复用（FDM，Frequency Division Multiplexing）：不同用户在不同频带，所用用户在同样时间占用不同带宽资源&lt;/li>
&lt;li>时分复用（TDM，Time Division Multiplexing）：不同用户在同一时间段的不同时间片，所有用户在不同时间占用同样的频带宽度&lt;/li>
&lt;li>波分复用（WDM，Wavelength Division Multiplexing）：光的频分复用&lt;/li>
&lt;li>码分复用（CDM，Code Division Multiplexing）：不同用户使用不同的码，可以在同样时间使用同样频带通信&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>三种数据传输方式&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>电路交换
&lt;ul>
&lt;li>通信前为双方建立专有的通信线路&lt;/li>
&lt;li>优点
&lt;ul>
&lt;li>传输快,时延小,&lt;strong>有序&lt;/strong>,避免冲突&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>缺点
&lt;ul>
&lt;li>信道利用率低,建立连接时间长,灵活性差&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>数据报交换
&lt;ul>
&lt;li>以报文为传输的数据单位, 采用&lt;strong>交换节点存储&lt;/strong>转发的方式&lt;/li>
&lt;li>优点
&lt;ul>
&lt;li>线路利用率搞，无连接,动态分配路线,&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>缺点
&lt;ul>
&lt;li>交换节点存储要求大&lt;/li>
&lt;li>&lt;strong>转发时延&lt;/strong>大&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>分组交换
&lt;ul>
&lt;li>面向连接的虚电路
&lt;ul>
&lt;li>通信前，在源主机和⽬的主机之间 建⽴⼀条虚连接，分组通过该路径顺序传送到⽬的主机。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>无连接的数据报
&lt;ul>
&lt;li>数据报的⽅式:将报⽂分割为较短的分组，交换机根据转发表转发分组传送到⽬的主机。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>将报文分割成多个分组，交换机根据&lt;strong>转发表&lt;/strong>逐个传输&lt;/li>
&lt;li>优点
&lt;ul>
&lt;li>,简化交换节点的存储，加速传输&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>缺点
&lt;ul>
&lt;li>传输时延大&lt;/li>
&lt;li>&lt;strong>失序&lt;/strong>,丢失重复问题&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>xDSL&lt;/strong> Digital Subscriber Line：用数字技术对现有的模拟电话用户线进行改造，使它能够承载宽带业务。前缀 x 则表示在数字用户线上实现的不同宽带方案。&lt;/p>
&lt;p>&lt;strong>ADSL&lt;/strong> (Asymmetric Digital Subscriber Line) &lt;strong>非对称数字用户线&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>它因为上行和下行带宽不对 称，因此称为非对称数字用户线环路。&lt;/li>
&lt;/ul>
&lt;ul>
&lt;li>属于DSL技术的一种，亦可称作非对称数字用户环路。是一种新的数据传输方式。&lt;/li>
&lt;li>ADSL采用&lt;strong>频分复用&lt;/strong>技术把普通的电话线分成了电话、上行和下行三个相对独立的信道，从而避免了相互之间的干扰。即使边打电话边上网，也不会发生上网速率和通话质量下降的 情况。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>FTTx&lt;/strong> Fiber To The X：实现宽带居民接入网的方案。这里字母 x 可代表不同意思。&lt;/p>
&lt;h2 id="3数据链路层">3.数据链路层&lt;/h2>
&lt;p>主要信道：&lt;/p>
&lt;ul>
&lt;li>点对点信道&lt;/li>
&lt;li>广播信道&lt;/li>
&lt;/ul>
&lt;h3 id="1九大功能">1.九大功能&lt;/h3>
&lt;h4 id="11为网络层提供服务">1.1为网络层提供服务&lt;/h4>
&lt;ul>
&lt;li>无确认的无连接&lt;/li>
&lt;li>有确认的无连接
&lt;ul>
&lt;li>不用建立链路，但目的主机收到帧后需要发送确认帧。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>有确认的有连接
&lt;ul>
&lt;li>建立连接，传输数据，释放连接。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="12链路管理">1.2链路管理&lt;/h4>
&lt;p>管理建立、维持和释放链路的过程。&lt;/p>
&lt;h4 id="13组帧-与-帧定界">1.3组帧 与 帧定界&lt;/h4>
&lt;p>确定帧的&lt;strong>首部尾部&lt;/strong>等&lt;strong>控制信息&lt;/strong>的&lt;strong>界限&lt;/strong>。&lt;/p>
&lt;h4 id="131字符计数法">1.3.1字符计数法&lt;/h4>
&lt;p>&lt;strong>帧的头部&lt;/strong> 使用 &lt;strong>计数字段&lt;/strong> 标明帧内字符数&lt;/p>
&lt;p>&lt;strong>缺点:&lt;/strong> 计数字段出错,会导致不能划分帧边界。&lt;/p>
&lt;h4 id="132字符填充的首尾界符法">1.3.2字符填充的首尾界符法&lt;/h4>
&lt;p>用于异步传输&lt;/p>
&lt;p>当&lt;strong>信息字段中&lt;/strong>出现：&lt;/p>
&lt;ul>
&lt;li>7E标志字段 转成 5E&lt;/li>
&lt;li>7D转义标记 转成 5D&lt;/li>
&lt;li>ASCII码字符（小于0x20的） 前面加入7D并改变编码&lt;/li>
&lt;/ul>
&lt;h4 id="133比特填充首尾标志法">1.3.3比特填充首尾标志法&lt;/h4>
&lt;p>用于同步传输,用硬件来实现.&lt;/p>
&lt;p>每5个0后面加1个1.&lt;/p>
&lt;h4 id="14帧同步">1.4帧同步&lt;/h4>
&lt;p>在二进制比特流中，&lt;strong>确定帧的开始和结束位置&lt;/strong>。&lt;/p>
&lt;h4 id="15透明传输">1.5透明传输&lt;/h4>
&lt;p>不管什么样的比特流都能在链路上传输。&lt;/p>
&lt;h4 id="16差错控制">1.6差错控制&lt;/h4>
&lt;p>确认发送的数据帧是否被&lt;strong>正确&lt;/strong>接受。&lt;/p>
&lt;ul>
&lt;li>检错编码
&lt;ul>
&lt;li>奇偶校验法&lt;/li>
&lt;li>循环冗余码CRC&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>纠错编码
&lt;ul>
&lt;li>海明码&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="17流量控制">1.7流量控制&lt;/h4>
&lt;p>由接收方控制发送方的流量。&lt;/p>
&lt;h5 id="171停等流量控制">1.7.1停等流量控制&lt;/h5>
&lt;p>与可靠传输中一致&lt;/p>
&lt;h5 id="172滑动窗口流量控制">1.7.2滑动窗口流量控制&lt;/h5>
&lt;h4 id="18可靠传输">1.8可靠传输&lt;/h4>
&lt;p>ARQ法 : Automatic Repeat reQuest 重传出错的帧.&lt;/p>
&lt;p>本质上是使用&lt;strong>确认&lt;/strong>机制和&lt;strong>超时重传&lt;/strong>机制&lt;/p>
&lt;p>ARQ分为&lt;/p>
&lt;h5 id="181停等协议">1.8.1停等协议&lt;/h5>
&lt;p>发送方发送一个帧之后,必须要等待对方确认后才可以发送下一个帧.&lt;/p>
&lt;p>若等待时间超过规定时间,则发送方超时,重传原始帧.&lt;/p>
&lt;h5 id="182gbn-后退n帧协议">1.8.2GBN 后退N帧协议&lt;/h5>
&lt;ul>
&lt;li>发送方发送完一个帧后,可以继续再发送若干帧. 发送方若收到确认帧,则可以继续发送.&lt;/li>
&lt;li>对于每一个帧,发送方判断超时时,重传该帧即之后的所有帧(&lt;strong>包括被确认的帧&lt;/strong>).&lt;/li>
&lt;li>接收方发现某个帧出错, 则&lt;strong>丢弃该帧和后续所有帧&lt;/strong>( &lt;strong>不返回否定帧&lt;/strong> ).&lt;/li>
&lt;/ul>
&lt;h5 id="183sr选择重传机制">1.8.3SR选择重传机制&lt;/h5>
&lt;p>发送方只重传 &lt;strong>超时&lt;/strong> 或 &lt;strong>被出错(返回否定)&lt;/strong> 的帧.&lt;/p>
&lt;p>接收方应当&lt;strong>加大接收窗口&lt;/strong> 来 接收&lt;strong>不连续但是未出现差错&lt;/strong>的帧,等重新收到出错帧的重传帧后⼀并提交给主机。&lt;/p>
&lt;h4 id="19介质访问控制-局域网">1.9介质访问控制 局域网&lt;/h4>
&lt;p>应用在&lt;strong>广播信道&lt;/strong>当中.&lt;/p>
&lt;p>介质访问控制：使得 &lt;strong>使用信道的结点&lt;/strong> 隔离 &lt;strong>其他结点发送的信号&lt;/strong>,以协调活动结点的传输,&lt;/p>
&lt;p>&lt;strong>介质访问控制协议处于MAC&lt;/strong>层。&lt;/p>
&lt;h5 id="191信道划分">1.9.1信道划分&lt;/h5>
&lt;p>通过&lt;strong>多路复用技术&lt;/strong>,把多个信号组合传入同一个物理信道.&lt;/p>
&lt;ul>
&lt;li>FDM 频分多路复用 将物理信道&lt;strong>根据频率&lt;/strong>划分 成 多个子信道,&lt;strong>每个子信道&lt;/strong>传输一种信号.&lt;/li>
&lt;li>TDM 时分多路复用 将物理信道 按照时间划分成若干时间片, 不同信号轮流使用.&lt;/li>
&lt;li>STDM 统计时分多路复用 在TDM的基础上,通过按实际需要来分配时间片.&lt;/li>
&lt;li>WDM 波分多路复用 光的频分多路复用&lt;/li>
&lt;li>CDM 码分多路复用 各个信号不同编码,既&lt;strong>共享信道频率又共享时间&lt;/strong>.
&lt;ul>
&lt;li>CDMA 码分多址&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h5 id="192随机访问">1.9.2随机访问&lt;/h5>
&lt;p>通过&lt;strong>检测冲突&lt;/strong>的方法来实现介质访问控制.&lt;/p>
&lt;ul>
&lt;li>纯ALOHA协议 ：不检测直接发送,&lt;strong>若超时&lt;/strong>则随机时间重发.&lt;/li>
&lt;li>时隙ALOHA协议： 不检测直接发送,&lt;strong>若超时&lt;/strong>则固定时隙重发.&lt;/li>
&lt;li>CSMA协议 ：载波监听多点接入
&lt;ul>
&lt;li>1-坚持CSMA, 闲则发送,忙则继续监听&lt;/li>
&lt;li>p-坚持CSMA, &lt;strong>闲&lt;/strong>则以&lt;strong>p的概率发送&lt;/strong>, 1-p的概率等待下一个时隙,忙则&lt;strong>等待随机时间&lt;/strong> &lt;strong>监听&lt;/strong>&lt;/li>
&lt;li>非坚持CSMA, 闲则发送,忙则&lt;strong>等待随机时间&lt;/strong>重新监听.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>CSMA/CD 带碰撞检测的 CSMA
&lt;ul>
&lt;li>先听后发
&lt;ul>
&lt;li>发送前一直在监听,闲则发送.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>边听边发
&lt;ul>
&lt;li>发送的时候监听&lt;strong>是否有冲突&lt;/strong>.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>冲突停发
&lt;ul>
&lt;li>有冲突则停止发送.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>随机重发
&lt;ul>
&lt;li>停止发送后,随机一段时间重发&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>CSMA/CA (用于&lt;strong>无线网&lt;/strong>) Collision Avoidance
&lt;ul>
&lt;li>无线网进行碰撞检测的难度大,则将CSMA/CD的&lt;strong>碰撞检测&lt;/strong>改为了&lt;strong>碰撞避免&lt;/strong>.&lt;/li>
&lt;li>发送数据时⼴播告知其他节点，让其他节点在某段时间内不要发送数据。利⽤ACK信号，对信道进⾏预约，以免出现碰撞。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h5 id="193轮询访问">1.9.3轮询访问&lt;/h5>
&lt;p>适用于环型总线.&lt;/p>
&lt;p>令牌传递协议:在环形⽹络中，只有得到令牌的主机才能够发送数据。&lt;/p>
&lt;p>FDDI环(光纤分布式数据接口): 令牌环形网络的一种。&lt;/p>
&lt;h3 id="2使用的协议">2.使用的协议&lt;/h3>
&lt;p>&lt;strong>WAN(广域网)&lt;/strong>:覆盖范围很广的&lt;strong>长距离网络&lt;/strong>，由具有&lt;strong>存储转发功能的结点交换机&lt;/strong>和&lt;strong>连接链路&lt;/strong>组成。采用&lt;strong>交换&lt;/strong>技术。&lt;/p>
&lt;p>&lt;strong>LAN(局域网)&lt;/strong>:某一较&lt;strong>小区域内&lt;/strong>由多台计算机相互连成的计算机网络。采用&lt;strong>广播&lt;/strong>技术。&lt;/p>
&lt;h4 id="21-广域网的协议使用点对点信道">2.1 广域网的协议（使用点对点信道）&lt;/h4>
&lt;p>&lt;strong>PPP Point To Point Protocol 点对点协议&lt;/strong>：&lt;/p>
&lt;p>面向&lt;strong>字节&lt;/strong>的数据链路层协议，应用于&lt;strong>直接连接在两个节点的链路&lt;/strong>上，通过&lt;strong>拨号&lt;/strong>或者&lt;strong>专线&lt;/strong>方式，&lt;strong>建立点对点连接&lt;/strong>发送数据。&lt;/p>
&lt;p>&lt;strong>HDLC High-Level Data Link Control 高级数据链路控制协议&lt;/strong>&lt;/p>
&lt;p>面向&lt;strong>比特&lt;/strong>的数据链路层协议。提供了&lt;strong>编号&lt;/strong>和&lt;strong>确认&lt;/strong>机制，能够提供&lt;strong>可靠传输&lt;/strong>。&lt;/p>
&lt;p>PPP&lt;strong>协议特点&lt;/strong>：&lt;/p>
&lt;p>&lt;strong>简单&lt;/strong>——这是首要的要求&lt;/p>
&lt;p>&lt;strong>不进行&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>纠错&lt;/li>
&lt;li>流量控制&lt;/li>
&lt;li>半双工或单工链路&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>三个组成部分&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>封装：一种封装多协议数据报的方法。PPP 封装提供了不同网络层协议同时在&lt;strong>同一链路传输的多路复用技术&lt;/strong>。&lt;/li>
&lt;li>&lt;strong>LCP&lt;/strong>链路控制协议 LCP (Link Control Protocol)&lt;/li>
&lt;li>&lt;strong>NCP&lt;/strong>网络控制协议 NCP (Network Control Protocol)&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>IPCP(网际协议控制协议)&lt;/strong>：用于&lt;strong>建立、配置&lt;/strong>和&lt;strong>检测&lt;/strong>数据链路连接的连接控制协议&lt;strong>LCP&lt;/strong> 以及 用于&lt;strong>建立和&lt;/strong>
&lt;strong>配置&lt;/strong>不同网络层协议的网络控制协议&lt;strong>NCP协议簇&lt;/strong>。&lt;/p>
&lt;h5 id="322-ppp-协议的帧格式">3.2.2 PPP 协议的帧格式&lt;/h5>
&lt;p>PPP 是面向字节的，所有的 PPP 帧的长度都是整数字节。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/2024-03-06-16-26-17.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>首部&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>标志字段&lt;/strong> F = 0x7E （符号“0x”表示后面的字符是用十六进制表示。十六进制的 7E 的二进制表示是 01111110） &lt;strong>标记首尾&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>地址字段&lt;/strong> A 只置为 0xFF。地址字段实际上并不起作用&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>控制字段&lt;/strong> C 通常置为 0x03&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>首部有5字节，尾部3字节&lt;/strong>&lt;/p>
&lt;p>&lt;strong>尾部&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>FCS：帧检验序列，一般由CRC得出但不是唯一方法
&lt;ul>
&lt;li>使用FCS表示使用了 &lt;strong>无差错接受&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>标志字段&lt;/strong> F=7E &lt;strong>标记首尾&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>透明传输&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>同步传输时 采用硬件来完成比特填充（和 HDLC 的做法一样）&lt;/li>
&lt;li>异步传输时 &lt;strong>特殊的字符填充法&lt;/strong>，当&lt;strong>信息字段中&lt;/strong>出现：
&lt;ul>
&lt;li>7E标志字段 转成 5E&lt;/li>
&lt;li>7D转义标记 转成 5D&lt;/li>
&lt;li>ASCII码字符（小于0x20的） 前面加入7D并改变编码&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>PPP 不提供序号&lt;/strong> 和 &lt;strong>确认的可靠传输&lt;/strong>的原因：&lt;/p>
&lt;ul>
&lt;li>PPP 的信息字段放入的数据是 IP 数据报。&lt;strong>数据链路层&lt;/strong>的&lt;strong>可靠传输&lt;/strong>并&lt;strong>不能保证网络层的传输&lt;/strong>也是&lt;strong>可靠&lt;/strong>的&lt;/li>
&lt;li>&lt;strong>帧检验序列 FCS&lt;/strong> 字段可&lt;strong>保证无差错接受&lt;/strong>&lt;/li>
&lt;li>数据链路层出现差错的概率不大时，使用比较&lt;strong>简单&lt;/strong>的 PPP 协议较为合理。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>PPP 协议的工作状态&lt;/strong>：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>当&lt;strong>用户拨号接入 ISP&lt;/strong> 时，&lt;strong>路由器&lt;/strong>的调制解调器对拨号&lt;strong>做出确认&lt;/strong>，并&lt;strong>建立&lt;/strong>一条&lt;strong>物理连接&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>PC 机&lt;/strong> 向 &lt;strong>路由器发送&lt;/strong>一系列的 &lt;strong>LCP 分组&lt;/strong>（封装成多个 PPP 帧）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>这些分组及其响应选择一些 &lt;strong>PPP 参数&lt;/strong>，和进行&lt;strong>网络层配置&lt;/strong>。&lt;strong>NCP&lt;/strong> 给新接入的 PC机&lt;strong>分配&lt;/strong>一个&lt;strong>临时的 IP 地址&lt;/strong>，使 &lt;strong>PC 机&lt;/strong>成为&lt;strong>因特网上的一个主机&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>通信完毕&lt;/strong>时，&lt;strong>NCP&lt;/strong> 释放&lt;strong>网络层连接&lt;/strong>，&lt;strong>收回&lt;/strong>原来分配出去的 &lt;strong>IP&lt;/strong> 地址。接着，&lt;strong>LCP&lt;/strong>释放&lt;strong>数据链路层连接&lt;/strong>。&lt;strong>最后释放&lt;/strong>的是&lt;strong>物理层连接&lt;/strong>。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h4 id="22以太网协议使用广播信道">2.2以太网协议（使用广播信道）&lt;/h4>
&lt;p>&lt;strong>局域网的特点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>范围有限，站点有限&lt;/li>
&lt;li>方便广播&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>局域网的规约&lt;/strong>&lt;/p>
&lt;p>IEEE 802.3标准 —— &lt;strong>以太网&lt;/strong>&lt;/p>
&lt;p>&lt;strong>以太网分层&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>LLC 逻辑链路控制&lt;/strong> LLC (Logical Link Control)子层&lt;/p>
&lt;ul>
&lt;li>1.建⽴和释放数据链路层的&lt;strong>逻辑连接&lt;/strong>。2.提供与⽹络层的&lt;strong>接口&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>MAC 媒体接入控制&lt;/strong> MAC (Medium Access Control)子层。&lt;/p>
&lt;ul>
&lt;li>负责控制与&lt;strong>连接物理层的物理介质&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>适配器&lt;/strong>：&lt;/p>
&lt;p>又称 通信适配器adapter 、&lt;strong>网络接口卡 NIC&lt;/strong> Network Interface Card 、&lt;strong>网卡&lt;/strong>&lt;/p>
&lt;p>功能就是&lt;/p>
&lt;ul>
&lt;li>串行/并行转换&lt;/li>
&lt;li>实现以太网协议&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>使用集线器的星形拓扑:&lt;/strong>&lt;/p>
&lt;p>星形拓扑的中心是 集线器 hub&lt;/p>
&lt;p>使用集线器的以太网&lt;strong>在逻辑上仍是一个总线网&lt;/strong>，各工作站使用的还是 CSMA/CD 协议，并共享逻辑上的总线。&lt;/p>
&lt;p>&lt;strong>MAC地址&lt;/strong>&lt;/p>
&lt;p>适配器从网络上每收到一个 MAC 帧就首先用硬件检查 MAC 帧中的 MAC 地址.&lt;/p>
&lt;ul>
&lt;li>如果是发往本站的帧则收下，然后再进行其他的处理。&lt;/li>
&lt;li>否则就将此帧丢弃，不再进行其他的处理。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>MAC帧格式&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/image-20221027211935439.png" alt="image-20221027211935439" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>类型字段&lt;/strong> 标志&lt;strong>上一层&lt;/strong>使用的协议&lt;/p>
&lt;p>首部 14字节 尾部 4字节。&lt;/p>
&lt;p>数据最少是 64-18 = 46字节.少于64时，数据字段后面加入整数字节填充。&lt;/p>
&lt;p>在&lt;strong>MAC帧前面&lt;/strong>会加入用于&lt;strong>比特同步的8字节&lt;/strong>&lt;/p>
&lt;p>&lt;strong>无效的MAC帧&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>数据字段的长度与长度字段的值不一致；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>帧的长度不是整数个字节；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>用收到的帧检验序列 FCS 查出有差错；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>数据字段的长度不在 46 ~ 1500 字节之间。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>有效的 MAC 帧长度为 64 ~ 1518 字节之间。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对于检查出的无效 MAC 帧就简单地丢弃。以太网不负责重传丢弃的帧。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>以太网重要特性&lt;/strong>：&lt;/p>
&lt;p>使用 CSMA/CD 协议的以太网&lt;strong>不能进行全双工通信&lt;/strong>而&lt;strong>只能进行双向交替通信（半双工通信）&lt;/strong>。&lt;/p>
&lt;p>发送的不确定性使整个以太网的平均通信量远小于以太网的最高数据率。&lt;/p>
&lt;h3 id="3设备及其特点">3.设备及其特点&lt;/h3>
&lt;h4 id="31网桥">3.1网桥&lt;/h4>
&lt;p>&lt;strong>用于连接多个以太网(局域网)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>透明网桥&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>(选择的&lt;strong>不是最佳路由&lt;/strong>):按照自学习算法填写转发表，按转发表转发。&lt;/li>
&lt;li>&lt;strong>工作原理&lt;/strong>
&lt;ul>
&lt;li>维护转发表：收到一个帧时，先将它的&lt;strong>源地址记录&lt;/strong>下来自学习。&lt;/li>
&lt;li>拿目的地址比较转发表，如果找到对应项，直接往对应项记录的接口发送该帧。&lt;/li>
&lt;li>否则，向出来接口X外的&lt;strong>其他接口广播&lt;/strong>该帧。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>STP(生成树协议)&lt;/strong>：
&lt;ul>
&lt;li>该协议应用于在&lt;strong>网络中建立树形拓扑&lt;/strong>，&lt;strong>消除&lt;/strong>网络中的&lt;strong>环路&lt;/strong>，&lt;strong>避免&lt;/strong>由于环路存在而造成的&lt;strong>广播风暴&lt;/strong>问题。&lt;/li>
&lt;li>即&lt;strong>互连在一起的网桥在进行彼此通信后，就能找出原来的网络拓扑的一个子集&lt;/strong>。在这个子集里，整个连通的网络中不存在回路，即在任何两个站之间只有一条路径。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>所谓&lt;strong>自学习建立转发表&lt;/strong>&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>MAC地址为A的设备A，发出的帧从接口X进入网桥。&lt;/li>
&lt;li>根据反向操作，网桥知道一定能从接口X发送帧给A设备。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>源路由网桥&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>(选择的是最佳路路由): 先发送 &lt;strong>发现帧&lt;/strong>，按返回结果转发。&lt;/li>
&lt;li>&lt;strong>工作原理&lt;/strong>
&lt;ul>
&lt;li>源站以广播的方式发送发现帧，每个&lt;strong>发现帧记录所经过的所有路由&lt;/strong>。&lt;/li>
&lt;li>发现帧到达目的后，返回源站。&lt;/li>
&lt;li>源站从这些发现帧中选择最佳路由。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="32交换机">3.2交换机&lt;/h4>
&lt;p>&lt;strong>交换式集线器&lt;/strong>常称为&lt;strong>以太网交换机(switch)&lt;strong>或&lt;/strong>第二层交换机&lt;/strong>.&lt;/p>
&lt;p>以太网交换机:有十几个接口,实质上就是一个多接口的网桥。&lt;/p>
&lt;p>以太网交换机的&lt;strong>每个接口都直接与主机相连&lt;/strong>，并且一般都工作在&lt;strong>全双工&lt;/strong>方式。&lt;/p>
&lt;p>每个用户在通信时是独占传输媒体的带宽，对于拥有 &lt;em>N&lt;/em> 对接口的交换机的总容量为 &lt;em>N&lt;/em>´10 Mb/s。这正是交换机的最大优点。&lt;/p>
&lt;p>&lt;strong>工作原理与透明网桥一致&lt;/strong>&lt;/p>
&lt;p>可用来实现VLAN&lt;/p>
&lt;p>&lt;strong>VLAN(虚拟局域网)&lt;/strong>: 网络中的站点&lt;strong>不拘泥于所处的物理位置&lt;/strong>，而可以根据需要灵活地加入不同的逻辑子网中的一种网络技术。&lt;/p>
&lt;h4 id="33特点">3.3特点&lt;/h4>
&lt;ul>
&lt;li>数据链路层设备&lt;strong>能够隔离冲突域&lt;/strong>但&lt;strong>不能隔离广播域&lt;/strong>。&lt;/li>
&lt;li>都&lt;strong>按MAC地址转发&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h2 id="4网络层">4.网络层&lt;/h2>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e7%bd%91%e7%bb%9c%e5%9f%ba%e7%a1%80/%e7%bd%91%e7%bb%9c%e5%b1%82%e5%8d%8f%e8%ae%ae.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>网络层提供的两种服务&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>面向有连接的虚电路服务&lt;/p>
&lt;/li>
&lt;li>
&lt;p>面向无连接的数据报服务&lt;/p>
&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>对比的方面&lt;/th>
&lt;th>虚电路服务&lt;/th>
&lt;th>数据报服务&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>思路&lt;/td>
&lt;td>可靠通信应当由网络来保证&lt;/td>
&lt;td>可靠通信应当由用户主机来保证&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>连接的建立&lt;/td>
&lt;td>必须有&lt;/td>
&lt;td>不需要&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>终点地址&lt;/td>
&lt;td>仅在连接建立阶段使用，每个分组使用&lt;strong>短的虚电路号&lt;/strong>&lt;/td>
&lt;td>每个分组都&lt;strong>有终点的完整地址&lt;/strong>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>分组的转发&lt;/td>
&lt;td>属于同一条虚电路的分组均&lt;strong>按照同一路由&lt;/strong>进行转发&lt;/td>
&lt;td>每个分组&lt;strong>独立选择路由&lt;/strong>进行转发&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>当结点出故障时&lt;/td>
&lt;td>所有通过出故障的结点的虚电路&lt;strong>均不能工作&lt;/strong>&lt;/td>
&lt;td>出故障的结点可能会&lt;strong>丢失分组&lt;/strong>，一些路由可能会发生变化&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>分组的顺序&lt;/td>
&lt;td>总是&lt;strong>按发送顺序&lt;/strong>到达终点&lt;/td>
&lt;td>到达终点时&lt;strong>不一定按&lt;/strong>发送顺序&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>端到端的差错处理和流量控制&lt;/td>
&lt;td>可以由网络负责，也可以由用户主机负责&lt;/td>
&lt;td>由用户主机负责&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>传统分类地址&lt;/strong>：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>类别&lt;/th>
&lt;th>网络号&lt;/th>
&lt;th>主机号&lt;/th>
&lt;th>第一个网络号&lt;/th>
&lt;th>最后一个网络号&lt;/th>
&lt;th>每个网络最大主机数&lt;/th>
&lt;th>内网地址&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>A&lt;/td>
&lt;td>8&lt;/td>
&lt;td>24&lt;/td>
&lt;td>1&lt;/td>
&lt;td>126&lt;/td>
&lt;td>16777214&lt;/td>
&lt;td>10.0.0.0 到 10.255.255.255&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>B&lt;/td>
&lt;td>16&lt;/td>
&lt;td>16&lt;/td>
&lt;td>128.1&lt;/td>
&lt;td>191.255&lt;/td>
&lt;td>65534&lt;/td>
&lt;td>172.16.0.0 到 172.31.255.255&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>C&lt;/td>
&lt;td>24&lt;/td>
&lt;td>8&lt;/td>
&lt;td>192.0.1&lt;/td>
&lt;td>223.255.255&lt;/td>
&lt;td>254&lt;/td>
&lt;td>192.168.0.0 到 192.168.255.255&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>D&lt;/td>
&lt;td>&lt;strong>组播地址&lt;/strong>&lt;/td>
&lt;td>&lt;/td>
&lt;td>224.0.0.0&lt;/td>
&lt;td>239.255.255.255&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>E&lt;/td>
&lt;td>保留&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>特殊地址&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>广播地址&lt;/strong>：除网络号外全为1&lt;/li>
&lt;li>127.0.0.1：本地保留地址&lt;/li>
&lt;li>&lt;strong>0.0.0.0&lt;/strong>：设置了缺省网关时的缺省路由&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>内网地址&lt;/strong>：&lt;/p>
&lt;p>RFC 1918 指明的专用地址(private address)（内网地址）&lt;/p>
&lt;p>10.0.0.0 到 10.255.255.255&lt;/p>
&lt;p>172.16.0.0 到 172.31.255.255&lt;/p>
&lt;p>192.168.0.0 到 192.168.255.255&lt;/p>
&lt;h3 id="41-路由协议igp-rip-ospf-bgp">4.1 路由协议(IGP RIP OSPF, BGP)&lt;/h3>
&lt;p>&lt;strong>静态路由与动态路由&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>静态路由&lt;/strong>：非自适应路由，指由网络管理员&lt;strong>手工配置的路由&lt;/strong>信息。&lt;strong>简单开销小&lt;/strong>，但&lt;strong>不能及时适应&lt;/strong>网络变化。&lt;/li>
&lt;li>&lt;strong>动态路由&lt;/strong>：自适应路由选择，&lt;strong>通过路由交换的信息&lt;/strong>来构造路由表。&lt;strong>复杂开销大，能适应&lt;/strong>变化。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>自治系统 AS&lt;/strong>
(Autonomous System) ：&lt;/p>
&lt;p>一个 AS 对其他 AS 表现出的是一个**单一的 **和 &lt;strong>一致的路由选择策略&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>IGP与EGP&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>内部网关协议 &lt;strong>IGP&lt;/strong> (Interior Gateway Protocol) 即在&lt;strong>一个自治系统内部使用的路由选择&lt;/strong>协议。目前这类路由选择协议使用得最多，如 &lt;strong>RIP 和 OSPF&lt;/strong> 协议。&lt;/li>
&lt;li>外部网关协议&lt;strong>EGP&lt;/strong> (External Gateway Protocol) 在自治系统之间使用的。在外部网关协议中目前使用最多的是 &lt;strong>BGP&lt;/strong>-4。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>DV 距离向量 / DVP(Distance Vector Protocol) 距离矢量协议&lt;/strong> ：所有结点都&lt;strong>定期&lt;/strong>地将他们整个&lt;strong>路由表传送给&lt;/strong>所有与之直接&lt;strong>相邻的结点&lt;/strong>。RIP IGRP.&lt;/p>
&lt;p>&lt;strong>LS 链路状态 / LSP(Link State Protocol) 链路状态协议&lt;/strong>： 主动测试&lt;strong>所有邻接结点的状态&lt;/strong>并定期将链路状态传播&lt;strong>给所有其他结点&lt;/strong>。OSPF&lt;/p>
&lt;p>&lt;strong>IGRP（Interior Gateway Routing Protocol）与 EIGRP 增强:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Cisco 专用协议，以延迟，带宽，负载，可靠性为度量标准
最大跳数：255 每 90 秒更新&lt;/li>
&lt;/ul>
&lt;p>**RIP **:&lt;/p>
&lt;ul>
&lt;li>基于&lt;strong>距离向量&lt;/strong>的路由选择协议（Bellman-Ford）
&lt;ul>
&lt;li>每个路由器维护从自己到其他网络的&lt;strong>跳数&lt;/strong>。&lt;/li>
&lt;li>使用&lt;strong>UDP&lt;/strong>,按固定的时间间隔(30s) 和 相邻路由器 交换 自己的路由表,并维护自己的路由表。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>在带宽、配置和管理方面要求低，适合于规模较小的网络中&lt;/li>
&lt;li>&lt;strong>好消息传播得快，而坏消息传播得慢&lt;/strong>。网络出故障的传播时间往往需要较长的时间(例如数分钟)。这是 RIP 的一个主要缺点。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>RIP工作原理&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>收到&lt;/strong>相邻路由器X的&lt;strong>RIP报文&lt;/strong>.&lt;/li>
&lt;li>&lt;strong>修改RIP报文&lt;/strong>,把所有项目的下一跳字段改成X,距离++.&lt;/li>
&lt;li>对于&lt;strong>每个项目&lt;/strong>
&lt;ul>
&lt;li>路由表中无该项目的&lt;strong>目的地址&lt;/strong>, 加入到路由表中.&lt;/li>
&lt;li>否则, 路由表已有的下一跳是X,直接替换.&lt;/li>
&lt;li>否则, 项目中的距离更小,直接替换.&lt;/li>
&lt;li>否则,啥都不做.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>检测相邻路由器心跳&lt;/strong>:3分钟没有收到相邻路由器传报文,将与它的距离置为16(不可达)&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>OSPF&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>是&lt;strong>分布式的链路状态&lt;/strong>协议。
&lt;ul>
&lt;li>只有当链路状态&lt;strong>发生变化&lt;/strong>时，路由器&lt;strong>直接用 IP 数据报&lt;/strong>用&lt;strong>洪泛法&lt;/strong>向&lt;strong>所有路由器&lt;/strong>发送 &lt;strong>与自己的相邻路由器的链路状态LSA（依据LSA而不是Hello）&lt;/strong>.
&lt;ul>
&lt;li>“链路状态” 就是说明本路由器都和哪些路由器相邻，以及该链路的**“度量”**(metric)。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Link - state database 链路状态数据库LSDB
&lt;ul>
&lt;li>全网的拓扑结构图.在全网范围内一致.&lt;/li>
&lt;li>能够较快更新.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>OSPF工作原理&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>OSPF路由器相互发送 HELLO 报文，&lt;strong>建立邻居&lt;/strong>关系&lt;/li>
&lt;li>&lt;strong>邻居&lt;/strong>路由器之间相互&lt;strong>通告自身的链路状态信息(LSA)&lt;/strong>;&lt;/li>
&lt;li>&lt;strong>经过&lt;/strong>一段时间的 &lt;strong>LSA 泛洪&lt;/strong>后所有路由器&lt;strong>形成统一的 LSDB&lt;/strong>&lt;/li>
&lt;li>路由器根据 SPF最短路 算法，以⾃⼰为根&lt;strong>计算最短⽣成树&lt;/strong>，&lt;strong>形成路由转发信息&lt;/strong>.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>BGP&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Border Gateway Protocol 边界网关协议,属于&lt;strong>EGP&lt;/strong>&lt;/p>
&lt;p>BGP 是不同自治系统的路由器之间交换路由信息的协议。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>边界网关协议 BGP 只能是力求寻找一条&lt;strong>能够到达目的网络且比较好&lt;/strong>的路由（不能兜圈子），而&lt;strong>并非要寻找一条最佳路由&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>BGP 协议交换路由信息的结点数量级是&lt;strong>自治系统数的量级&lt;/strong>，这要比这些自治系统中的网络数少很多。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>BGP &lt;strong>支持 CIDR&lt;/strong>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>BGP工作原理&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>每个自治系统至少有一个路由器作为BGP发言人。&lt;/li>
&lt;li>不同自治系统的
BGP发言人都过&lt;strong>建立TCP连接&lt;/strong>交换不同自治系统之间的路由信息。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>“转发”和“路由选择”的区别&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>“转发”(forwarding)就是&lt;strong>路由器根据转发表&lt;/strong>将用户的 &lt;strong>IP 数据报从合适的端口转发&lt;/strong>出去。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>“路由选择”(routing)则是按照&lt;strong>分布式算法&lt;/strong>，根据&lt;strong>从各相邻路由器得到的关于网络拓扑的变化&lt;/strong> 情况，动态地&lt;strong>改变所选择的路由&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>路由表&lt;/strong>是根据&lt;strong>路由选择算法&lt;/strong>得出的。而&lt;strong>转发表是从路由表得出&lt;/strong>的。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>ACL&lt;/strong>: 访问控制列表Access Control Lists
一些告诉路由哪些包该拒绝哪些包能通过的序列集。可以根据源地址，目的地址，链路协议来决定。如果包没有在ACL找到相应的条目，则会被丢弃。&lt;/p>
&lt;h3 id="42-ip多播组播igmpnat">4.2 IP多播/组播(IGMP,NAT)&lt;/h3>
&lt;p>&lt;strong>多播/组播&lt;/strong>: 主机之间 &lt;strong>一对一组&lt;/strong>的通讯模式，同组的主机可接收此组内所有数据. 发送者只需要发送一次, &lt;strong>组播路由器&lt;/strong>只向有需求者复制并转发其所需数据。&lt;/p>
&lt;p>&lt;strong>组播地址&lt;/strong>: 使用D类地址 224.0.0.0 ~ 239.255.255.255.每个D类地址标识一个组.&lt;/p>
&lt;p>&lt;strong>IGMP&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>网际组管理协议 IGMP&lt;/strong> (Internet Group Management Protocol&lt;/li>
&lt;li>&lt;strong>IGMP 使用 IP 数据报传递其报文&lt;/strong>，不把 IGMP 看成是一个单独的协议，而是属于&lt;strong>整个网际协议 IP 的一个组成部分&lt;/strong>&lt;/li>
&lt;li>&lt;strong>不是&lt;/strong>对所有组播成员管理的协议&lt;/li>
&lt;li>不知道成员数和成员分布情况&lt;/li>
&lt;li>让连接在本地局域网的&lt;strong>组播路由器&lt;/strong>知道是否有&lt;strong>主机加入/退出多播组&lt;/strong>.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>IGMP工作原理&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>主机的加入&lt;/strong>
&lt;ul>
&lt;li>想加入的主机,向&lt;strong>对应组播组的组播地址&lt;/strong>发送IGMP.&lt;/li>
&lt;li>&lt;strong>本地组播路由器&lt;/strong>收到后,将&lt;strong>该组成员关系&lt;/strong>发送给&lt;strong>因特网&lt;/strong>上的&lt;strong>其他组播路由器&lt;/strong>.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>探询主机&lt;/strong>
&lt;ul>
&lt;li>本地&lt;strong>组播路由器周期性探询&lt;/strong>本地主机.主机收到后响应.&lt;/li>
&lt;li>如有一个组经过几次探询都没有主机响应,则不再转发该组成员关系.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>VPN&lt;/strong>: 基于TCP/IP的虚拟专用网,分为内联网和外联网,使用&lt;strong>内网地址&lt;/strong>.&lt;/p>
&lt;p>&lt;strong>NAT&lt;/strong>:Network Address Translation 网络地址转换:实现&lt;strong>专用网络地址和公用网络地址&lt;/strong>之间的转化。当私有网和公网主机通信的私有IP经过NAT时，&lt;strong>将IP包中的私有IP与NAT的公有IP进行转换&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>NAT&lt;/strong> 软件 ：需要在&lt;strong>专用网连接到因特网&lt;/strong>的&lt;strong>路由器&lt;/strong>上安装 &lt;strong>NAT&lt;/strong> 软件&lt;/p>
&lt;p>&lt;strong>NAT路由器&lt;/strong>：装有 NAT 软件的路由器叫做 NAT路由器，它至少有一个有效的外部全球地址 IP&lt;em>G&lt;/em>。&lt;/p>
&lt;p>&lt;strong>PAT/NAPT(端口地址转换)&lt;/strong>:将本地网上的多个设备映射到一个单一的公共ip地址。&lt;/p>
&lt;h3 id="43-网际协议-ip">4.3 网际协议 IP&lt;/h3>
&lt;p>TCP/IP 协议中最重要的协议之一，属于网络层的协议，主要作用是定义数据包的格式、对数据包进行路由和寻址，以便它们可以跨网络传播并到达正确的目的地。目前 IP 协议主要分为两种，一种是过去的 IPv4，另一种是较新的 IPv6，目前这两种协议都在使用，但后者已经被提议来取代前者。&lt;/p>
&lt;p>&lt;strong>三种IP地址的编址方法&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>分类&lt;/strong>的 IP 地址（二级IP地址）。这是最基本的编址方法，&lt;/li>
&lt;li>&lt;strong>子网&lt;/strong>的划分（三级IP地址）。这是对最基本的编址方法的改进，&lt;/li>
&lt;li>构成&lt;strong>超网&lt;/strong>。这是比较新的&lt;strong>无分类编址 CIDR&lt;/strong>方法。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>传统分类方法&lt;/strong>：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>类别&lt;/th>
&lt;th>网络号&lt;/th>
&lt;th>主机号&lt;/th>
&lt;th>第一个网络号&lt;/th>
&lt;th>最后一个网络号&lt;/th>
&lt;th>每个网络最大主机数&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>A&lt;/td>
&lt;td>8&lt;/td>
&lt;td>24&lt;/td>
&lt;td>1&lt;/td>
&lt;td>126&lt;/td>
&lt;td>16777214&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>B&lt;/td>
&lt;td>16&lt;/td>
&lt;td>16&lt;/td>
&lt;td>128.1&lt;/td>
&lt;td>191.255&lt;/td>
&lt;td>65534&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>C&lt;/td>
&lt;td>24&lt;/td>
&lt;td>8&lt;/td>
&lt;td>192.0.1&lt;/td>
&lt;td>223.255.255&lt;/td>
&lt;td>254&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>D&lt;/td>
&lt;td>组播地址&lt;/td>
&lt;td>&lt;/td>
&lt;td>224.0.0.0&lt;/td>
&lt;td>239.255.255.255&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>E&lt;/td>
&lt;td>保留&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>划分子网方法&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>IP 地址中增加了一个 “&lt;strong>子网号&lt;/strong>字段”，使两级的 IP 地址变成为&lt;strong>三级&lt;/strong>的 IP 地址。划分子网已成为因特网的正式标准协议。&lt;/li>
&lt;li>ABC类地址的&lt;strong>默认子网掩码&lt;/strong>就是对应网络号的位数。&lt;/li>
&lt;li>255.0.0.0 / 255.255.0.0 / 255.255.255.0&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>子网掩码&lt;/strong>: 通过&lt;strong>与IP地址进行与操作&lt;/strong>，将IP地址划分成网络地址和主机地址两个部分。&lt;/p>
&lt;p>&lt;strong>划分子网的匹配方法&lt;/strong>: 将IP地址 与 该网络的子网掩码相与得到网络号,判断是否匹配.(不能得出唯一网络地址)&lt;/p>
&lt;p>&lt;strong>无分类编址CIDR&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>CIDR Classless Inter-Domain Routing &lt;strong>无分类域间路由选择&lt;/strong>：使用&lt;strong>各种长度的网络前缀&lt;/strong>来代替分类地址中的&lt;strong>网络号和子网号&lt;/strong>的一种子网划分方式。&lt;/li>
&lt;li>格式：网络前缀 + 主机号。从三级地址回到两级地址。&lt;/li>
&lt;li>CIDR记法 128.14.32.0/20. 20表示的是网络前缀位数。主机号位数 = 32 - 网络前缀位数&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>VLSM (Variable Length Subnet Mask) 变长子网掩码&lt;/strong>：在一个划分子网的网络中可同时使用几个不同的子网掩码。CIDR是在VLSM基础上研究出的。&lt;/p>
&lt;p>&lt;strong>路由聚合(构成超网)&lt;/strong>: CIDR 地址块可以表示很多地址，这种地址的聚合常称为&lt;strong>路由聚合&lt;/strong>，它使得&lt;strong>路由表中的一个项目&lt;/strong>可以表示&lt;strong>很多个（例如上千个）&lt;strong>原来&lt;/strong>传统分类地址&lt;/strong>的&lt;strong>路由&lt;/strong>。&lt;/p>
&lt;ul>
&lt;li>缩短路由表尺寸&lt;/li>
&lt;li>支持不连续子网&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>超网&lt;/strong>：前缀长度&lt;strong>不超过 23&lt;/strong> 位的 CIDR 地址块都包含了多个 C 类地址。&lt;strong>这些 C 类地址合起来&lt;/strong>就构成了超网。&lt;/p>
&lt;p>&lt;strong>特定主机路由&lt;/strong>：为&lt;strong>特定的目的主机&lt;/strong> &lt;strong>指明一个路由&lt;/strong>。采用特定主机路由可使网络管理人员能够更&lt;strong>方便地控制&lt;/strong>网络和&lt;strong>测试&lt;/strong>网络，同时也可在需要考虑某种安全问题时采用这种特定主机路由。&lt;/p>
&lt;p>&lt;strong>默认路由&lt;/strong>：采用默认路由可以&lt;strong>减少路由表所占用的空间&lt;/strong>和&lt;strong>搜索路由表所用的时间&lt;/strong>。 当目的网络&lt;strong>不在路由表中&lt;/strong>就选择&lt;strong>默认路由&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>如何找下一跳路由器&lt;/strong>：路由器将IP送交&lt;strong>下层网络接口软件&lt;/strong>，&lt;strong>使用 ARP&lt;/strong> 负责将下一跳路由器的 IP 地址转换成硬件地址。硬件地址放在MAC帧首部，&lt;strong>根据硬件地址找到下一跳&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>分组转发算法工作原理&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>数据包首部提取主机IP地址D&lt;/li>
&lt;li>判断能否&lt;strong>直接交付&lt;/strong>
&lt;ul>
&lt;li>传统分类: 直接提取网络地址N,网络N与路由器直接相连就直接交付.&lt;/li>
&lt;li>划分子网: 将路由器相连的各网络进行匹配.匹配成功就直接交付.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>判断是否有&lt;strong>特定路由&lt;/strong>
&lt;ul>
&lt;li>都是通过判断是否有&lt;strong>目的地址为D&lt;/strong>的特定路由&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>在路由表中查找
&lt;ul>
&lt;li>传统分类:直接一一匹配.&lt;/li>
&lt;li>划分子网:IP地址 与 每一个项目的子网掩码相与后匹配.&lt;/li>
&lt;li>无分类编址: 使用&lt;strong>二叉线索树&lt;/strong>进行&lt;strong>最长前缀匹配&lt;/strong>.前缀越长,地址块越小,地址越具体.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>使用默认路由, 如没有&lt;/li>
&lt;li>报告转发失败.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>路由环路&lt;/strong>:用户的数据包不停在网络上循环发送，始终到达不了目的地，严重浪费网络资源。&lt;/p>
&lt;p>&lt;strong>路由环路解决方法&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>Defining a Maximum/定义最大跳数(一般为15)：&lt;strong>超过最大跳数&lt;/strong>则&lt;strong>抛弃报文&lt;/strong>。&lt;/li>
&lt;li>路由毒害/Route Poisoning:当路由信息的跳数超过定义最大跳时，不是直接从路由表中删除该路由信息，而是&lt;strong>向相邻路由发送&lt;/strong>相关路由信息，&lt;strong>通知其他路由该路径失效&lt;/strong>。&lt;/li>
&lt;li>Split Horizon/&lt;strong>水平分割&lt;/strong>:路由器从某个接口接收到的更新信息&lt;strong>不允许再从这个接口发回去&lt;/strong>。&lt;/li>
&lt;li>Hold-Down-Timers/抑制计时器器:如果一条路由更新的跳数大于路由表已记录的该路由的跳数，&lt;strong>启动计时器&lt;/strong>，在计时器超时前，路由器不再接收关于这条路由的更新信息。&lt;/li>
&lt;/ul>
&lt;h3 id="44-arp-rarp-dhcp">4.4 ARP RARP DHCP&lt;/h3>
&lt;p>&lt;strong>ARP&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>ARP 地址解析协议：源主机在向目标主机&lt;strong>发送IP包前&lt;/strong>，通过&lt;strong>广播ARP请求包&lt;/strong>，将&lt;strong>目标主机的IP地址映射为MAC地址&lt;/strong>。&lt;/li>
&lt;li>每一个主机都设有一个ARP 高速缓存(ARP cache)，里面有所在的局域网上的各主机和路由器的 &lt;strong>IP 地址到硬件地址&lt;/strong>的映射表。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>ARP的四种典型使用情况&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>发送方是主机 / 路由器，要发送IP数据报到&lt;strong>本网络的另一个主机&lt;/strong>。
&lt;ul>
&lt;li>用ARP找目的主机的硬件地址&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>发送方是主机 / 路由器，发送IP数据报的另一个网络上。
&lt;ul>
&lt;li>用ARP找到本网络 &lt;strong>另一个路由器&lt;/strong>的硬件地址。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>ARP工作原理&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>源主机在向⽬标主机发送 IP 包前，如果源主机不知道⽬标主机的 MAC地址。&lt;/li>
&lt;li>源主机&lt;strong>向以太网所有计算机广播&lt;/strong>一个填有⽬标主机IP的&lt;strong>ARP请求包&lt;/strong>。&lt;/li>
&lt;li>&lt;strong>目标主机接收请求&lt;/strong>后，向源主机回复填充上了⽬标主机的 MAC
地址&lt;strong>ARP 应答包&lt;/strong>。&lt;/li>
&lt;li>源主机得到 &lt;strong>ARP 应答&lt;/strong>后，将⽬标主机的 MAC 地址存入本机ARP高速缓存，便于下次使用。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>RARP(反向地址转换协议)&lt;/strong>:用于将局域网中的某个主机的&lt;strong>物理地址转换为IP地址&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>RARP协议工作原理&lt;/strong>:&lt;/p>
&lt;ol>
&lt;li>源主机发送一个&lt;strong>声明自己的MAC地址&lt;/strong>的&lt;strong>请求分配IP地址&lt;/strong>的本地的RARP广播包。&lt;/li>
&lt;li>本地网段上的&lt;strong>RARP服务器&lt;/strong>收到此请求后，检查其RARP列表，查找该MAC地址对应的IP地址；&lt;/li>
&lt;li>如果存在，RARP服务器就给源主机发送一个包含此IP地址响应数据包；如果不存在，&lt;strong>RARP服务器对此不做任何的响应&lt;/strong>；&lt;/li>
&lt;li>源主机如果收到从RARP服务器的响应信息，就利用得到的IP地址进行通讯；如果一直没有收到
RARP服务器的响应信息，表示初始化失败。&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>DHCP（动态主机配置协议 !!应用层!! ）&lt;/strong>：用于给网络中的主机&lt;strong>动态分配&lt;/strong>IP地址。&lt;/p>
&lt;p>&lt;strong>DHCP工作原理&lt;/strong>：&lt;/p>
&lt;ol>
&lt;li>寻找服务器：DHCP客户端广播”DHCP&lt;strong>发现&lt;/strong>消息”，寻找网络中的DHCP服务器。&lt;/li>
&lt;li>提供IP地址: DHCP服务器收到“DHCP&lt;strong>发现&lt;/strong>消息”后，就广播”DHCP&lt;strong>提供&lt;/strong>消息”，包括提供&lt;strong>客户端的IP地址和&lt;/strong>
&lt;strong>相关配置信息&lt;/strong>。&lt;/li>
&lt;li>请求分配IP: DHCP客户端收到“DHCP&lt;strong>提供&lt;/strong>消息”，如果接收客户端提供的相关参数，则广播“DHCP&lt;strong>请求&lt;/strong>消息”向DHCP服务端请求使用该IP地址。&lt;/li>
&lt;li>确认分配:DHCP服务端收
到”DHCP&lt;strong>请求&lt;/strong>消息后“，广播”DHCP&lt;strong>确认&lt;/strong>消息“，将IP地址分配给DHCP客户端。&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>DHCP和RARP的区别&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>RARP只能实现简单的从MAC地址到IP地址的&lt;strong>查询&lt;/strong>工作，RARP服务器上的
MAC地址和IP地址必须&lt;strong>事先静态配置&lt;/strong>好。&lt;/li>
&lt;li>DHCP可以实现除静态分配以外的&lt;strong>动态IP地址分配&lt;/strong>以及&lt;strong>IP地址租期管理等&lt;/strong>复杂功能。&lt;/li>
&lt;/ul>
&lt;h3 id="45-icmp">4.5 ICMP&lt;/h3>
&lt;p>&lt;strong>ICMP(英特网控制报文协议):&lt;/strong> 用来给&lt;strong>主机或路由器报告差错和异常&lt;/strong>情况。ICMP 报文作为 IP 层数据报的数据，加上数据报的首部，组成 IP 数据报发送出去。&lt;/p>
&lt;p>一种用于传输网络状态和错误消息的协议，常用于网络诊断和故障排除。例如，Ping 工具就使用了 ICMP 协议来测试网络连通性。&lt;/p>
&lt;p>&lt;strong>ICMP种类&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>ICMP 差错报告报文
&lt;ul>
&lt;li>终点不可达&lt;/li>
&lt;li>源点抑制(Source quench)&lt;/li>
&lt;li>时间超过&lt;/li>
&lt;li>参数问题&lt;/li>
&lt;li>改变路由（重定向）(Redirect)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ICMP 询问报文
&lt;ul>
&lt;li>有两类 &lt;strong>回送请求和回答报文&lt;/strong>、&lt;strong>时间戳请求和回答报文&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>PING&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Packet InterNet Groper 分组网间探测 ：&lt;/p>
&lt;/li>
&lt;li>
&lt;p>PING 是&lt;strong>应用层直接使用网络层 ICMP&lt;/strong> 的例子，它没有通过运输层的 TCP 或UDP。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>用来测试两个主机之间的连通性。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>PING 使用了 ICMP &lt;strong>回送请求与回送回答报文&lt;/strong>。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Traceroute/Trace&lt;/strong>：工作在&lt;strong>网络层&lt;/strong>，使用了&lt;strong>时间超过报文&lt;/strong>&lt;/p>
&lt;h3 id="45设备">4.5设备&lt;/h3>
&lt;p>网络层设备 &amp;ndash; 路由器: &lt;strong>既能隔离冲突域又能隔离广播域&lt;/strong>&lt;/p>
&lt;h2 id="5传输层">5.传输层&lt;/h2>
&lt;p>&lt;strong>传输层的功能&lt;/strong>:端到端的逻辑通信;收到的报文进行差错检测;提供面向连接的TCP和无连接的UDP.&lt;/p>
&lt;p>&lt;strong>传输层提供的信道&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>使用TCP: 逻辑通信道就相当于一条全双工的可靠信道.&lt;/li>
&lt;li>UDP:不可靠的无连接信道.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>运输协议数据单元 TPDU&lt;/strong>.Transport Protocol Data Unit&lt;/p>
&lt;p>&lt;strong>TCP&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>Transmission Control Protocol 传输控制协议&lt;/li>
&lt;li>提供&lt;strong>面向连接&lt;/strong>的、&lt;strong>可靠&lt;/strong>的&lt;strong>字节流&lt;/strong>服务&lt;/li>
&lt;li>TPDU: TCP &lt;strong>报文段&lt;/strong>(segment)&lt;/li>
&lt;li>传输开销大、报文头部大&lt;/li>
&lt;li>&lt;strong>全双工&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>UDP&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>User Datagram Protocol 用户数据报协议&lt;/li>
&lt;li>提供&lt;strong>面向事务&lt;/strong>的&lt;strong>简单不可靠&lt;/strong>信息传送服务&lt;/li>
&lt;li>TPDU: UDP &lt;strong>报文或用户数据报&lt;/strong>。&lt;/li>
&lt;li>传输开销小、报文头部小 &lt;strong>8字节&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>端口port&lt;/strong>：&lt;strong>2字节16位&lt;/strong>，用来&lt;strong>标识和区分某一台主机上的不同应用进程&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>套接字 Socket&lt;/strong>：由主机IP地址和端口号组成。唯一标识了某台主机上的某个应用进程。&lt;/p>
&lt;p>HTTP 80，SNMP 161&lt;/p>
&lt;p>DNS 53，SMTP 25&lt;/p>
&lt;p>&lt;strong>TELNET 23&lt;/strong>，FTP 21&lt;/p>
&lt;p>&lt;strong>TCP的三种可靠传输机制&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>TCP数据&lt;strong>编号&lt;/strong>: 建立连接时协定初始编号,每一个&lt;strong>字节&lt;/strong>对应一个&lt;strong>编号&lt;/strong>,保证数据有序提交应用层。&lt;/li>
&lt;li>TCP数据&lt;strong>确认&lt;/strong>: 对接收到的数据的&lt;strong>最高序号表示确认&lt;/strong>。&lt;/li>
&lt;li>TCP&lt;strong>重传&lt;/strong>机制: 设置计时器&lt;strong>超时重传&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>流量控制&lt;/strong>： 端与端之间通信量的控制。&lt;strong>让发送方的发送速率不要太快&lt;/strong>，既要让接收方来得及接收，也不要使网络发生拥塞。一般使用滑动窗口进行流量控制。&lt;/p>
&lt;p>&lt;strong>拥塞控制&lt;/strong>：使网络能够承受现有的&lt;strong>网络负荷&lt;/strong>。本质是根据自己估算的网络拥塞程度&lt;strong>设置拥塞窗口的值cwnd&lt;/strong>来限定发送速率。&lt;/p>
&lt;p>&lt;strong>TCP的拥塞控制四种方法&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>慢开始: cwnd = 1，每收到一个确认cwnd++&lt;/p>
&lt;/li>
&lt;li>
&lt;p>拥塞避免: 设置慢开始门限 ssthresh&lt;/p>
&lt;ul>
&lt;li>当 cwnd &amp;lt; ssthresh 时，使用慢开始算法。&lt;/li>
&lt;li>当 cwnd &amp;gt; ssthresh 时，使用&lt;strong>拥塞避免算法&lt;/strong>：每过一个RTT往返时间cwnd++&lt;/li>
&lt;li>出现拥塞时，ssthresh 为 cwnd/2 ，cwnd = 1&lt;/li>
&lt;li>思想：乘法减小，加法增大&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>快重传:&lt;/p>
&lt;ul>
&lt;li>接收方&lt;strong>每收到一个 失序 的报文段&lt;/strong>后就&lt;strong>立即&lt;/strong>发出&lt;strong>重复确认&lt;/strong>。&lt;/li>
&lt;li>发送方只要&lt;strong>一连收到三个重复确认&lt;/strong>就应当立即&lt;strong>重传对方尚未收到的报文段&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>快恢复: 发送方&lt;strong>一连收到三个重复确认&lt;/strong>，ssthresh = cwnd/2，但cwnd不变，此时是由RRT线性增大。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>TCP三次握手&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>第一次&lt;/strong>
&lt;ul>
&lt;li>客户机发送&lt;strong>连接请求报文段&lt;/strong>，请求建立连接&lt;/li>
&lt;li>client：置为syn_send，发送请求 SYN = 1, seq = x&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>第二次&lt;/strong>
&lt;ul>
&lt;li>服务机收到请求后,发回&lt;strong>确认报文段&lt;/strong>.&lt;/li>
&lt;li>同时发送自己的序列号.&lt;/li>
&lt;li>server：置为syn_recvd,发送 SYN = 1,seq = y，ACK x.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>第三次&lt;/strong>
&lt;ul>
&lt;li>客户端收到确认后，发回&lt;strong>确认报文段&lt;/strong>.&lt;/li>
&lt;li>A 的 TCP 通知上层应用进程，连接已经建立。&lt;/li>
&lt;li>client:置为established&lt;/li>
&lt;li>server 收到 该确认报文段后，置为established&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>TCP三次握手的原因&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>因为第二次服务端接收到连接请求的时候，也想建立连接，所以将SYN和ACK一起发送。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>第一次和第二次：为了保证&lt;strong>服务端能收接受到客户端&lt;/strong>的信息并能做出正确的应答。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>第二次和第三次：为了保证&lt;strong>客户端能收接受到服务端&lt;/strong>的信息并能做出正确的应答。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>TCP四次挥手过程&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>第一次&lt;/strong>：&lt;strong>客户端&lt;/strong>发送&lt;strong>FIN报文请求释放连接&lt;/strong>。用来关闭客户端到服务端的数据传送。单向关闭。&lt;/li>
&lt;li>&lt;strong>第二次&lt;/strong>：&lt;strong>服务端&lt;/strong>收到这个FIN后，&lt;strong>发回ACK确认&lt;/strong>。客户端到服务端方向的连接释放，TCP处于半关闭。客户端无法向服务端发送数据，但服务端仍然可以向客户端发送数据。&lt;/li>
&lt;li>&lt;strong>第三次&lt;/strong>：&lt;strong>服务端&lt;/strong>发送&lt;strong>FIN报文释放连接&lt;/strong>，用来关闭服务端到客户端的数据传送。&lt;/li>
&lt;li>&lt;strong>第四次&lt;/strong>：&lt;strong>客户端发送ACK&lt;/strong>，并等待2MSL。若客户端在2MSL内&lt;strong>未收到&lt;/strong>服务端&lt;strong>重发的FIN报文&lt;/strong>，则客户端在
2MSL后关闭。TCP连接释放完成。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>TCP四次挥手原因&lt;/strong>:
当客户端请求释放连接时，服务端发回ACK确认，但是服务端并不一定也要关闭TCP连接。即服务端不一定会马上关闭SOCKET。所以会将&lt;strong>ACK报⽂文和FIN报文分开&lt;/strong>发送。&lt;/p>
&lt;p>&lt;strong>TCP最后一次挥手客户端要等待2MSL(最长报文寿命)时间的原因:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>若&lt;strong>客户端&lt;/strong>发送&lt;strong>最后的ACK丢失&lt;/strong>，
则&lt;strong>服务端会在经过MSL后重发FIN报文&lt;/strong>。若客户端此时已经关闭，则无法重发ACK，则&lt;strong>服务端则无法进入关闭状态&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>TCP建立的连接、虚电路建立的连接、电路交换三者区别：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>TCP建立的连接&lt;/strong>：只是在TCP的TCB(传输控制块中)存储了&lt;strong>目的地址&lt;/strong>的&lt;strong>端口信息&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>虚电路路建立的连接&lt;/strong>：指通信前，在&lt;strong>源主机&lt;/strong>和&lt;strong>目的主机&lt;/strong>之间建立一条虚连接，&lt;strong>分组&lt;/strong>通过&lt;strong>该路径顺序&lt;/strong>
传送到目的主机。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>电路交换&lt;/strong>：是建立&lt;strong>真实&lt;/strong>存在的&lt;strong>物理连接&lt;/strong>。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="6应用层">6.应用层&lt;/h2>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e7%bd%91%e7%bb%9c%e5%9f%ba%e7%a1%80/%e5%ba%94%e7%94%a8%e5%b1%82%e5%8d%8f%e8%ae%ae.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="61-http">6.1 http&lt;/h3>
&lt;p>&lt;strong>HTTP&lt;/strong>: HyperText Transfer Protocol 超文本传输协议&lt;/p>
&lt;ul>
&lt;li>&lt;strong>面向事务的(transaction-oriented)应用层&lt;/strong>协议。HTTP 使用 &lt;strong>TCP 连接进行可靠的&lt;/strong>传送。HTTP是客户端与服务端交互的协议。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>HTTPS&lt;/strong>：HTTP&lt;strong>通信接口部分用SSL和TLS协议代替&lt;/strong>。通常是HTTP直接和TCP通信，当使用SSL时，则演变为先和SSL通信，再由SSL和TCP通信了。&lt;/p>
&lt;h3 id="62-电子邮件协议">6.2 &lt;strong>电子邮件协议&lt;/strong>&lt;/h3>
&lt;p>都是基于TCP&lt;/p>
&lt;ul>
&lt;li>发送邮件的协议：SMTP&lt;/li>
&lt;li>读取邮件的协议：POP3 和 IMAP&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>SMTP&lt;/strong>(简单邮件传输协议)：规定了两个相互通信的SMTP进程之间如何交换信息&lt;/p>
&lt;p>&lt;strong>MIME&lt;/strong>: 在SMTP协议的基础上&lt;strong>增加了邮件主体的结构&lt;/strong>，并定义了&lt;strong>传送非ASCII码&lt;/strong>的编码规则。&lt;/p>
&lt;p>&lt;strong>POP3&lt;/strong>(&lt;strong>邮局版本协议&lt;/strong>3): 支持客户端&lt;strong>远程管理在服务器上的电子邮件&lt;/strong>，邮件发送到服务器上，&lt;strong>客户端调用邮件客户机程序以连接服务器&lt;/strong>，并&lt;strong>下载&lt;/strong>所有未阅读的电子邮件。&lt;/p>
&lt;p>&lt;strong>IMAP&lt;/strong>： Internet Message Access Protocol 互联网邮件访问协议 是一个&lt;strong>联机协议&lt;/strong>。当用户 PC 机上的 IMAP 客户程序打开 IMAP 服务器的邮箱时，用户就可看到邮件的首部。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>优点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>用户可以&lt;strong>在不同的地方使用不同的计算机&lt;/strong>随时上网阅读和处理自己的邮件&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>缺点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>如果用户没有将邮件复制到自己的 PC 上，则邮件一直是存放在 IMAP 服务器上。因此&lt;strong>用户需要经常与 IMAP 服务器建立连接&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>SMTP POP IMAP 三者的区别&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>发信人的用户代理&lt;/strong> 向 &lt;strong>源邮件服务器发送邮件&lt;/strong>，以及&lt;strong>源邮件服务器&lt;/strong> 向 &lt;strong>目的邮件服务器发送邮件&lt;/strong>，都是使用 &lt;strong>SMTP&lt;/strong> 协议。&lt;/li>
&lt;li>而 &lt;strong>POP&lt;/strong> 协议或 &lt;strong>IMAP&lt;/strong> 协议则是&lt;strong>用户&lt;/strong> 从 &lt;strong>目的邮件服务器&lt;/strong>上 &lt;strong>读取邮件&lt;/strong>所使用的协议。&lt;/li>
&lt;/ul>
&lt;h3 id="62-ftp">6.2 FTP&lt;/h3>
&lt;p>&lt;strong>FTP&lt;/strong>：(文本传输协议File Transfer Protocol): 运行在TCP之上，用于在&lt;strong>异构网络&lt;/strong>中任意计算机之间传送文件。FTP 是一种不安全的协议.&lt;/p>
&lt;p>&lt;strong>TFTP&lt;/strong>(简单文件传输协议 运行在UDP之上):用于在&lt;strong>客户端与服务端&lt;/strong>之间进行&lt;strong>简单文件传输&lt;/strong>。TFTP有自己的差错改正措施，不支持交互。&lt;/p>
&lt;p>&lt;strong>FTP工作原理&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>使用&lt;strong>客户服务器&lt;/strong>方式。&lt;/li>
&lt;li>可同时为多个客户进程提供服务。&lt;/li>
&lt;li>FTP 的服务器进程由两大部分组成：&lt;strong>一个主进程&lt;/strong>，负责接受新的请求；另外有&lt;strong>若干个从属进程&lt;/strong>，负责处理单个请求。&lt;/li>
&lt;li>使用两个TCP连接：
&lt;ul>
&lt;li>&lt;strong>控制连接&lt;/strong>在整个会话期间一直保持打开，FTP 客户发出的&lt;strong>传送请求&lt;/strong>通过控制连接&lt;strong>发送给&lt;/strong>服务器端的&lt;strong>控制进程&lt;/strong>。&lt;/li>
&lt;li>用于传输文件的是“&lt;strong>数据连接&lt;/strong>”，被 控制连接 创建。&lt;strong>端口20&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="63-telnet">6.3 Telnet&lt;/h3>
&lt;p>&lt;strong>TELNET&lt;/strong>：简单的&lt;strong>远程终端协议&lt;/strong>，使用C/S方式，使用TCP连接。&lt;/p>
&lt;p>Telnet 协议的最大缺点之一是所有数据（包括用户名和密码）均以明文形式发送，这有潜在的安全风险。这就是为什么如今很少使用 Telnet，而是使用一种称为 SSH 的非常安全的网络传输协议的主要原因。&lt;/p>
&lt;h3 id="64-sshsecure-shell-protocol安全的网络传输协议">6.4 SSH（Secure Shell Protocol，安全的网络传输协议）&lt;/h3>
&lt;p>基于 TCP 协议，通过加密和认证机制实现安全的访问和文件传输等业务&lt;/p>
&lt;h3 id="65-rtpreal-time-transport-protocol实时传输协议">6.5 RTP（Real-time Transport Protocol，实时传输协议）&lt;/h3>
&lt;p>通常基于 UDP 协议，但也支持 TCP 协议。它提供了端到端的实时传输数据的功能，但不包含资源预留存、不保证实时传输质量，这些功能由 WebRTC 实现。&lt;/p>
&lt;h3 id="66-dns-domain-name-system域名系统">6.6 DNS (Domain Name System)域名系统&lt;/h3>
&lt;p>基于 UDP 协议，用于解决域名和 IP 地址的映射问题。&lt;/p>
&lt;p>因特网采用&lt;strong>层次结构的命名树&lt;/strong>作为主机的名字，并使用&lt;strong>分布式&lt;/strong>的域名系统 DNS。用来将域名转换为IP地址。&lt;/p>
&lt;p>&lt;strong>域名服务器&lt;/strong>：&lt;strong>域名服务器程序在专&lt;/strong>设的结点上运行，运行该程序的机器称为&lt;strong>域名服务器&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>基础结构域名&lt;/strong>(infrastructure domain)：这种顶级域名只有一个，即 &lt;strong>arpa&lt;/strong>，用于&lt;strong>反向域名解析&lt;/strong>，因此又称为&lt;strong>反向域名&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>DNS查询方式 域名解析过程&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>主机向本地域名服务器&lt;/strong>的查询一般都是采用&lt;strong>递归查询&lt;/strong>。
&lt;ul>
&lt;li>知道则回复。如本地域名服务器不知道，则本地域名服务器就以 &lt;strong>DNS 客户&lt;/strong>的身份，&lt;strong>向其他域名服务器&lt;/strong>继续发出查询请求报文。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>本地域名服务器&lt;/strong>向&lt;strong>根域名服务器&lt;/strong>的查询通常是采用&lt;strong>迭代查询&lt;/strong>。
&lt;ul>
&lt;li>&lt;strong>根域名服务器要么&lt;/strong>给出所要查询的&lt;strong>IP 地址&lt;/strong>，要么告诉本地域名服务器：“你下一步&lt;strong>应当向哪一个域名服务器&lt;/strong>进行查询”。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="65-其他概念">6.5 其他概念&lt;/h3>
&lt;p>&lt;strong>WWW&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>万维网 WWW (World Wide Web)&lt;strong>并非某种特殊&lt;/strong>的&lt;strong>计算机网络&lt;/strong>。&lt;/li>
&lt;li>是一个&lt;strong>大规模的、联机式&lt;/strong>的&lt;strong>信息储藏所&lt;/strong>。是&lt;strong>分布式超媒体&lt;/strong>(hypermedia)系统，它是&lt;strong>超文本&lt;/strong>(hypertext)系统的扩充。&lt;/li>
&lt;li>&lt;strong>浏览器&lt;/strong>就是在用户计算机上的&lt;strong>万维网客户程序&lt;/strong>。&lt;/li>
&lt;li>&lt;strong>万维网服务器&lt;/strong>：&lt;strong>万维网文档&lt;/strong>所&lt;strong>驻留的计算机&lt;/strong>的&lt;strong>运行服务器程序&lt;/strong>&lt;/li>
&lt;li>&lt;strong>页面&lt;/strong>(page)：在一个&lt;strong>客户程序主窗口上显示出&lt;/strong>的&lt;strong>万维网文档&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>HTML&lt;/strong>(HyperText &lt;strong>Markup&lt;/strong> Language 超文本标记语言): &lt;strong>文档结构标记语言&lt;/strong>，使用约定的标记对页面上的信息进行描述。&lt;/p>
&lt;p>&lt;strong>URL&lt;/strong>: 统一资源定位符Uniform Resource Locator， 标识万维网上的各种文档。每个文档在整个因特网都具有唯一的URL。&lt;/p>
&lt;ul>
&lt;li>格式：协议(ftp/http)://主机:端口/路径。&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e7%bd%91%e7%bb%9c%e5%9f%ba%e7%a1%80/URL%e7%9a%84%e7%bb%84%e6%88%90.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;ul>
&lt;li>协议。URL 的前缀通常表示了该网址采用了何种应用层协议，通常有两种——HTTP 和 HTTPS。当然也有一些不太常见的前缀头，比如文件传输时用到的ftp:。&lt;/li>
&lt;li>域名。域名便是访问网址的通用名，这里也有可能是网址的 IP 地址，域名可以理解为 IP 地址的可读版本，毕竟绝大部分人都不会选择记住一个网址的 IP 地址。&lt;/li>
&lt;li>端口。如果指明了访问网址的端口的话，端口会紧跟在域名后面，并用一个冒号隔开。&lt;/li>
&lt;li>资源路径。域名（端口）后紧跟的就是资源路径，从第一个/开始，表示从服务器上根目录开始进行索引到的文件路径，上图中要访问的文件就是服务器根目录下/path/to/myfile.html。早先的设计是该文件通常物理存储于服务器主机上，但现在随着网络技术的进步，该文件不一定会物理存储在服务器主机上，有可能存放在云上，而文件路径也有可能是虚拟的（遵循某种规则）。&lt;/li>
&lt;li>参数。参数是浏览器在向服务器提交请求时，在 URL 中附带的参数。服务器解析请求时，会提取这些参数。参数采用键值对的形式key=value，每一个键值对使用&amp;amp;隔开。参数的具体含义和请求操作的具体方法有关。&lt;/li>
&lt;li>锚点。锚点顾名思义，是在要访问的页面上的一个锚。要访问的页面大部分都多于一页，如果指定了锚点，那么在客户端显示该网页是就会定位到锚点处，相当于一个小书签。值得一提的是，在 URL 中，锚点以#开头，并且不会作为请求的一部分发送给服务端&lt;/li>
&lt;/ul></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90/</guid><description>&lt;h3 id="程序分析主要关注两大方面">程序分析主要关注两大方面：&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>程序优化&lt;/strong>侧重于提高程序的性能，通过对程序中关键函数的跟踪或者运行时信息的统计，找到系统性能的瓶颈，从而采取进一步行动对程序进行优化，同时减少资源使用。&lt;/li>
&lt;li>&lt;strong>程序正确性&lt;/strong>侧重于确保程序执行它应该做的事情，帮助开发者找出错误代码的位置。（本文以程序正确性的分析为主）&lt;/li>
&lt;/ul>
&lt;h3 id="程序分析方法">程序分析方法：&lt;/h3>
&lt;p>第一类是&lt;strong>静态程序分析&lt;/strong>，即在不执行程序的情况下进行程序分析。&lt;/p>
&lt;p>第二类是&lt;strong>动态程序分析&lt;/strong>，即通过运行程序或者在程序运行期间进行分析。&lt;/p>
&lt;p>&lt;a href="https://wiki.mbalib.com/wiki/%e5%8a%a8%e6%80%81%e5%88%86%e6%9e%90" target="_blank" rel="noopener">动态分析方法包括：调试、覆盖测试、剖面测试、动态切片、动态污点分析等&lt;/a>&lt;a href="https://wiki.mbalib.com/wiki/%e5%8a%a8%e6%80%81%e5%88%86%e6%9e%90" target="_blank" rel="noopener">1&lt;/a>。&lt;/p>
&lt;p>当然，也有很多研究工作是关于&lt;strong>如何有效结合静态和动态程序分析&lt;/strong>的。同时，因为通常无法拿到真正的程序正确性的需求，绝大多数的程序分析技术着重于分析&lt;strong>通用的程序正确性需求&lt;/strong>，比如如果有断言的话，我们尽量分析断言会不会被违背，再比如分析是否存在整数或者缓存溢出，再或者检测指针相关的安全漏洞等。&lt;/p>
&lt;p>&lt;strong>符号执行&lt;/strong>（通过用求解每条程序路上上的条件来生成测试用例）&lt;/p>
&lt;p>&lt;strong>模型检测&lt;/strong>（通过抽象并遍历所有的程序行为来判断程序是不是正确）&lt;/p>
&lt;p>&lt;strong>模糊测试&lt;/strong>（通过优化大量的生成测试用例）&lt;/p>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/396531255" target="_blank" rel="noopener">模型检查、符号执行、抽象解释等&lt;/a>&lt;a href="https://zhuanlan.zhihu.com/p/396531255" target="_blank" rel="noopener">1&lt;/a>。&lt;/p>
&lt;p>对基于静态分析（比如抽象解释，或者 lint）的工具，一个重要的问题就是&lt;strong>如何减少假警报&lt;/strong>的。&lt;/p>
&lt;p>而对于动态分析（比如测试）而言，对应的问题就是&lt;strong>如何减少漏报&lt;/strong>。&lt;/p>
&lt;p>除了把静态分析做的更精确（比如设计更复杂的 lint 规则），和把动态分析做的更完备（比如提要求更高的覆盖率标准）&lt;/p>
&lt;p>还有一个趋势，就是&lt;strong>结合不同的程序分析技术取长补短&lt;/strong>。比如 hybrid fuzzing 的做法是，通过有效的结合符号执行与模糊测试来提高测试的覆盖率。&lt;/p>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/396531255" target="_blank" rel="noopener">插桩、覆盖率、动态切片、动态污点分析等。&lt;/a>&lt;a href="https://zhuanlan.zhihu.com/p/396531255" target="_blank" rel="noopener">1&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/396531255" target="_blank" rel="noopener">技术分享 | 浅谈程序分析&lt;/a>&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid><description/></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/</guid><description/></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/git/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/git/</guid><description>&lt;p>软件配置管理&lt;/p>
&lt;p>21.做代码管理用什么东西&lt;/p>
&lt;p>Git 代码仓库&lt;/p>
&lt;p>22.git rebase和git merge的区别&lt;/p>
&lt;p>Merge会自动根据两个分支的共同祖先和两个分支的最新提交 进行一个三方合并，然后将合并中修改的内容生成一个新的 commit，即merge合并两个分支并生成一个新的提交,并且仍然后保存原来分支的commit记录&lt;/p>
&lt;p>Rebase会从两个分支的共同祖先开始提取当前分支上的修改，然后将当前分支上的所有修改合并到目标分支的最新提交后面，如果提取的修改有多个，那git将依次应用到最新的提交后面。Rebase后只剩下一个分支的commit记录&lt;/p>
&lt;p>rebase会打乱时间线，但是更加整洁，merge保留了时间线信息&lt;/p>
&lt;h3 id="23git提交流程">23.git提交流程&lt;/h3>
&lt;p>&lt;a href="https://blog.csdn.net/weixin_44256848/article/details/123812716" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44256848/article/details/123812716&lt;/a>&lt;/p>
&lt;p>git pull 同步远程代码&lt;/p>
&lt;p>修改代码&lt;/p>
&lt;p>git status 显示被修改的文件&lt;/p>
&lt;p>git diff 文件名 显示文件具体变更&lt;/p>
&lt;p>git add 文件名 提交文件到本地缓存区&lt;/p>
&lt;p>git commit 提交到本地仓库&lt;/p>
&lt;p>git push 提交本地代码到远程仓库&lt;/p>
&lt;p>&lt;a href="https://blog.csdn.net/weixin_44256848/article/details/123812716" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44256848/article/details/123812716&lt;/a>&lt;/p>
&lt;p>生产分支（master）‌&lt;/p>
&lt;ul>
&lt;li>Master分支是仓库的主分支，也有人叫Production分支，这个分支包含最近发布到生产环境的代码，最近发布的Release， 这个分支只能从其他分支合并，不能在这个分支直接修改‌&lt;/li>
&lt;/ul>
&lt;p>补丁分支（hotfix）‌&lt;/p>
&lt;ul>
&lt;li>当我们在生产环境发现新的Bug时候，我们需要基于master分支创建一个Hotfix分支，然后在Hotfix分支上修复bug，完成Hotfix后，我们要把hotfix分支合并回Master和Develop分支‌，所以Hotfix的改动会进入下一个Release&lt;/li>
&lt;/ul>
&lt;p>发布分支（release)‌&lt;/p>
&lt;ul>
&lt;li>当你需要发布一个新功能的时候，要基于Develop分支创建一个Release分支，在Release分支测试并修复bug，完成release后，把release合并到master和develop分支‌&lt;/li>
&lt;/ul>
&lt;p>开发分支（develop）‌&lt;/p>
&lt;ul>
&lt;li>这个分支是我们的主开发分支，包含所有要发布到下一个Release的代码，这个主要合并与其他分支，比如Feature分支‌&lt;/li>
&lt;/ul>
&lt;p>功能分支（feature）‌&lt;/p>
&lt;ul>
&lt;li>feature分支主要是用来开发一个新的功能，一旦开发完成，我们合并回Develop分支进入下一个Release‌&lt;/li>
&lt;/ul></description></item><item><title/><link>https://ysyyhhh.github.io/docs/language/c++/modern-c++/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/language/c++/modern-c++/</guid><description>&lt;h1 id="modern-c">Modern C++&lt;/h1>
&lt;h2 id="面向对象">面向对象&lt;/h2>
&lt;h3 id="c多态">C++多态&lt;/h3>
&lt;p>多态分为两种，一种是运行时的多态，一种是编译时的多态。
前者称为动态绑定，后者称为静态绑定。动态绑定时由虚函数来实现，静态绑定是由函数重载来实现。&lt;/p>
&lt;h2 id="语法">语法&lt;/h2>
&lt;h3 id="lambda表达式">lambda表达式&lt;/h3>
&lt;p>描述:&lt;/p>
&lt;ul>
&lt;li>一个匿名函数对象&lt;/li>
&lt;li>一个可调用的代码单元&lt;/li>
&lt;li>一个函数对象的语法糖&lt;/li>
&lt;/ul>
&lt;p>语法规则:
&lt;a href="">&lt;/a>{};&lt;br>
[]: lambda表达式的引导符
(): 参数列表&lt;/p>
&lt;p>具体示例&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">auto&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="kr">thread&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">threads&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">thread&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="kr">thread&lt;/span>&lt;span class="p">([&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">taskId&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">num_total_tasks&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">runnable&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">id&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">taskId&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">id&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">num_total_tasks&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">id&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">taskId&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">runnable&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">runTask&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">num_total_tasks&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在示例中, thread的初始化是一个lambda表达式, 该lambda表达式的参数列表为空, 函数体为&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">id&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">taskId&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">id&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">num_total_tasks&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">id&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">taskId&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">runnable&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">runTask&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">num_total_tasks&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样一个thread可以负载多个任务.&lt;/p>
&lt;p>如果不用lambda表达式, 那么就需要定义一个函数, 然后将函数的地址传递给thread, 这样就会增加代码量.&lt;/p>
&lt;p>也就是说实际上 thread的参数可以是一个函数对象, 也可以是一个函数指针, 也可以是一个lambda表达式.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">explicit
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">不能在传参时隐式调用构造函数。
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="err">使用&lt;/span>&lt;span class="n">reset来用子类覆盖父类&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">auto&lt;/span> &lt;span class="n">new_node&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">TrieNodeWithValue&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">move&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">**&lt;/span>&lt;span class="n">end_node&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">end_node&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">reset&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">new_node&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="stl">STL&lt;/h2>
&lt;h3 id="vector">vector&lt;/h3>
&lt;p>可变长数组，用倍增的思想。&lt;/p>
&lt;p>vector在push_back以成倍增长可以在均摊后达到O(1)的事件复杂度&lt;/p>
&lt;p>2倍 gcc&lt;/p>
&lt;p>1.5倍 vs2019&lt;/p>
&lt;p>以2倍的方式扩容，导致&lt;strong>下一次申请的内存必然大于之前分配内存的总和&lt;/strong>，导致&lt;strong>之前分配的内存不能再被使用&lt;/strong>，所以最好倍增长因子设置为(1,2)之间.&lt;/p>
&lt;h3 id="map">map&lt;/h3>
&lt;p>map底层红黑树&lt;/p>
&lt;p>unordered_map底层哈希&lt;/p>
&lt;h3 id="bitset">bitset&lt;/h3>
&lt;p>二进制数组，bool类型的数组。&lt;/p>
&lt;p>可以加速到/64&lt;/p>
&lt;h3 id="迭代器失效的情况以及解决方法">迭代器失效的情况，以及解决方法&lt;/h3>
&lt;ol>
&lt;li>对于序列容器vector，deque来说，使用erase后，后边的每个元素的迭代器都会失效，后边每个元素都往前移动一位，&lt;strong>erase返回下一个有效的迭代器&lt;/strong>。&lt;/li>
&lt;li>对于关联容器map，set来说，使用了erase后，当前元素的迭代器失效，但是其结构是红黑树，删除当前元素，不会影响下一个元素的迭代器，所以&lt;strong>在调用erase之前，记录下一个元素的迭代器&lt;/strong>即可。&lt;/li>
&lt;li>对于list来说，它使用了不连续分配的内存，并且它的erase方法也会返回下一个有效的迭代器，因此上面两种方法都可以使用。&lt;/li>
&lt;/ol>
&lt;h3 id="哈希冲突的解决方法">哈希冲突的解决方法&lt;/h3>
&lt;p>开放地址法/再散列法&lt;/p>
&lt;ul>
&lt;li>冲突时采用&lt;/li>
&lt;li>线性探查&lt;/li>
&lt;li>二次探测&lt;/li>
&lt;li>伪随机&lt;/li>
&lt;/ul>
&lt;p>链表法/拉链法&lt;/p>
&lt;ul>
&lt;li>冲突时直接单链表&lt;/li>
&lt;/ul>
&lt;p>再哈希法&lt;/p>
&lt;ul>
&lt;li>输出是同一个位置就再次哈希（第二个哈希函数）&lt;/li>
&lt;/ul>
&lt;h3 id="空类包括什么成员">空类包括什么成员&lt;/h3>
&lt;p>默认构造函数、一个拷贝默认构造函数、一个默认拷贝赋值操作符和一个默认析构函数&lt;/p>
&lt;h3 id="浅拷贝和深拷贝">浅拷贝和深拷贝&lt;/h3>
&lt;p>浅拷贝/值拷贝 数据数量不变，共享同一片空间&lt;/p>
&lt;p>深拷贝 开辟一块新的空间存入数据&lt;/p>
&lt;h3 id="虚函数">虚函数&lt;/h3>
&lt;p>虚函数使用的其核心目的是&lt;strong>通过基类访问派生类定义的函数&lt;/strong>。&lt;/p>
&lt;p>有vptr（虚指针）和vtbl(虚表)&lt;/p>
&lt;p>在派生类中重写该虚函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。&lt;/p>
&lt;p>纯虚函数：virtual void fun()=0。即抽象类必须在子类实现这个函数，即先有名称，没有内容，在派生类实现内容。&lt;/p>
&lt;p>抽象类是指包括至少一个纯虚函数的类。&lt;/p>
&lt;h3 id="类的大小子类继承后的影响">类的大小，子类继承后的影响&lt;/h3>
&lt;ol>
&lt;li>非静态成员变量的内存占用之和&lt;/li>
&lt;li>考虑内存对其的问题；&lt;/li>
&lt;li>&lt;a href="https://so.csdn.net/so/search?q=%E8%99%9A%E5%87%BD%E6%95%B0&amp;amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener">虚函数&lt;/a>产生的额外内存开销，即虚函数表指针(Virtual Table Pointer);&lt;/li>
&lt;/ol>
&lt;p>空白类被继承后可能会被编译器优化掉&lt;/p>
&lt;p>内存相关、&lt;/p>
&lt;h3 id="new和malloc">new和malloc&lt;/h3>
&lt;p>&lt;a href="https://blog.csdn.net/weixin_43899008/article/details/123261412" target="_blank" rel="noopener">new malloc&lt;/a>&lt;/p>
&lt;p>malloc(100M)一块大小，相应的虚拟内存有多少？ （我说这个不是可以自己设么）&lt;/p>
&lt;ul>
&lt;li>new是关键字，需要编译器支持；malloc是库函数，需要头文件支持。&lt;/li>
&lt;li>new申请内存无需指定内存大小，编译器会根据类型信息自行计算。除此之外，new会调用构造函数。&lt;/li>
&lt;li>malloc必须由我们计算需要申请的字节数，需要显式指出所需内存的尺寸，并且返回后强行转换为实际类型的指针。而且malloc只管分配内存，并不能对所得的内存进行初始化，所以得到的一片新内存中，其&lt;strong>值是随机&lt;/strong>的。&lt;/li>
&lt;li>new在自由储存区分配内存，malloc在堆上分配内存。&lt;/li>
&lt;/ul>
&lt;h3 id="悬空指针和野指针">悬空指针和野指针&lt;/h3>
&lt;p>悬空指针是指一个&lt;strong>没有指向任何内存单元&lt;/strong>的指针.&lt;/p>
&lt;p>使用悬空指针报&lt;strong>段错误&lt;/strong>。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">void *p = malloc(size);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">assert(p);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">free(p);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">// 现在 p 是“悬空指针”
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">p = NULL;//// 避免“悬空指针”
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>野指针是指一个不确定其具体指向的指针，最常来自于未初始化的指针。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">void *p;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">// 此时 p 是“野指针”
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">void *p = NULL;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">void *data = malloc(size);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>因为“野指针”可能指向任意内存段，因此它可能会损坏正常的数据，也有可能引发其他未知错误，所以C语言中的“野指针”危害性甚至比“悬空指针”还要严重。&lt;/p>
&lt;p>在实际的C语言程序开发中，定义指针时，一般都要尽量避免“野指针”的出现（赋初值）：&lt;/p>
&lt;h3 id="用c如何保证资源不泄露">用C++如何保证资源不泄露&lt;/h3>
&lt;p>遵循RAII原则。&lt;/p>
&lt;p>在初始化中获取资源 Resource acquisition is initialation&lt;/p>
&lt;p>对象管理自己的资源。&lt;/p>
&lt;p>智能指针是RAII原则的体现。&lt;/p>
&lt;h3 id="内存泄漏">内存泄漏&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>内存泄露及解决办法&lt;/strong>：&lt;/p>
&lt;p>&lt;strong>什么是内存泄露？&lt;/strong>&lt;/p>
&lt;p>简单地说就是申请了一块内存空间，使用完毕后没有释放掉。（1）new和malloc申请资源使用后，没有用delete和free释放；（2）子类继承父类时，父类析构函数不是虚函数。&lt;/p>
&lt;p>（3）Windows句柄资源使用后没有释放。&lt;/p>
&lt;p>&lt;strong>怎么检测？&lt;/strong>&lt;/p>
&lt;p>第一：良好的编码习惯，使用了内存分配的函数，一旦使用完毕,要记得使用其相应的函数释放掉。&lt;/p>
&lt;p>第二：将分配的内存的指针以链表的形式自行管理，使用完毕之后从链表中删除，程序结束时可检查改链表。&lt;/p>
&lt;p>第三：使用&lt;strong>智能指针&lt;/strong>。&lt;/p>
&lt;p>第四：一些常见的工具插件，如ccmalloc、Dmalloc、Leaky、Valgrind等等。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="智能指针-shared_ptr与unique_ptr的开销比较">智能指针 shared_ptr与unique_ptr的开销比较&lt;/h3>
&lt;p>shared_ptr内部引用计数对象要通过new创建，这样所有的对象才能指向同一个引用计数变量；&lt;/p>
&lt;p>unique_ptr接近原生的性能&lt;/p>
&lt;p>&lt;a href="https://blog.csdn.net/codingcs/article/details/120403980" target="_blank" rel="noopener">https://blog.csdn.net/codingcs/article/details/120403980&lt;/a>&lt;/p>
&lt;h3 id="右值引用">右值引用&lt;/h3>
&lt;p>右值引用主要用于移动语义和完美转发&lt;/p>
&lt;h3 id="如果有多个重载函数那么我根据函数名打断点gdb会怎么执行呢是只执行一个还是全部都显示出来都显示出来">如果有多个重载函数，那么我根据函数名打断点，GDB会怎么执行呢，是只执行一个还是全部都显示出来（都显示出来）&lt;/h3></description></item><item><title/><link>https://ysyyhhh.github.io/docs/language/c++/stl/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/language/c++/stl/</guid><description/></item><item><title/><link>https://ysyyhhh.github.io/docs/language/c++/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/language/c++/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</guid><description>&lt;h1 id="多线程">多线程&lt;/h1>
&lt;h2 id="锁">锁&lt;/h2>
&lt;h3 id="unique_lock-和-lock_guard">unique_lock 和 lock_guard&lt;/h3>
&lt;p>unique_lock 和 lock_guard 都是 RAII 的封装，都是用来管理 mutex 的，但是 unique_lock 比 lock_guard 更加灵活，可以随时 unlock 和 lock，而 lock_guard 只能在构造的时候 lock，在析构的时候 unlock。&lt;/p>
&lt;p>unique_lock:&lt;/p>
&lt;pre>&lt;code>```cpp
std::mutex mtx;
std::unique_lock&amp;lt;std::mutex&amp;gt; lck(mtx);
lck.unlock();
lck.lock();
```
&lt;/code>&lt;/pre>
&lt;p>lock_guard:&lt;/p>
&lt;pre>&lt;code>```cpp
std::mutex mtx;
std::lock_guard&amp;lt;std::mutex&amp;gt; lck(mtx);
```
&lt;/code>&lt;/pre>
&lt;h4 id="和-condition_variable-使用时的区别">和 condition_variable 使用时的区别&lt;/h4>
&lt;p>unique_lock 和 lock_guard 都可以和 condition_variable 一起使用，但是 unique_lock 更加灵活，可以随时 unlock 和 lock，而 lock_guard 只能在构造的时候 lock，在析构的时候 unlock。&lt;/p>
&lt;p>unique_lock:&lt;/p>
&lt;pre>&lt;code>```cpp
std::mutex mtx;
std::condition_variable cv;
std::unique_lock&amp;lt;std::mutex&amp;gt; lck(mtx);
cv.wait(lck);
/*
这部分仍然被锁住
*/
lck.unlock();
lck.lock();
```
&lt;/code>&lt;/pre>
&lt;p>lock_guard:&lt;/p>
&lt;pre>&lt;code>```cpp
std::mutex mtx;
std::condition_variable cv;
std::lock_guard&amp;lt;std::mutex&amp;gt; lck(mtx);
cv.wait(lck);
/*
这部分已经被解锁
*/
```
&lt;/code>&lt;/pre></description></item><item><title/><link>https://ysyyhhh.github.io/docs/language/c++/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/language/c++/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</guid><description/></item><item><title/><link>https://ysyyhhh.github.io/docs/language/java/javaio/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/language/java/javaio/</guid><description/></item><item><title/><link>https://ysyyhhh.github.io/docs/language/java/java%E5%9F%BA%E7%A1%80/java%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/language/java/java%E5%9F%BA%E7%A1%80/java%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B/</guid><description>&lt;h1 id="java--编译与解释共存的语言">Java&amp;ndash;编译与解释共存的语言&lt;/h1>
&lt;p>&lt;a href="https://tech.meituan.com/2020/10/22/java-jit-practice-in-meituan.html" target="_blank" rel="noopener">基本功 | Java即时编译器原理解析及实践&lt;/a>&lt;/p>
&lt;p>编译型语言：
编译型语言是指在程序运行之前，需要先将源代码编译成机器码，然后再运行&lt;strong>编译后的机器码&lt;/strong>。编译型语言有C、C++、Rust、Go等。&lt;/p>
&lt;p>解释型语言：
解释型语言是指在程序运行时，需要通过解释器将源代码逐行解释成机器码，然后再运行机器码。解释型语言有Python、JavaScript、Ruby等。&lt;/p>
&lt;p>而Java是一种编译与解释共存的语言，它的编译与解释过程如下：&lt;/p>
&lt;ol>
&lt;li>编译：Java源代码首先通过javac编译器&lt;strong>编译成字节码&lt;/strong>（.class文件）。&lt;/li>
&lt;li>解释：然后通过Java虚拟机（JVM）将字节码解释成机器码，然后再运行机器码。&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>字节码(.class文件)：Java源代码经过编译后生成的中间代码，它不是机器码，而是一种介于源代码和机器码之间的代码。字节码可以在任何支持Java虚拟机的平台上运行，因此Java具有“一次编译，到处运行”的特性。&lt;/p>
&lt;/blockquote>
&lt;p>因此在性能上Java介于编译型语言和解释型语言之间，它的性能比解释型语言要好，但比编译型语言要差。&lt;/p>
&lt;h2 id="优化解释即时编译-jit-just-in-time-compilation技术">优化解释(即时编译 JIT, Just-In-Time Compilation)技术&lt;/h2>
&lt;p>为了优化性能,在第二步的解释中,Java使用了即时编译（JIT，Just-In-Time Compilation）技术&lt;/p>
&lt;p>当程序运行时，解释器首先发挥作用，代码可以直接执行。随着时间推移，即时编译器逐渐发挥作用，把越来越多的代码编译优化成本地代码，来获取更高的执行效率。&lt;/p>
&lt;p>即时编译器与静态编译相比:&lt;/p>
&lt;ul>
&lt;li>可以选择热点代码进行编译，而不是整个程序&lt;/li>
&lt;li>即时编译器已经非常成熟，可以进行更多的优化，比如内联、逃逸分析、栈上分配等&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Java%e5%9f%ba%e7%a1%80/Java%e7%a8%8b%e5%ba%8f%e5%8f%98%e4%b8%ba%e6%9c%ba%e5%99%a8%e7%a0%81.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>同样使用JIT技术的还有&lt;a href="https://zh.wikipedia.org/zh-cn/LLVM" target="_blank" rel="noopener">LLVM&lt;/a>、V8引擎等。&lt;/p>
&lt;blockquote>
&lt;p>AOT: Ahead-Of-Time Compilation，预编译，是指在程序运行之前，将源代码编译成机器码(属于静态编译)。
JDK 9引入了AOT编译器。
AOT 避免了 JIT 预热等各方面的开销，可以提高 Java 程序的启动速度，避免预热时间长。并且，AOT 还能减少内存占用和增强 Java 程序的安全性（AOT 编译后的代码不容易被反编译和修改），特别适合云原生场景。&lt;/p>
&lt;/blockquote>
&lt;h2 id="aot和jit">AOT和JIT&lt;/h2>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Java%e5%9f%ba%e7%a1%80/JITvsAOT.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>AOT 的主要优势在于启动时间、内存占用和打包体积。
JIT 的主要优势在于具备更高的极限处理能力，可以降低请求的最大延迟。&lt;/p>
&lt;blockquote>
&lt;p>GraalVM 是一种高性能的 JDK（完整的 JDK 发行版本），它可以运行 Java 和其他 JVM 语言，以及 JavaScript、Python 等非 JVM 语言。 GraalVM 不仅能提供 AOT 编译，还能提供 JIT 编译。&lt;/p>
&lt;/blockquote>
&lt;p>AOT 更适合当下的云原生场景，对微服务架构的支持也比较友好。
但AOT 编译无法支持 Java 的一些动态特性，如反射、动态代理、动态加载、JNI（Java Native Interface）等。而很多框架和库（如 Spring、CGLIB）都用到了这些特性。为了支持类似的动态特性，所以选择使用 JIT 即时编译器。&lt;/p>
&lt;blockquote>
&lt;p>如: CGLIB 动态代理使用的是 ASM 技术，而这种技术大致原理是运行时直接在内存中生成并加载修改后的字节码文件也就是 .class 文件，如果全部使用 AOT 提前编译，也就不能使用 ASM 技术了。&lt;/p>
&lt;/blockquote></description></item><item><title/><link>https://ysyyhhh.github.io/docs/language/java/java%E5%9F%BA%E7%A1%80/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/language/java/java%E5%9F%BA%E7%A1%80/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</guid><description>&lt;h1 id="基本概念">基本概念&lt;/h1>
&lt;h2 id="javasejavaeejavame">JavaSE、JavaEE、JavaME&lt;/h2>
&lt;ul>
&lt;li>JavaSE（Java Platform, Standard Edition）：Java平台标准版，是Java的核心部分，包括Java语言、Java虚拟机、Java API等。&lt;/li>
&lt;li>JavaEE（Java Platform, Enterprise Edition）：Java平台企业版，是JavaSE的扩展，用于开发企业级应用程序，包括Servlet、JSP、EJB等。&lt;/li>
&lt;li>JavaME（Java Platform, Micro Edition）：Java平台微型版，用于开发嵌入式设备和移动设备上的应用程序。&lt;/li>
&lt;/ul>
&lt;h2 id="jdkjrejvm">JDK、JRE、JVM&lt;/h2>
&lt;ul>
&lt;li>JVM（Java Virtual Machine）：Java虚拟机，用于执行Java字节码。&lt;/li>
&lt;li>JRE（Java Runtime Environment）：Java运行时环境，他包含了JVM和Java类库，用于运行Java程序。&lt;/li>
&lt;li>JDK（Java Development Kit）：Java&lt;strong>开发&lt;/strong>工具包，它包含了JRE，同时还包含了编译器javac、调试器jdb、文档生成器javadoc等开发工具。
&lt;ul>
&lt;li>开发时必须安装JDK，运行时通常只需要安装JRE（除非需要使用Java特性的开发工具，如JSP转换为Servlet，反射等）。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>Java1.0 到 Java9: 对应JDK1.0 到 JDK1.9&lt;/p>
&lt;p>Java10及之后: 对应JDK10及之后&lt;/p>
&lt;p>最新描述：
从JDK 9开始，不区分JDK和JRE，被模块系统取代：JDK（被重新组织成94个模块）和jlink工具。
并且从JDK 11开始，不再提供JRE，只提供JDK。&lt;/p>
&lt;h2 id="oracle-jdk-和-openjdk">Oracle JDK 和 OpenJDK&lt;/h2>
&lt;ul>
&lt;li>OpenJDK：由OpenJDK社区提供的JDK，是一个开源项目，不包含Oracle公司的商业特性，可以完全免费使用，基于GPLv2协议。&lt;/li>
&lt;li>Oracle JDK：由Oracle公司提供的JDK，一般是3年免费使用，之后需要付费。
&lt;ul>
&lt;li>JDK原本是SUN公司的产品且开源，后来SUN公司被Oracle公司收购，Oracle公司继续维护JDK，并且提供了商业特性。&lt;/li>
&lt;li>基于BCL/OTN协议。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>区别：&lt;/p>
&lt;ul>
&lt;li>更新频率：OpenJDK三个月更新一次，Oracle JDK每6个月更新一次。&lt;/li>
&lt;li>稳定性：Oracle JDK更稳定，OpenJDK更先进。&lt;/li>
&lt;/ul>
&lt;h2 id="java和c比较">Java和C++比较&lt;/h2>
&lt;p>不同点&lt;/p>
&lt;ul>
&lt;li>内存访问: Java是通过引用访问对象,内存更安全; 而C++是通过指针访问对象。&lt;/li>
&lt;li>类的继承: Java只支持单继承, C++支持多继承。&lt;/li>
&lt;li>运行环境: Java是跨平台的, C++不是。&lt;/li>
&lt;li>内存管理: Java有垃圾回收机制, C++需要手动管理内存。&lt;/li>
&lt;li>异常处理: Java使用异常处理机制, C++使用异常和错误码。&lt;/li>
&lt;li>重载: Java不支持运算符重载, C++支持。&lt;/li>
&lt;/ul></description></item><item><title/><link>https://ysyyhhh.github.io/docs/language/java/java%E5%9F%BA%E7%A1%80/%E5%B8%B8%E8%A7%81%E5%B7%A5%E5%85%B7%E7%B1%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/language/java/java%E5%9F%BA%E7%A1%80/%E5%B8%B8%E8%A7%81%E5%B7%A5%E5%85%B7%E7%B1%BB/</guid><description>&lt;h1 id="常见的java工具类">常见的Java工具类&lt;/h1>
&lt;h2 id="jwt">JWT&lt;/h2>
&lt;h3 id="jwt里面有什么httpsblogcsdnnetweixin_36378232articledetails113022878">jwt&lt;a href="https://blog.csdn.net/weixin_36378232/article/details/113022878" target="_blank" rel="noopener">里面有什么&lt;/a>&lt;/h3>
&lt;p>JWT主要由三个部分组成(前两部分可以通过base64解密得到)：头部(HEADER)，载荷(PAYLOAD)，签证(SIGNATURE)。&lt;/p>
&lt;ul>
&lt;li>头部描述该JWT的最基本信息，主要包含两个部分：声明类型 JWT 和声明加密算法(通常直接使用HMAC，SHA256)。
&lt;ul>
&lt;li>&lt;code>{ &amp;quot;alg&amp;quot;: &amp;quot;HS256&amp;quot;, //第三段字符串的不可逆加密类型HS256 &amp;quot;typ&amp;quot;: &amp;quot;JWT&amp;quot; //token类型JWT }&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>载荷主要是存放有效信息为自定义值，这些信息按照职能可以分成三个部分
&lt;ul>
&lt;li>标准的注册声明
&lt;ul>
&lt;li>人:签发者,jwt面向用户,接收jwt的一方.&lt;/li>
&lt;li>时间相关,过期时间,不可用时间.签发时间&lt;/li>
&lt;li>唯一标识, 可用于一次性token&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>公共的声明:公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息。但不建议添加敏感信息，因为该部分在客户端可解密。&lt;/li>
&lt;li>私有的声明:私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为BASE64是对称解密的，意味着该部分信息可以归类为明文信息。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>签证
&lt;ul>
&lt;li>先将第一段和第二段的密文&lt;strong>拼接&lt;/strong>起来&lt;/li>
&lt;li>对拼接起来的密文字符串和自定义的盐进行上边&lt;strong>指定的HS256加密&lt;/strong>&lt;/li>
&lt;li>&lt;strong>对HS256加密后的密文再做base64加密&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="要是想要传输密码怎么解决盐值怎么存储">要是想要传输密码，怎么解决？盐值怎么存储？&lt;/h3>
&lt;p>SHA,&lt;/p>
&lt;p>&lt;a href="https://blog.csdn.net/biubiubiubibibi/article/details/127579426" target="_blank" rel="noopener">BCryptPasswordEncoder&lt;/a>&lt;/p>
&lt;p>盐存在密文里.&lt;/p>
&lt;p>status字段是什么类型&lt;/p>
&lt;p>函数的返回值类型。&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/language/java/java%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/language/java/java%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid><description>&lt;h1 id="数据类型">数据类型&lt;/h1>
&lt;p>八种基本数据类型:&lt;/p>
&lt;p>byte/8
char/16
short/16
int/32
float/32
long/64
double/64
boolean/~&lt;/p>
&lt;p>基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用&lt;strong>自动装箱与拆箱完成&lt;/strong>。&lt;/p>
&lt;h2 id="基本数据类型和包装类型的区别">基本数据类型和包装类型的区别&lt;/h2>
&lt;ul>
&lt;li>用途: 基本数据类型一般只用于常量和局部变量, 而包装类型可以用于类的成员变量, 方法参数和返回值&lt;/li>
&lt;li>内存占用: 基本数据类型占用的内存较小, 包装类型占用的内存较大&lt;/li>
&lt;li>默认值: 基本数据类型有默认值, 包装类型默认值为null&lt;/li>
&lt;li>引用: 基本数据类型不是对象, 包装类型是对象&lt;/li>
&lt;li>比较: 基本数据类型比较值, 包装类型&lt;strong>比较引用&lt;/strong>,比较内容需要使用equals方法&lt;/li>
&lt;li>存储方式: 基本数据类型的存储位置取决于变量的作用域和声明方式, 包装类型存储在堆中.(几乎所有的对象都存储在堆中)&lt;/li>
&lt;/ul>
&lt;p>为什么说是几乎所有对象实例都存在于堆中呢？&lt;/p>
&lt;p>这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存&lt;/p>
&lt;p>&lt;strong>基本数据类型的存储位置取决于它们的作用域和声明方式。&lt;/strong>
栈中:&lt;/p>
&lt;ul>
&lt;li>局部变量&lt;/li>
&lt;/ul>
&lt;p>堆中:&lt;/p>
&lt;ul>
&lt;li>成员变量(非static)&lt;/li>
&lt;/ul>
&lt;h2 id="自动装箱与拆箱">自动装箱与拆箱&lt;/h2>
&lt;p>自动装箱: 将基本数据类型转换为包装类型&lt;/p>
&lt;p>自动拆箱: 将包装类型转换为基本数据类型&lt;/p>
&lt;p>都是调用包装类型的valueOf方法和基本类型的xxxValue方法完成的&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="n">Integer&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">2&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// 装箱 调用了 Integer.valueOf(2)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// 拆箱 调用了 X.intValue()&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果频繁进行装箱和拆箱操作，会影响程序的性能.&lt;/p>
&lt;h3 id="装箱时使用的缓冲池">装箱时使用的缓冲池&lt;/h3>
&lt;p>new Integer(123) 与 Integer.valueOf(123) 的区别在于：&lt;/p>
&lt;ul>
&lt;li>new Integer(123) 每次都会新建一个对象；&lt;/li>
&lt;li>Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。&lt;/li>
&lt;/ul>
&lt;p>Java中的包装类型中，Integer、Byte、Short、Long、Character这几种包装类型默认会缓存-128到127之间的数值，这个区间的数值被缓存到了内部的缓冲池中，如果数值在这个区间内，就直接从缓冲池中获取对象，而不是重新创建一个新的对象。&lt;/p>
&lt;p>基本类型对应的缓冲池如下：&lt;/p>
&lt;p>boolean values true and false
all byte values
short values between -128 and 127
int values between -128 and 127
char in the range \u0000 to \u007F
在使用这些基本类型对应的包装类型时，如果该数值范围在缓冲池范围内，就可以直接使用缓冲池中的对象。&lt;/p>
&lt;h3 id="自动拆箱引发的空指针异常">自动拆箱引发的空指针异常&lt;/h3>
&lt;p>自动拆箱会引发空指针异常，当包装类型为null时，调用其xxxValue方法会引发空指针异常。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="n">Integer&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// NullPointerException&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>三目运算符中隐含的自动拆箱可能引发空指针异常&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="n">Integer&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kc">false&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">?&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// NullPointerException&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c1">//正确写法 保持两者类型一致&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kc">false&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">?&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Integer&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">valueOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这是因为0是int类型，x会自动拆箱，而x为null，所以会引发空指针异常。&lt;/p>
&lt;blockquote>
&lt;p>阿里开发手册
【强制】三目运算符 condition?表达式1:表达式2中,高度注意表达式1和2在类型对产时，可能抛出因自动拆箱导致的 NPE 异常。说明:以下两种场景会触发类型对齐的拆箱操作:
1)表达式1或表达式2的值只要有一个是原始类型。
2)表达式1或表达式2的值的类型不一致，会强制拆箱升级成表示范围更大的那个类型&lt;/p>
&lt;/blockquote>
&lt;h2 id="高精度与大整数">高精度与大整数&lt;/h2>
&lt;h3 id="浮点数运算须使用bigdecimal">浮点数运算须使用BigDecimal&lt;/h3>
&lt;p>Java中的浮点数运算时会有精度丢失的问题，这是因为浮点数是用二进制表示的，而二进制无法精确表示某些十进制小数，比如0.1。&lt;/p>
&lt;p>而BigDecimal可以精确表示任意精度的十进制小数，因此在需要精确计算的场景下，应该使用BigDecimal来进行浮点数运算。&lt;/p>
&lt;h4 id="初始化">初始化&lt;/h4>
&lt;p>【强制】禁止使用构造方法 **BigDecimal(double)**的方式把 double 值转化为 BigDecimal 对象说明:BigDecimal(double)存在精度损失风险，在精确计算或值比较的场景中可能会导致业务逻辑异常。&lt;/p>
&lt;p>如:BigDecimalg=new BigDecimal(0.1F);
实际的存储值为:0.10000000149正例:优先推荐入参为 String 的构造方法，或使用 BigDecimal的valueOf方法，此方法内部其实执行之Double的 toString,而 Double 的 toString 按 double 的实际能表达的精度对尾数进行了截断。&lt;/p>
&lt;p>BigDecimal recommend1 = new BigDecimal(&amp;ldquo;0.1&amp;rdquo;);
BigDecimal recommend2 = BigDecimal.valueOf(0.1);&lt;/p>
&lt;h4 id="比较">比较&lt;/h4>
&lt;p>【强制】BigDecimal 的大小比较，推荐使用 compareTo 方法，equals 方法是同时比较值和精度，与预期不一致。说明:compareTo 方法是比较值，equals 方法是比较值和精度。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="n">BigDecimal&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">BigDecimal&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;1&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">BigDecimal&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">BigDecimal&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;1.0&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">equals&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">));&lt;/span>&lt;span class="c1">//false&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="超过long的数据应该用biginteger">超过Long的数据应该用BigInteger&lt;/h3>
&lt;p>超过Long导致的溢出问题&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">long&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Long&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">MAX_VALUE&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// -9223372036854775808&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">l&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">==&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Long&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">MIN_VALUE&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// true&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>BigInteger可以表示任意精度的整数，因此在需要表示超过Long的整数时，应该使用BigInteger。&lt;/p>
&lt;p>BigInteger内部是用int[]来存储数据的，因此可以表示任意精度的整数，但是由于是数组存储，因此在进行加减乘除等运算时，性能会比较差。&lt;/p>
&lt;h2 id="object">Object&lt;/h2>
&lt;p>Object是所有类的父类，因此任何类的对象都可以赋值给Object类型的变量。&lt;/p>
&lt;p>创建一个对象用什么运算符?对象实体与对象引用有何不同?new 运算符，new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。&lt;/p>
&lt;p>一个对象引用可以指向 0 个或 1 个对象
一个对象可以有 n 个引用指向它&lt;/p>
&lt;p>对象的相等和引用相等的区别对象的相等一般比较的是内存中存放的内容是否相等。引用相等一般比较的是他们指向的内存地址是否相等。&lt;/p>
&lt;h2 id="string">String&lt;/h2>
&lt;p>String是不可变的，一旦创建就不能被修改。
String的不可变性是通过final关键字实现的，因此String类是不可继承的。&lt;/p>
&lt;p>String的不可变性有以下好处：&lt;/p>
&lt;ul>
&lt;li>可以缓存hash值&lt;/li>
&lt;li>String Pool的实现是基于不可变性的&lt;/li>
&lt;li>安全性&lt;/li>
&lt;li>线程安全&lt;/li>
&lt;/ul>
&lt;p>StringBuffer和StringBuilder是可变的字符串，它们的实现是通过字符数组实现的。&lt;/p>
&lt;p>StringBuffer是线程安全的，而StringBuilder是非线程安全的。&lt;/p>
&lt;p>StringBuffer和StringBuilder的区别在于StringBuffer的方法是同步的，而StringBuilder的方法是非同步的。&lt;/p>
&lt;p>Java本身不支持运算符重载，但String的+和+=操作符是专门针对String的重载的。&lt;/p>
&lt;p>字符串的+=默认使用StringBuilder实现的，因此在循环中使用+=拼接字符串会产生大量的StringBuilder对象，可以在循环外使用StringBuilder来优化。&lt;/p>
&lt;blockquote>
&lt;p>JDK9之后，String的+和+=操作符的实现已经不是通过StringBuilder来实现的，而是通过invokedynamic指令来实现的，这样可以更好的优化字符串的拼接操作。
但也有常量折叠的优化，所以在编译时会自动将字符串拼接操作优化为常量。&lt;/p>
&lt;/blockquote>
&lt;p>Object的equals方法是比较的引用，而String的equals方法是比较的内容。&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/language/java/java%E5%9F%BA%E7%A1%80/%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/language/java/java%E5%9F%BA%E7%A1%80/%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7/</guid><description>&lt;h1 id="语法特性">语法特性&lt;/h1>
&lt;h2 id="异常">异常&lt;/h2>
&lt;h3 id="异常分类">异常分类&lt;/h3>
&lt;p>异常属于Java.lang包中的Throwable类的子类, 分为两种&lt;/p>
&lt;ul>
&lt;li>Error
&lt;ul>
&lt;li>属于程序无法处理的错误&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Exception
&lt;ul>
&lt;li>属于程序可以处理的错误, 通过catch捕获,分为
&lt;ul>
&lt;li>受检异常
&lt;ul>
&lt;li>如果这些异常没用被catch或者throws, 编译器会报错&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>非受检异常: RuntimeException及其子类
&lt;ul>
&lt;li>NullPointerException(空指针异常)&lt;/li>
&lt;li>ArrayIndexOutOfBoundsException(数组越界异常)&lt;/li>
&lt;li>ClassCastException(类型转换异常)&lt;/li>
&lt;li>IllegalArgumentException(非法参数异常)&lt;/li>
&lt;li>NumberFormatException(数字格式异常)&lt;/li>
&lt;li>ArithmeticException(算术异常)&lt;/li>
&lt;li>IndexOutOfBoundsException(索引越界异常)&lt;/li>
&lt;li>ConcurrentModificationException(并发修改异常)&lt;/li>
&lt;li>UnsupportedOperationException(不支持的操作异常)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="异常处理机制">异常处理机制&lt;/h3>
&lt;p>try-catch-finally 和 try-with-resources&lt;/p>
&lt;ul>
&lt;li>try-catch-finally
&lt;ul>
&lt;li>try
&lt;ul>
&lt;li>包含可能抛出异常的代码&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>catch
&lt;ul>
&lt;li>捕获异常, 处理异常&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>finally
&lt;ul>
&lt;li>无论是否发生异常, 都会执行的代码块&lt;/li>
&lt;li>实际,如果cpu停止或者执行System.exit(0)方法, finally块不会执行&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>用Java 7之后的try-with-resources可以自动关闭资源, 例如文件流, 网络流, 数据库连接等,并且可以通过分号分隔多个资源&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="k">try&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">BufferedReader&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">br&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">BufferedReader&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">FileReader&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="p">));&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">BufferedWriter&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">bw&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">BufferedWriter&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">FileWriter&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="p">)))&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 读取文件&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">line&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">while&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="n">line&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">br&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">readLine&lt;/span>&lt;span class="p">())&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">!=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 写入文件&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">bw&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">write&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">line&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">catch&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">IOException&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">printStackTrace&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="泛型">泛型&lt;/h2>
&lt;p>三种使用方式: 泛型类、泛型接口、泛型方法&lt;/p>
&lt;h3 id="泛型类">泛型类&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">Generic&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">Generic&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">key&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">getKey&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="泛型接口">泛型接口&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">interface&lt;/span> &lt;span class="nc">Generator&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">next&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="泛型方法">泛型方法&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">static&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">E&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">printArray&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">E&lt;/span>&lt;span class="o">[]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">inputArray&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">for&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">E&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">element&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">inputArray&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">){&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;%s &amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">element&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c1">// 使用&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">Integer&lt;/span>&lt;span class="o">[]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">intArray&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">2&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">3&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">4&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">5&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">};&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">Character&lt;/span>&lt;span class="o">[]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">charArray&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sc">&amp;#39;H&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sc">&amp;#39;E&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sc">&amp;#39;L&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sc">&amp;#39;L&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sc">&amp;#39;O&amp;#39;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">};&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">printArray&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">intArray&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">printArray&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">charArray&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>项目中的泛型：&lt;/p>
&lt;ul>
&lt;li>接口返回值&lt;/li>
&lt;li>接口参数&lt;/li>
&lt;li>集合工具类&lt;/li>
&lt;/ul>
&lt;h2 id="反射">反射&lt;/h2>
&lt;p>反射是指程序在运行时能够获取自身的信息, 比如类的属性和方法, 并且可以调用类的方法和属性&lt;/p>
&lt;p>优点：&lt;/p>
&lt;ul>
&lt;li>为框架提供灵活性&lt;/li>
&lt;li>为IDE提供更好的编码体验&lt;/li>
&lt;/ul>
&lt;p>缺点：&lt;/p>
&lt;ul>
&lt;li>性能开销&lt;/li>
&lt;li>安全问题
&lt;ul>
&lt;li>反射可以访问私有方法和属性&lt;/li>
&lt;li>反射可以绕过泛型检查&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="反射的应用">反射的应用&lt;/h3>
&lt;ul>
&lt;li>动态代理&lt;/li>
&lt;li>注解&lt;/li>
&lt;/ul>
&lt;p>通过反射实现动态代理&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">ProxyHandler&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">implements&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">InvocationHandler&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Object&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">target&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">ProxyHandler&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Object&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">target&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">target&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">target&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nd">@Override&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Object&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">invoke&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Object&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">proxy&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Method&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">method&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Object&lt;/span>&lt;span class="o">[]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">args&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">throws&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Throwable&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;before&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">Object&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">result&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">method&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">invoke&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">target&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">args&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;after&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">result&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>注解的实现&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="nd">@Target&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ElementType&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">METHOD&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nd">@Retention&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">RetentionPolicy&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">RUNTIME&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nd">@interface&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">MyAnnotation&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">value&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">default&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;hello&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="err">###&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">反射实战&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">知道具体的类&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="err">```&lt;/span>&lt;span class="n">java&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">Class&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">clazz&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">User&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="2">
&lt;li>通过类的全路径名&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="n">Class&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">clazz&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Class&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">forName&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;com.example.User&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="3">
&lt;li>通过对象实例&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="n">User&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">user&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">User&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">Class&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">clazz&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">user&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">getClass&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="4">
&lt;li>通过类加载器&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="n">ClassLoader&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">classLoader&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Thread&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">currentThread&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="na">getContextClassLoader&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">Class&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">clazz&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">classLoader&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">loadClass&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;com.example.User&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>具体的操作&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">class&lt;/span> &lt;span class="nc">User&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">age&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">sayHello&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Hello&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">Main&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">static&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">args&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">throws&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Exception&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">Class&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">clazz&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">User&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 获取类的属性&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">Field&lt;/span>&lt;span class="o">[]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">fields&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">clazz&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">getDeclaredFields&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">for&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Field&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">field&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">fields&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">field&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">getName&lt;/span>&lt;span class="p">());&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 使用指定属性&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">Field&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">field&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">clazz&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">getDeclaredField&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;name&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 修改属性的值&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">filed&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">setAccessible&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">filed&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">set&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">user&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;Tom&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 获取类的方法&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">Method&lt;/span>&lt;span class="o">[]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">methods&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">clazz&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">getDeclaredMethods&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">for&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Method&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">method&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">methods&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">method&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">getName&lt;/span>&lt;span class="p">());&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 使用指定方法&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">Method&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">method&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">clazz&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">getDeclaredMethod&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;sayHello&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 调用方法&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">method&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">invoke&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">user&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">//调用私有方法&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">Method&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">method&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">clazz&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">getDeclaredMethod&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;privateMethod&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">method&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">setAccessible&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">method&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">invoke&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">user&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 获取类的构造方法&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">Constructor&lt;/span>&lt;span class="o">[]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">constructors&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">clazz&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">getDeclaredConstructors&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">for&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Constructor&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">constructor&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">constructors&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">constructor&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">getName&lt;/span>&lt;span class="p">());&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="注解">注解&lt;/h2>
&lt;p>Annotation是一种标记, 可以在类, 方法, 字段, 参数等上使用, 用于提供信息给编译器, 代码分析工具或者运行时的处理器&lt;/p>
&lt;h3 id="内置注解">内置注解&lt;/h3>
&lt;ul>
&lt;li>@Override
&lt;ul>
&lt;li>用于标记方法重写&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>@Deprecated
&lt;ul>
&lt;li>用于标记方法或类已经过时&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="自定义注解">自定义注解&lt;/h3>
&lt;p>本质是继承了Annotation接口的接口, 并且可以添加属性&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="nd">@Target&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ElementType&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">METHOD&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nd">@Retention&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">RetentionPolicy&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">SOURCE&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nd">@interface&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">MyAnnotation&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">value&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">default&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;hello&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="注解的应用">注解的应用&lt;/h3>
&lt;p>主要分为两种解析方式&lt;/p>
&lt;ul>
&lt;li>编译时注解
&lt;ul>
&lt;li>通过注解处理器在编译时处理注解&lt;/li>
&lt;li>例如lombok, @Override, @Deprecated&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>运行时注解
&lt;ul>
&lt;li>通过反射在运行时处理注解&lt;/li>
&lt;li>例如Spring的@Service, @Autowired, @RequestMapping&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="spi">SPI&lt;/h2>
&lt;p>SPI(Service Provider Interface)是一种服务发现机制, 它通过在ClassPath路径下的META-INF/services文件夹查找文件, 自动加载文件里所定义的类&lt;/p>
&lt;p>SPI与API的区别&lt;/p>
&lt;ul>
&lt;li>API是应用程序接口, 是一种约定, 由开发者来实现&lt;/li>
&lt;li>SPI是服务提供接口, 是一种约定, 由服务提供者来实现&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e8%af%ad%e6%b3%95%e7%89%b9%e6%80%a7/SPI%20vs%20API.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>SPI的优缺点&lt;/p>
&lt;ul>
&lt;li>优点
&lt;ul>
&lt;li>松耦合&lt;/li>
&lt;li>可扩展&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>缺点
&lt;ul>
&lt;li>不能按需加载, 无法动态添加或删除实现类&lt;/li>
&lt;li>无法动态修改实现类的优先级&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="spi实战">SPI实战&lt;/h3>
&lt;p>&lt;a href="https://javaguide.cn/java/basis/spi.html#%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA" target="_blank" rel="noopener">参考&lt;/a>&lt;/p>
&lt;ol>
&lt;li>定义接口&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">interface&lt;/span> &lt;span class="nc">HelloService&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">sayHello&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="2">
&lt;li>实现接口&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">HelloServiceImpl1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">implements&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">HelloService&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nd">@Override&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">sayHello&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Hello1&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">HelloServiceImpl2&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">implements&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">HelloService&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nd">@Override&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">sayHello&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Hello2&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="3">
&lt;li>在META-INF/services文件夹下创建文件&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="n">com&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">example&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">HelloServiceImpl1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">com&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">example&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">HelloServiceImpl2&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="4">
&lt;li>加载实现类&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">Main&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">static&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">args&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">ServiceLoader&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">HelloService&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">serviceLoader&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ServiceLoader&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">load&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">HelloService&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">for&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">HelloService&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">helloService&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">serviceLoader&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">helloService&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">sayHello&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="序列化和反序列化">序列化和反序列化&lt;/h2>
&lt;p>序列化: 将对象转换为字节序列的过程
反序列化: 将字节序列转换为对象的过程&lt;/p>
&lt;h3 id="序列化的场景">序列化的场景&lt;/h3>
&lt;ul>
&lt;li>网络传输
&lt;ul>
&lt;li>远程调用&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>持久化存储
&lt;ul>
&lt;li>文件&lt;/li>
&lt;li>数据库&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>缓存&lt;/li>
&lt;/ul>
&lt;p>对应OSI七层模型中的应用层和表示层&lt;/p>
&lt;h3 id="序列化的实现">序列化的实现&lt;/h3>
&lt;h4 id="自带的序列化方式">自带的序列化方式&lt;/h4>
&lt;ul>
&lt;li>Java原生序列化
&lt;ul>
&lt;li>实现Serializable接口&lt;/li>
&lt;li>通过ObjectOutputStream和ObjectInputStream实现序列化和反序列化&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">User&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">implements&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Serializable&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">age&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">transient&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">password&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>serialVersionUID是用来验证版本一致性的, 如果不指定, 编译器会自动生成, 但是如果类的定义发生变化, 会导致serialVersionUID变化, 从而导致反序列化失败&lt;/p>
&lt;p>不想被序列化的字段可以使用transient关键字修饰
注意:&lt;/p>
&lt;ul>
&lt;li>静态变量没有transient修饰符, 也不会被序列化&lt;/li>
&lt;li>transient只能修饰变量, 不能修饰类和方法&lt;/li>
&lt;li>transient变量被序列化后会被赋予默认值&lt;/li>
&lt;/ul>
&lt;p>不推荐使用原生序列化, 因为&lt;/p>
&lt;ul>
&lt;li>性能差
&lt;ul>
&lt;li>序列化和反序列化的性能差&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>不支持跨语言
&lt;ul>
&lt;li>Java原生序列化是Java特有的, 不支持跨语言&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>不安全
&lt;ul>
&lt;li>反序列化会导致安全问题&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="第三方序列化方式">第三方序列化方式&lt;/h4>
&lt;p>Kryo&lt;/p>
&lt;p>Protobuf&lt;/p>
&lt;p>ProtoStuff&lt;/p>
&lt;h2 id="语法糖">语法糖&lt;/h2>
&lt;p>语法糖是指在编程语言中, 不影响语言功能和性能的情况下, 为程序员提供的更方便的语法&lt;/p>
&lt;p>语法糖被正确执行需要编译器的支持, JVM不能直接执行语法糖.
如,在com.sun.tools.javac.main.JavaCompiler中,有一个方法,public void compile(List&lt;JavaFileObject> compilationUnits),这个方法里有一个步骤是desugar,这个步骤就是将语法糖转换为普通的语法&lt;/p>
&lt;h3 id="常见的语法糖">常见的语法糖&lt;/h3>
&lt;ul>
&lt;li>自动装箱和拆箱
&lt;ul>
&lt;li>Integer i = 1; // 自动装箱&lt;/li>
&lt;li>int j = i; // 自动拆箱&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>泛型
&lt;ul>
&lt;li>List&lt;String> list = new ArrayList&amp;lt;&amp;gt;();&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>foreach
&lt;ul>
&lt;li>for (String s : list) {}&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>变长参数
&lt;ul>
&lt;li>public void test(String&amp;hellip; args) {}&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>枚举
&lt;ul>
&lt;li>enum Color {RED, GREEN, BLUE}&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>try-with-resources
&lt;ul>
&lt;li>try (BufferedReader br = new BufferedReader&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Lambda
&lt;ul>
&lt;li>(a, b) -&amp;gt; a + b&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title/><link>https://ysyyhhh.github.io/docs/language/java/java%E9%9B%86%E5%90%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/language/java/java%E9%9B%86%E5%90%88/</guid><description>&lt;h1 id="java集合体系">Java集合体系&lt;/h1>
&lt;p>Java 集合， 也叫作容器，主要是由两大接口派生而来：一个是 Collection接口，主要用于存放单一元素；另一个是 Map 接口，主要用于存放键值对。对于Collection 接口，下面又有三个主要的子接口：List、Set 和 Queue。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Java%e9%9b%86%e5%90%88/Java%e9%9b%86%e5%90%88%e7%9a%84%e7%bb%93%e6%9e%84.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>List: 有序，可重复&lt;/p>
&lt;ul>
&lt;li>ArrayList: Object[] 数组, 查询快, 增删慢&lt;/li>
&lt;li>Vector: Object[] 数组, 线程安全(与ArrayList区别)&lt;/li>
&lt;li>LinkedList: 双向链表, 查询慢, 增删快&lt;/li>
&lt;/ul>
&lt;p>Set: 元素不可重复&lt;/p>
&lt;ul>
&lt;li>HashSet: 基于HashMap实现, 无序&lt;/li>
&lt;li>TreeSet: 红黑树(自平衡的二叉查找树), 有序&lt;/li>
&lt;li>LinkedHashSet: 基于LinkedHashMap实现, 是HashSet的子类, 有序&lt;/li>
&lt;/ul>
&lt;p>Queue: 有序，可重复, 用于存放队列元素&lt;/p>
&lt;ul>
&lt;li>PriorityQueue: 优先级队列, Object[] 数组&lt;/li>
&lt;li>DelayQueue: 延迟队列, 用于存放延迟元素&lt;/li>
&lt;li>ArrayDeque: 双端队列, Object[] 数组&lt;/li>
&lt;/ul>
&lt;p>Map: 无序，不可重复，键值对&lt;/p>
&lt;ul>
&lt;li>HashMap: JDK1.8之前是数组+链表, JDK1.8之后是数组+链表/红黑树&lt;/li>
&lt;li>LinkedHashMap: 基于HashMap实现, 有序&lt;/li>
&lt;li>TreeMap: 红黑树(自平衡的二叉查找树), 有序&lt;/li>
&lt;li>Hashtable: 数组(主体)+链表(解决哈希冲突), 线程安全&lt;/li>
&lt;/ul>
&lt;p>如何选用集合&lt;/p>
&lt;ul>
&lt;li>要键值对 - Map
&lt;ul>
&lt;li>需要排序 - TreeMap&lt;/li>
&lt;li>不需要排序 - HashMap&lt;/li>
&lt;li>需要线程安全 - Hashtable&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>不需要键值对 - Collection
&lt;ul>
&lt;li>保证元素唯一 - Set
&lt;ul>
&lt;li>需要排序 - TreeSet&lt;/li>
&lt;li>不需要排序 - HashSet&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>允许重复元素 - List
&lt;ul>
&lt;li>需要高效的增删 - LinkedList&lt;/li>
&lt;li>需要高效的查询 - ArrayList&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="list">List&lt;/h2>
&lt;p>ArrayList 与 Array比较&lt;/p>
&lt;ul>
&lt;li>ArrayList是数组的封装，可以动态扩容，而数组是静态的&lt;/li>
&lt;li>ArrayList允许使用泛型&lt;/li>
&lt;/ul>
&lt;p>ArrayList 与 Vector比较&lt;/p>
&lt;ul>
&lt;li>ArrayList是非线程安全的，而Vector是线程安全的&lt;/li>
&lt;li>ArrayList是JDK1.2引入的(主要实现类,新)，而Vector是JDK1.0引入的&lt;/li>
&lt;/ul>
&lt;p>ArrayList&lt;/p>
&lt;ul>
&lt;li>底层是数组,支持随机访问&lt;/li>
&lt;li>可以添加null元素&lt;/li>
&lt;li>插入:
&lt;ul>
&lt;li>头部插入: O(n)&lt;/li>
&lt;li>尾部插入: O(1), 扩容时O(n),每次扩容是原来的1.5倍&lt;/li>
&lt;li>指定位置插入: O(n)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>删除:
&lt;ul>
&lt;li>只有尾部删除是O(1), 其他都是O(n)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>LinkedList&lt;/p>
&lt;ul>
&lt;li>底层是双向链表, 不支持随机访问&lt;/li>
&lt;li>头部和尾部的插入删除都是O(1)&lt;/li>
&lt;li>一般不使用,作者都不使用&lt;/li>
&lt;/ul>
&lt;h2 id="set">Set&lt;/h2>
&lt;p>对集合进行排序时,需要实现Comparable接口,重写compareTo方法&lt;/p>
&lt;p>集合的不可重复性是通过equals方法来判断的, 需要重写equals方法和hashCode方法&lt;/p>
&lt;h4 id="hashset了解过吗">hashset了解过吗&lt;/h4>
&lt;p>HashSet是一种基于哈希表的Set实现，其底层实现与HashMap类似，只不过HashSet中存储的是不重复的元素。HashSet中的元素是无序的，不保证元素的插入顺序和遍历顺序一致。&lt;/p>
&lt;h4 id="判断某对象是否在set中存在需要重写哪些方法">判断某对象是否在set中存在，需要重写哪些方法&lt;/h4>
&lt;p>为了判断某个对象是否在Set中存在，需要重写该对象的hashCode()和equals()方法。hashCode()方法用于计算对象的哈希值，equals()方法用于比较两个对象是否相等。在重写这两个方法时，需要保证相等的对象具有相同的哈希值，否则会导致Set中出现重复元素。&lt;/p>
&lt;h2 id="queue">Queue&lt;/h2>
&lt;p>ArrayDeque 和 LinkedList的区别&lt;/p>
&lt;ul>
&lt;li>都实现了Deque接口&lt;/li>
&lt;li>ArrayDeque是数组实现的双端队列, 随机访问快, 队列操作慢；LinkedList是双向链表实现的双端队列, 队列操作快&lt;/li>
&lt;li>ArrayDeque不支持null元素, LinkedList支持&lt;/li>
&lt;li>ArrayDeque存在扩容，但均摊快；LinkedList不存在，每次插入需要申请空间，均摊慢。&lt;/li>
&lt;/ul>
&lt;h3 id="priorityqueue">PriorityQueue&lt;/h3>
&lt;p>JDK1.5 引入的&lt;/p>
&lt;ul>
&lt;li>底层是堆, 默认是小顶堆, 可以通过传入Comparator来实现大顶堆&lt;/li>
&lt;li>是插入删除是O(logn)，查顶推是O(1)&lt;/li>
&lt;li>是非线程安全的，不支持null元素&lt;/li>
&lt;/ul>
&lt;p>典型算法题的应用&lt;/p>
&lt;ul>
&lt;li>推排序&lt;/li>
&lt;li>第k大数（不过这个一般用快排O(n)实现）&lt;/li>
&lt;li>带权图的遍历&lt;/li>
&lt;/ul>
&lt;h3 id="blockingqueue-阻塞队列">BlockingQueue 阻塞队列&lt;/h3>
&lt;p>是一个接口，继承于Qeueu。&lt;/p>
&lt;p>阻塞的原因是，支持当队列没用元素时一直阻塞，直到有元素。
如果队列已满，则等到队列有空间时再插入元素。&lt;/p>
&lt;p>常用于生产者消费者模型。&lt;/p>
&lt;h2 id="map">Map**&lt;/h2>
&lt;h3 id="hashmap">HashMap&lt;/h3>
&lt;p>HashMap 和 HashTable的区别&lt;/p>
&lt;ul>
&lt;li>HashMap是非线程安全的，而HashTable是线程安全的&lt;/li>
&lt;li>HashMap允许使用null作为键和值，而HashTable不允许&lt;/li>
&lt;li>效率：HashMap效率高，HashTable效率低&lt;/li>
&lt;li>容量大小：HashMap默认大小为16，HashTable默认大小为11&lt;/li>
&lt;li>扩容：HashMap扩容是原来的2倍，HashTable扩容是原来的2倍+1&lt;/li>
&lt;li>底层数据结构：HashMap是数组+链表/红黑树，HashTable是数组+链表
&lt;ul>
&lt;li>JDK1.8 HashMap在链表长度超过8时，链表会自动转化为红黑树，优化查询速度&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>HashMap 和 TreeMap的区别&lt;/p>
&lt;ul>
&lt;li>HashMap是无序的，而TreeMap是有序的&lt;/li>
&lt;/ul>
&lt;h4 id="hashmap原理">HashMap原理&lt;/h4>
&lt;p>HashMap是一种基于哈希表的Map实现，其底层实现主要包括数组和链表（或红黑树）两部分。数组用来存储哈希桶，链表（或红黑树）用来解决哈希冲突。&lt;/p>
&lt;p>数组+链表+红黑树。&lt;/p>
&lt;p>那么在jdk1.8的HashMap中，当链表的长度超过8时，链表会自动转化为红黑树，优化查询速度。&lt;/p>
&lt;p>put原理&lt;/p>
&lt;p>同时还有一个区别：发生“hash冲突”时，我们上面的做法是“头插法”，这是jdk1.7的做法，而在jdk1.8中，使用的是“尾插法”。&lt;/p>
&lt;h4 id="hashmap底层实现">hashmap底层实现&lt;/h4>
&lt;p>HashMap是一种基于哈希表的Map实现，其底层实现主要包括数组和链表（或红黑树）两部分。数组用来存储哈希桶，链表（或红黑树）用来解决哈希冲突。&lt;/p>
&lt;p>具体来说，HashMap中的每个元素都是一个键值对，其中键和值都可以为null。当向HashMap中添加元素时，首先根据键的哈希值计算出该元素在数组中的位置，如果该位置上已经有元素了，则需要使用链表（或红黑树）来解决哈希冲突。如果链表（或红黑树）中已经存在该键，则更新该键对应的值，否则将该键值对添加到链表（或红黑树）的末尾。&lt;/p>
&lt;p>当链表（或红黑树）的长度超过一定阈值时，链表（或红黑树）会被转换为红黑树（或链表），以提高查询效率。当链表（或红黑树）的长度小于等于6时，会使用链表来存储元素，当长度大于6时，会使用红黑树来存储元素。&lt;/p>
&lt;p>在HashMap中，数组的长度是2的幂次方，这是为了使哈希值的高位和低位都能够参与到计算中，提高哈希值的均匀性。同时，数组的长度也决定了HashMap中哈希桶的数量，当哈希桶的数量过少时，容易导致哈希冲突，影响查询效率；当哈希桶的数量过多时，会浪费内存空间。因此，在创建HashMap时，需要根据实际情况来选择合适的数组长度。&lt;/p>
&lt;h4 id="hashmap17和18区别">hashmap1.7和1.8区别&lt;/h4>
&lt;p>HashMap1.7和1.8的主要区别在于底层实现方式的改变。1.7中使用的是数组+链表的方式来解决哈希冲突，而1.8中引入了红黑树来优化链表过长的情况，提高了查询效率。此外，1.8中还引入了一些新的方法和特性，如forEach()方法、Lambda表达式等。&lt;/p>
&lt;h4 id="hashmap怎么让他线程安全的方法">hashmap怎么让他线程安全的方法&lt;/h4>
&lt;p>HashMap本身是非线程安全的，如果需要在多线程环境下使用HashMap，可以使用以下几种方法来保证线程安全：&lt;/p>
&lt;ol>
&lt;li>使用Collections.synchronizedMap()方法将HashMap转换为线程安全的Map。&lt;/li>
&lt;li>使用ConcurrentHashMap代替HashMap，ConcurrentHashMap是一种线程安全的Map实现。&lt;/li>
&lt;li>使用读写锁来保证HashMap的线程安全性，即使用ReentrantReadWriteLock来控制读写操作的并发访问。&lt;/li>
&lt;/ol>
&lt;h3 id="concurrenthashmap">ConcurrentHashMap&lt;/h3>
&lt;h4 id="concurrenthashmap原理">ConcurrentHashMap原理&lt;/h4>
&lt;p>红黑树可用别的数据结构代替吗&lt;/p>
&lt;p>跳表与红黑树比较&lt;/p>
&lt;p>线程安全的类有哪些，为什么线程安全&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/language/java/jucjava%E5%B9%B6%E5%8F%91/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/language/java/jucjava%E5%B9%B6%E5%8F%91/</guid><description>&lt;h1 id="java-多线程">Java 多线程&lt;/h1>
&lt;p>一个Java程序的运行是一个进程，包括一个main线程和多个其他线程&lt;/p>
&lt;p>Java的线程和操作系统的线程的区别&lt;/p>
&lt;ul>
&lt;li>JDK1.2之前使用的是JVM模拟的用户级线程，JDK1.2之后使用的是操作系统的内核级线程&lt;/li>
&lt;/ul>
&lt;p>用户级线程和内核级线程的区别&lt;/p>
&lt;ul>
&lt;li>用户线程：由用户空间程序管理和调度的线程，运行在用户空间（专门给应用程序使用）。&lt;/li>
&lt;li>内核线程：由操作系统内核管理和调度的线程，运行在内核空间（只有内核程序可以访问）。&lt;/li>
&lt;/ul>
&lt;p>线程模型是用户线程和内核线程之间的关联方式，常见的线程模型有这三种：&lt;/p>
&lt;ul>
&lt;li>一对一（一个用户线程对应一个内核线程）&lt;/li>
&lt;li>多对一（多个用户线程映射到一个内核线程）&lt;/li>
&lt;li>多对多（多个用户线程映射到多个内核线程）&lt;/li>
&lt;/ul>
&lt;p>Java采用的是一对一的线程模型，即一个用户线程对应一个内核线程。这种线程模型的优点是可以充分利用多核处理器的性能，缺点是创建和销毁线程的开销较大。&lt;/p>
&lt;p>JDK21正式引入了虚拟线程&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/JUC%28Java%e5%b9%b6%e5%8f%91%29/Java%e7%ba%bf%e7%a8%8b%e7%bb%93%e6%9e%84.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>线程池&lt;/p>
&lt;p>线程池的使用&lt;/p>
&lt;p>1个10G大小文件，如何得前100个最大数字&lt;/p>
&lt;h2 id="线程">线程&lt;/h2>
&lt;h4 id="java创建线程的方法">Java创建线程的方法&lt;/h4>
&lt;p>Java中创建线程的方法主要有两种：&lt;/p>
&lt;ol>
&lt;li>继承Thread类并重写run()方法。&lt;/li>
&lt;li>实现Runnable接口并实现run()方法，然后将其作为参数传递给Thread类的构造方法。&lt;/li>
&lt;/ol>
&lt;h4 id="查看线程的执行结果怎么拿到">查看线程的执行结果，怎么拿到&lt;/h4>
&lt;p>可以通过线程的join()方法来等待线程执行完毕，并获取线程的执行结果。join()方法会阻塞当前线程，直到被调用的线程执行完毕。&lt;/p>
&lt;p>另外，可以通过线程的返回值来获取线程的执行结果。如果线程需要返回结果，可以在run()方法中返回一个值，然后在调用线程的地方通过Thread对象的get()方法获取返回值。&lt;/p>
&lt;h4 id="有哪些实现好的线程池既然他们不推荐为什么java官方还要给你">有哪些实现好的线程池，既然他们不推荐，为什么Java官方还要给你&lt;/h4>
&lt;p>Java中提供了多种线程池实现，包括ThreadPoolExecutor、ScheduledThreadPoolExecutor、ForkJoinPool等。这些线程池实现都是经过优化和测试的，可以满足大部分场景的需求。&lt;/p>
&lt;p>虽然Java官方不推荐直接使用这些线程池实现，但是它们提供了一种可靠、高效的线程池实现，可以作为开发者自己实现线程池的参考。&lt;/p>
&lt;h4 id="阻塞队列有哪些">阻塞队列有哪些&lt;/h4>
&lt;p>Java中提供了多种阻塞队列实现，包括ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue等。这些阻塞队列实现都是线程安全的，可以在多线程环境下使用。&lt;/p>
&lt;h4 id="线程池的工作流程">线程池的工作流程&lt;/h4>
&lt;p>线程池的工作流程如下：&lt;/p>
&lt;ol>
&lt;li>当有任务需要执行时，线程池会从线程池中获取一个空闲线程来执行任务。&lt;/li>
&lt;li>如果线程池中没有空闲线程，则会根据线程池的配置创建新的线程来执行任务。&lt;/li>
&lt;li>当任务执行完毕后，线程会返回线程池，并等待下一次任务的分配。&lt;/li>
&lt;/ol>
&lt;h4 id="线程池拒绝策略有哪些">线程池拒绝策略有哪些&lt;/h4>
&lt;p>线程池的拒绝策略主要有以下几种：&lt;/p>
&lt;ol>
&lt;li>AbortPolicy：直接抛出RejectedExecutionException异常。&lt;/li>
&lt;li>CallerRunsPolicy：将任务交给调用线程来执行。&lt;/li>
&lt;li>DiscardPolicy：直接丢弃任务，不做任何处理。&lt;/li>
&lt;li>DiscardOldestPolicy：丢弃队列中最老的任务，然后尝试重新提交任务。&lt;/li>
&lt;/ol>
&lt;h4 id="线程池的参数有哪些">线程池的参数有哪些&lt;/h4>
&lt;p>线程池的参数主要包括以下几个：&lt;/p>
&lt;ol>
&lt;li>corePoolSize：核心线程数，即线程池中保留的线程数。&lt;/li>
&lt;li>maximumPoolSize：最大线程数，即线程池中允许的最大线程数。&lt;/li>
&lt;li>keepAliveTime：线程空闲时间，即当线程池中的线程空闲时间超过该值时，多余的线程会被销毁。&lt;/li>
&lt;li>unit：时间单位，用于指定keepAliveTime的时间单位。&lt;/li>
&lt;li>workQueue：任务队列，用于存储等待执行的任务。&lt;/li>
&lt;li>threadFactory：线程工厂，用于创建新的线程。&lt;/li>
&lt;li>handler：拒绝策略，用于处理无法处理的任务。&lt;/li>
&lt;/ol></description></item><item><title/><link>https://ysyyhhh.github.io/docs/language/java/jvm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/language/java/jvm/</guid><description>&lt;h2 id="jvm的内存模型">jvm的内存模型&lt;/h2>
&lt;h3 id="integer-a--128b128两个相等吗">integer a = 128,b=128，两个相等吗&lt;/h3>
&lt;p>&lt;a href="https://blog.csdn.net/qq_42208194/article/details/117536553" target="_blank" rel="noopener">https://blog.csdn.net/qq_42208194/article/details/117536553&lt;/a>&lt;/p>
&lt;p>在Java中，对于Integer类型的对象，如果其值在-128到127之间，会被缓存到常量池中，因此当创建值在该范围内的Integer对象时，会直接从常量池中获取已有的对象。而对于值不在该范围内的Integer对象，则会创建新的对象。&lt;/p>
&lt;p>因此，对于Integer a = 128, b = 128，由于128不在-128到127之间，因此会创建两个不同的Integer对象，即a和b不相等。而对于Integer a = 127, b = 127，由于127在-128到127之间，因此会从常量池中获取同一个Integer对象，即a和b相等。&lt;/p>
&lt;h3 id="什么叫零拷贝">什么叫零拷贝&lt;/h3>
&lt;p>零拷贝（Zero Copy）是一种数据传输技术，它可以在不需要将数据从一个缓冲区复制到另一个缓冲区的情况下，将数据从一个地方传输到另一个地方。在零拷贝技术中，数据可以直接从磁盘、网络或其他设备中读取，然后通过DMA（Direct Memory Access）技术直接写入内存中，从而避免了数据的多次复制，提高了数据传输的效率。&lt;/p>
&lt;p>在Java中，零拷贝技术可以通过NIO（New I/O）来实现。NIO提供了一种基于通道（Channel）和缓冲区（Buffer）的I/O模型，可以直接将数据从通道中读取到缓冲区中，或者将缓冲区中的数据直接写入通道中，从而避免了数据的多次复制。&lt;/p>
&lt;h3 id="为什么用常量池有哪些常量池">为什么用常量池，有哪些常量池&lt;/h3>
&lt;p>&lt;a href="https://blog.csdn.net/qq_41376740/article/details/80338158" target="_blank" rel="noopener">https://blog.csdn.net/qq_41376740/article/details/80338158&lt;/a>&lt;/p>
&lt;p>常量池是Java中的一种特殊的内存区域，用于存储常量和符号引用。在Java中，常量池主要有以下几种：&lt;/p>
&lt;ol>
&lt;li>字面量常量池：用于存储字符串、数字等字面量常量。&lt;/li>
&lt;li>符号引用常量池：用于存储类、方法、字段等符号引用。&lt;/li>
&lt;li>运行时常量池：用于存储在类加载时解析的常量池信息，包括字面量常量池和符号引用常量池中的内容。&lt;/li>
&lt;/ol>
&lt;p>使用常量池的主要目的是为了提高程序的性能和减少内存的占用。由于常量池中的常量是唯一的，因此可以避免重复创建相同的常量对象，从而减少内存的占用。同时，由于常量池中的常量是在编译期间就确定的，因此可以在运行时直接使用，避免了重复计算和创建对象的开销，提高了程序的性能。&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/language/java/spring/code%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/language/java/spring/code%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</guid><description>&lt;h5 id="service层的返回值">Service层的返回值&lt;/h5>
&lt;p>service 做校验，如果非法，直接抛异常 + 全局异常处理&lt;/p>
&lt;p>controller 正常就是组合 service ，返回前端需要的数据。&lt;/p>
&lt;p>java异常效率低下是因为抛出异常会遍历所有涉及堆栈，具体代码在基类Throwable的fillInStackTrace()方法里。但其实可以通过在自定义异常中重写fillInStackTrace()来大幅度提高异常效率。&lt;/p>
&lt;p>&lt;a href="https://segmentfault.com/q/1010000020840854" target="_blank" rel="noopener">https://segmentfault.com/q/1010000020840854&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://blog.csdn.net/qq_41107231/article/details/115874974" target="_blank" rel="noopener">https://blog.csdn.net/qq_41107231/article/details/115874974&lt;/a>&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/language/java/spring/spring-cloud-alibaba/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/language/java/spring/spring-cloud-alibaba/</guid><description>&lt;h1 id="微服务">微服务&lt;/h1>
&lt;p>各个springboot&lt;/p>
&lt;h1 id="nacos注册中心">Nacos注册中心&lt;/h1>
&lt;h4 id="核心功能">核心功能&lt;/h4>
&lt;p>服务注册：&lt;/p>
&lt;p>服务心跳：&lt;/p>
&lt;p>服务同步：&lt;/p>
&lt;p>服务发现：拿到微服务地址&lt;/p>
&lt;p>服务调用：&lt;/p>
&lt;p>服务健康检查：&lt;/p>
&lt;h2 id="ribbon-负载均衡">Ribbon 负载均衡&lt;/h2>
&lt;h2 id="feign-优雅地调用远程服务">feign 优雅地调用远程服务&lt;/h2>
&lt;p>解决的是微服务之间调用问题&lt;/p>
&lt;h2 id="sentinel-服务容错">sentinel 服务容错&lt;/h2>
&lt;p>解决服务雪崩等问题&lt;/p>
&lt;h2 id="服务网关">服务网关&lt;/h2>
&lt;h3 id="解决的问题">解决的问题&lt;/h3>
&lt;p>解决客户端访问微服务的问题：&lt;/p>
&lt;ol>
&lt;li>维护微服务的多个地址&lt;/li>
&lt;li>认证 鉴权复杂&lt;/li>
&lt;li>跨域问题&lt;/li>
&lt;/ol>
&lt;p>所谓的API网关，就是指系统的统一入口。对于客服端来说，它封装了应用程序的内部结构，为客户端提供统一服务，一些&lt;strong>与业务本身功能无关&lt;/strong>的&lt;strong>公共逻辑&lt;/strong>可以在这里实现，诸如&lt;strong>认证、鉴权、监控、路由转发&lt;/strong>等等。&lt;/p>
&lt;h3 id="目前主流的解决方案">目前主流的解决方案&lt;/h3>
&lt;ul>
&lt;li>Ngnix+lua&lt;/li>
&lt;/ul>
&lt;p>使用nginx的&lt;strong>反向代理和负载均衡&lt;/strong>可实现对api服务器的负载均衡及高可用&lt;/p>
&lt;p>lua是一种脚本语言,可以来编写一些简单的逻辑, nginx支持lua脚本&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Kong&lt;/p>
&lt;p>基于Nginx+Lua开发，性能高，稳定，有多个可用的插件(限流、鉴权等等)可以开箱即用。 问题：&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>只支持Http协议；二次开发，自由扩展困难；提供管理API，缺乏更易用的管控、配置方式。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Zuul&lt;/p>
&lt;p>springboot1系列用的，Netflix开源的网关，功能丰富，使用JAVA开发，易于二次开发。Zuul 1.0 有问题：缺乏管控，无法动态配置；依赖组件较多；处理Http请求依赖的是Web容器，性能不如Nginx。&lt;/p>
&lt;p>Zuul有2.0&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Spring Cloud Gateway&lt;/p>
&lt;p>Spring公司为了替换Zuul而开发的网关服务，将在下面具体介绍。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Gateway&lt;/p>
&lt;p>缺点：&lt;/p>
&lt;ul>
&lt;li>其实现依赖Netty与WebFlux，不是传统的Servlet编程模型，学习成本高&lt;/li>
&lt;li>不能将其部署在Tomcat、Jetty等Servlet容器里，只能打成jar包执行&lt;/li>
&lt;li>需要Spring Boot 2.0及以上的版本，才支持&lt;/li>
&lt;/ul>
&lt;h3 id="路由-route">路由 route&lt;/h3>
&lt;p>路由(Route) 是 gateway 中最基本的组件之一，表示一个具体的路由信息载体。主要定义了下面的几个信息:&lt;/p>
&lt;p>id，路由标识符，区别于其他 Route，默认是一个随机的UID，最好自己起一个###&lt;/p>
&lt;p>uri，路由指向的目的地 uri，即客户端请求最终被转发到的微服务。&lt;/p>
&lt;p>order，用于多个 Route 之间的排序，数值越小排序越靠前，匹配优先级越高。&lt;/p>
&lt;p>predicate，断言的作用是进行条件判断，只有断言都返回真，才会真正的执行路由。&lt;/p>
&lt;p>filter，过滤器用于修改请求和响应信息。&lt;/p>
&lt;h3 id="断言">断言&lt;/h3>
&lt;p>predicate 用于条件判断，只有全部的断言为真，才实现路由转发。&lt;/p>
&lt;p>4.5.1 内置路由断言工厂&lt;/p>
&lt;p>可以自定义断言&lt;/p>
&lt;h3 id="过滤器">过滤器&lt;/h3>
&lt;ol>
&lt;li>作用：在请求过程中，对请求和响应做手脚&lt;/li>
&lt;li>生命周期：PRE 和 POST&lt;/li>
&lt;li>分类：局部过滤器（作用在一个路由上），全局过滤器（全部路由是）&lt;/li>
&lt;/ol>
&lt;p>PRE生命周期：在被路由之前调用，跨域实现验证身份，集群。&lt;/p>
&lt;p>POST生命周期：可以添加标准的Header，收集统计信息。&lt;/p>
&lt;h4 id="局部过滤器-gateaway">局部过滤器 GateAway&lt;/h4>
&lt;p>内置有很多，可以自定义&lt;/p>
&lt;h4 id="全局过滤器">全局过滤器&lt;/h4>
&lt;h4 id="网关限流">网关限流&lt;/h4>
&lt;p>用sentinel&lt;/p>
&lt;h2 id="mq消息队列">MQ消息队列&lt;/h2>
&lt;p>一般用于请求加快&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/language/java/spring/spring%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/language/java/spring/spring%E5%9F%BA%E7%A1%80/</guid><description>&lt;h4 id="介绍一下springboot">介绍一下springboot&lt;/h4>
&lt;p>简化spring应用的创建及部署&lt;/p>
&lt;p>Spring Boot通过自动配置功能，降低了复杂性，同时支持基于JVM的多种开源框架，可以缩短开发时间，使开发更加简单和高效。&lt;/p>
&lt;h4 id="3mvc的dispatcherservlet的分派原理">3.mvc的dispatcherservlet的分派原理&lt;/h4>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="4.13%e6%bb%b4%e6%bb%b4%e5%87%86%e5%a4%87/img/image-20230413193651300.png" alt="image-20230413193651300" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;ol>
&lt;li>用户发送 请求到 前端控制器（DispatcherServlet）。&lt;/li>
&lt;li>前端控制器 请求 &lt;strong>处理器映射器&lt;/strong>（HandlerMapping）去 查找 处理器（Handler）。&lt;/li>
&lt;li>找到以后 处理器映射器（HandlerMappering）向 前端控制器 返回 执行链（HandlerExecutionChain）。&lt;/li>
&lt;li>前端控制器（DispatcherServlet）调用 &lt;strong>处理器适配器&lt;/strong>（HandlerAdapter） 去执行 处理器（Handler）。&lt;/li>
&lt;li>处理器适配器 去执行 处理器Handler。&lt;/li>
&lt;li>处理器 执行完给 处理器适配器 返回ModelAndView。&lt;/li>
&lt;li>&lt;strong>处理器适配器&lt;/strong> 向 前端控制器 返回ModelAndView。&lt;/li>
&lt;li>前端控制器 请求 &lt;strong>视图解析器&lt;/strong>（ViewResolver）去进行 视图解析。&lt;/li>
&lt;li>视图解析器 向 前端控制器返回View。&lt;/li>
&lt;li>前端控制器 对 &lt;strong>视图进行渲染&lt;/strong>。&lt;/li>
&lt;li>前端控制器 向用户&lt;strong>响应结果&lt;/strong>。&lt;/li>
&lt;/ol>
&lt;h4 id="restful风格在mvc的分派如何解析参数这个我不知道瞎答的">restful风格在mvc的分派，如何解析参数（这个我不知道瞎答的）&lt;/h4>
&lt;p>restful 即 URL表示资源， + GET POST PUT DELETE 表示行为&lt;/p>
&lt;p>Restful风格的请求是使用 &lt;strong>url+请求方式&lt;/strong> 表示一次请求目的的，并且规范了一些的状态码，使得看到接口就知道请求要干嘛。&lt;/p>
&lt;p>RequestMappingURL&lt;/p>
&lt;p>PathVariable 获取参数&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>@Controller&lt;/code>声名一个处理请求的控制器&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>@RequestMapping&lt;/code>请求映射地址，它存在几个子注解对于实现&lt;code>REST&lt;/code>风格来说更加具有语义性&lt;/p>
&lt;/li>
&lt;li>
&lt;ul>
&lt;li>&lt;code>GETMapping&lt;/code> GET请求&lt;/li>
&lt;li>&lt;code>PUTMapping&lt;/code> PUT请求&lt;/li>
&lt;li>&lt;code>POSTMapping&lt;/code> POST请求&lt;/li>
&lt;li>&lt;code>DELETEMapping&lt;/code> DELETE请求&lt;code>sponseBody&lt;/code> 将响应内容转换为&lt;code>JSON&lt;/code>格式&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;code>@RequestBody&lt;/code> 请求内容转换为&lt;code>JSON&lt;/code>格式&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>@PathVariable(&amp;quot;id&amp;quot;)&lt;/code>用于绑定一个参数&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>@RESTController&lt;/code> 等同于&lt;code>@Controller&lt;/code>+&lt;code>@ResponseBody&lt;/code>在类上写了这个注解，标识这个类的所有方法只返回数据，而不进行视图跳转&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title/><link>https://ysyyhhh.github.io/docs/language/java/spring/spring%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/language/java/spring/spring%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81/</guid><description>&lt;h5 id="jpa注解">JPA注解&lt;/h5>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">https://www.jianshu.com/p/38d247f02724
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="安全">安全&lt;/h5>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">https://blog.csdn.net/qq_37023928/article/details/116777630
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="解决前后端分离的跨域问题">解决前后端分离的跨域问题&lt;/h5>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">https://www.yisu.com/zixun/606000.html
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="创建test类注解">创建Test类注解&lt;/h5>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">@RunWith(SpringJUnit4ClassRunner.class)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">@SpringBootTest
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">依赖
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;lt;dependency&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;lt;artifactId&amp;gt;spring-boot-test&amp;lt;/artifactId&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;lt;/dependency&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;lt;dependency&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;lt;artifactId&amp;gt;spring-test&amp;lt;/artifactId&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;lt;/dependency&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="开启services">开启services&lt;/h5>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">Views -&amp;gt; Tool Windows -&amp;gt; Services
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="spring容器中找不到servletwebserverfactory类出现的异常">&lt;strong>Spring容器中找不到ServletWebServerFactory类出现的异常&lt;/strong>&lt;/h5>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">https://cloud.tencent.com/developer/article/1893349
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title/><link>https://ysyyhhh.github.io/docs/language/java/spring/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/language/java/spring/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/</guid><description>&lt;h2 id="实体类命名">实体类命名&lt;/h2>
&lt;p>1.分层领域模型规约：&lt;/p>
&lt;pre>&lt;code>• DO（ Data Object）：与数据库表结构一一对应，通过DAO层向上传输数据源对象。
• DTO（ Data Transfer Object）：数据传输对象，Service或Manager向外传输的对象。
• BO（ Business Object）：业务对象。 由Service层输出的封装业务逻辑的对象。
• AO（ Application Object）：应用对象。 在Web层与Service层之间抽象的复用对象模型，极为贴近展示层，复用度不高。
• VO（ View Object）：显示层对象，通常是Web向模板渲染引擎层传输的对象。
• POJO（ Plain Ordinary Java Object）：在本手册中， POJO专指只有setter/getter/toString的简单类，包括DO/DTO/BO/VO等。
• Query：数据查询对象，各层接收上层的查询请求。 注意超过2个参数的查询封装，禁止使用Map类来传输。
&lt;/code>&lt;/pre>
&lt;p>2.领域模型命名规约：&lt;/p>
&lt;pre>&lt;code>• 数据对象：xxxDO，xxx即为数据表名。
• 数据传输对象：xxxDTO，xxx为业务领域相关的名称。
• 展示对象：xxxVO，xxx一般为网页名称。 • POJO是DO/DTO/BO/VO的统称，禁止命名成xxxPOJO。
&lt;/code>&lt;/pre>
&lt;h1 id="restful-接口风格">Restful 接口风格&lt;/h1></description></item><item><title/><link>https://ysyyhhh.github.io/docs/language/java/spring/%E6%9C%8D%E5%8A%A1%E7%AB%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/language/java/spring/%E6%9C%8D%E5%8A%A1%E7%AB%AF/</guid><description>&lt;p>jar包启动&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">nohup java -jar -Xms128M -Xmx128M -XX:PermSize=128M -XX:MaxPermSize=128M jar包名.jar
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>nacos启动&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">sh /home/tmp/nacos/bin/startup.sh -m standalone
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>服务器启动&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">cd /home/mind_wings
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">nohup java -jar -Xms128M -Xmx128M -XX:PermSize=128M -XX:MaxPermSize=128M service-user-1.0-SNAPSHOT.jar &amp;amp;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">nohup java -jar -Xms128M -Xmx128M -XX:PermSize=128M -XX:MaxPermSize=128M service-timetable-1.0-SNAPSHOT.jar &amp;amp;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">nohup java -jar -Xms128M -Xmx128M -XX:PermSize=128M -XX:MaxPermSize=128M -noverify api-gateway-1.0-SNAPSHOT.jar &amp;amp;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>出现过的问题&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">api-gateway 启动失败
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">https://blog.csdn.net/crxk_/article/details/103196146
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title/><link>https://ysyyhhh.github.io/docs/language/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/language/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/</guid><description>&lt;h1 id="编译原理基础">编译原理基础&lt;/h1>
&lt;h2 id="概述">概述&lt;/h2>
&lt;p>&lt;a href="https://messiahhh.github.io/blog/docs/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" target="_blank" rel="noopener">编译原理概述&lt;/a>&lt;/p>
&lt;p>编译原理是计算机科学的一个重要分支，它研究如何将高级语言翻译成机器语言。编译原理的研究内容包括词法分析、语法分析、语义分析、中间代码生成、代码优化和目标代码生成等。&lt;/p>
&lt;ul>
&lt;li>词法分析：词法分析器将源程序中的字符序列转换成单词序列，单词是语言中的基本单位，如标识符、关键字、运算符、界符等。&lt;/li>
&lt;li>语法分析：语法分析器将单词序列转换成语法树。&lt;/li>
&lt;li>语义分析：语义分析器对语法树进行语义检查，如类型检查、作用域检查等。&lt;/li>
&lt;li>中间代码生成：中间代码是一种抽象的机器语言，它比源程序更接近机器语言，但比机器语言更容易理解。&lt;/li>
&lt;li>代码优化：代码优化器对中间代码进行优化，以提高程序的性能。&lt;/li>
&lt;li>目标代码生成：目标代码生成器将中间代码转换成目标机器的机器语言。&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://juejin.cn/post/7080832945136599077" target="_blank" rel="noopener">以Babel和V8来举例&lt;/a>&lt;/p>
&lt;p>编译器的前端&lt;/p>
&lt;ul>
&lt;li>词法分析&lt;/li>
&lt;li>语法分析&lt;/li>
&lt;li>语义分析&lt;/li>
&lt;li>中间代码(IR)生成&lt;/li>
&lt;/ul>
&lt;p>编译器的后端&lt;/p>
&lt;ul>
&lt;li>代码优化&lt;/li>
&lt;li>目标代码生成&lt;/li>
&lt;/ul>
&lt;h2 id="编译器后端框架">编译器后端框架&lt;/h2>
&lt;p>&lt;a href="https://freegeektime.com/100034101/153192/" target="_blank" rel="noopener">后端技术的重用：LLVM&lt;/a>&lt;/p>
&lt;p>编译器后端功能&lt;/p>
&lt;h3 id="编译优化">编译优化&lt;/h3>
&lt;p>SSA&lt;/p>
&lt;h3 id="目标代码生成">目标代码生成&lt;/h3>
&lt;p>LLVM和GCC&lt;/p>
&lt;ul>
&lt;li>GCC是GNU Compiler Collection的缩写，是一个由GNU开发的编译器套件，它支持多种编程语言，如C、C++、Fortran、Java等。&lt;/li>
&lt;li>LLVM是Low Level Virtual Machine的缩写，是一个编译器基础设施，它包括编译器、汇编器、链接器等，支持多种编程语言，如C、C++、Rust、Swift等。&lt;/li>
&lt;li>LLVM和GCC都是开源软件，它们都是编译器后端的框架，可以用来开发编译器。&lt;/li>
&lt;/ul>
&lt;h3 id="llvm----low-level-virtual-machine">llvm &amp;ndash; Low Level Virtual Machine&lt;/h3></description></item><item><title/><link>https://ysyyhhh.github.io/docs/tips/docker/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/tips/docker/</guid><description>&lt;h1 id="docker相关技巧">docker相关技巧&lt;/h1>
&lt;h2 id="记把深度学习项目装入docker">记把深度学习项目装入docker&lt;/h2>
&lt;p>安装时出现选项&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-Dockerfile" data-lang="Dockerfile">&lt;span class="line">&lt;span class="cl">&lt;span class="c"># RUN apt-get install libglib2.0-dev -y&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 由于安装libglib2.0-dev的时候，bash会有交互操作叫你选择对应的时区，在docker build的时候没有交互的，所以需要加上DEBIAN_FRONTEND=&amp;#34;noninteractive&amp;#34;&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> &lt;span class="nv">DEBIAN_FRONTEND&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;noninteractive&amp;#34;&lt;/span> apt -y install libglib2.0-dev&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="docker清理">docker清理&lt;/h2>
&lt;p>在win10下，docker是基于wsl2的，所以docker的镜像和容器都是在wsl2的文件系统中。
所以在清理完docker的镜像和容器后，需要对wsl的盘进行压缩。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 停止所有的容器&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker stop &lt;span class="k">$(&lt;/span>docker ps -aq&lt;span class="k">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 删除所有未使用的容器&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker volume prune
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 删除所有未使用的镜像&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker image prune -a
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 删除缓存&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker builder prune
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看当前占用的空间&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker system df
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>对wsl2的盘进行压缩&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">wsl --shutdown
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看wsl2的盘&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">wsl --list -v
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 使用diskpart压缩&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">diskpart
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># open window Diskpart&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">select&lt;/span> vdisk &lt;span class="nv">file&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;D:\ubuntu\wsl\docker-desktop-data\ext4.vhdx&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">attach vdisk &lt;span class="nb">readonly&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">compact vdisk
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">detach vdisk
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">exit&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="docker中安装conda">docker中安装conda&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-Dockerfile" data-lang="Dockerfile">&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># 安装conda&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> apt-get install -y wget&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># yhyu13 : donwload anaconda package &amp;amp; install&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> wget &lt;span class="s2">&amp;#34;https://repo.anaconda.com/archive/Anaconda3-2023.03-1-Linux-x86_64.sh&amp;#34;&lt;/span> &lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> sh Anaconda3-2023.03-1-Linux-x86_64.sh -b -p /opt/conda&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># RUN rm /anaconda.sh &lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> ln -s /opt/conda/etc/profile.d/conda.sh /etc/profile.d/conda.sh&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;. /opt/conda/etc/profile.d/conda.sh&amp;#34;&lt;/span> &amp;gt;&amp;gt; ~/.bashrc&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># yhyu13 : add conda to path &lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">ENV&lt;/span> PATH /opt/conda/bin:/opt/conda/condabin:&lt;span class="nv">$PATH&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="docker-compose-使用gpu">docker-compose 使用gpu&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">version&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;3.7&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">services&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">pytorch&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">build&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">runtime&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">nvidia&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">environment&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="l">NVIDIA_VISIBLE_DEVICES=all&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="l">NVIDIA_DRIVER_CAPABILITIES=all&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">volumes&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="l">.:/workspace&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">ports&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="s2">&amp;#34;8888:8888&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="s2">&amp;#34;6006:6006&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">command&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">bash -c &amp;#34;jupyter notebook --ip&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="wsl-盘迁移到非系统盘">wsl 盘迁移到非系统盘&lt;/h2>
&lt;p>一般情况下 wsl盘的位置在
&lt;code>C:\Users\&amp;lt;用户名&amp;gt;\AppData\Local\Docker\wsl&lt;/code>&lt;/p>
&lt;p>docker的盘在
&lt;code>C:\Users\&amp;lt;用户名&amp;gt;\AppData\Local\Docker\wsl\data&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 1. 停止wsl&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">wsl --shutdown
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 2. 查看wsl状态&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">wsl --list -v
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 可以看到docker有两个wsl，一个是docker-desktop-data，一个是docker-desktop&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 只需要迁移docker-desktop-data即可,另一个很小&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 3. 迁移wsl&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">wsl --export Ubuntu-20.04 D:&lt;span class="se">\u&lt;/span>buntu&lt;span class="se">\w&lt;/span>sl&lt;span class="se">\U&lt;/span>buntu-20.04.tar
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 4. 删除wsl&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">wsl --unregister Ubuntu-20.04
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 5. 查看是否删除成功&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">wsl --list -v
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 6. 导入wsl&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">wsl --import Ubuntu-20.04 D:&lt;span class="se">\u&lt;/span>buntu&lt;span class="se">\w&lt;/span>sl&lt;span class="se">\U&lt;/span>buntu-20.04 D:&lt;span class="se">\u&lt;/span>buntu&lt;span class="se">\w&lt;/span>sl&lt;span class="se">\U&lt;/span>buntu-20.04.tar --version &lt;span class="m">2&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 7. 查看是否导入成功&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">wsl --list -v
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="docker-中设置特定版本的python">docker 中设置特定版本的python&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 创建一个基础镜像 &lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">FROM ubuntu:20.04
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 重置apt-get&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">RUN rm -rf /etc/apt/sources.list
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 安装conda&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># yhyu13 : install additional packages&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 设置apt的源为tsinghua镜像源&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">RUN sed -i &lt;span class="s1">&amp;#39;s/archive.ubuntu.com/mirrors.tuna.tsinghua.edu.cn/g&amp;#39;&lt;/span> /etc/apt/sources.list
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">RUN apt-get update &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> apt-get install -y curl wget
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 安装conda&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">RUN curl -O https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> bash Miniconda3-latest-Linux-x86_64.sh -b -p /opt/conda &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> rm Miniconda3-latest-Linux-x86_64.sh
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 创建conda环境并安装python&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">RUN /opt/conda/bin/conda create -n py38 &lt;span class="nv">python&lt;/span>&lt;span class="o">=&lt;/span>3.8.5
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ENV PATH /opt/conda/envs/py38/bin:&lt;span class="nv">$PATH&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="docker中使用display">docker中使用display&lt;/h2>
&lt;p>在启动时需要设置环境变量DISPLAY&lt;/p>
&lt;h3 id="win下的情况">win下的情况&lt;/h3>
&lt;p>参考&lt;a href="https://www.cnblogs.com/larva-zhh/p/10531824.html" target="_blank" rel="noopener">在Docker for Windows中运行GUI程序&lt;/a>&lt;/p>
&lt;h2 id="前后端项目静态资源转发">前后端项目静态资源转发&lt;/h2>
&lt;p>后端 springboot时：
把静态资源放在static目录下，然后在application中配置&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">spring&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">mvc&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">static-path-pattern&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/static/**&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">resources&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">static-locations&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">classpath:/static/&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果设置了拦截器，需要在拦截器上加入&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="nd">@Configuration&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">WebMvcConfig&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">implements&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">WebMvcConfigurer&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nd">@Bean&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">CorsInterceptor&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">corsInterceptor&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">CorsInterceptor&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nd">@Override&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">addInterceptors&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">InterceptorRegistry&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">registry&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">registry&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">addInterceptor&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">corsInterceptor&lt;/span>&lt;span class="p">())&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">addPathPatterns&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/**&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nd">@Override&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">addResourceHandlers&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ResourceHandlerRegistry&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">registry&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">registry&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">addResourceHandler&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/static/**&amp;#34;&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="na">addResourceLocations&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;classpath:/static/&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;file:static/&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>jar 包和静态路径关系&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-md" data-lang="md">&lt;span class="line">&lt;span class="cl">&lt;span class="k">-&lt;/span> .jar
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">-&lt;/span> static
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>前端，需要在nginx上加入转发后访问静态路径后缀。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-nginx" data-lang="nginx">&lt;span class="line">&lt;span class="cl"> &lt;span class="k">location&lt;/span> &lt;span class="s">/api&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">rewrite&lt;/span> &lt;span class="s">^/api(.*)&lt;/span> &lt;span class="nv">$1&lt;/span> &lt;span class="s">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">proxy_pass&lt;/span> &lt;span class="nv">$SERVER_URL&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">proxy_set_header&lt;/span> &lt;span class="s">Host&lt;/span> &lt;span class="nv">$host&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">proxy_set_header&lt;/span> &lt;span class="s">X-Real-IP&lt;/span> &lt;span class="nv">$remote_addr&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">proxy_set_header&lt;/span> &lt;span class="s">X-Forwarded-For&lt;/span> &lt;span class="nv">$proxy_add_x_forwarded_for&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">proxy_set_header&lt;/span> &lt;span class="s">X-Forwarded-Photo&lt;/span> &lt;span class="nv">$scheme&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">location&lt;/span> &lt;span class="p">~&lt;/span>&lt;span class="sr">*.+\.(jpg|jpeg|gif|png|ico|css|js|pdf|txt|swf|xml|woff|woff2|ttf|eot|svg)$&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">rewrite&lt;/span> &lt;span class="s">^/api(.*)&lt;/span> &lt;span class="nv">$1&lt;/span> &lt;span class="s">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">proxy_pass&lt;/span> &lt;span class="nv">$SERVER_URL&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">proxy_redirect&lt;/span> &lt;span class="no">off&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title/><link>https://ysyyhhh.github.io/docs/tips/linux/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/tips/linux/</guid><description>&lt;h1 id="linux">Linux&lt;/h1>
&lt;h2 id="系统资源相关">系统资源相关&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看内存&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">free -h
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看cpu&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cat /proc/cpuinfo
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看cpu使用情况&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">top
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看GPU使用情况&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">nvidia-smi
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看磁盘&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">df -h
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看系统版本&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cat /etc/os-release
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看系统信息&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">uname -a
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 列出所有文件夹和文件 显示占用空间&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">du -sh *
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看文件夹大小&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">du -sh folder_name
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看文件大小&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">du -sh file_name
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="用户相关">用户相关&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 创建用户&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">useradd -m -s /bin/bash -d /home/username username
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">## 解释: -m 创建用户目录, -s 指定shell, -d 指定用户目录&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 设置密码&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">passwd username
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 删除用户&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">userdel -r username
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 添加用户的sudo权限&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">## 编辑sudoers文件&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">vi /etc/sudoers
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">## 在root ALL=(ALL) ALL下面添加&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">username &lt;span class="nv">ALL&lt;/span>&lt;span class="o">=(&lt;/span>ALL&lt;span class="o">)&lt;/span> ALL
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看用户组&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">groups username
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 修改用户组&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">usermod -g groupname username
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看所有用户&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cat /etc/passwd
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="目录挂载">目录挂载&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看挂载&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">df -h
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 挂载目录&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">mount /dev/sdb1 /home/username/data
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 卸载目录&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">umount /home/username/data
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 挂载硬盘&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">## 查看硬盘&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">fdisk -l
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">## 格式化硬盘&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">fdisk /dev/sdb
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">## 格式化为ext4&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">mkfs.ext4 /dev/sdb1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>挂载目录并立即生效&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 挂载目录&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">mount /dev/sdb1 /home/username/data
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 立即生效&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">mount -a
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="文件">文件&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 带权限复制&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cp -rp &lt;span class="nb">source&lt;/span> dest
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 远程连接复制文件&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">scp -r username@ip:/home/username/data /home/username/data
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="工具">工具&lt;/h2>
&lt;h3 id="压缩解压缩">压缩解压缩&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 压缩&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">tar -czvf filename.tar.gz foldername
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 解压&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">tar -xzvf filename.tar.gz
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">### 定时脚本
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">```shell
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 查看定时脚本
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">crontab -l
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="curl">curl&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 下载文件&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">curl -o filename url
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="系统路径变量">系统路径/变量&lt;/h2>
&lt;p>持久化添加/改变系统路径/变量&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 添加到系统路径&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">echo&lt;/span> &lt;span class="s1">&amp;#39;export PATH=$PATH:/home/username/bin&amp;#39;&lt;/span> &amp;gt;&amp;gt; /etc/profile
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 立即生效&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">source&lt;/span> /etc/profile
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="tool">tool&lt;/h2>
&lt;h3 id="ssh">ssh&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 生成密钥&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ssh-keygen -t rsa -C &lt;span class="s2">&amp;#34;{email}&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看密钥&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cat ~/.ssh/id_rsa.pub
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="apt">apt&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 设置tsinghua源&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo sed -i &lt;span class="s1">&amp;#39;s/archive.ubuntu.com/mirrors.tuna.tsinghua.edu.cn/g&amp;#39;&lt;/span> /etc/apt/sources.list
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 更新源&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">s
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title/><link>https://ysyyhhh.github.io/docs/tips/piplineaction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/tips/piplineaction/</guid><description>&lt;p>&lt;a href="https://docs.github.com/en/actions/migrating-to-github-actions/manual-migrations/migrating-from-gitlab-cicd-to-github-actions" target="_blank" rel="noopener">github action&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://docs.gitlab.com/ee/ci/" target="_blank" rel="noopener">gitlab pipline&lt;/a>&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/tips/server/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/tips/server/</guid><description>&lt;h1 id="服务器">服务器&lt;/h1>
&lt;h2 id="scp传输文件">scp传输文件&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 本地到远程&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">scp -r /home/username/data username@ip:/home/username/data
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title/><link>https://ysyyhhh.github.io/docs/tips/windows%E4%B8%8B%E7%9A%84%E5%AD%90%E7%B3%BB%E7%BB%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/tips/windows%E4%B8%8B%E7%9A%84%E5%AD%90%E7%B3%BB%E7%BB%9F/</guid><description>&lt;h1 id="windows-下的子系统">windows 下的子系统&lt;/h1>
&lt;h2 id="wsl">wsl&lt;/h2>
&lt;p>pass&lt;/p>
&lt;h2 id="适用于android的windows子系统">适用于Android的Windows子系统&lt;/h2>
&lt;p>安装apk&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">adb install xxx.apk
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title/><link>https://ysyyhhh.github.io/docs/tool/docker/docker/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/tool/docker/docker/</guid><description>&lt;h1 id="docker-usage">docker Usage&lt;/h1>
&lt;h2 id="多阶段构建docker镜像">多阶段构建docker镜像&lt;/h2>
&lt;p>多阶段构建的修改不会保留到下一阶段，只有COPY和ADD命令会保留到下一阶段&lt;/p>
&lt;p>usages：&lt;/p>
&lt;ul>
&lt;li>第一阶段：编译/打包程序依赖&lt;/li>
&lt;/ul>
&lt;p>多阶段用途：&lt;/p>
&lt;ul>
&lt;li>缩小镜像体积&lt;/li>
&lt;li>&lt;/li>
&lt;/ul>
&lt;h2 id="新系统build时出现cannot-autolaunch-d-bus-without-x11-display">新系统build时出现&lt;code>Cannot autolaunch D-Bus without X11 $DISPLAY&lt;/code>&lt;/h2>
&lt;p>docker 拉取包时需要登录.&lt;/p>
&lt;p>问题出在Linux缺少一个密码管理包gnupg，它用于加密，我们在登录时需要这个包将密码加密后才能完成，因此直接安装&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">sudo apt install gnupg2 pass
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title/><link>https://ysyyhhh.github.io/docs/tool/docker/docker%E5%91%BD%E4%BB%A4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/tool/docker/docker%E5%91%BD%E4%BB%A4/</guid><description>&lt;h1 id="docker命令">Docker命令&lt;/h1>
&lt;h2 id="安装docker">安装docker&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">sudo apt -y update
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo apt -y upgrade
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo apt -y full-upgrade
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 安装依赖&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo apt install -y apt-transport-https ca-certificates curl software-properties-common gnupg lsb-release
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 添加官方GPG密钥&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">curl -fsSL https://download.docker.com/linux/ubuntu/gpg &lt;span class="p">|&lt;/span> sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">#添加仓库&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;deb [arch=&lt;/span>&lt;span class="k">$(&lt;/span>dpkg --print-architecture&lt;span class="k">)&lt;/span>&lt;span class="s2"> signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu &lt;/span>&lt;span class="k">$(&lt;/span>lsb_release -cs&lt;span class="k">)&lt;/span>&lt;span class="s2"> stable&amp;#34;&lt;/span> &lt;span class="p">|&lt;/span> sudo tee /etc/apt/sources.list.d/docker.list &amp;gt; /dev/null
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 更新apt&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo apt -y update
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 安装docker&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo apt install -y docker-ce docker-ce-cli containerd.io docker-compose-plugin
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 安装docker-compose&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo apt install -y docker-compose
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>centos 6.9 下安装docker&lt;/p>
&lt;p>&lt;a href="https://medium.com/@zihansyu/centos-6-x-%E5%AE%89%E8%A3%9Ddocker-9e61354fd2ae" target="_blank" rel="noopener">https://medium.com/@zihansyu/centos-6-x-%E5%AE%89%E8%A3%9Ddocker-9e61354fd2ae&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://blog.csdn.net/kinginblue/article/details/73527832" target="_blank" rel="noopener">https://blog.csdn.net/kinginblue/article/details/73527832&lt;/a>&lt;/p>
&lt;h2 id="1镜像相关">1.镜像相关&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 构建镜像&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker build &lt;span class="o">[&lt;/span>选项&lt;span class="o">]&lt;/span> &amp;lt;上下文路径/URL/-&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 选项: -f, --file=&amp;#34;&amp;#34; # 指定要使用的Dockerfile路径（默认为./Dockerfile）&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># --force-rm=false # 在构建过程中删除中间容器&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># --no-cache=false # 始终使用缓存&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># --pull=false # 在构建过程中尝试去更新镜像的新版本&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># --quiet=false # 安静模式，成功后只输出镜像ID&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># --rm=true # 在构建成功后删除临时容器&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># -t, --tag=[] # 镜像名称（默认值：&amp;lt;上下文路径&amp;gt;的基本名称）&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># --ulimit=[] # Ulimit配置&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 拉取镜像&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker pull &lt;span class="o">[&lt;/span>选项&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>Docker Registry 地址&lt;span class="o">[&lt;/span>:端口号&lt;span class="o">]&lt;/span>/&lt;span class="o">]&lt;/span>仓库名&lt;span class="o">[&lt;/span>:标签&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看镜像&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker images &lt;span class="o">[&lt;/span>选项&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>仓库名&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 删除镜像&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker rmi &lt;span class="o">[&lt;/span>选项&lt;span class="o">]&lt;/span> &amp;lt;镜像1&amp;gt; &lt;span class="o">[&lt;/span>&amp;lt;镜像2&amp;gt; ...&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看镜像历史&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker &lt;span class="nb">history&lt;/span> &lt;span class="o">[&lt;/span>选项&lt;span class="o">]&lt;/span> &amp;lt;镜像名&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看镜像详细信息&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker inspect &lt;span class="o">[&lt;/span>选项&lt;span class="o">]&lt;/span> &amp;lt;镜像名&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="2容器相关">2.容器相关&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 创建容器&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker run &lt;span class="o">[&lt;/span>选项&lt;span class="o">]&lt;/span> &amp;lt;镜像名&amp;gt; &lt;span class="o">[&lt;/span>命令&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">#eg: docker run -d -p 8080:8080 --name tomcat tomcat:8.5.51&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">#选项&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># -d 后台运行容器，并返回容器ID&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># -i 以交互模式运行容器，通常与 -t 同时使用&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># -t 为容器重新分配一个伪输入终端，通常与 -i 同时使用&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># -P 随机端口映射&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># -p 指定端口映射，格式为：主机(宿主)端口:容器端口&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># --name 指定容器名字&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># --link 连接到其它容器&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># --rm 容器退出后自动删除容器文件&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># --volumes-from 从其它容器或数据卷挂载一些配置或其它文件&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># --volume 挂载宿主机目录或文件，格式为：主机目录:容器目录&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># --privileged=true 给容器内的root用户赋予最高权限，容器内的root用户就拥有了真正的root权限&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># --restart&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># no 容器退出时不重启&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># on-failure[:max-retries] 容器故障退出（返回值非零）时重启，最多重启max-retries次&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># always 容器退出时总是重启&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># unless-stopped 容器退出时总是重启，但是不考虑在Docker守护进程启动时就已经停止了的容器&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># --env-file 从指定文件读入环境变量&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># eg:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># docker run -d -p 8080:8080 --name tomcat tomcat:8.5.51 --env-file ./env.list&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看容器&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker ps &lt;span class="o">[&lt;/span>选项&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 删除容器&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker rm &lt;span class="o">[&lt;/span>选项&lt;span class="o">]&lt;/span> &amp;lt;容器名&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 启动容器&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 启动和创建容器的区别在于，启动容器是针对已经创建好的容器进行启动，而创建容器则是针对镜像进行的操作&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker start &lt;span class="o">[&lt;/span>选项&lt;span class="o">]&lt;/span> &amp;lt;容器名&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 停止容器&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker stop &lt;span class="o">[&lt;/span>选项&lt;span class="o">]&lt;/span> &amp;lt;容器名&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看容器日志&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker logs &lt;span class="o">[&lt;/span>选项&lt;span class="o">]&lt;/span> &amp;lt;容器名&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看容器内进程&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker top &lt;span class="o">[&lt;/span>选项&lt;span class="o">]&lt;/span> &amp;lt;容器名&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看容器详细信息&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker inspect &lt;span class="o">[&lt;/span>选项&lt;span class="o">]&lt;/span> &amp;lt;容器名&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 进入容器&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker &lt;span class="nb">exec&lt;/span> &lt;span class="o">[&lt;/span>选项&lt;span class="o">]&lt;/span> &amp;lt;容器名&amp;gt; &lt;span class="o">[&lt;/span>命令&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 导出容器&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker &lt;span class="nb">export&lt;/span> &lt;span class="o">[&lt;/span>选项&lt;span class="o">]&lt;/span> &amp;lt;容器名&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 导入容器&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker import &lt;span class="o">[&lt;/span>选项&lt;span class="o">]&lt;/span> &amp;lt;容器名&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 重命名容器&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker rename &lt;span class="o">[&lt;/span>选项&lt;span class="o">]&lt;/span> &amp;lt;容器名&amp;gt; &amp;lt;新容器名&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看容器使用的资源&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker stats &lt;span class="o">[&lt;/span>选项&lt;span class="o">]&lt;/span> &amp;lt;容器名&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看容器端口映射&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker port &lt;span class="o">[&lt;/span>选项&lt;span class="o">]&lt;/span> &amp;lt;容器名&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 导出容器中的文件&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker cp &lt;span class="o">[&lt;/span>选项&lt;span class="o">]&lt;/span> &amp;lt;容器名&amp;gt;:&amp;lt;容器内路径&amp;gt; &amp;lt;宿主机路径&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 选项: -a, --archive=false # 归档模式(默认)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># -L, --follow-link=false # 总是解析符号链接&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># -d, --device=false # 复制字符和块设备&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># -r, --recursive=false # 递归复制整个目录&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># -p, --pause=true # 暂停容器中的所有进程&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="docker-检查与排错">docker 检查与排错&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">docker logs &lt;span class="o">[&lt;/span>选项&lt;span class="o">]&lt;/span> &amp;lt;容器名&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 选项: -f, --follow=false # 跟踪日志输出&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># --since=&amp;#34;&amp;#34; # 显示自某个timestamp之后的日志，或相对时间，如42m（即42分钟）&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># --tail=&amp;#34;all&amp;#34; # 从日志末尾显示多少行日志， 默认是all&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># -t, --timestamps=false # 显示时间戳&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># --until=&amp;#34;&amp;#34; # 显示自某个timestamp之前的日志，或相对时间，如42m（即42分钟）&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看容器占用&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker stats &lt;span class="o">[&lt;/span>选项&lt;span class="o">]&lt;/span> &amp;lt;容器名&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 选项: --all=false # 显示所有容器（默认显示运行中的容器）&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># --format=&amp;#34;&amp;#34; # 使用Go模板显示&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># --no-stream=false # 不显示实时流容器的统计信息&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># --no-trunc=false # 不截断输出&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 停止所有容器&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker stop &lt;span class="k">$(&lt;/span>docker ps -a -q&lt;span class="k">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 移除所有容器&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker rm &lt;span class="k">$(&lt;/span>docker ps -a -q&lt;span class="k">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 移除所有镜像&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker image rmi &lt;span class="k">$(&lt;/span>docker images -q&lt;span class="k">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 清空docker中所有的东西&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker system prune -a
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 清空缓存&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker system prune -f
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 清空未使用的镜像&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker image prune -a
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 清空未使用的容器&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker container prune
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 清空未使用的卷&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker volume prune
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 清空未使用的网络&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker network prune
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 清空未使用的构建缓存&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker builder prune
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 清空未使用的数据&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker system prune -a --volumes
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 清空所有未使用的数据&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker system prune -a --volumes --force
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="3容器日志">3.容器日志&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看容器日志&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker logs &lt;span class="o">[&lt;/span>选项&lt;span class="o">]&lt;/span> &amp;lt;容器名&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 选项: -f, --follow=false # 跟踪日志输出&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># --since=&amp;#34;&amp;#34; # 显示自某个timestamp之后的日志，或相对时间，如42m（即42分钟）&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># --tail=&amp;#34;all&amp;#34; # 从日志末尾显示多少行日志， 默认是all&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># -t, --timestamps=false # 显示时间戳&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># --until=&amp;#34;&amp;#34; # 显示自某个timestamp之前的日志，或相对时间，如42m（即42分钟）&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="docker-submodule">docker submodule&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 获取子模块&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git submodule update --init --recursive
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="docker-compose">docker-compose&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 启动命令&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker-compose up &lt;span class="o">[&lt;/span>选项&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>服务名&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 选项&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># -d 后台运行&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># --build 构建镜像&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 删除容器&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker-compose rm &lt;span class="o">[&lt;/span>选项&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>服务名&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 删除镜像&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker-compose down &lt;span class="o">[&lt;/span>选项&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>服务名&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="docker私服的相关命令">docker私服的相关命令&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 登录&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker login
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 上传&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker push &amp;lt;镜像名&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title/><link>https://ysyyhhh.github.io/docs/tool/git/git/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/tool/git/git/</guid><description>&lt;h1 id="git">git&lt;/h1>
&lt;h2 id="git-常用命令">git 常用命令&lt;/h2>
&lt;h3 id="git-基本配置">git 基本配置&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">git config --global user.name &lt;span class="s2">&amp;#34;your name&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git config --global user.email &lt;span class="s2">&amp;#34;your email&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="git-基本操作">git 基本操作&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">git init &lt;span class="c1"># 初始化仓库&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git add . &lt;span class="c1"># 添加所有文件到暂存区&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git commit -m &lt;span class="s2">&amp;#34;commit message&amp;#34;&lt;/span> &lt;span class="c1"># 提交到本地仓库&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git remote add origin
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git push -u origin master &lt;span class="c1"># 推送到远程仓库&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git pull origin master &lt;span class="c1"># 拉取远程仓库&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git clone &lt;span class="c1"># 克隆远程仓库&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git status &lt;span class="c1"># 查看当前状态&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git log &lt;span class="c1"># 查看提交日志&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git diff &lt;span class="c1"># 查看修改内容&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git branch &lt;span class="c1"># 查看分支&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git checkout -b branch_name &lt;span class="c1"># 创建并切换到新分支&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git checkout branch_name &lt;span class="c1"># 切换分支&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git merge branch_name &lt;span class="c1"># 合并分支&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git branch -d branch_name &lt;span class="c1"># 删除分支&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git reset --hard HEAD^ &lt;span class="c1"># 回退到上一个版本&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git reset --hard commit_id &lt;span class="c1"># 回退到指定版本&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git reflog &lt;span class="c1"># 查看命令历史&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git rm file_name &lt;span class="c1"># 删除文件&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git stash &lt;span class="c1"># 暂存当前修改&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git stash list &lt;span class="c1"># 查看暂存列表&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git stash apply &lt;span class="c1"># 恢复暂存&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git stash drop &lt;span class="c1"># 删除暂存&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git stash pop &lt;span class="c1"># 恢复并删除暂存&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git remote -v &lt;span class="c1"># 查看远程仓库地址&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git remote set-url origin new_url &lt;span class="c1"># 修改远程仓库地址&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git push origin --delete branch_name &lt;span class="c1"># 删除远程分支&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git push origin :branch_name &lt;span class="c1"># 删除远程分支&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git tag &lt;span class="c1"># 查看标签&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git tag tag_name &lt;span class="c1"># 创建标签&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git tag tag_name commit_id &lt;span class="c1"># 指定提交创建标签&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git tag -a tag_name -m &lt;span class="s2">&amp;#34;tag message&amp;#34;&lt;/span> &lt;span class="c1"># 创建带有说明的标签&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git tag -d tag_name &lt;span class="c1"># 删除标签&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git push origin tag_name &lt;span class="c1"># 推送标签到远程&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git push origin --tags &lt;span class="c1"># 推送所有标签到远程&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git push origin :refs/tags/tag_name &lt;span class="c1"># 删除远程标签&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git push origin --delete tag tag_name &lt;span class="c1"># 删除远程标签&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git checkout -- file_name &lt;span class="c1"># 撤销工作区修改&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git reset HEAD file_name &lt;span class="c1"># 撤销暂存区修改&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git reset --hard HEAD^ &lt;span class="c1"># 撤销本地提交&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git reset --hard commit_id &lt;span class="c1"># 撤销本地提交&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git config --global alias.st status &lt;span class="c1"># 设置别名&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git config --global alias.co checkout &lt;span class="c1"># 设置别名&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git config --global alias.ci commit &lt;span class="c1"># 设置别名&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git config --global alias.br branch &lt;span class="c1"># 设置别名&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git config --global alias.unstage &lt;span class="s1">&amp;#39;reset HEAD&amp;#39;&lt;/span> &lt;span class="c1"># 设置别名&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git config --global alias.last &lt;span class="s1">&amp;#39;log -1&amp;#39;&lt;/span> &lt;span class="c1"># 设置别名&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git config --global alias.lg &lt;span class="s2">&amp;#34;log --color --graph --pretty=format:&amp;#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&amp;lt;%an&amp;gt;%Creset&amp;#39; --abbrev-commit&amp;#34;&lt;/span> &lt;span class="c1"># 设置别名&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="git-子模块">git 子模块&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看子模块&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git submodule
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git submodule add &lt;span class="c1"># 添加子模块&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 添加子模块并自定义子模块目录名称和分支&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git submodule add &amp;lt;repository&amp;gt; &lt;span class="o">[&lt;/span>&amp;lt;path&amp;gt;&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git submodule init &lt;span class="c1"># 初始化子模块&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git submodule update &lt;span class="c1"># 更新子模块&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git submodule foreach git pull &lt;span class="c1"># 更新所有子模块&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 删除子模块&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 1. 删除.gitmodules中对应子模块的条目&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 2. 删除.git/config中对应子模块的条目&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 3. 执行git rm --cached path/to/submodule&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 4. 执行rm -rf .git/modules/path/to/submodule&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 5. 执行rm -rf path/to/submodule&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title/><link>https://ysyyhhh.github.io/docs/tool/git/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/tool/git/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</guid><description>&lt;p>多个笔记之间存在关联, 可以先在mind-wings内笔记搜索, 再搜索百度.&lt;/p>
&lt;p>笔记格式为&lt;/p>
&lt;ul>
&lt;li>指令集&lt;/li>
&lt;li>名称解释&lt;/li>
&lt;li>学习步骤&lt;/li>
&lt;/ul>
&lt;p>其中指令集和名称解释是将学习步骤的内容做一个简要整理, 即备忘录. 目的是方便快速搜索.&lt;/p>
&lt;p>如果是初学者,直接跳过指令集和名词解释.&lt;/p>
&lt;h1 id="指令集">指令集&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">git init # 初始化本地git仓库（创建新仓库）
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git config --global user.name &amp;#34;xxx&amp;#34; # 配置用户名
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git config --global user.email &amp;#34;xxx@xxx.com&amp;#34; # 配置邮件
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git config --global color.ui true # git status等命令自动着色
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git config --global color.status auto
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git config --global color.diff auto
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git config --global color.branch auto
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git config --global color.interactive auto
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git config --global --unset http.proxy # remove proxy configuration on git
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git clone git+ssh://git@192.168.53.168/VT.git # clone远程仓库
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git status # 查看当前版本状态（是否修改）
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git add xyz # 添加xyz文件至index
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git add . # 增加当前子目录下所有更改过的文件至index
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git commit -m &amp;#39;xxx&amp;#39; # 提交
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git commit --amend -m &amp;#39;xxx&amp;#39; # 合并上一次提交（用于反复修改）
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git commit -am &amp;#39;xxx&amp;#39; # 将add和commit合为一步
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git rm xxx # 删除index中的文件
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git rm -r * # 递归删除
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git log # 显示提交日志
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git log -1 # 显示1行日志 -n为n行
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git log -5
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git log --stat # 显示提交日志及相关变动文件
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git log -p -m
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git show dfb02e6e4f2f7b573337763e5c0013802e392818 # 显示某个提交的详细内容
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git show dfb02 # 可只用commitid的前几位
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git show HEAD # 显示HEAD提交日志
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git show HEAD^ # 显示HEAD的父（上一个版本）的提交日志 ^^为上两个版本 ^5为上5个版本
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git tag # 显示已存在的tag
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git tag -a v2.0 -m &amp;#39;xxx&amp;#39; # 增加v2.0的tag
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git show v2.0 # 显示v2.0的日志及详细内容
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git log v2.0 # 显示v2.0的日志
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git diff # 显示所有未添加至index的变更
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git diff --cached # 显示所有已添加index但还未commit的变更
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git diff HEAD^ # 比较与上一个版本的差异
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git diff HEAD -- ./lib # 比较与HEAD版本lib目录的差异
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git diff origin/master..master # 比较远程分支master上有本地分支master上没有的
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git diff origin/master..master --stat # 只显示差异的文件，不显示具体内容
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git remote add origin git+ssh://git@192.168.53.168/VT.git # 增加远程定义（用于push/pull/fetch）
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git branch # 显示本地分支
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git branch --contains 50089 # 显示包含提交50089的分支
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git branch -a # 显示所有分支
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git branch -r # 显示所有原创分支
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git branch --merged # 显示所有已合并到当前分支的分支
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git branch --no-merged # 显示所有未合并到当前分支的分支
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git branch -m master master_copy # 本地分支改名
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git checkout -b master_copy # 从当前分支创建新分支master_copy并检出
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git checkout -b master master_copy # 上面的完整版
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git checkout features/performance # 检出已存在的features/performance分支
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git checkout --track hotfixes/BJVEP933 # 检出远程分支hotfixes/BJVEP933并创建本地跟踪分支
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git checkout v2.0 # 检出版本v2.0
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git checkout -b devel origin/develop # 从远程分支develop创建新本地分支devel并检出
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git checkout -- README # 检出head版本的README文件（可用于修改错误回退）
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git merge origin/master # 合并远程master分支至当前分支
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git cherry-pick ff44785404a8e # 合并提交ff44785404a8e的修改
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git push origin master # 将当前分支push到远程master分支
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git push origin :hotfixes/BJVEP933 # 删除远程仓库的hotfixes/BJVEP933分支
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git push --tags # 把所有tag推送到远程仓库
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git fetch # 获取所有远程分支（不更新本地分支，另需merge）
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git fetch --prune # 获取所有原创分支并清除服务器上已删掉的分支
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git pull origin master # 获取远程分支master并merge到当前分支
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git mv README README2 # 重命名文件README为README2
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git reset --hard HEAD # 将当前版本重置为HEAD（通常用于merge失败回退）
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git rebase
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git branch -d hotfixes/BJVEP933 # 删除分支hotfixes/BJVEP933（本分支修改已合并到其他分支）
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git branch -D hotfixes/BJVEP933 # 强制删除分支hotfixes/BJVEP933
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git ls-files # 列出git index包含的文件
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git show-branch # 图示当前分支历史
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git show-branch --all # 图示所有分支历史
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git whatchanged # 显示提交历史对应的文件修改
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git revert dfb02e6e4f2f7b573337763e5c0013802e392818 # 撤销提交dfb02e6e4f2f7b573337763e5c0013802e392818
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git ls-tree HEAD # 内部命令：显示某个git对象
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git rev-parse v2.0 # 内部命令：显示某个ref对于的SHA1 HASH
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git reflog # 显示所有提交，包括孤立节点
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git show HEAD@{5}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git show master@{yesterday} # 显示master分支昨天的状态
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git log --pretty=format:&amp;#39;%h %s&amp;#39; --graph # 图示提交日志
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git show HEAD~3
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git show -s --pretty=raw 2be7fcb476
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git stash # 暂存当前修改，将所有至为HEAD状态
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git stash list # 查看所有暂存
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git stash show -p stash@{0} # 参考第一次暂存
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git stash apply stash@{0} # 应用第一次暂存
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git grep &amp;#34;delete from&amp;#34; # 文件中搜索文本“delete from”
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git grep -e &amp;#39;#define&amp;#39; --and -e SORT_DIRENT
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git gc
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git fsck
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="名词解释">名词解释&lt;/h1>
&lt;p>repo&lt;/p>
&lt;h1 id="git概述">Git概述&lt;/h1>
&lt;h2 id="简要介绍">简要介绍&lt;/h2>
&lt;h2 id="安装与检查">安装与检查&lt;/h2>
&lt;p>安装命令&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">sudo apt-get install git #Ubuntu
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo yum install git #Centos
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>检查安装是否成功&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">git --version #检查版本号
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="配置">配置&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">git config --global user.name &amp;#34;username&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git config --global user.email &amp;#34;xxx@example.com&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title/><link>https://ysyyhhh.github.io/docs/tool/ide/vscode%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%85%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/tool/ide/vscode%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%85%A8/</guid><description>&lt;h1 id="工作学习流vscode快捷键">工作学习流(vscode快捷键)&lt;/h1>
&lt;h2 id="markdown-快捷键">markdown 快捷键&lt;/h2>
&lt;p>删除线: &lt;code>alt + s&lt;/code>&lt;/p>
&lt;p>待办事项勾选/取消勾选: &lt;code>alt + c&lt;/code>&lt;/p>
&lt;h2 id="terminal">terminal&lt;/h2>
&lt;p>命令行创建: &lt;code>Ctrl + Shift + ~&lt;/code>&lt;/p>
&lt;p>命令行切换: &lt;code>Ctrl + fn + upArrow/downArrow&lt;/code>&lt;/p>
&lt;h2 id="view">view&lt;/h2>
&lt;h2 id="run">Run&lt;/h2>
&lt;p>Run python file in terminal: &lt;code>Ctrl + F5&lt;/code>&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/tool/k8s/k8s/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/tool/k8s/k8s/</guid><description>&lt;h1 id="k8s">k8s&lt;/h1>
&lt;p>&lt;strong>&lt;a href="https://kubernetes.io/zh-cn/docs/reference/kubectl/" target="_blank" rel="noopener">kubectl&lt;/a> 命令行工具&lt;/strong>&lt;/p>
&lt;p>kubectl [command] [TYPE] [NAME] [flags]&lt;/p>
&lt;p>- &lt;code>command&lt;/code>：指定要对一个或多个资源执行的操作，例如 &lt;code>create&lt;/code>、&lt;code>get&lt;/code>、&lt;code>describe&lt;/code>、&lt;code>delete&lt;/code>。&lt;/p>
&lt;p>- &lt;code>TYPE&lt;/code>：指定&lt;a href="https://kubernetes.io/zh-cn/docs/reference/kubectl/#resource-types" target="_blank" rel="noopener">资源类型&lt;/a>。资源类型不区分大小写， 可以指定单数、复数或缩写形式。&lt;/p>
&lt;p>- &lt;code>NAME&lt;/code>：指定资源的名称。名称区分大小写。 如果省略名称，则显示所有资源的详细信息。例如：&lt;/p>
&lt;p>命令大全&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">- kubectl get:列出资源,比如 pod、deployment、service 等
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">- kubectl describe:显示资源的详细信息
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">- kubectl create:创建资源,比如 pod、deployment、service 等
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">- kubectl delete:删除资源
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">- kubectl apply:对资源进行配置更改
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">- kubectl rollout:管理资源的发布,比如 deployment 的发布
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">- kubectl scale:扩缩 pod 副本数
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">- kubectl expose:暴露资源为 service
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">- kubectl logs:打印 pod 的日志
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">- kubectl exec:在 pod 内执行命令
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">- kubectl cp:在 pod 之间 copy 文件
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">- kubectl port-forward:将 pod 的端口转发到本地
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">- kubectl label:给资源加标签
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">- kubectl annotate:给资源加注释
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">- kubectl config:管理 kubeconfig 文件
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">- kubectl cluster-info:显示集群信息
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">- kubectl version:显示 CLI 版本和服务端版本
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">- kubectl api-versions:显示所支持的 API 版本
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">- kubectl api-resources:显示每个API group下的资源列表
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>常用命令&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kubectl get 资源类型
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kubectl get pod
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kubectl get pod -o wide
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kubectl get deployment
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kubectl get deployment -o wide
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kubectl get namespace
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 指定查看某个命名空间下的pod
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kubectl get pod -n kube-system
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 查看所有命名空间下的pod
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kubectl get pod -A -o wide
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kubectl describe 资源类型
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kubectl describe pod
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kubectl describe pod web-nginx-dep2-5f4fbd5bfb-jqw9z
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kubectl describe pod -o wide
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kubectl describe deployment
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kubectl describe deployment -o wide
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kubectl describe namespace
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 指定查看某个命名空间下的pod
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kubectl describe pod -n kube-system
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 查看所有命名空间下的pod
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kubectl describe pod -A -o wide
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kubectl logs 显示pod中的容器中运行过程中产生的日志信息
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kubectl logs ngx-dep3-64cfcc9ddc-92x9s
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kubectl logs injoi-5c9b8f98bd-trm95 | grep &amp;#34;capturing the emotions&amp;#34; -A 100 -B 100 搜索并查看上下文
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kubectl run bx --image=busybox
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kubectl exec -it nginx-dep1-6dd5d75f8b-mgndd /bin/bash
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kubectl exec -it pod对象 /bin/bash
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://kubernetes.io/zh-cn/docs/" target="_blank" rel="noopener">https://kubernetes.io/zh-cn/docs/&lt;/a>&lt;/p>
&lt;h1 id="container">container&lt;/h1>
&lt;h1 id="pod">pod&lt;/h1>
&lt;p>Pod 类似于共享名字空间并共享文件系统卷的一组容器。&lt;/p>
&lt;h1 id="deployment">deployment&lt;/h1>
&lt;h2 id="depploymentyaml">depployment.yaml&lt;/h2>
&lt;p>① &lt;code>apiVersion&lt;/code> 是当前配置格式的版本。&lt;br>
② &lt;code>kind&lt;/code> 是要创建的资源类型，这里是 &lt;code>Deployment&lt;/code>。&lt;br>
③ &lt;code>metadata&lt;/code> 是该资源的元数据，&lt;code>name&lt;/code> 是必需的元数据项。&lt;br>
④ &lt;code>spec&lt;/code> 部分是该 &lt;code>Deployment&lt;/code> 的规格说明。&lt;br>
⑤ &lt;code>replicas&lt;/code> 指明副本数量，默认为 1。&lt;br>
⑥ &lt;code>template&lt;/code> 定义 Pod 的模板，这是配置文件的重要部分。&lt;br>
⑦ &lt;code>metadata&lt;/code> 定义 Pod 的元数据，至少要定义一个 label。label 的 key 和 value 可以任意指定。&lt;br>
⑧ &lt;code>spec&lt;/code> 描述 Pod 的规格，此部分定义 Pod 中每一个容器的属性，&lt;code>name&lt;/code> 和 &lt;code>image&lt;/code> 是必需的。&lt;/p>
&lt;h1 id="secret">secret&lt;/h1>
&lt;p>Secret 是 Kubernetes 中的一种资源,用于存储敏感信息,比如密码、OAuth 令牌、SSH 密钥等。Secret 的数据是 base64 编码并存储在 etcd 中。Secret 有三种类型:1. Opaque:任意数据,用于存储密码、密钥等;base64 编码后存储。&lt;br>
2. &lt;a href="http://kubernetes.io/service-account-token:%E6%9C%8D%E5%8A%A1%E8%B4%A6%E5%8F%B7%E4%BB%A4%E7%89%8C,%E7%94%B1" target="_blank" rel="noopener">kubernetes.io/service-account-token:服务账号令牌,由&lt;/a> Kubernetes 自动创建和更新。&lt;br>
3. &lt;a href="http://kubernetes.io/dockercfg:Docker" target="_blank" rel="noopener">kubernetes.io/dockercfg:Docker&lt;/a> 配置文件,用来存储私有 Docker Registry 的认证信息。主要用途是:- 存储敏感数据,比如密码、密钥、认证信息等&lt;br>
- 在 Pod 中设置环境变量&lt;br>
- 用于拉取私有镜像仓库的镜像创建 Secret 有三种方式:1. 从文件中创建:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">bash
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kubectl create secret generic &amp;lt;secret-name&amp;gt; --from-file=path/to/file
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>2. 从字串中创建:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">bash
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kubectl create secret generic &amp;lt;secret-name&amp;gt; --from-literal=&amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>3. 编写 YAML 文件创建:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">yaml
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">apiVersion: v1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kind: Secret
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">metadata:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> name: mysecret
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">type: Opaque
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">data:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> username: YWRtaW4= # base64 编码后的密码或密钥
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> password: MWYyZDFlMmU2N2Rm # base64 编码后的密码或密钥
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在 Pod 中可以以三种方式使用 Secret:1. 设置环境变量的值 &lt;code>env&lt;/code>&lt;br>
2. 以 Volume 文件的形式挂载,然后在 Volume 中访问&lt;br>
3. 使用 kubectl 在本地执行工具中设置 Secret总的来说,Secret 用于在 Kubernetes 集群中存储敏感信息,有以下主要用途:- 存储密码、密钥、认证信息等敏感数据&lt;br>
- 用于在 Pod 中设置环境变量的值&lt;br>
- 用于在 Volume 中创建 config 文件&lt;br>
- 拉取私有 Docker Registry 的镜像&lt;/p>
&lt;h1 id="namespace">namespace&lt;/h1></description></item><item><title/><link>https://ysyyhhh.github.io/docs/tool/k8s/minikube/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/tool/k8s/minikube/</guid><description>&lt;h1 id="minikube">minikube&lt;/h1>
&lt;p>使用&lt;/p>
&lt;p>进入pods的容器&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">kubectl &lt;span class="nb">exec&lt;/span> -it &amp;lt;pod-name&amp;gt; -c &amp;lt;container-name&amp;gt; -- /bin/bash
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看对应容器的日志&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kubectl logs -f &amp;lt;pod-name&amp;gt; -c &amp;lt;container-name&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="错误和解决方案">错误和解决方案&lt;/h2>
&lt;h3 id="minikube-挂载-本地目录进minikube时作为mysql的数据目录但是mysql无法启动">minikube 挂载 本地目录进minikube时,作为mysql的数据目录,但是mysql无法启动&lt;/h3>
&lt;p>挂载方式:
在minikube正常启动后, 使用&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">minikube mount &amp;lt;本地目录&amp;gt;:&amp;lt;minikube目录&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>进行挂载&lt;/p>
&lt;p>检查问题&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 进入pod 的 db容器内查看日志 &lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">kubectl logs -f &amp;lt;pod-name&amp;gt; -c &amp;lt;container-name&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>输出为&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">find: File system loop detected&lt;span class="p">;&lt;/span> &lt;span class="s1">&amp;#39;/var/lib/mysql/test&amp;#39;&lt;/span> is part of the same file system loop as &lt;span class="s1">&amp;#39;/var/lib/mysql/&amp;#39;&lt;/span>.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>原因是挂载时发现循环&lt;/p>
&lt;p>解决方案:&lt;/p>
&lt;ol>
&lt;li>关闭并&lt;strong>删除&lt;/strong>minikube&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">minikube stop
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">minikube delete
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="2">
&lt;li>在minikube启动时就挂载&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">minikube start --mount --mount-string&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;&amp;lt;本地目录&amp;gt;:&amp;lt;minikube目录&amp;gt;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>问题解决&lt;/p>
&lt;h3 id="minikube-中-设置ingress未转发的问题">minikube 中 设置ingress未转发的问题&lt;/h3>
&lt;p>参考&lt;a href="https://stackoverflow.com/questions/66275458/could-not-access-kubernetes-ingress-in-browser-on-windows-home-with-minikube" target="_blank" rel="noopener">Could not access Kubernetes Ingress in Browser on Windows Home with Minikube?&lt;/a>&lt;/p>
&lt;p>问题1：
当使用minikube时，设置ingress后，minikube ssh 内部可以通过ingress转发的服务端口访问。
但127.0.0.1 或 minikube ip 在主机上无法访问。&lt;/p>
&lt;p>解决方法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-md" data-lang="md">&lt;span class="line">&lt;span class="cl">Set custom domain IP to 127.0.01 in %WINDIR%\System32\drivers\etc\hosts file, i.e. by adding line 127.0.0.1 my-k8s.com
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Get ingress pod name: kubectl get pods -n ingress-nginx
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Start port forwarding: kubectl -n ingress-nginx port-forward pod/ingress-nginx-controller-5d88495688-dxxgw --address 0.0.0.0 80:80 443:443, where you should replace ingress-nginx-controller-5d88495688-dxxgw with your ingress pod name.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Enjoy using ingress on custom domain in any browser (but only when port forwarding is active)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>问题2:
ingress中使用prefix的转发规则时,无法获取路径中的query&lt;/p>
&lt;p>解决方法:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">networking.k8s.io/v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Ingress&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">minimal-ingress&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">annotations&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">nginx.ingress.kubernetes.io/use-regex&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;true&amp;#34;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># 需要添加这个&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">nginx.ingress.kubernetes.io/rewrite-target&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/$2&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">defaultBackend&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">service&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">default-http-backend&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">port&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">number&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">80&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">rules&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">host&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">fuzzs-scene-sim-test.localhost&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">http&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">paths&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">path&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/FuzzsSceneSimTest(/|$)(.*)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># 后缀加上(/|$)(.*) 用于获取query&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">pathType&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ImplementationSpecific &lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">backend&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">service&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">fuzzs-scene-sim-test&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">port&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">number&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">8089&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title/><link>https://ysyyhhh.github.io/docs/tool/maven/maven/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/tool/maven/maven/</guid><description>&lt;h1 id="maven">maven&lt;/h1>
&lt;h2 id="打包">打包&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">mvn clean package -Dmaven.test.skip&lt;span class="o">=&lt;/span>&lt;span class="nb">true&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="常见问题">常见问题&lt;/h2>
&lt;h3 id="找不到主类">找不到主类&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">Error: Could not find or load main class com.xxx.xxx.xxx
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Caused by: java.lang.ClassNotFoundException: com.xxx.xxx.xxx
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>解决方法：在pom.xml中添加如下配置&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-xml" data-lang="xml">&lt;/code>&lt;/pre>&lt;/div></description></item><item><title/><link>https://ysyyhhh.github.io/docs/tool/nginx/nginx/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/tool/nginx/nginx/</guid><description>&lt;h1 id="nginx">nginx&lt;/h1>
&lt;h2 id="nginx安装">nginx安装&lt;/h2>
&lt;h3 id="1-安装依赖">1. 安装依赖&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">yum install -y gcc gcc-c++ autoconf automake make
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">yum install -y pcre pcre-devel
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">yum install -y zlib zlib-devel
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">yum install -y openssl openssl-devel
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="2-转发后端图片">2. 转发后端图片&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 1. 创建目录&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">mkdir -p /data/nginx/cache
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 2. 修改目录权限&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">chown -R nginx:nginx /data/nginx/cache
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="nginx-命令">nginx 命令&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 启动&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">nginx
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 重启, 重新加载配置文件&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">nginx -s reload
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 停止&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">nginx -s stop
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 测试配置文件是否正确&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">nginx -t
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title/><link>https://ysyyhhh.github.io/docs/tool/npm/npm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/tool/npm/npm/</guid><description>&lt;h1 id="npm">npm&lt;/h1>
&lt;h2 id="docker中的npm">docker中的npm&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 设置npm源&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">npm config &lt;span class="nb">set&lt;/span> registry https://registry.npm.taobao.org
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title/><link>https://ysyyhhh.github.io/docs/tool/python/conda/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/tool/python/conda/</guid><description>&lt;h1 id="conda">conda&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看环境&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">conda env list
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 创建环境&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">conda create -n py3 &lt;span class="nv">python&lt;/span>&lt;span class="o">=&lt;/span>3.6
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 通过yml文件创建环境&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">conda env create -f environment.yml
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 激活环境&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">conda activate py3
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 退出环境&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">conda deactivate
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 删除环境&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">conda remove -n py3 --all
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="迁移时可能会出现pip问题">迁移时可能会出现pip问题&lt;/h2>
&lt;p>可以在yml的pip:上面加上pip&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yml" data-lang="yml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">py3&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">channels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="l">defaults&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">dependencies&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="l">python=3.6&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="l">pip&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">pip&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- -&lt;span class="l">r requirements.txt&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title/><link>https://ysyyhhh.github.io/docs/tool/python/poetry/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/tool/python/poetry/</guid><description>&lt;h1 id="poetry">poetry&lt;/h1>
&lt;h2 id="poetry-出现的错误及解决方法">poetry 出现的错误及解决方法&lt;/h2>
&lt;h3 id="poetry-install-时failed-to-create-the-collection-prompt-dismissed">poetry install 时Failed to create the collection: Prompt dismissed&lt;/h3>
&lt;p>解决方案: 关闭keyring&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">python3 -m keyring --disable
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>原因:
&lt;a href="https://github.com/python-poetry/poetry/issues/1917" target="_blank" rel="noopener">https://github.com/python-poetry/poetry/issues/1917&lt;/a>&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/tool/sql/mongodb/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/tool/sql/mongodb/</guid><description>&lt;h1 id="mongodb">mongoDB&lt;/h1>
&lt;h2 id="常用命令">常用命令&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 连接&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">mongosh ip&lt;span class="o">[&lt;/span>:port&lt;span class="o">]&lt;/span>/database -u username -p password
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看数据库&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">show dbs
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 切换数据库&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">use database
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看集合&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">show collections
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># file&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看集合数据&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">db.&lt;span class="o">{&lt;/span>collection&lt;span class="o">}&lt;/span>.find&lt;span class="o">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 按条件查看集合数据&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">## pid=1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">db.&lt;span class="o">{&lt;/span>collection&lt;span class="o">}&lt;/span>.find&lt;span class="o">({&lt;/span>pid:1&lt;span class="o">})&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">## 限制4条&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">db.&lt;span class="o">{&lt;/span>collection&lt;span class="o">}&lt;/span>.find&lt;span class="o">()&lt;/span>.limit&lt;span class="o">(&lt;/span>4&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">## 只显示其中一个字段&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">db.&lt;span class="o">{&lt;/span>collection&lt;span class="o">}&lt;/span>.find&lt;span class="o">({}&lt;/span>, &lt;span class="o">{&lt;/span>name:1&lt;span class="o">})&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">## 统计数量&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">db.&lt;span class="o">{&lt;/span>collection&lt;span class="o">}&lt;/span>.find&lt;span class="o">()&lt;/span>.count&lt;span class="o">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">## 全部删除&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">db.&lt;span class="o">{&lt;/span>collection&lt;span class="o">}&lt;/span>.remove&lt;span class="o">({})&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">## 插入或更新数据&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title/><link>https://ysyyhhh.github.io/docs/tool/sql/mysql/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/tool/sql/mysql/</guid><description>&lt;h1 id="mysql">MySQL&lt;/h1>
&lt;h2 id="mysql常用命令">MySql常用命令&lt;/h2>
&lt;h5 id="修改用户">修改用户&lt;/h5>
&lt;p>修改密码&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">alter user &amp;#39;root&amp;#39;@&amp;#39;localhost&amp;#39; identified with mysql_native_password by &amp;#39;123456&amp;#39;;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>修改用户host&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">update&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">mysql&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">user&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">set&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">host&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;%&amp;#39;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">where&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">user&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;root
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="刷新权限">刷新权限&lt;/h5>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">flush privileges;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="添加一个远程用户">添加一个远程用户&lt;/h5>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">create user &amp;#39;remote&amp;#39;@&amp;#39;%&amp;#39; identified by &amp;#39;password&amp;#39;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">GRANT all ON *.* TO &amp;#39;remote&amp;#39;@&amp;#39;%&amp;#39;;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">grant all privileges on *.* to &amp;#39;remote&amp;#39;@&amp;#39;%&amp;#39; with grant option;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">*.*所有数据库下的所有表
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="删除用户">删除用户&lt;/h5>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">drop user &amp;#39;remote&amp;#39;@&amp;#39;%&amp;#39;;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="创建数据库并设定中文编码">创建数据库并设定中文编码&lt;/h5>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-mysql" data-lang="mysql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">CREATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">DATABASE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="n">db_name&lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">DEFAULT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">CHARACTER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">SET&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">utf8&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">COLLATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">utf8_general_ci&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="登录格式">登录格式&lt;/h5>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">mysql -h #{数据库IP} -P 3306 -u #{用户名} -p -D #{数据库名}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="自增id-不连续时">自增id 不连续时&lt;/h5>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SET @auto_id = 0;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">UPDATE 表名 SET 自增字段名 = (@auto_id := @auto_id + 1);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ALTER TABLE 表名 AUTO_INCREMENT = 1;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="文件">文件&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">source
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="数据库">数据库&lt;/h4>
&lt;p>设置数据库的字符集&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">alter&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">database&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">数据库名&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">character&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">set&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">utf8&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="表">表&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="o">#&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">添加一列&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">alter&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">table&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">表名&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">add&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">column&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">列名&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">类型&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="数据">数据&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="o">#&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">插入数据&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">insert&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">into&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">表名&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="err">字段&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="err">字段&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">values&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="err">值&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="err">值&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="o">#&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">更新数据&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">update&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">表名&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">set&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">字段&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="err">值&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="err">字段&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="err">值&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">where&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">条件&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="o">#&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">删除数据&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">delete&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">from&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">表名&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">where&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">条件&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="时间处理">时间处理&lt;/h3>
&lt;p>Date&lt;/p>
&lt;h3 id="条件语句">条件语句&lt;/h3>
&lt;p>CASE&lt;/p>
&lt;p>强制转换&lt;/p>
&lt;p>CAST&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/tool/sql/redis/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/tool/sql/redis/</guid><description>&lt;h1 id="redis">redis&lt;/h1>
&lt;p>flushall 清空&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/tool/terminal/grep/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/tool/terminal/grep/</guid><description>&lt;h1 id="grep">grep&lt;/h1>
&lt;p>grep工具&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/tool/terminal/%E5%91%BD%E4%BB%A4%E8%A1%8C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/tool/terminal/%E5%91%BD%E4%BB%A4%E8%A1%8C/</guid><description>&lt;h1 id="命令行">命令行&lt;/h1>
&lt;h2 id="cmd">cmd&lt;/h2>
&lt;p>后缀 &lt;code>.bat&lt;/code> 或 &lt;code>.cmd&lt;/code> 的批处理文件&lt;/p>
&lt;h2 id="powershell">powershell&lt;/h2>
&lt;p>后缀 &lt;code>.ps1&lt;/code> 的脚本文件&lt;/p>
&lt;h2 id="bash">bash&lt;/h2>
&lt;h2 id="zsh">zsh&lt;/h2>
&lt;h2 id="fish">fish&lt;/h2></description></item><item><title/><link>https://ysyyhhh.github.io/docs/tool/terminal/%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/tool/terminal/%E5%B7%A5%E5%85%B7/</guid><description>&lt;h1 id="命令行工具">命令行工具&lt;/h1>
&lt;h2 id="查看文件">查看文件&lt;/h2>
&lt;h3 id="cat">cat&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">cat 文件名
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="heading">&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">more 文件名
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="下载文件">下载文件&lt;/h2>
&lt;h3 id="wget">wget&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">wget -c -t &lt;span class="m">0&lt;/span> -T &lt;span class="m">60&lt;/span> -O 文件名 下载地址
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># -c 断点续传&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># -t 0 重试次数&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># -T 60 超时时间&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># -O 文件名 保存文件名&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="tree指令在windows下">tree指令在windows下&lt;/h2>
&lt;p>&lt;a href="https://blog.csdn.net/pyufftj/article/details/83102530" target="_blank" rel="noopener">https://blog.csdn.net/pyufftj/article/details/83102530&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://blog.csdn.net/fragrant_no1/article/details/85986511" target="_blank" rel="noopener">https://blog.csdn.net/fragrant_no1/article/details/85986511&lt;/a>&lt;/p>
&lt;p>nohup&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">nohup python3 -u tcp_client.py &amp;gt; tcp.log 2&amp;gt;&amp;amp;1 &amp;amp;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">nuhup : 不挂起的意思
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">python3 tcp_client.py : 使用python3环境运行 tcp_client.py文件
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">-u : 代表程序不启用缓存，也就是把输出直接放到log中，没这个参数的话，log文件的生成会有延迟
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&amp;gt; tcp.log : 把程序输出日志保存到tcp.log文件中
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">2&amp;gt;&amp;amp;1 : 换成2&amp;gt;&amp;amp;1，&amp;amp;与1结合就代表标准输出了，就变成错误重定向到标准输出
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&amp;amp; : 最后一个&amp;amp; ，代表该命令在后台执行
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">nohup python3 -u main.py &amp;gt; chatbot.log 2&amp;gt;&amp;amp;1 &amp;amp;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">nohup ./go-cqhttp &amp;gt; go-cq.log 2&amp;gt;&amp;amp;1 &amp;amp;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="curl">curl&lt;/h1>
&lt;h1 id="curl-1">curl&lt;/h1></description></item><item><title/><link>https://ysyyhhh.github.io/docs/tool/vim/%E6%8C%87%E4%BB%A4%E6%89%8B%E5%86%8C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/tool/vim/%E6%8C%87%E4%BB%A4%E6%89%8B%E5%86%8C/</guid><description>&lt;h1 id="vim的使用">vim的使用&lt;/h1>
&lt;h2 id="光标移动">光标移动&lt;/h2>
&lt;p>h: 左移一个字符
j: 下移一行
k: 上移一行
l: 右移一个字符&lt;/p>
&lt;p>w: 移动到下一个单词的开头
e: 移动到当前单词末尾
b: 移动到上一个单词的开头&lt;/p>
&lt;p>0: 移动到行首
$: 移动到行尾&lt;/p>
&lt;p>n + 上面的命令: 移动n次&lt;/p>
&lt;p>gg: 移动到文件开头
G: 移动到文件末尾&lt;/p>
&lt;p>上面所有命令构成了一个移动命令，可以和d命令组合使用，删除从当前光标到移动命令所指的位置的内容&lt;/p>
&lt;p>ctrl + f: 下翻一页
ctrl + b: 上翻一页
ctrl + G: 显示当前光标所在行的行号&lt;/p>
&lt;p>ctrl + i: 跳转到上次位置·
ctrl + o: 跳转到下次位置&lt;/p>
&lt;p>G + n: 移动到第n行&lt;/p>
&lt;h2 id="插入">插入&lt;/h2>
&lt;p>i: 在当前光标处插入
I: 在当前行首插入&lt;/p>
&lt;p>a: 在当前光标后插入
A: 在当前行尾插入&lt;/p>
&lt;p>o: 在当前行下方插入一行
O: 在当前行上方插入一行&lt;/p>
&lt;h2 id="删除">删除&lt;/h2>
&lt;p>x: 删除当前光标所在的字符
X: 删除当前光标所在的前一个字符&lt;/p>
&lt;p>dd: 删除当前行
D: 删除当前光标所在位置到行尾的内容&lt;/p>
&lt;p>d + 移动命令: 删除从当前光标到移动命令所指的位置的内容&lt;/p>
&lt;p>如:
dw: 删除当前光标所在的单词
db: 删除当前光标所在的单词
d$: 删除当前光标所在位置到行尾的内容
dnG: 删除当前光标所在行到第n行的内容
dG: 删除当前光标所在行到文件末尾的内容&lt;/p>
&lt;h2 id="剪切">剪切&lt;/h2>
&lt;p>上面删除的内容都会被保存到剪切板中&lt;/p>
&lt;h2 id="删除并进入插入模式">删除并进入插入模式&lt;/h2>
&lt;p>s: 删除当前光标所在的字符并进入插入模式
S: 删除当前行并进入插入模式&lt;/p>
&lt;p>c + 移动命令: 删除从当前光标到移动命令所指的位置的内容并进入插入模式&lt;/p>
&lt;p>如:
cw: 删除当前光标所在的单词并进入插入模式
c$: 删除当前光标所在位置到行尾的内容并进入插入模式
cnG: 删除当前光标所在行到第n行的内容并进入插入模式&lt;/p>
&lt;h2 id="复制">复制&lt;/h2>
&lt;p>y + 移动命令: 复制从当前光标到移动命令所指的位置的内容&lt;/p>
&lt;p>如:
yw: 复制当前光标所在的单词
yb: 复制当前光标所在的单词
y$: 复制当前光标所在位置到行尾的内容
ynG: 复制当前光标所在行到第n行的内容&lt;/p>
&lt;h2 id="粘贴">粘贴&lt;/h2>
&lt;p>所有删除的内容都会被保存到剪切板中，可以使用p命令将剪切板中的内容粘贴到当前光标所在位置
p: 将剪切板中的内容粘贴到当前光标所在位置的后面
P: 将剪切板中的内容粘贴到当前光标所在位置的前面&lt;/p>
&lt;h2 id="替换">替换&lt;/h2>
&lt;p>r + 字符: 将当前光标所在的字符替换为指定的字符&lt;/p>
&lt;p>R + 字符串: 将当前光标所在位置开始的字符串替换为指定的字符串&lt;/p>
&lt;h2 id="撤销">撤销&lt;/h2>
&lt;p>u: 撤销上一次操作
U: 撤销当前行的所有操作&lt;/p>
&lt;p>ctrl + r: 恢复上一次撤销的操作&lt;/p>
&lt;h2 id="重复">重复&lt;/h2>
&lt;p>. : 重复上一次操作&lt;/p>
&lt;h2 id="查找">查找&lt;/h2>
&lt;p>/ + 关键字: 从当前光标开始向下查找关键字
? + 关键字: 从当前光标开始向上查找关键字&lt;/p>
&lt;p>输完后按回车，会跳转到第一个匹配的位置.&lt;/p>
&lt;p>n: 跳转到下一个匹配的位置
N: 跳转到上一个匹配的位置&lt;/p>
&lt;h2 id="-进阶命令">: 进阶命令&lt;/h2>
&lt;p>:w 保存文件
:q 退出
:q! 强制退出，不保存
:wq 保存并退出
:wq! 强制保存并退出&lt;/p>
&lt;p>上面的命令 + 文件名: 保存文件到指定的文件名&lt;/p>
&lt;p>:help 命令名: 查看命令的帮助文档&lt;/p>
&lt;h3 id="替换-1">替换&lt;/h3>
&lt;p>:%s/old/new/g 将所有的old替换为new
:%s/old/new/gc 将所有的old替换为new，替换前询问是否替换&lt;/p>
&lt;p>:#,#s/old/new/g 将第#行到第#行的old替换为new&lt;/p>
&lt;h3 id="外部命令">外部命令&lt;/h3>
&lt;p>:! + 命令: 执行外部命令&lt;/p>
&lt;p>如:
:!ls 执行ls命令
:!dir 执行dir命令&lt;/p></description></item></channel></rss>