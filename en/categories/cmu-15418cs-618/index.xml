<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>cmu-15418&amp;cs-618 on ysyy&#39;s blog</title>
    <link>/en/categories/cmu-15418cs-618/</link>
    <description>Recent content in cmu-15418&amp;cs-618 on ysyy&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Tue, 17 Oct 2023 00:00:00 +0000</lastBuildDate><atom:link href="/en/categories/cmu-15418cs-618/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>L6</title>
      <link>/en/posts/cmu-15418cs-618/l6/</link>
      <pubDate>Tue, 17 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>/en/posts/cmu-15418cs-618/l6/</guid>
      <description>虚拟文件系统 /proc/cpuinfo model name cpu MHz - 频率 cache size - 缓存大小 siblings - 逻辑cpu数量 processor - 逻辑cpu编号 cpu cores - 物理cpu数量 core id - 物理cpu编号 这样查看的cpu数量很</description>
    </item>
    
    <item>
      <title>L5 Work distribution and scheduling</title>
      <link>/en/posts/cmu-15418cs-618/l5/</link>
      <pubDate>Mon, 16 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>/en/posts/cmu-15418cs-618/l5/</guid>
      <description>三种分配策略的总结 静态分配 优点: 几乎没有运行时的开销(关于分配) 缺点: 不总是均匀的分配任务 什么时候使用: (最简单的例子) 当知道每个任务的工作</description>
    </item>
    
    <item>
      <title>L4 Parallel Programing basics</title>
      <link>/en/posts/cmu-15418cs-618/l4/</link>
      <pubDate>Sun, 15 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>/en/posts/cmu-15418cs-618/l4/</guid>
      <description>主要用三种方式实现并行程序(没有进行真正的优化) 例子 n-body simulation 创建并行程序的过程 1. Decomposition 主要思想: 创造至少足够的任务让所有的处理单元都有事情做 Amdahl&amp;rsquo;s Law: 串行</description>
    </item>
    
    <item>
      <title>Abstraction vs implementation</title>
      <link>/en/posts/cmu-15418cs-618/l3/</link>
      <pubDate>Sat, 14 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>/en/posts/cmu-15418cs-618/l3/</guid>
      <description>ISPC language SPMD: Single Program Multiple Data 一种花哨的方式来说，就是一种并行编程的范式，它的特点是：在编程时，我们只需要写一个程序，然后在运行时，这个程序会被复制多份，每</description>
    </item>
    
    <item>
      <title>asst2</title>
      <link>/en/posts/cmu-15418cs-618/asst2/</link>
      <pubDate>Sat, 14 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>/en/posts/cmu-15418cs-618/asst2/</guid>
      <description>1. 问题</description>
    </item>
    
    <item>
      <title></title>
      <link>/en/posts/cmu-15418cs-618/asst1-performance-analysis-on-a-quad-core-cpu/</link>
      <pubDate>Mon, 09 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>/en/posts/cmu-15418cs-618/asst1-performance-analysis-on-a-quad-core-cpu/</guid>
      <description>参考 任务 提示: 需要先看CMU15-418/CS149的L2再完成Pro1 任务描述: 用多线程画mandelbrot fractal. 代码中给出了串行的实现, 你</description>
    </item>
    
    <item>
      <title>L2</title>
      <link>/en/posts/cmu-15418cs-618/l2/</link>
      <pubDate>Thu, 05 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>/en/posts/cmu-15418cs-618/l2/</guid>
      <description>并行程序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void sinx(int N, int terms, float* x, float* result) { for (int i = 0; i &amp;lt; N; i++) { float value = x[i]; float number = x[i] * x[i] * x[i]; int sign = -1; int denom = 6; for (int j = 0; j &amp;lt; terms; j++) { value</description>
    </item>
    
    <item>
      <title>Why parallelism? Why efficiency?</title>
      <link>/en/posts/cmu-15418cs-618/l1-%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97%E5%92%8C%E9%AB%98%E6%95%88/</link>
      <pubDate>Thu, 05 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>/en/posts/cmu-15418cs-618/l1-%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97%E5%92%8C%E9%AB%98%E6%95%88/</guid>
      <description>Parallelism 加速比 Speed up 是指： 程序在单处理器上运行的时间 / 程序在多处理器上运行的时间 我们一般会期望用两倍的硬件得到两倍的速度提升,但是实际上并不是这样的</description>
    </item>
    
  </channel>
</rss>
