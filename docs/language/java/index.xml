<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>java | Ysyy's</title><link>https://ysyyhhh.github.io/docs/language/java/</link><atom:link href="https://ysyyhhh.github.io/docs/language/java/index.xml" rel="self" type="application/rss+xml"/><description>java</description><generator>Hugo Blox Builder (https://hugoblox.com)</generator><language>en-us</language><image><url>https://ysyyhhh.github.io/media/logo.svg</url><title>java</title><link>https://ysyyhhh.github.io/docs/language/java/</link></image><item><title/><link>https://ysyyhhh.github.io/docs/language/java/javaio/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/language/java/javaio/</guid><description/></item><item><title/><link>https://ysyyhhh.github.io/docs/language/java/java%E9%9B%86%E5%90%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/language/java/java%E9%9B%86%E5%90%88/</guid><description>&lt;h1 id="java集合体系">Java集合体系&lt;/h1>
&lt;p>Java 集合， 也叫作容器，主要是由两大接口派生而来：一个是 Collection接口，主要用于存放单一元素；另一个是 Map 接口，主要用于存放键值对。对于Collection 接口，下面又有三个主要的子接口：List、Set 和 Queue。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Java%e9%9b%86%e5%90%88/Java%e9%9b%86%e5%90%88%e7%9a%84%e7%bb%93%e6%9e%84.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>List: 有序，可重复&lt;/p>
&lt;ul>
&lt;li>ArrayList: Object[] 数组, 查询快, 增删慢&lt;/li>
&lt;li>Vector: Object[] 数组, 线程安全(与ArrayList区别)&lt;/li>
&lt;li>LinkedList: 双向链表, 查询慢, 增删快&lt;/li>
&lt;/ul>
&lt;p>Set: 元素不可重复&lt;/p>
&lt;ul>
&lt;li>HashSet: 基于HashMap实现, 无序&lt;/li>
&lt;li>TreeSet: 红黑树(自平衡的二叉查找树), 有序&lt;/li>
&lt;li>LinkedHashSet: 基于LinkedHashMap实现, 是HashSet的子类, 有序&lt;/li>
&lt;/ul>
&lt;p>Queue: 有序，可重复, 用于存放队列元素&lt;/p>
&lt;ul>
&lt;li>PriorityQueue: 优先级队列, Object[] 数组&lt;/li>
&lt;li>DelayQueue: 延迟队列, 用于存放延迟元素&lt;/li>
&lt;li>ArrayDeque: 双端队列, Object[] 数组&lt;/li>
&lt;/ul>
&lt;p>Map: 无序，不可重复，键值对&lt;/p>
&lt;ul>
&lt;li>HashMap: JDK1.8之前是数组+链表, JDK1.8之后是数组+链表/红黑树&lt;/li>
&lt;li>LinkedHashMap: 基于HashMap实现, 有序&lt;/li>
&lt;li>TreeMap: 红黑树(自平衡的二叉查找树), 有序&lt;/li>
&lt;li>Hashtable: 数组(主体)+链表(解决哈希冲突), 线程安全&lt;/li>
&lt;/ul>
&lt;p>如何选用集合&lt;/p>
&lt;ul>
&lt;li>要键值对 - Map
&lt;ul>
&lt;li>需要排序 - TreeMap&lt;/li>
&lt;li>不需要排序 - HashMap&lt;/li>
&lt;li>需要线程安全 - Hashtable&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>不需要键值对 - Collection
&lt;ul>
&lt;li>保证元素唯一 - Set
&lt;ul>
&lt;li>需要排序 - TreeSet&lt;/li>
&lt;li>不需要排序 - HashSet&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>允许重复元素 - List
&lt;ul>
&lt;li>需要高效的增删 - LinkedList&lt;/li>
&lt;li>需要高效的查询 - ArrayList&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="list">List&lt;/h2>
&lt;p>ArrayList 与 Array比较&lt;/p>
&lt;ul>
&lt;li>ArrayList是数组的封装，可以动态扩容，而数组是静态的&lt;/li>
&lt;li>ArrayList允许使用泛型&lt;/li>
&lt;/ul>
&lt;p>ArrayList 与 Vector比较&lt;/p>
&lt;ul>
&lt;li>ArrayList是非线程安全的，而Vector是线程安全的&lt;/li>
&lt;li>ArrayList是JDK1.2引入的(主要实现类,新)，而Vector是JDK1.0引入的&lt;/li>
&lt;/ul>
&lt;p>ArrayList&lt;/p>
&lt;ul>
&lt;li>底层是数组,支持随机访问&lt;/li>
&lt;li>可以添加null元素&lt;/li>
&lt;li>插入:
&lt;ul>
&lt;li>头部插入: O(n)&lt;/li>
&lt;li>尾部插入: O(1), 扩容时O(n),每次扩容是原来的1.5倍&lt;/li>
&lt;li>指定位置插入: O(n)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>删除:
&lt;ul>
&lt;li>只有尾部删除是O(1), 其他都是O(n)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>LinkedList&lt;/p>
&lt;ul>
&lt;li>底层是双向链表, 不支持随机访问&lt;/li>
&lt;li>头部和尾部的插入删除都是O(1)&lt;/li>
&lt;li>一般不使用,作者都不使用&lt;/li>
&lt;/ul>
&lt;h2 id="set">Set&lt;/h2>
&lt;p>对集合进行排序时,需要实现Comparable接口,重写compareTo方法&lt;/p>
&lt;p>集合的不可重复性是通过equals方法来判断的, 需要重写equals方法和hashCode方法&lt;/p>
&lt;h4 id="hashset了解过吗">hashset了解过吗&lt;/h4>
&lt;p>HashSet是一种基于哈希表的Set实现，其底层实现与HashMap类似，只不过HashSet中存储的是不重复的元素。HashSet中的元素是无序的，不保证元素的插入顺序和遍历顺序一致。&lt;/p>
&lt;h4 id="判断某对象是否在set中存在需要重写哪些方法">判断某对象是否在set中存在，需要重写哪些方法&lt;/h4>
&lt;p>为了判断某个对象是否在Set中存在，需要重写该对象的hashCode()和equals()方法。hashCode()方法用于计算对象的哈希值，equals()方法用于比较两个对象是否相等。在重写这两个方法时，需要保证相等的对象具有相同的哈希值，否则会导致Set中出现重复元素。&lt;/p>
&lt;h2 id="queue">Queue&lt;/h2>
&lt;p>ArrayDeque 和 LinkedList的区别&lt;/p>
&lt;ul>
&lt;li>都实现了Deque接口&lt;/li>
&lt;li>ArrayDeque是数组实现的双端队列, 随机访问快, 队列操作慢；LinkedList是双向链表实现的双端队列, 队列操作快&lt;/li>
&lt;li>ArrayDeque不支持null元素, LinkedList支持&lt;/li>
&lt;li>ArrayDeque存在扩容，但均摊快；LinkedList不存在，每次插入需要申请空间，均摊慢。&lt;/li>
&lt;/ul>
&lt;h3 id="priorityqueue">PriorityQueue&lt;/h3>
&lt;p>JDK1.5 引入的&lt;/p>
&lt;ul>
&lt;li>底层是堆, 默认是小顶堆, 可以通过传入Comparator来实现大顶堆&lt;/li>
&lt;li>是插入删除是O(logn)，查顶推是O(1)&lt;/li>
&lt;li>是非线程安全的，不支持null元素&lt;/li>
&lt;/ul>
&lt;p>典型算法题的应用&lt;/p>
&lt;ul>
&lt;li>推排序&lt;/li>
&lt;li>第k大数（不过这个一般用快排O(n)实现）&lt;/li>
&lt;li>带权图的遍历&lt;/li>
&lt;/ul>
&lt;h3 id="blockingqueue-阻塞队列">BlockingQueue 阻塞队列&lt;/h3>
&lt;p>是一个接口，继承于Qeueu。&lt;/p>
&lt;p>阻塞的原因是，支持当队列没用元素时一直阻塞，直到有元素。
如果队列已满，则等到队列有空间时再插入元素。&lt;/p>
&lt;p>常用于生产者消费者模型。&lt;/p>
&lt;h2 id="map">Map**&lt;/h2>
&lt;h3 id="hashmap">HashMap&lt;/h3>
&lt;p>HashMap 和 HashTable的区别&lt;/p>
&lt;ul>
&lt;li>HashMap是非线程安全的，而HashTable是线程安全的&lt;/li>
&lt;li>HashMap允许使用null作为键和值，而HashTable不允许&lt;/li>
&lt;li>效率：HashMap效率高，HashTable效率低&lt;/li>
&lt;li>容量大小：HashMap默认大小为16，HashTable默认大小为11&lt;/li>
&lt;li>扩容：HashMap扩容是原来的2倍，HashTable扩容是原来的2倍+1&lt;/li>
&lt;li>底层数据结构：HashMap是数组+链表/红黑树，HashTable是数组+链表
&lt;ul>
&lt;li>JDK1.8 HashMap在链表长度超过8时，链表会自动转化为红黑树，优化查询速度&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>HashMap 和 TreeMap的区别&lt;/p>
&lt;ul>
&lt;li>HashMap是无序的，而TreeMap是有序的&lt;/li>
&lt;/ul>
&lt;h4 id="hashmap原理">HashMap原理&lt;/h4>
&lt;p>HashMap是一种基于哈希表的Map实现，其底层实现主要包括数组和链表（或红黑树）两部分。数组用来存储哈希桶，链表（或红黑树）用来解决哈希冲突。&lt;/p>
&lt;p>数组+链表+红黑树。&lt;/p>
&lt;p>那么在jdk1.8的HashMap中，当链表的长度超过8时，链表会自动转化为红黑树，优化查询速度。&lt;/p>
&lt;p>put原理&lt;/p>
&lt;p>同时还有一个区别：发生“hash冲突”时，我们上面的做法是“头插法”，这是jdk1.7的做法，而在jdk1.8中，使用的是“尾插法”。&lt;/p>
&lt;h4 id="hashmap底层实现">hashmap底层实现&lt;/h4>
&lt;p>HashMap是一种基于哈希表的Map实现，其底层实现主要包括数组和链表（或红黑树）两部分。数组用来存储哈希桶，链表（或红黑树）用来解决哈希冲突。&lt;/p>
&lt;p>具体来说，HashMap中的每个元素都是一个键值对，其中键和值都可以为null。当向HashMap中添加元素时，首先根据键的哈希值计算出该元素在数组中的位置，如果该位置上已经有元素了，则需要使用链表（或红黑树）来解决哈希冲突。如果链表（或红黑树）中已经存在该键，则更新该键对应的值，否则将该键值对添加到链表（或红黑树）的末尾。&lt;/p>
&lt;p>当链表（或红黑树）的长度超过一定阈值时，链表（或红黑树）会被转换为红黑树（或链表），以提高查询效率。当链表（或红黑树）的长度小于等于6时，会使用链表来存储元素，当长度大于6时，会使用红黑树来存储元素。&lt;/p>
&lt;p>在HashMap中，数组的长度是2的幂次方，这是为了使哈希值的高位和低位都能够参与到计算中，提高哈希值的均匀性。同时，数组的长度也决定了HashMap中哈希桶的数量，当哈希桶的数量过少时，容易导致哈希冲突，影响查询效率；当哈希桶的数量过多时，会浪费内存空间。因此，在创建HashMap时，需要根据实际情况来选择合适的数组长度。&lt;/p>
&lt;h4 id="hashmap17和18区别">hashmap1.7和1.8区别&lt;/h4>
&lt;p>HashMap1.7和1.8的主要区别在于底层实现方式的改变。1.7中使用的是数组+链表的方式来解决哈希冲突，而1.8中引入了红黑树来优化链表过长的情况，提高了查询效率。此外，1.8中还引入了一些新的方法和特性，如forEach()方法、Lambda表达式等。&lt;/p>
&lt;h4 id="hashmap怎么让他线程安全的方法">hashmap怎么让他线程安全的方法&lt;/h4>
&lt;p>HashMap本身是非线程安全的，如果需要在多线程环境下使用HashMap，可以使用以下几种方法来保证线程安全：&lt;/p>
&lt;ol>
&lt;li>使用Collections.synchronizedMap()方法将HashMap转换为线程安全的Map。&lt;/li>
&lt;li>使用ConcurrentHashMap代替HashMap，ConcurrentHashMap是一种线程安全的Map实现。&lt;/li>
&lt;li>使用读写锁来保证HashMap的线程安全性，即使用ReentrantReadWriteLock来控制读写操作的并发访问。&lt;/li>
&lt;/ol>
&lt;h3 id="concurrenthashmap">ConcurrentHashMap&lt;/h3>
&lt;h4 id="concurrenthashmap原理">ConcurrentHashMap原理&lt;/h4>
&lt;p>红黑树可用别的数据结构代替吗&lt;/p>
&lt;p>跳表与红黑树比较&lt;/p>
&lt;p>线程安全的类有哪些，为什么线程安全&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/language/java/jucjava%E5%B9%B6%E5%8F%91/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/language/java/jucjava%E5%B9%B6%E5%8F%91/</guid><description>&lt;h1 id="java-多线程">Java 多线程&lt;/h1>
&lt;h2 id="线程与进程">线程与进程&lt;/h2>
&lt;p>一个Java程序的运行是一个进程，包括一个main线程和多个其他线程&lt;/p>
&lt;p>Java的线程和操作系统的线程的区别&lt;/p>
&lt;ul>
&lt;li>JDK1.2之前使用的是JVM模拟的用户级线程，JDK1.2之后使用的是操作系统的内核级线程&lt;/li>
&lt;/ul>
&lt;p>用户级线程和内核级线程的区别&lt;/p>
&lt;ul>
&lt;li>用户线程：由用户空间程序管理和调度的线程，运行在用户空间（专门给应用程序使用）。&lt;/li>
&lt;li>内核线程：由操作系统内核管理和调度的线程，运行在内核空间（只有内核程序可以访问）。&lt;/li>
&lt;/ul>
&lt;p>线程模型是用户线程和内核线程之间的关联方式，常见的线程模型有这三种：&lt;/p>
&lt;ul>
&lt;li>一对一（一个用户线程对应一个内核线程）&lt;/li>
&lt;li>多对一（多个用户线程映射到一个内核线程）&lt;/li>
&lt;li>多对多（多个用户线程映射到多个内核线程）&lt;/li>
&lt;/ul>
&lt;p>Java采用的是一对一的线程模型，即一个用户线程对应一个内核线程。这种线程模型的优点是可以充分利用多核处理器的性能，缺点是创建和销毁线程的开销较大。&lt;/p>
&lt;p>JDK21正式引入了虚拟线程&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/JUC%28Java%e5%b9%b6%e5%8f%91%29/Java%e7%ba%bf%e7%a8%8b%e7%bb%93%e6%9e%84.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="为什么程序计数器虚拟机栈和本地方法栈是线程私有的呢">为什么程序计数器、虚拟机栈和本地方法栈是线程私有的呢？&lt;/h3>
&lt;p>程序计数器的功能是记录当前线程执行的字节码指令的地址，从而实现线程切换和恢复。&lt;/p>
&lt;p>程序计数器是线程私有的，是为了线程切换时能够正确恢复执行现场。&lt;/p>
&lt;p>虚拟机栈：每个线程在创建时都会创建一个虚拟机栈，用于存放线程的方法调用栈、局部变量表、操作数栈等信息。（执行的是Java方法）&lt;/p>
&lt;p>本地方法栈：用于支持本地方法调用，即调用C/C++编写的本地方法。&lt;/p>
&lt;p>为了保证线程的局部变量不被其他线程访问，虚拟机栈和本地方法栈是线程私有的。&lt;/p>
&lt;h3 id="为什么堆和方法区是线程共享的呢">为什么堆和方法区是线程共享的呢？&lt;/h3>
&lt;p>堆：是进程中所有线程共享的内存区域，用于存放对象实例。&lt;/p>
&lt;p>方法区：是进程中所有线程共享的内存区域，用于存放类的元数据信息、常量池、静态变量等。&lt;/p>
&lt;h3 id="并发并行同步异步">并发并行、同步异步&lt;/h3>
&lt;p>并发：指多个线程交替执行，从宏观上看是同时执行的。&lt;/p>
&lt;p>并行：指多个线程同时执行，从微观上看是同时执行的。&lt;/p>
&lt;p>同步：指多个线程按照一定的顺序执行。&lt;/p>
&lt;p>异步：指多个线程按照不确定的顺序执行。&lt;/p>
&lt;h2 id="多线程">多线程&lt;/h2>
&lt;h3 id="为什么要使用多线程">为什么要使用多线程？&lt;/h3>
&lt;p>多线程的主要优点有以下几点：&lt;/p>
&lt;ul>
&lt;li>线程间的切换开销小&lt;/li>
&lt;li>多线程高并发是高并发量的基础&lt;/li>
&lt;li>现在的CPU都是多核的，多线程可以充分利用CPU的性能&lt;/li>
&lt;/ul>
&lt;h3 id="多线程带来的问题">多线程带来的问题？&lt;/h3>
&lt;p>多线程的主要问题有以下几点：&lt;/p>
&lt;ul>
&lt;li>线程安全问题&lt;/li>
&lt;li>死锁问题&lt;/li>
&lt;li>内存泄漏问题&lt;/li>
&lt;/ul>
&lt;p>线程安全：&lt;/p>
&lt;ul>
&lt;li>线程安全是指多个线程访问共享资源时不会出现数据不一致的问题。&lt;/li>
&lt;/ul>
&lt;p>死锁：&lt;/p>
&lt;ul>
&lt;li>死锁是指两个或多个线程互相等待对方释放资源，导致所有线程都无法继续执行的问题。&lt;/li>
&lt;/ul>
&lt;p>内存泄漏：&lt;/p>
&lt;ul>
&lt;li>内存泄漏是指程序中的对象无法被垃圾回收器回收，导致内存占用过多的问题。&lt;/li>
&lt;/ul>
&lt;h3 id="单核上的多线程效率">单核上的多线程效率&lt;/h3>
&lt;p>单核上的多线程效率，取决于线程的类型&lt;/p>
&lt;ul>
&lt;li>CPU密集型线程：多线程效率不高，因为多个线程会争夺CPU资源，导致线程切换开销大。&lt;/li>
&lt;li>IO密集型线程：多线程效率较高，因为线程在等待IO时会释放CPU资源，不会争夺CPU资源。&lt;/li>
&lt;/ul>
&lt;h3 id="多线程的实现方式">多线程的实现方式&lt;/h3>
&lt;p>Java中实现多线程主要有两种方式：&lt;/p>
&lt;ol>
&lt;li>继承Thread类并重写run()方法。&lt;/li>
&lt;li>实现Runnable接口并实现run()方法，然后将其作为参数传递给Thread类的构造方法。&lt;/li>
&lt;/ol>
&lt;p>严格来说，这两种都是实现Runnable接口的方式，只不过一种是直接继承Thread类，另一种是将Runnable接口的实现类作为参数传递给Thread类的构造方法。&lt;/p>
&lt;h2 id="线程的生命周期和状态">线程的生命周期和状态&lt;/h2>
&lt;p>线程的生命周期主要包括以下几个状态：&lt;/p>
&lt;ul>
&lt;li>新建状态（New）：线程对象被创建后的状态。&lt;/li>
&lt;li>就绪状态（Waiting）：线程对象调用start()方法后的状态。&lt;/li>
&lt;li>运行状态（Running）：线程对象调用run()方法后的状态。&lt;/li>
&lt;li>阻塞状态（Blocked）：线程对象调用sleep()、wait()、join()等方法后的状态。&lt;/li>
&lt;li>死亡状态（Terminated）：线程对象执行完run()方法后的状态。&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/JUC%28Java%e5%b9%b6%e5%8f%91%29/Java%e7%ba%bf%e7%a8%8b%e7%8a%b6%e6%80%81%e5%8f%98%e5%8c%96.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="上下文切换">上下文切换&lt;/h3>
&lt;p>上下文切换是指CPU从一个线程切换到另一个线程时，需要保存当前线程的上下文信息，然后加载另一个线程的上下文信息。&lt;/p>
&lt;p>发生上下文切换的原因主要有以下几点：&lt;/p>
&lt;ul>
&lt;li>时间片耗尽&lt;/li>
&lt;li>调用阻塞类型的中断，如请求IO、sleep、wait、join等&lt;/li>
&lt;li>被终止&lt;/li>
&lt;/ul>
&lt;p>上下文切换的开销主要包括以下几个方面：&lt;/p>
&lt;ul>
&lt;li>保存和恢复寄存器&lt;/li>
&lt;li>保存和恢复程序计数器&lt;/li>
&lt;li>保存和恢复内存映射表&lt;/li>
&lt;/ul>
&lt;h3 id="线程死锁">线程死锁&lt;/h3>
&lt;p>线程池&lt;/p>
&lt;p>线程池的使用&lt;/p>
&lt;p>1个10G大小文件，如何得前100个最大数字&lt;/p>
&lt;h2 id="线程">线程&lt;/h2>
&lt;h4 id="java创建线程的方法">Java创建线程的方法&lt;/h4>
&lt;p>Java中创建线程的方法主要有两种：&lt;/p>
&lt;ol>
&lt;li>继承Thread类并重写run()方法。&lt;/li>
&lt;li>实现Runnable接口并实现run()方法，然后将其作为参数传递给Thread类的构造方法。&lt;/li>
&lt;/ol>
&lt;h4 id="查看线程的执行结果怎么拿到">查看线程的执行结果，怎么拿到&lt;/h4>
&lt;p>可以通过线程的join()方法来等待线程执行完毕，并获取线程的执行结果。join()方法会阻塞当前线程，直到被调用的线程执行完毕。&lt;/p>
&lt;p>另外，可以通过线程的返回值来获取线程的执行结果。如果线程需要返回结果，可以在run()方法中返回一个值，然后在调用线程的地方通过Thread对象的get()方法获取返回值。&lt;/p>
&lt;h4 id="有哪些实现好的线程池既然他们不推荐为什么java官方还要给你">有哪些实现好的线程池，既然他们不推荐，为什么Java官方还要给你&lt;/h4>
&lt;p>Java中提供了多种线程池实现，包括ThreadPoolExecutor、ScheduledThreadPoolExecutor、ForkJoinPool等。这些线程池实现都是经过优化和测试的，可以满足大部分场景的需求。&lt;/p>
&lt;p>虽然Java官方不推荐直接使用这些线程池实现，但是它们提供了一种可靠、高效的线程池实现，可以作为开发者自己实现线程池的参考。&lt;/p>
&lt;h4 id="阻塞队列有哪些">阻塞队列有哪些&lt;/h4>
&lt;p>Java中提供了多种阻塞队列实现，包括ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue等。这些阻塞队列实现都是线程安全的，可以在多线程环境下使用。&lt;/p>
&lt;h4 id="线程池的工作流程">线程池的工作流程&lt;/h4>
&lt;p>线程池的工作流程如下：&lt;/p>
&lt;ol>
&lt;li>当有任务需要执行时，线程池会从线程池中获取一个空闲线程来执行任务。&lt;/li>
&lt;li>如果线程池中没有空闲线程，则会根据线程池的配置创建新的线程来执行任务。&lt;/li>
&lt;li>当任务执行完毕后，线程会返回线程池，并等待下一次任务的分配。&lt;/li>
&lt;/ol>
&lt;h4 id="线程池拒绝策略有哪些">线程池拒绝策略有哪些&lt;/h4>
&lt;p>线程池的拒绝策略主要有以下几种：&lt;/p>
&lt;ol>
&lt;li>AbortPolicy：直接抛出RejectedExecutionException异常。&lt;/li>
&lt;li>CallerRunsPolicy：将任务交给调用线程来执行。&lt;/li>
&lt;li>DiscardPolicy：直接丢弃任务，不做任何处理。&lt;/li>
&lt;li>DiscardOldestPolicy：丢弃队列中最老的任务，然后尝试重新提交任务。&lt;/li>
&lt;/ol>
&lt;h4 id="线程池的参数有哪些">线程池的参数有哪些&lt;/h4>
&lt;p>线程池的参数主要包括以下几个：&lt;/p>
&lt;ol>
&lt;li>corePoolSize：核心线程数，即线程池中保留的线程数。&lt;/li>
&lt;li>maximumPoolSize：最大线程数，即线程池中允许的最大线程数。&lt;/li>
&lt;li>keepAliveTime：线程空闲时间，即当线程池中的线程空闲时间超过该值时，多余的线程会被销毁。&lt;/li>
&lt;li>unit：时间单位，用于指定keepAliveTime的时间单位。&lt;/li>
&lt;li>workQueue：任务队列，用于存储等待执行的任务。&lt;/li>
&lt;li>threadFactory：线程工厂，用于创建新的线程。&lt;/li>
&lt;li>handler：拒绝策略，用于处理无法处理的任务。&lt;/li>
&lt;/ol></description></item><item><title/><link>https://ysyyhhh.github.io/docs/language/java/jvm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/language/java/jvm/</guid><description>&lt;h2 id="jvm的内存模型">jvm的内存模型&lt;/h2>
&lt;h3 id="integer-a--128b128两个相等吗">integer a = 128,b=128，两个相等吗&lt;/h3>
&lt;p>&lt;a href="https://blog.csdn.net/qq_42208194/article/details/117536553" target="_blank" rel="noopener">https://blog.csdn.net/qq_42208194/article/details/117536553&lt;/a>&lt;/p>
&lt;p>在Java中，对于Integer类型的对象，如果其值在-128到127之间，会被缓存到常量池中，因此当创建值在该范围内的Integer对象时，会直接从常量池中获取已有的对象。而对于值不在该范围内的Integer对象，则会创建新的对象。&lt;/p>
&lt;p>因此，对于Integer a = 128, b = 128，由于128不在-128到127之间，因此会创建两个不同的Integer对象，即a和b不相等。而对于Integer a = 127, b = 127，由于127在-128到127之间，因此会从常量池中获取同一个Integer对象，即a和b相等。&lt;/p>
&lt;h3 id="什么叫零拷贝">什么叫零拷贝&lt;/h3>
&lt;p>零拷贝（Zero Copy）是一种数据传输技术，它可以在不需要将数据从一个缓冲区复制到另一个缓冲区的情况下，将数据从一个地方传输到另一个地方。在零拷贝技术中，数据可以直接从磁盘、网络或其他设备中读取，然后通过DMA（Direct Memory Access）技术直接写入内存中，从而避免了数据的多次复制，提高了数据传输的效率。&lt;/p>
&lt;p>在Java中，零拷贝技术可以通过NIO（New I/O）来实现。NIO提供了一种基于通道（Channel）和缓冲区（Buffer）的I/O模型，可以直接将数据从通道中读取到缓冲区中，或者将缓冲区中的数据直接写入通道中，从而避免了数据的多次复制。&lt;/p>
&lt;h3 id="为什么用常量池有哪些常量池">为什么用常量池，有哪些常量池&lt;/h3>
&lt;p>&lt;a href="https://blog.csdn.net/qq_41376740/article/details/80338158" target="_blank" rel="noopener">https://blog.csdn.net/qq_41376740/article/details/80338158&lt;/a>&lt;/p>
&lt;p>常量池是Java中的一种特殊的内存区域，用于存储常量和符号引用。在Java中，常量池主要有以下几种：&lt;/p>
&lt;ol>
&lt;li>字面量常量池：用于存储字符串、数字等字面量常量。&lt;/li>
&lt;li>符号引用常量池：用于存储类、方法、字段等符号引用。&lt;/li>
&lt;li>运行时常量池：用于存储在类加载时解析的常量池信息，包括字面量常量池和符号引用常量池中的内容。&lt;/li>
&lt;/ol>
&lt;p>使用常量池的主要目的是为了提高程序的性能和减少内存的占用。由于常量池中的常量是唯一的，因此可以避免重复创建相同的常量对象，从而减少内存的占用。同时，由于常量池中的常量是在编译期间就确定的，因此可以在运行时直接使用，避免了重复计算和创建对象的开销，提高了程序的性能。&lt;/p></description></item></channel></rss>