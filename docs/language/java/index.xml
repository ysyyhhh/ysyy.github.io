<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>java | Ysyy's</title><link>https://ysyyhhh.github.io/docs/language/java/</link><atom:link href="https://ysyyhhh.github.io/docs/language/java/index.xml" rel="self" type="application/rss+xml"/><description>java</description><generator>Hugo Blox Builder (https://hugoblox.com)</generator><language>en-us</language><image><url>https://ysyyhhh.github.io/media/logo.svg</url><title>java</title><link>https://ysyyhhh.github.io/docs/language/java/</link></image><item><title/><link>https://ysyyhhh.github.io/docs/language/java/javaio/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/language/java/javaio/</guid><description>&lt;h1 id="java-io">Java IO&lt;/h1>
&lt;h2 id="java-io流介绍">Java IO流介绍&lt;/h2>
&lt;p>Java IO流主要分为字节流和字符流，字节流主要用于处理二进制文件，字符流主要用于处理文本文件。&lt;/p>
&lt;p>四个抽象类：&lt;/p>
&lt;ul>
&lt;li>InputStream：字节输入流&lt;/li>
&lt;li>OutputStream：字节输出流&lt;/li>
&lt;li>Reader：字符输入流&lt;/li>
&lt;li>Writer：字符输出流&lt;/li>
&lt;/ul>
&lt;h3 id="字节流">字节流&lt;/h3>
&lt;p>字节流主要用于处理二进制文件，如图片、视频、音频等。&lt;/p>
&lt;p>FileInputStream和FileOutputStream是两个基本的字节流，用于读写文件。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">FileInputStreamTest&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">static&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">args&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">try&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">FileInputStream&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">fis&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">FileInputStream&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;test.txt&amp;#34;&lt;/span>&lt;span class="p">))&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">while&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">fis&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">read&lt;/span>&lt;span class="p">())&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">!=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">print&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="kt">char&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">catch&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">IOException&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">printStackTrace&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">FileOutputStreamTest&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">static&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">args&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">try&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">FileOutputStream&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">fos&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">FileOutputStream&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;test.txt&amp;#34;&lt;/span>&lt;span class="p">))&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">str&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;Hello, World!&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kt">byte&lt;/span>&lt;span class="o">[]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">bytes&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">str&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">getBytes&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">fos&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">write&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">bytes&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">catch&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">IOException&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">printStackTrace&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="字符流">字符流&lt;/h3>
&lt;p>字符流主要用于处理文本文件，如txt文件。&lt;/p>
&lt;p>为什么会有字符流&lt;/p>
&lt;ul>
&lt;li>字节流是以字节为单位读写数据，而字符流是以字符为单位读写数据&lt;/li>
&lt;li>字节流读取中文字符时可能会出现乱码，而字符流不会出现乱码&lt;/li>
&lt;/ul>
&lt;p>字符流默认采用unicode编码，可以指定编码格式。&lt;/p>
&lt;p>常用字符编码所占字节数&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>编码格式&lt;/th>
&lt;th>中文字符所占字节数&lt;/th>
&lt;th>英文字符所占字节数&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>GBK&lt;/td>
&lt;td>2&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>UTF-8&lt;/td>
&lt;td>3&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>UTF-16&lt;/td>
&lt;td>2&lt;/td>
&lt;td>2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>unicode&lt;/td>
&lt;td>2&lt;/td>
&lt;td>2&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>FileReader和FileWriter是两个基本的字符流，用于读写文件。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">FileReaderTest&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">static&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">args&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">try&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">FileReader&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">fr&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">FileReader&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;test.txt&amp;#34;&lt;/span>&lt;span class="p">))&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">while&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">fr&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">read&lt;/span>&lt;span class="p">())&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">!=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">print&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="kt">char&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">catch&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">IOException&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">printStackTrace&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">FileWriterTest&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">static&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">args&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">try&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">FileWriter&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">fw&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">FileWriter&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;test.txt&amp;#34;&lt;/span>&lt;span class="p">))&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">str&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;Hello, World!&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">fw&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">write&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">str&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">catch&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">IOException&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">printStackTrace&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="字节缓冲流">字节缓冲流&lt;/h3>
&lt;p>字节缓冲流主要用于提高读写文件的效率。&lt;/p>
&lt;p>BufferedInputStream和BufferedOutputStream是两个基本的字节缓冲流，用于读写文件。&lt;/p>
&lt;p>BufferedInputStream 内部维护了一个缓冲区，这个缓冲区实际就是一个字节数组，通过阅读 BufferedInputStream 源码即可得到这个结论.
缓冲器默认大小为 8192 字节，也就是 8KB，这个大小是可以通过构造函数来指定的。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">BufferedInputStream&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">extends&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">FilterInputStream&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 内部缓冲区数组&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">protected&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">volatile&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">byte&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="o">[]&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 缓冲区的默认大小&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">static&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">DEFAULT_BUFFER_SIZE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">8192&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 使用默认的缓冲区大小&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">BufferedInputStream&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">InputStream&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">in&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">in&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">DEFAULT_BUFFER_SIZE&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 自定义缓冲区大小&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">BufferedInputStream&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">InputStream&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">in&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">size&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">super&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">in&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">if&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">size&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;lt;=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">throw&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">IllegalArgumentException&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Buffer size &amp;lt;= 0&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">byte&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">size&lt;/span>&lt;span class="o">]&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="字符缓冲流">字符缓冲流&lt;/h3>
&lt;p>字符缓冲流主要用于提高读写文件的效率。&lt;/p>
&lt;h3 id="打印流">打印流&lt;/h3>
&lt;p>PrintStream和PrintWriter是两个基本的打印流，用于打印数据。&lt;/p>
&lt;p>System.out实际是获取了一个PrintStream对象，System.out.println()实际是调用了PrintStream对象的println()方法。&lt;/p>
&lt;h3 id="随机访问流">随机访问流&lt;/h3>
&lt;p>RandomAccessFile是一个基本的随机访问流，用于读写文件, 支持随机访问文件。
RandomAccessFile 的构造方法如下&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">RandomAccessFile&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">mode&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">throws&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">FileNotFoundException&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">!=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">?&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">File&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">mode&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>mode 参数指定了 RandomAccessFile 的访问模式，有 &amp;ldquo;r&amp;rdquo;、&amp;ldquo;rw&amp;rdquo;、&amp;ldquo;rws&amp;rdquo;、&amp;ldquo;rwd&amp;rdquo; 四种模式，分别表示：&lt;/p>
&lt;ul>
&lt;li>&amp;ldquo;r&amp;rdquo;：以只读方式打开&lt;/li>
&lt;li>&amp;ldquo;rw&amp;rdquo;：以读写方式打开&lt;/li>
&lt;li>&amp;ldquo;rws&amp;rdquo;：以读写方式打开，对文件的内容或元数据的每个更新都同步写入到底层存储设备&lt;/li>
&lt;li>&amp;ldquo;rwd&amp;rdquo;：以读写方式打开，对文件内容的每个更新都同步写入到底层存储设备&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">RandomAccessFileTest&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">static&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">args&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">try&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">RandomAccessFile&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">raf&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">RandomAccessFile&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;test.txt&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;rw&amp;#34;&lt;/span>&lt;span class="p">))&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">raf&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">write&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Hello, World!&amp;#34;&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">getBytes&lt;/span>&lt;span class="p">());&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">raf&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">seek&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kt">byte&lt;/span>&lt;span class="o">[]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">bytes&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">byte&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">1024&lt;/span>&lt;span class="o">]&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">len&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">while&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="n">len&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">raf&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">read&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">bytes&lt;/span>&lt;span class="p">))&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">!=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">bytes&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">len&lt;/span>&lt;span class="p">));&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">catch&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">IOException&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">printStackTrace&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="io中的设计模式">IO中的设计模式&lt;/h2>
&lt;h3 id="装饰器模式">装饰器模式&lt;/h3>
&lt;p>装饰器模式是一种结构型设计模式，允许你通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。&lt;/p>
&lt;p>装饰器模式的主要优点有：&lt;/p>
&lt;ul>
&lt;li>可以在不修改现有对象的情况下，动态地给一个对象增加一些额外的功能&lt;/li>
&lt;li>可以使用多个装饰器包装一个对象，得到功能更加强大的对象&lt;/li>
&lt;/ul>
&lt;p>字节流和字符流的装饰器模式
FilterInputStream和FilterOutputStream是两个基本的装饰器，用于装饰字节流。&lt;/p>
&lt;h3 id="适配器模式">适配器模式&lt;/h3>
&lt;p>适配器模式是一种结构型设计模式，它能使接口不兼容的对象能够相互合作。&lt;/p>
&lt;p>InputStreamReader和OutputStreamWriter是两个基本的适配器，用于适配字节流和字符流。&lt;/p>
&lt;p>InputStreamReader是字节流到字符流的适配器，OutputStreamWriter是字符流到字节流的适配器。&lt;/p>
&lt;h3 id="观察者模式">观察者模式&lt;/h3>
&lt;p>观察者模式是一种行为型设计模式，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。&lt;/p>
&lt;p>NIO中的文件监听器就是观察者模式的一种应用。&lt;/p>
&lt;p>NIO中的文件监听器基于WatchService接口和Watchable接口.&lt;/p>
&lt;h3 id="工厂模式">工厂模式&lt;/h3>
&lt;p>Files类的newInputStream()和newOutputStream()方法就是工厂模式的一种应用。&lt;/p>
&lt;h2 id="io模型">IO模型&lt;/h2>
&lt;p>IO操作的本质是数据的输入和输出，而IO模型是操作系统对IO操作的抽象。
平时接触最多的是磁盘IO和网络IO。&lt;/p>
&lt;p>UNIX系统下, IO模型有五种：&lt;/p>
&lt;ul>
&lt;li>同步阻塞IO&lt;/li>
&lt;li>同步非阻塞IO&lt;/li>
&lt;li>IO复用&lt;/li>
&lt;li>信号驱动IO&lt;/li>
&lt;li>异步IO&lt;/li>
&lt;/ul>
&lt;h3 id="java中的三种常见io">Java中的三种常见IO&lt;/h3>
&lt;ul>
&lt;li>BIO（Blocking IO）：同步阻塞IO&lt;/li>
&lt;li>NIO（Non-blocking IO）：同步非阻塞IO&lt;/li>
&lt;li>AIO（Asynchronous IO）：异步IO&lt;/li>
&lt;/ul>
&lt;p>BIO（Blocking IO）：同步阻塞IO&lt;/p>
&lt;ul>
&lt;li>一个线程只能处理一个连接&lt;/li>
&lt;li>适用于连接数较少的场景&lt;/li>
&lt;/ul>
&lt;p>当有大量的连接时，BIO的效率会很低，因为每个连接都需要一个线程来处理。&lt;/p>
&lt;p>IO多路复用（IO Multiplexing）：IO复用
线程首先发起IO请求，然后阻塞在IO复用器上，当IO复用器检测到有IO事件时，线程才会被唤醒。&lt;/p>
&lt;p>NIO（Non-blocking IO）：同步非阻塞IO&lt;/p>
&lt;p>NIO是一种同步非阻塞IO模型，适用于连接数较多的场景。
NIO的核心是Selector，Selector可以同时监控多个通道的IO事件。&lt;/p>
&lt;p>AIO（Asynchronous IO）：异步IO
AIO是一种异步IO模型，适用于连接数较多且数据量较大的场景。&lt;/p>
&lt;h2 id="javanio">JavaNIO&lt;/h2>
&lt;p>NIO的核心组件&lt;/p>
&lt;ul>
&lt;li>Channel: 通道, 用于读写数据&lt;/li>
&lt;li>Buffer: 缓冲区, 用于存储数据&lt;/li>
&lt;li>Selector: 多路复用器, 用于监控多个通道的IO事件&lt;/li>
&lt;/ul>
&lt;h3 id="nio零拷贝">NIO零拷贝&lt;/h3>
&lt;p>零拷贝是指数据在内存和磁盘之间传输时，不需要在中间进行数据拷贝。&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/language/java/java%E9%9B%86%E5%90%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/language/java/java%E9%9B%86%E5%90%88/</guid><description>&lt;h1 id="java集合体系">Java集合体系&lt;/h1>
&lt;p>Java 集合， 也叫作容器，主要是由两大接口派生而来：一个是 Collection接口，主要用于存放单一元素；另一个是 Map 接口，主要用于存放键值对。对于Collection 接口，下面又有三个主要的子接口：List、Set 和 Queue。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Java%e9%9b%86%e5%90%88/Java%e9%9b%86%e5%90%88%e7%9a%84%e7%bb%93%e6%9e%84.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>List: 有序，可重复&lt;/p>
&lt;ul>
&lt;li>ArrayList: Object[] 数组, 查询快, 增删慢&lt;/li>
&lt;li>Vector: Object[] 数组, 线程安全(与ArrayList区别)&lt;/li>
&lt;li>LinkedList: 双向链表, 查询慢, 增删快&lt;/li>
&lt;/ul>
&lt;p>Set: 元素不可重复&lt;/p>
&lt;ul>
&lt;li>HashSet: 基于HashMap实现, 无序&lt;/li>
&lt;li>TreeSet: 红黑树(自平衡的二叉查找树), 有序&lt;/li>
&lt;li>LinkedHashSet: 基于LinkedHashMap实现, 是HashSet的子类, 有序&lt;/li>
&lt;/ul>
&lt;p>Queue: 有序，可重复, 用于存放队列元素&lt;/p>
&lt;ul>
&lt;li>PriorityQueue: 优先级队列, Object[] 数组&lt;/li>
&lt;li>DelayQueue: 延迟队列, 用于存放延迟元素&lt;/li>
&lt;li>ArrayDeque: 双端队列, Object[] 数组&lt;/li>
&lt;/ul>
&lt;p>Map: 无序，不可重复，键值对&lt;/p>
&lt;ul>
&lt;li>HashMap: JDK1.8之前是数组+链表, JDK1.8之后是数组+链表/红黑树&lt;/li>
&lt;li>LinkedHashMap: 基于HashMap实现, 有序&lt;/li>
&lt;li>TreeMap: 红黑树(自平衡的二叉查找树), 有序&lt;/li>
&lt;li>HashTable: 数组(主体)+链表(解决哈希冲突), 线程安全&lt;/li>
&lt;/ul>
&lt;p>如何选用集合&lt;/p>
&lt;ul>
&lt;li>要键值对 - Map
&lt;ul>
&lt;li>需要排序 - TreeMap&lt;/li>
&lt;li>不需要排序 - HashMap&lt;/li>
&lt;li>需要线程安全 - HashTable&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>不需要键值对 - Collection
&lt;ul>
&lt;li>保证元素唯一 - Set
&lt;ul>
&lt;li>需要排序 - TreeSet&lt;/li>
&lt;li>不需要排序 - HashSet&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>允许重复元素 - List
&lt;ul>
&lt;li>需要高效的增删 - LinkedList&lt;/li>
&lt;li>需要高效的查询 - ArrayList&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="list">List&lt;/h2>
&lt;p>ArrayList 与 Array比较&lt;/p>
&lt;ul>
&lt;li>ArrayList是数组的封装，可以动态扩容，而数组是静态的&lt;/li>
&lt;li>ArrayList允许使用泛型&lt;/li>
&lt;/ul>
&lt;p>ArrayList 与 Vector比较&lt;/p>
&lt;ul>
&lt;li>ArrayList是非线程安全的，而Vector是线程安全的&lt;/li>
&lt;li>ArrayList是JDK1.2引入的(主要实现类,新)，而Vector是JDK1.0引入的&lt;/li>
&lt;/ul>
&lt;p>ArrayList&lt;/p>
&lt;ul>
&lt;li>底层是数组,支持随机访问&lt;/li>
&lt;li>可以添加null元素&lt;/li>
&lt;li>插入:
&lt;ul>
&lt;li>头部插入: O(n)&lt;/li>
&lt;li>尾部插入: O(1), 扩容时O(n),每次扩容是原来的1.5倍&lt;/li>
&lt;li>指定位置插入: O(n)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>删除:
&lt;ul>
&lt;li>只有尾部删除是O(1), 其他都是O(n)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>LinkedList&lt;/p>
&lt;ul>
&lt;li>底层是双向链表, 不支持随机访问&lt;/li>
&lt;li>头部和尾部的插入删除都是O(1)&lt;/li>
&lt;li>一般不使用,作者都不使用&lt;/li>
&lt;/ul>
&lt;h3 id="arraylist">ArrayList&lt;/h3>
&lt;p>底层是动态数组&lt;/p>
&lt;h4 id="声明arraylistjava语言会做什么操作">声明arraylist，java语言会做什么操作&lt;/h4>
&lt;p>A:声明ArrayList时，Java会创建一个长度为0的数组，当第一次添加元素时，会创建一个长度为10的数组，并将元素添加到数组中。当数组长度不够时，会创建一个原数组长度的1.5倍的新数组，并将原数组中的元素复制到新数组中。&lt;/p>
&lt;h4 id="arraylist什么时候扩容">arraylist什么时候扩容&lt;/h4>
&lt;p>A:ArrayList在添加元素时，会先判断当前数组的容量是否足够，如果不够则会进行扩容。扩容时，会创建一个原数组长度的1.5倍的新数组，并将原数组中的元素复制到新数组中。&lt;/p>
&lt;h4 id="arraylist是线程安全的吗">arraylist是线程安全的吗&lt;/h4>
&lt;p>A:ArrayList是非线程安全的，如果需要在多线程环境下使用ArrayList，可以使用Collections.synchronizedList()方法将ArrayList转换为线程安全的List。&lt;/p>
&lt;h4 id="线程安全的list有哪些">线程安全的list有哪些&lt;/h4>
&lt;p>A:线程安全的List有Vector和Collections.synchronizedList()方法转换的List。Vector是一种线程安全的List实现，而Collections.synchronizedList()方法可以将ArrayList转换为线程安全的List。&lt;/p>
&lt;h3 id="vector">Vector&lt;/h3>
&lt;p>Vector的底层&lt;/p>
&lt;p>为其所有需要保证线程安全的方法都添加了&lt;strong>synchronized关键字&lt;/strong>，锁住了整个对象&lt;/p>
&lt;h2 id="set">Set&lt;/h2>
&lt;p>对集合进行排序时,需要实现Comparable接口,重写compareTo方法&lt;/p>
&lt;p>集合的不可重复性是通过equals方法来判断的, 需要重写equals方法和hashCode方法&lt;/p>
&lt;h4 id="hashset了解过吗">hashset了解过吗&lt;/h4>
&lt;p>HashSet是一种基于哈希表的Set实现，其底层实现与HashMap类似，只不过HashSet中存储的是不重复的元素。HashSet中的元素是无序的，不保证元素的插入顺序和遍历顺序一致。&lt;/p>
&lt;h4 id="判断某对象是否在set中存在需要重写哪些方法">判断某对象是否在set中存在，需要重写哪些方法&lt;/h4>
&lt;p>为了判断某个对象是否在Set中存在，需要重写该对象的hashCode()和equals()方法。hashCode()方法用于计算对象的哈希值，equals()方法用于比较两个对象是否相等。在重写这两个方法时，需要保证相等的对象具有相同的哈希值，否则会导致Set中出现重复元素。&lt;/p>
&lt;h2 id="queue">Queue&lt;/h2>
&lt;p>ArrayDeque 和 LinkedList的区别&lt;/p>
&lt;ul>
&lt;li>都实现了Deque接口&lt;/li>
&lt;li>ArrayDeque是数组实现的双端队列, 随机访问快, 队列操作慢；LinkedList是双向链表实现的双端队列, 队列操作快&lt;/li>
&lt;li>ArrayDeque不支持null元素, LinkedList支持&lt;/li>
&lt;li>ArrayDeque存在扩容，但均摊快；LinkedList不存在，每次插入需要申请空间，均摊慢。&lt;/li>
&lt;/ul>
&lt;h3 id="priorityqueue">PriorityQueue&lt;/h3>
&lt;p>JDK1.5 引入的&lt;/p>
&lt;ul>
&lt;li>底层是堆, 默认是小顶堆, 可以通过传入Comparator来实现大顶堆&lt;/li>
&lt;li>是插入删除是O(logn)，查顶推是O(1)&lt;/li>
&lt;li>是非线程安全的，不支持null元素&lt;/li>
&lt;/ul>
&lt;p>典型算法题的应用&lt;/p>
&lt;ul>
&lt;li>推排序&lt;/li>
&lt;li>第k大数（不过这个一般用快排O(n)实现）&lt;/li>
&lt;li>带权图的遍历&lt;/li>
&lt;/ul>
&lt;h3 id="blockingqueue-阻塞队列">BlockingQueue 阻塞队列&lt;/h3>
&lt;p>是一个接口，继承于Queue。&lt;/p>
&lt;p>阻塞的原因是，支持当队列没用元素时一直阻塞，直到有元素。
如果队列已满，则等到队列有空间时再插入元素。&lt;/p>
&lt;p>常用于生产者消费者模型。&lt;/p>
&lt;h2 id="map">Map**&lt;/h2>
&lt;h3 id="hashmap">HashMap&lt;/h3>
&lt;p>HashMap 和 HashTable的区别&lt;/p>
&lt;ul>
&lt;li>HashMap是非线程安全的，而HashTable是线程安全的&lt;/li>
&lt;li>HashMap允许使用null作为键和值，而HashTable不允许&lt;/li>
&lt;li>效率：HashMap效率高，HashTable效率低&lt;/li>
&lt;li>容量大小：HashMap默认大小为16，HashTable默认大小为11&lt;/li>
&lt;li>扩容：HashMap扩容是原来的2倍，HashTable扩容是原来的2倍+1&lt;/li>
&lt;li>底层数据结构：HashMap是数组+链表/红黑树，HashTable是数组+链表
&lt;ul>
&lt;li>JDK1.8 HashMap在链表长度超过8时，链表会自动转化为红黑树，优化查询速度&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>HashMap 和 TreeMap的区别&lt;/p>
&lt;ul>
&lt;li>HashMap是无序的，而TreeMap是有序的&lt;/li>
&lt;/ul>
&lt;h4 id="hashmap原理">HashMap原理&lt;/h4>
&lt;p>HashMap是一种基于哈希表的Map实现，其底层实现主要包括数组和链表（或红黑树）两部分。数组用来存储哈希桶，链表（或红黑树）用来解决哈希冲突。&lt;/p>
&lt;p>数组+链表+红黑树。&lt;/p>
&lt;p>那么在jdk1.8的HashMap中，当链表的&lt;strong>长度超过8&lt;/strong>时，链表会自动转化为红黑树，优化查询速度。&lt;/p>
&lt;p>jdk1.8之前插入链表是头插法，jdk1.8之后是尾插法。&lt;/p>
&lt;p>头插法：效率高、满足时间局部性原理&lt;/p>
&lt;ul>
&lt;li>但在扩容后可能会导致链表逆序，影响查询效率。&lt;/li>
&lt;li>扩容时可能会导致死循环（多线程场景下，跟链表逆序有关）&lt;/li>
&lt;/ul>
&lt;p>put原理&lt;/p>
&lt;p>同时还有一个区别：发生“hash冲突”时，我们上面的做法是“头插法”，这是jdk1.7的做法，而在jdk1.8中，使用的是“尾插法”。&lt;/p>
&lt;h4 id="hash冲突解决方案">hash冲突解决方案&lt;/h4>
&lt;ul>
&lt;li>开放定址法
&lt;ul>
&lt;li>线性探测法&lt;/li>
&lt;li>二次探测法&lt;/li>
&lt;li>伪随机&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>链地址法
&lt;ul>
&lt;li>相同的hash值的元素，用链表存储&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>再哈希法
&lt;ul>
&lt;li>提供多个hash函数&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>建立公共溢出区
&lt;ul>
&lt;li>将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。&lt;/li>
&lt;li>在查找的时候，先与哈希表的相应位置比较，如果查找成功，则返回。否则去公共溢出区按顺序一一查找。在冲突数据少时性能好，冲突数据多的时候耗时。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="hashmap底层实现">hashmap底层实现&lt;/h4>
&lt;p>HashMap是一种基于哈希表的Map实现，其底层实现主要包括数组和链表（或红黑树）两部分。数组用来存储哈希桶，链表（或红黑树）用来解决哈希冲突。&lt;/p>
&lt;p>一般情况下，当元素数量超过阈值时便会触发扩容。每次扩容的容量都是之前容量的2倍。&lt;/p>
&lt;p>具体来说，HashMap中的每个元素都是一个键值对，其中键和值都可以为null。当向HashMap中添加元素时，首先根据键的哈希值计算出该元素在数组中的位置，如果该位置上已经有元素了，则需要使用链表（或红黑树）来解决哈希冲突。如果链表（或红黑树）中已经存在该键，则更新该键对应的值，否则将该键值对添加到链表（或红黑树）的末尾。&lt;/p>
&lt;p>当链表（或红黑树）的长度超过一定阈值时，链表（或红黑树）会被转换为红黑树（或链表），以提高查询效率。当链表（或红黑树）的长度小于等于6时，会使用链表来存储元素，当长度大于6时，会使用红黑树来存储元素。&lt;/p>
&lt;p>在HashMap中，数组的长度是2的幂次方，这是为了使哈希值的高位和低位都能够参与到计算中，提高哈希值的均匀性。同时，数组的长度也决定了HashMap中哈希桶的数量，当哈希桶的数量过少时，容易导致哈希冲突，影响查询效率；当哈希桶的数量过多时，会浪费内存空间。因此，在创建HashMap时，需要根据实际情况来选择合适的数组长度。&lt;/p>
&lt;h4 id="hashmap17和18区别">hashmap1.7和1.8区别&lt;/h4>
&lt;p>HashMap1.7和1.8的主要区别在于底层实现方式的改变。1.7中使用的是数组+链表的方式来解决哈希冲突，而1.8中引入了红黑树来优化链表过长的情况，提高了查询效率。此外，1.8中还引入了一些新的方法和特性，如forEach()方法、Lambda表达式等。&lt;/p>
&lt;h4 id="hashmap怎么让他线程安全的方法">hashmap怎么让他线程安全的方法&lt;/h4>
&lt;p>线程安全的map有哪些&lt;/p>
&lt;p>HashMap本身是非线程安全的，如果需要在多线程环境下使用HashMap，可以使用以下几种方法来保证线程安全：&lt;/p>
&lt;ol>
&lt;li>使用Collections.synchronizedMap()方法将HashMap转换为线程安全的Map。&lt;/li>
&lt;li>使用ConcurrentHashMap代替HashMap，ConcurrentHashMap是一种线程安全的Map实现。&lt;/li>
&lt;li>使用读写锁来保证HashMap的线程安全性，即使用ReentrantReadWriteLock来控制读写操作的并发访问。&lt;/li>
&lt;/ol>
&lt;h3 id="hashtable">HashTable&lt;/h3>
&lt;p>Hashtable与Vector类似，都是为每个方法添加了synchronized关键字，来实现的线程安全，锁住了整个对象。Hashtable是一个线程安全的集合,是单线程集合，它给几乎所有public方法都加上了synchronized关键字。&lt;/p>
&lt;h3 id="concurrenthashmap">ConcurrentHashMap&lt;/h3>
&lt;h4 id="concurrenthashmap原理">ConcurrentHashMap原理**&lt;/h4>
&lt;p>在 JDK 1.7 中它使用的是数组加链表的形式实现的，而数组又分为：大数组 Segment 和小数组 HashEntry
Segment 本身是基于 ReentrantLock 实现的加锁和释放锁的操作，这样就能保证多个线程同时访问 ConcurrentHashMap 时，同一时间只有一个线程能操作相应的节点，这样就保证了 ConcurrentHashMap 的线程安全了。&lt;/p>
&lt;p>分段锁的缺点是：在高并发的情况下，会出现大量线程阻塞，导致性能下降。&lt;/p>
&lt;p>JDK1.7之后
使用的是 CAS + volatile 或 synchronized 的方式来保证线程安全的
ConcurrentHashMap 已经摒弃了 Segment 的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。&lt;/p>
&lt;p>在 JDK 1.8 中，添加元素时首先会判断&lt;/p>
&lt;ul>
&lt;li>&lt;strong>容器是否为空，如果为空则使用 volatile 加 CAS 来初始化&lt;/strong>。&lt;/li>
&lt;li>如果容器不为空则根据存储的元素计算该位置是否为空
&lt;ul>
&lt;li>如果为空则利用 CAS 设置该节点；&lt;/li>
&lt;li>&lt;strong>如果不为空则使用 synchronize 加锁&lt;/strong>，遍历桶中的数据，替换或新增节点到桶中，最后再判断是否需要转为红黑树，这样就能保证并发访问时的线程安全了。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>我们把上述流程简化一下，我们可以简单的认为在 JDK 1.8 中，ConcurrentHashMap 是在头节点加锁来保证线程安全的，锁的粒度相比 Segment 来说更小了，发生冲突和加锁的频率降低了，并发操作的性能就提高了。而且 JDK 1.8 使用的是红黑树优化了之前的固定链表，那么当数据量比较大的时候，查询性能也得到了很大的提升，从之前的 O(n) 优化到了 O(logn) 的时间复杂&lt;/p>
&lt;p>13、concurrenthashmap最耗时的操作是什么
A: ConcurrentHashMap最耗时的操作是put操作，因为put操作需要保证线程安全，需要进行加锁操作，而加锁操作会影响并发性能。&lt;/p>
&lt;p>12、hashtable和concurrenthashmap的区别&lt;/p>
&lt;p>线程安全的类有哪些，为什么线程安全&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/language/java/jucjava%E5%B9%B6%E5%8F%91/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/language/java/jucjava%E5%B9%B6%E5%8F%91/</guid><description>&lt;h1 id="java-多线程">Java 多线程&lt;/h1>
&lt;h2 id="线程与进程">线程与进程&lt;/h2>
&lt;p>一个Java程序的运行是一个进程，包括一个main线程和多个其他线程&lt;/p>
&lt;p>Java的线程和操作系统的线程的区别&lt;/p>
&lt;ul>
&lt;li>JDK1.2之前使用的是JVM模拟的用户级线程，JDK1.2之后使用的是操作系统的内核级线程&lt;/li>
&lt;/ul>
&lt;p>用户级线程和内核级线程的区别&lt;/p>
&lt;ul>
&lt;li>用户线程：由用户空间程序管理和调度的线程，运行在用户空间（专门给应用程序使用）。&lt;/li>
&lt;li>内核线程：由操作系统内核管理和调度的线程，运行在内核空间（只有内核程序可以访问）。&lt;/li>
&lt;/ul>
&lt;p>线程模型是用户线程和内核线程之间的关联方式，常见的线程模型有这三种：&lt;/p>
&lt;ul>
&lt;li>一对一（一个用户线程对应一个内核线程）&lt;/li>
&lt;li>多对一（多个用户线程映射到一个内核线程）&lt;/li>
&lt;li>多对多（多个用户线程映射到多个内核线程）&lt;/li>
&lt;/ul>
&lt;p>Java采用的是一对一的线程模型，即一个用户线程对应一个内核线程。这种线程模型的优点是可以充分利用多核处理器的性能，缺点是创建和销毁线程的开销较大。&lt;/p>
&lt;p>JDK21正式引入了虚拟线程&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/JUC%28Java%E5%B9%B6%E5%8F%91%29/Java%E7%BA%BF%E7%A8%8B%E7%BB%93%E6%9E%84.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="java中没有协程">Java中没有协程&lt;/h3>
&lt;p>协程是多个协程对应一个内核线程的模型 协程是一种用户级的轻量级&amp;quot;线程&amp;quot;, 由程序员自己控制切换时机, 不需要操作系统内核介入。&lt;/p>
&lt;h3 id="为什么程序计数器虚拟机栈和本地方法栈是线程私有的呢">为什么程序计数器、虚拟机栈和本地方法栈是线程私有的呢？&lt;/h3>
&lt;p>程序计数器的功能：&lt;/p>
&lt;ul>
&lt;li>记录当前线程执行的字节码指令的地址，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。&lt;/li>
&lt;li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。&lt;/li>
&lt;/ul>
&lt;p>程序计数器是线程私有的，是为了线程切换时能够正确恢复执行现场。&lt;/p>
&lt;p>虚拟机栈&lt;/p>
&lt;ul>
&lt;li>每个线程在创建时都会创建一个虚拟机栈，用于存放线程的方法调用栈、局部变量表、操作数栈等信息。（执行的是Java方法）&lt;/li>
&lt;/ul>
&lt;p>本地方法栈&lt;/p>
&lt;ul>
&lt;li>用于支持本地方法调用，即调用C/C++编写的本地方法。&lt;/li>
&lt;/ul>
&lt;p>为了保证&lt;strong>线程的局部变量不被其他线程访问&lt;/strong>，虚拟机栈和本地方法栈是线程私有的。&lt;/p>
&lt;h3 id="为什么堆和方法区是线程共享的呢">为什么堆和方法区是线程共享的呢？&lt;/h3>
&lt;p>堆：是进程中所有线程共享的内存区域，用于存放对象实例。&lt;/p>
&lt;p>方法区：是进程中所有线程共享的内存区域，用于存放类的元数据信息、常量池、静态变量等。&lt;/p>
&lt;p>堆和方法区是线程共享的，是为了&lt;strong>方便线程之间共享数据&lt;/strong>。&lt;/p>
&lt;h3 id="并发并行同步异步">并发并行、同步异步&lt;/h3>
&lt;p>并发：指多个线程交替执行，从宏观上看是同时执行的。&lt;/p>
&lt;p>并行：指多个线程同时执行，从微观上看是同时执行的。&lt;/p>
&lt;p>同步：指多个线程按照一定的顺序执行。&lt;/p>
&lt;p>异步：指多个线程按照不确定的顺序执行。&lt;/p>
&lt;h2 id="多线程概念">多线程概念&lt;/h2>
&lt;h3 id="为什么要使用多线程">为什么要使用多线程？&lt;/h3>
&lt;p>多线程的主要优点有以下几点：&lt;/p>
&lt;ul>
&lt;li>线程间的切换开销小&lt;/li>
&lt;li>多线程高并发是高并发量的基础&lt;/li>
&lt;li>现在的CPU都是多核的，多线程可以充分利用CPU的性能&lt;/li>
&lt;/ul>
&lt;h3 id="多线程带来的问题">多线程带来的问题？&lt;/h3>
&lt;p>多线程的主要问题有以下几点：&lt;/p>
&lt;ul>
&lt;li>线程安全问题&lt;/li>
&lt;li>死锁问题&lt;/li>
&lt;li>内存泄漏问题&lt;/li>
&lt;/ul>
&lt;p>线程安全：&lt;/p>
&lt;ul>
&lt;li>线程安全是指多个线程访问共享资源时不会出现数据不一致的问题。&lt;/li>
&lt;/ul>
&lt;p>死锁：&lt;/p>
&lt;ul>
&lt;li>死锁是指两个或多个线程互相等待对方释放资源，导致所有线程都无法继续执行的问题。&lt;/li>
&lt;li>四个条件： 互斥条件、请求与保持条件、不剥夺条件、循环等待条件&lt;/li>
&lt;/ul>
&lt;p>内存泄漏：&lt;/p>
&lt;ul>
&lt;li>内存泄漏是指程序中的对象无法被垃圾回收器回收，导致内存占用过多的问题。&lt;/li>
&lt;/ul>
&lt;h3 id="单核上的多线程效率">单核上的多线程效率&lt;/h3>
&lt;p>单核上的多线程效率，取决于线程的类型&lt;/p>
&lt;ul>
&lt;li>CPU密集型线程：多线程效率不高，因为多个线程会争夺CPU资源，导致线程切换开销大。&lt;/li>
&lt;li>IO密集型线程：多线程效率较高，因为线程在等待IO时会释放CPU资源，不会争夺CPU资源。&lt;/li>
&lt;/ul>
&lt;h3 id="多线程的实现方式">多线程的实现方式&lt;/h3>
&lt;p>Java中实现多线程主要有两种方式：&lt;/p>
&lt;ol>
&lt;li>继承Thread类并重写run()方法。&lt;/li>
&lt;li>实现Runnable接口并实现run()方法，然后将其作为参数传递给Thread类的构造方法。&lt;/li>
&lt;li>实现Callable接口并实现call()方法，然后将其作为参数传递给FutureTask类的构造方法, 最后还是通过Thread来调用&lt;/li>
&lt;/ol>
&lt;p>严格来说，这两种都是实现Runnable接口的方式，只不过一种是直接继承Thread类，另一种是将Runnable接口的实现类作为参数传递给Thread类的构造方法。&lt;/p>
&lt;h4 id="实现runnable接口">实现Runnable接口&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">public class MyRunnable implements Runnable {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> @Override
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public void run() {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> System.out.println(&amp;#34;MyRunnable.run()&amp;#34;);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">public class Main {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public static void main(String[] args) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Thread thread = new Thread(new MyRunnable());
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> thread.start();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="继承thread类">继承Thread类&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-gdscript3" data-lang="gdscript3">&lt;span class="line">&lt;span class="cl">&lt;span class="n">public&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="n">MyThread&lt;/span> &lt;span class="k">extends&lt;/span> &lt;span class="ne">Thread&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">@&lt;/span>&lt;span class="n">Override&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">public&lt;/span> &lt;span class="n">void&lt;/span> &lt;span class="n">run&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;MyThread.run()&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">public&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="n">Main&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">public&lt;/span> &lt;span class="k">static&lt;/span> &lt;span class="n">void&lt;/span> &lt;span class="n">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="ne">String&lt;/span>&lt;span class="p">[]&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">MyThread&lt;/span> &lt;span class="n">myThread&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">new&lt;/span> &lt;span class="n">MyThread&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">myThread&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">start&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="实现callable接口">实现Callable接口&lt;/h4>
&lt;p>可以有返回值&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">public class MyCallable implements Callable&amp;lt;String&amp;gt; {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> @Override
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public String call() throws Exception {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> return &amp;#34;return value&amp;#34;;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">public class Main {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public static void main(String[] args) throws ExecutionException, InterruptedException {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> FutureTask&amp;lt;String&amp;gt; futureTask = new FutureTask&amp;lt;&amp;gt;(new MyCallable());
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Thread thread = new Thread(futureTask);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> thread.start();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> System.out.println(futureTask.get()); //阻塞 return value
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="实现接口-vs-继承类">实现接口 vs 继承类&lt;/h4>
&lt;p>实现接口的方式更加灵活，因为Java是单继承的，如果继承了Thread类就不能再继承其他类了。&lt;/p>
&lt;p>类一般只要求可执行就行, 继承了Thread类, 会有一些额外的方法, 比如start, stop等, 但是一般不会用到.&lt;/p>
&lt;h2 id="线程的生命周期和状态">线程的生命周期和状态&lt;/h2>
&lt;p>线程的生命周期主要包括以下几个状态：&lt;/p>
&lt;ul>
&lt;li>新建状态（New）：线程对象被创建后的状态, 还没有调用start()方法。&lt;/li>
&lt;li>运行状态（Runable）：线程对象调用start()方法后的状态。&lt;/li>
&lt;li>阻塞状态（Blocking）：需要等待锁被释放&lt;/li>
&lt;li>无限期等待状态（Waiting）：等待其它线程显式地唤醒&lt;/li>
&lt;li>超时等待状态 (TIME_WAITING) ：等待一段时间后自动唤醒&lt;/li>
&lt;li>终止状态（Terminated）：表示该线程已经运行完毕。&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/JUC%28Java%E5%B9%B6%E5%8F%91%29/Java%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="上下文切换">上下文切换&lt;/h3>
&lt;p>上下文切换是指CPU从一个线程切换到另一个线程时，需要保存当前线程的上下文信息，然后加载另一个线程的上下文信息。&lt;/p>
&lt;p>发生上下文切换的原因主要有以下几点：&lt;/p>
&lt;ul>
&lt;li>时间片耗尽&lt;/li>
&lt;li>调用阻塞类型的中断，如请求IO、sleep、wait、join等&lt;/li>
&lt;li>被终止&lt;/li>
&lt;/ul>
&lt;p>上下文切换的开销主要包括以下几个方面：&lt;/p>
&lt;ul>
&lt;li>保存和恢复寄存器&lt;/li>
&lt;li>保存和恢复程序计数器&lt;/li>
&lt;li>保存和恢复内存映射表&lt;/li>
&lt;/ul>
&lt;h3 id="线程死锁">线程死锁&lt;/h3>
&lt;p>四个条件： 互斥条件、请求与保持条件、不剥夺条件、循环等待条件&lt;/p>
&lt;h4 id="预防和避免">预防和避免&lt;/h4>
&lt;p>预防死锁是破坏死锁的后三个条件。&lt;/p>
&lt;ul>
&lt;li>破坏请求与保持条件：一次性申请所有资源。&lt;/li>
&lt;li>破坏不剥夺条件：如果一个线程申请不到资源，就释放已经占有的资源。&lt;/li>
&lt;li>破坏循环等待条件：按序申请资源。&lt;/li>
&lt;/ul>
&lt;p>避免死锁是通过银行家算法来实现的。&lt;/p>
&lt;ul>
&lt;li>银行家算法是一种避免死锁的算法，它通过判断系统是否处于安全状态来避免死锁。&lt;/li>
&lt;li>银行家算法的核心思想是：当一个进程申请资源时，系统会先判断该进程申请资源后系统是否处于安全状态，如果是则分配资源，否则等待。&lt;/li>
&lt;/ul>
&lt;h2 id="jmm">JMM&lt;/h2>
&lt;p>JMM是Java内存模型的缩写，是一种抽象的概念，用于描述Java程序中的内存访问规则。&lt;/p>
&lt;p>定义了一个线程之间如何通过内存进行通信的规范，即线程之间如何访问共享内存。&lt;/p>
&lt;p>JMM是Java解决多线程并发问题的核心，它定义了一套规范，用于保证多线程环境下的内存可见性、原子性和有序性。&lt;/p>
&lt;h3 id="jmm概念cpu缓存模型和指令重排序">JMM概念(CPU缓存模型和指令重排序)&lt;/h3>
&lt;h4 id="cpu缓存">CPU缓存&lt;/h4>
&lt;p>CPU 缓存是为了解决 CPU 处理速度和内存处理速度不对等的问题。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/JUC%28Java%E5%B9%B6%E5%8F%91%29/CPU%E7%BC%93%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>CPU Cache 的工作方式： 先复制一份数据到 CPU Cache 中，当 CPU 需要用到的时候就可以&lt;strong>直接从 CPU Cache 中读取数据&lt;/strong>，当运算完成后，再将运算得到的数据写回 Main Memory 中。&lt;/p>
&lt;p>CPU内部缓存不一致的解决 是通过&lt;strong>缓存一致性协议&lt;/strong>来解决的。&lt;/p>
&lt;p>常见的CPU内部缓存一致性协议主要有以下几种:&lt;/p>
&lt;ol>
&lt;li>&lt;strong>MESI协议&lt;/strong>:
&lt;ul>
&lt;li>该协议定义了四种缓存行状态：Modified(已修改)、Exclusive(独占)、Shared(共享)和Invalid(无效)。&lt;/li>
&lt;li>当一个CPU读取或修改缓存行时,会通过总线事务与其他CPU进行协调,以维护缓存一致性。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>MOESI协议&lt;/strong>:
&lt;ul>
&lt;li>在MESI协议的基础上,增加了Owned(拥有)状态。&lt;/li>
&lt;li>Owned状态表示该缓存行被某个CPU独占修改,但其他CPU也可读取。&lt;/li>
&lt;li>相比MESI,MOESI协议能更好地处理写回操作,提高性能。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Synapse协议&lt;/strong>:
&lt;ul>
&lt;li>这是一种基于目录的缓存一致性协议。&lt;/li>
&lt;li>每个缓存块都有一个目录项,记录该缓存块的状态和拥有该缓存块的处理器。&lt;/li>
&lt;li>当某个处理器要访问缓存块时,先查询目录项,根据状态信息进行适当的操作。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Dragon协议&lt;/strong>:
&lt;ul>
&lt;li>这是一种基于所有权的缓存一致性协议。&lt;/li>
&lt;li>每个缓存块都有一个所有权状态,指示该缓存块是被独占修改、共享还是无效。&lt;/li>
&lt;li>通过控制缓存块的所有权状态,可以实现缓存一致性。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>多机下的缓存一致性协议：&lt;/p>
&lt;ul>
&lt;li>写更新协议（Write-through）: 当数据被修改时,立即更新缓存和后端存储。这能保证缓存中的数据始终是最新的,但会增加写操作的延迟。&lt;/li>
&lt;li>写回协议（Write-back）: 当数据被修改时,只更新缓存,并将修改异步地刷新到后端存储。这能减少写操作的延迟,但可能会导致缓存中的数据暂时与后端不一致。&lt;/li>
&lt;li>失效协议（Write-invalidate）: 当数据被修改时,向其他缓存发送失效消息,使其失效。读取数据时,需要从后端重新加载。这能最大限度地减少写操作对读操作的影响。&lt;/li>
&lt;li>读独占协议（Read-exclusive）: 当一个缓存读取数据时,向其他缓存发送独占请求。其他缓存必须放弃该数据的副本,直到该缓存完成操作。这能避免读写冲突,但会增加读操作的延迟。&lt;/li>
&lt;/ul>
&lt;p>但同时操作系统也需要解决缓存不一致的问题.(JMM)&lt;/p>
&lt;h4 id="指令重排序">指令重排序&lt;/h4>
&lt;p>指令重排序是指 CPU 和编译器为了提高程序运行效率而对指令序列进行重新排序的一种手段。&lt;/p>
&lt;p>指令重排序可以保证&lt;strong>串行语义一致&lt;/strong>，但是没有义务保证多线程间的语义也一致 ，所以在多线程下，指令重排序可能会导致一些问题。&lt;/p>
&lt;p>编译器优化重排：&lt;/p>
&lt;ul>
&lt;li>编译器（包括 JVM、JIT 编译器等）在不改变单线程程序语义的前提下，重新安排语句的执行顺序。&lt;/li>
&lt;li>指令并行重排：现代处理器采用了指令级并行技术(Instruction-Level Parallelism，ILP)来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。&lt;/li>
&lt;li>内存系统的重排序：处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/JUC%28Java%E5%B9%B6%E5%8F%91%29/Java%E6%BA%90%E4%BB%A3%E7%A0%81%E7%BB%8F%E5%8E%86%E7%9A%84%E9%87%8D%E6%8E%92%E5%BA%8F.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>指令重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致 ，所以在多线程下，指令重排序可能会导致一些问题。&lt;/p>
&lt;p>编译器和处理器的指令重排序的处理方式不一样。对于编译器，通过禁止特定类型的编译器重排序的方式来禁止重排序。&lt;/p>
&lt;p>对于处理器，通过插入内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence）的方式来禁止特定类型的&lt;strong>处理器重排序&lt;/strong>。 &lt;strong>指令并行重排和内存系统重排都属于是处理器级别的指令重排序。&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence）是一种 CPU 指令，用来禁止处理器指令发生重排序（像屏障一样），从而保障指令执行的有序性。另外，为了达到屏障的效果，它也会使处理器写入、读取值之前，将主内存的值写入高速缓存，清空无效队列，从而保障变量的可见性。&lt;/p>
&lt;/blockquote>
&lt;h4 id="jmm-1">JMM&lt;/h4>
&lt;p>JMM是定义了一套规范，用于保证多线程环境下的内存可见性、原子性和有序性。包括:&lt;/p>
&lt;ul>
&lt;li>抽象了线程和主内存之间的关系&lt;/li>
&lt;li>规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/JUC%28Java%E5%B9%B6%E5%8F%91%29/JMM%28Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%29.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>Java内存区域的区别 JVM 内存结构和 Java 虚拟机的运行时区域相关，定义了 JVM 在运行时如何分区存储程序数据，就比如说堆主要用于存放对象实例。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/JUC%28Java%E5%B9%B6%E5%8F%91%29/JMM%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="并发问题的原因">并发问题的原因&lt;/h3>
&lt;p>CPU、内存、I/O 设备的速度是有极大差异的，为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系结构、操作系统、编译程序都做出了贡献，同时导致了并发问题。&lt;/p>
&lt;ul>
&lt;li>CPU 增加了缓存，以均衡与内存的速度差异.
&lt;ul>
&lt;li>导致可见性问题&lt;/li>
&lt;li>可见性是指当多个线程访问共享变量时，一个线程修改了共享变量的值，其他线程&lt;strong>能够看到修改后的值。&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异
&lt;ul>
&lt;li>导致原子性问题&lt;/li>
&lt;li>原子性: 是指一个操作是不可中断的，要么全部执行成功，要么全部不执行。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。
&lt;ul>
&lt;li>导致有序性问题&lt;/li>
&lt;li>有序性：代码的执行顺序按照代码的先后顺序执行。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="可见性问题">可见性问题&lt;/h4>
&lt;p>可见性问题,就是看不到修改后的值, 由CPU缓存导致. 多个线程访问共享变量时，由于缓存和指令重排等因素，导致某个线程修改了变量的值，而其他线程并没有立即看到修改后的值，从而出现数据不一致的问题。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">//线程1执行
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">int a = 0;//1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">a = 10;//2
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">//线程2执行
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">int j = a//3
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>假设,有两个CPU, CPU1执行线程1, CPU2执行线程2. 线程1执行语句2时, 会先把a=0这个初始值从主内存中加载到CPU1的高速缓存中, 然后在CPU1的高速缓存中赋值a=10, 并没有立即写入到主存.&lt;/p>
&lt;p>线程2 如果在 线程1写入主存之前,执行了语句3, 那么就会读取到a=0这个初始值, 而不是修改后的值10.&lt;/p>
&lt;h4 id="原子性问题">原子性问题&lt;/h4>
&lt;p>原子性问题由分时复用CPU导致.&lt;/p>
&lt;p>Java中只有对基本数据类型的&lt;strong>读取和赋值&lt;/strong>操作是原子性的，其他的操作都不是原子性的。 下面语句1是原子性的, 其他都不是原子性的.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">x = 10; //语句1: 直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">y = x; //语句2: 包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">x++; //语句3： x++包括3个操作：读取x的值，进行加1操作，写入新的值。
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">x = x + 1; //语句4： 同语句3
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>因此在执行一些常见,但不是原子性的操作时,会导致原子性问题.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">int i = 1;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">// 线程1执行
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">i += 1;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">// 线程2执行
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">i += 1;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>i += 1需要三条 CPU 指令&lt;/p>
&lt;ol>
&lt;li>将变量 i 从内存读取到 CPU寄存器；&lt;/li>
&lt;li>在CPU寄存器中执行 i + 1 操作；&lt;/li>
&lt;li>将最后的结果i写入内存（缓存机制导致可能写入的是 CPU 缓存而不是内存）。&lt;/li>
&lt;/ol>
&lt;p>如果线程1执行完1后, 轮到线程2执行三条指令, 线程1再执行2,3. 会导致i最后的值是2而不是3.&lt;/p>
&lt;h4 id="有序性问题">有序性问题&lt;/h4>
&lt;p>在执行程序时，为了提高性能，编译器和处理器会对指令进行重排序。 重排序不会影响单线程程序的执行结果，但是会影响多线程程序的执行结果。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">int i = 0;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">boolean flag = false;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">i = 1; //语句1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">flag = true; //语句2
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>比如语句1和语句2顺序可能会被重排.&lt;/p>
&lt;h3 id="解决并发问题">解决并发问题&lt;/h3>
&lt;p>第一个角度: Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法。&lt;/p>
&lt;ul>
&lt;li>volatile关键字&lt;/li>
&lt;li>synchronized关键字&lt;/li>
&lt;li>final关键字&lt;/li>
&lt;li>Happens-Before规则&lt;/li>
&lt;/ul>
&lt;p>第二个角度,通过可见性原子性有序性三个方面来解决并发问题.&lt;/p>
&lt;ul>
&lt;li>原子性问题：通过synchronized关键字和原子类来解决。
&lt;ul>
&lt;li>synchronized关键字可以&lt;strong>保证代码块的原子性&lt;/strong>。&lt;/li>
&lt;li>原子类可以保证对变量的操作是原子性的。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>可见性问题：通过volatile关键字来解决。
&lt;ul>
&lt;li>当一个变量被volatile修饰时，表示它是一个共享变量，能保证修改的值立即更新到主存中.&lt;/li>
&lt;li>synchronized和lock可以通过同步的方式来解决可见性问题。(即同一时刻只有一个线程获取锁,在释放锁之前会将修改的值刷新到主存中)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>有序性问题
&lt;ul>
&lt;li>通过volatile关键字来保证&lt;strong>一定的有序性&lt;/strong>。&lt;/li>
&lt;li>通过synchronized关键字来保证&lt;strong>有序性&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="volatile关键字">volatile关键字&lt;/h3>
&lt;h4 id="作用">作用&lt;/h4>
&lt;p>作用:&lt;/p>
&lt;ul>
&lt;li>保证可见性&lt;/li>
&lt;li>禁止指令重排&lt;/li>
&lt;/ul>
&lt;p>保证可见性 一个变量使用 volatile 修饰，这就指示 编译器，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。&lt;/p>
&lt;p>禁止指令重排 将变量声明为 volatile ，在对这个变量进行读写操作的时候，会通过&lt;strong>插入特定的内存屏障&lt;/strong> 的方式来禁止指令重排序。&lt;/p>
&lt;h4 id="volatile-实现原理">volatile 实现原理&lt;/h4>
&lt;p>在Java 中，当线程读取一个volatile 变量时，会从主内存中读取变量的最新值，并把它存储到线程的工作内存中。&lt;/p>
&lt;p>volatile主要通过汇编lock前缀指令，它会锁定当前内存区域的缓存（缓存行），并且立即将当前缓存行数据写入主内存（耗时非常短）&lt;/p>
&lt;p>当线程写入 volatile 变量时,会在写操作后加入一个 &amp;ldquo;写屏障&amp;rdquo; 指令,保证写操作立即刷新到主内存。&lt;/p>
&lt;ul>
&lt;li>写屏障指令会将当前 CPU 缓存行的数据立即刷新到主内存中 当线程读取 volatile 变量时,会在读操作前加入一个 &amp;ldquo;读屏障&amp;rdquo; 指令,保证读取的是主内存中的最新值。&lt;/li>
&lt;/ul>
&lt;p>内存屏障指令可以禁止 CPU 和编译器对相关指令进行重排序优化。&lt;/p>
&lt;h4 id="为什么volatile不能保证原子性">为什么volatile不能保证原子性&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">public class VolatileExample {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> private static volatile int count = 0;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public static void main(String[] args) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ExecutorService executorService = Executors.newCachedThreadPool();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> for (int i = 0; i &amp;lt; 1000; i++) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> executorService.execute(() -&amp;gt; count++);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> executorService.shutdown();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> System.out.println(count);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">Exception in thread &amp;#34;main&amp;#34; java.util.concurrent.RejectedExecutionException: Task java.util.concurrent.FutureTask@5e2de80c rejected from java.util.concurrent.ThreadPoolExecutor@3b9a45b3[Terminated, pool size = 0, active threads = 0, queued tasks = 0, completed tasks = 1000]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2063)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:830)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1379)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> at VolatileExample.main(VolatileExample.java:13)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>volatile不能保证原子性, &lt;strong>因为count++不是原子性的操作&lt;/strong>, 它包括三个步骤: 读取count的值, 将count的值加1, 写入count的值.&lt;/p>
&lt;h4 id="应用场景">应用场景&lt;/h4>
&lt;p>单例模式中的双重检查锁&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">public class Singleton {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> private static volatile Singleton instance;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> private Singleton() {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public static Singleton getInstance() {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> if (instance == null) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> synchronized (Singleton.class) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> if (instance == null) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> instance = new Singleton();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> return instance;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>为什么要volatile修饰instance? A: 保证instance是可见的, 避免指令重排.&lt;/p>
&lt;h3 id="synchronized关键字">synchronized关键字&lt;/h3>
&lt;p>见 &lt;a href="####synchronized">synchronized关键字&lt;/a>&lt;/p>
&lt;h3 id="final关键字">final关键字&lt;/h3>
&lt;h4 id="final的基础用法">final的基础用法&lt;/h4>
&lt;p>Q: 可以父类的final方法能不能够被子类重写?&lt;/p>
&lt;p>修饰类&lt;/p>
&lt;ul>
&lt;li>final类不能有子类&lt;/li>
&lt;li>final类的所有方法都隐式的是final的&lt;/li>
&lt;/ul>
&lt;p>Q: 如何理解private所修饰的方法是隐式的final? 说说final类型的类如何拓展? 比如String是final类型，我们想写个MyString复用所有String中方法，同时增加一个新的toMyString()的方法，应该如何做? 组合代替继承 final方法可以被重载吗?&lt;/p>
&lt;p>修饰方法&lt;/p>
&lt;ul>
&lt;li>&lt;strong>private方法&lt;/strong>隐式的是final的&lt;/li>
&lt;li>final方法不能被重写&lt;/li>
&lt;li>final方法可以被重载&lt;/li>
&lt;/ul>
&lt;p>修饰参数&lt;/p>
&lt;ul>
&lt;li>final参数不能被修改&lt;/li>
&lt;li>用于向匿名内部类传递参数&lt;/li>
&lt;/ul>
&lt;p>Q: 所有的final修饰的字段都是编译期常量吗?&lt;/p>
&lt;p>修饰变量&lt;/p>
&lt;ul>
&lt;li>final修饰的字段&lt;strong>不都是编译期常量&lt;/strong>&lt;/li>
&lt;li>但是final修饰的字段&lt;strong>只能被赋值一次&lt;/strong>&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">public class Test {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> //编译期常量
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> final int i = 1;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> final static int J = 1;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> final int[] a = {1,2,3,4};
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> //非编译期常量
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Random r = new Random();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> final int k = r.nextInt();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public static void main(String[] args) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果是 static final 修饰的字段, 就必须是在声明的时候就赋值, 不能在构造方法中赋值, 一定是编译期常量.&lt;/p>
&lt;p>blank final&lt;/p>
&lt;ul>
&lt;li>final修饰的字段, 在声明的时候不赋值, &lt;strong>在构造方法中赋值&lt;/strong>, 但是只能赋值一次.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">public class Test {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> final int i;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public Test() {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> i = 1;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以说说final域重排序规则?&lt;/p>
&lt;h4 id="todo-final域重排序">TODO: final域重排序&lt;/h4>
&lt;h5 id="final域为基本类型">final域为基本类型&lt;/h5>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">public class FinalDemo {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> private int a; //普通域
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> private final int b; //final域
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> private static FinalDemo finalDemo;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public FinalDemo() {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> a = 1; // 1. 写普通域
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> b = 2; // 2. 写final域
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public static void writer() {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> finalDemo = new FinalDemo();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public static void reader() {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> FinalDemo demo = finalDemo; // 3.读对象引用
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> int a = demo.a; //4.读普通域
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> int b = demo.b; //5.读final域
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>写final域重排序规则&lt;/p>
&lt;p>写final域的重排序规则&lt;strong>禁止对final域的写&lt;/strong>重排序到构造函数之外，这个规则的实现主要包含了两个方面：&lt;/p>
&lt;ul>
&lt;li>JMM禁止编译器把final域的写重排序到构造函数之外；&lt;/li>
&lt;li>编译器会在final域写之后，构造函数return之前，插入一个storestore屏障。这个屏障可以禁止处理器把final域的写重排序到构造函数之外。&lt;/li>
&lt;/ul>
&lt;p>我们再来分析writer方法，虽然只有一行代码，但实际上做了两件事情：&lt;/p>
&lt;ul>
&lt;li>构造了一个FinalDemo对象；&lt;/li>
&lt;li>把这个对象赋值给成员变量finalDemo。&lt;/li>
&lt;/ul>
&lt;p>我们来画下存在的一种可能执行时序图，如下：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/JUC%28Java%E5%B9%B6%E5%8F%91%29/%E5%86%99final%E5%9F%9F%E9%87%8D%E6%8E%92%E5%BA%8F.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>由于a,b之间没有数据依赖性，普通域(普通变量)a可能会被重排序到构造函数之外，线程B就有可能读到的是普通变量a初始化之前的值(零值)，这样就可能出现错误。&lt;/p>
&lt;p>而final域变量b，根据重排序规则，会禁止final修饰的变量b重排序到构造函数之外，从而b能够正确赋值，线程B就能够读到final变量初始化后的值。&lt;/p>
&lt;p>因此，写final域的重排序规则可以确保：在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了，而普通域就不具有这个保障。比如在上例，线程B有可能就是一个未正确初始化的对象finalDemo。&lt;/p>
&lt;p>读final域重排序规则&lt;/p>
&lt;p>在一个线程中，初次读对象引用和初次读该对象包含的final域，JMM会禁止这两个操作的重排序。(注意，这个规则仅仅是针对处理器)，处理器会在读final域操作的前面插入一个LoadLoad屏障。&lt;/p>
&lt;p>实际上，读对象的引用和读该对象的final域存在间接依赖性，一般处理器不会重排序这两个操作。但是有一些处理器会重排序，因此，这条禁止重排序规则就是针对这些处理器而设定的。&lt;/p>
&lt;p>read()方法主要包含了三个操作：&lt;/p>
&lt;ul>
&lt;li>初次读引用变量finalDemo;&lt;/li>
&lt;li>初次读引用变量finalDemo的普通域a;&lt;/li>
&lt;li>初次读引用变量finalDemo的final域b;&lt;/li>
&lt;/ul>
&lt;p>假设线程A写过程没有重排序，那么线程A和线程B有一种的可能执行时序为下图&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/JUC%28Java%E5%B9%B6%E5%8F%91%29/%E8%AF%BB%E9%87%8D%E6%8E%92%E5%BA%8F.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>读final域的重排序规则可以确保：在读一个对象的final域之前，一定会先读这个包含这个final域的对象的引用。&lt;/p>
&lt;h5 id="todo为引用类型">TODO：为引用类型&lt;/h5>
&lt;p>按照final修饰的数据类型分类： 基本数据类型:&lt;/p>
&lt;ul>
&lt;li>final域写：禁止final域写与构造方法重排序，即禁止final域写重排序到构造方法之外，从而保证该对象对所有线程可见时，该对象的final域全部已经初始化过。&lt;/li>
&lt;li>final域读：禁止初次读对象的引用与读该对象包含的final域的重排序。&lt;/li>
&lt;/ul>
&lt;p>引用数据类型：&lt;/p>
&lt;ul>
&lt;li>额外增加约束：禁止在构造函数对一个final修饰的对象的成员域的写入与随后将这个被构造的对象的引用赋值给引用变量 重排序&lt;/li>
&lt;/ul>
&lt;h4 id="说说final的原理">说说final的原理?&lt;/h4>
&lt;p>写final域会要求编译器在final域写之后，构造函数返回前插入一个StoreStore屏障。读final域的重排序规则会要求编译器在读final域的操作前插入一个LoadLoad屏障。&lt;/p>
&lt;h4 id="使用-final-的限制条件和局限性">使用 final 的限制条件和局限性?&lt;/h4>
&lt;h3 id="happens-before规则">Happens-Before规则&lt;/h3>
&lt;p>Happens-Before规则是Java内存模型中的一组规则，用于描述多线程环境下的内存可见性、原子性和有序性。&lt;/p>
&lt;p>Happens-Before规则主要包括以下几个规则：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>单一线程&lt;/strong>原则: 一个线程内部, 代码的执行顺序是按照代码的先后顺序执行的.&lt;/li>
&lt;li>&lt;strong>管程锁定&lt;/strong>规则: 对同一个锁unlock操作必须先于在lock操作.&lt;/li>
&lt;li>&lt;strong>volatile变量&lt;/strong>规则: 对一个volatile变量的写操作必须先于对该变量的读操作&lt;/li>
&lt;li>&lt;strong>线程启动&lt;/strong>规则: start()方法调用先于线程的每一个动作.&lt;/li>
&lt;li>&lt;strong>线程加入(join)&lt;/strong> 规则: Thread对象的&lt;strong>终止操作先于join()方法返回&lt;/strong>.&lt;/li>
&lt;li>&lt;strong>线程中断&lt;/strong>规则: 对线程interrupt()方法的调用先于被中断线程的代码检测到中断事件的发生. 即, 可以&lt;strong>用interrupt()方法来检测线程是否被中断&lt;/strong>.&lt;/li>
&lt;li>&lt;strong>对象终结&lt;/strong>规则: 对象的&lt;strong>构造函数执行结束&lt;/strong>先于finalize()方法的开始.&lt;/li>
&lt;li>&lt;strong>传递性&lt;/strong>: A先于B, B先于C, 那么A先于C.&lt;/li>
&lt;/ul>
&lt;h2 id="理解线程安全">理解线程安全&lt;/h2>
&lt;p>一个类在可以被多个线程安全调用时就是线程安全的。&lt;/p>
&lt;p>线程安全不是一个非真即假的命题，可以将共享数据按照安全程度的强弱顺序分成以下五类: 不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。&lt;/p>
&lt;h3 id="不可变">不可变&lt;/h3>
&lt;p>不可变(Immutable)的对象一定是线程安全的，不需要再采取任何的线程安全保障措施。 只要一个不可变的对象被正确地构建出来，永远也不会看到它在多个线程之中处于不一致的状态。&lt;/p>
&lt;p>多线程环境下，应当尽量使对象成为不可变，来满足线程安全。&lt;/p>
&lt;p>不可变的类型:&lt;/p>
&lt;ul>
&lt;li>final 关键字修饰的基本数据类型&lt;/li>
&lt;li>String&lt;/li>
&lt;li>枚举类型&lt;/li>
&lt;li>Number 部分子类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。
&lt;ul>
&lt;li>但同为 Number 的原子类 AtomicInteger 和 AtomicLong 则是可变的&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>对于集合类型，可以使用 Collections.unmodifiableXXX() 方法来获取一个不可变的集合。&lt;/p>
&lt;p>Collections.unmodifiableXXX() 先对原始的集合进行拷贝，需要对集合进行修改的方法都直接抛出异常。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">public class ImmutableExample {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public static void main(String[] args) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Map&amp;lt;String, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Map&amp;lt;String, Integer&amp;gt; unmodifiableMap = Collections.unmodifiableMap(map);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> unmodifiableMap.put(&amp;#34;a&amp;#34;, 1);//抛出异常
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">Exception in thread &amp;#34;main&amp;#34; java.lang.UnsupportedOperationException
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> at java.util.Collections$UnmodifiableMap.put(Collections.java:1457)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> at ImmutableExample.main(ImmutableExample.java:9)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>因为put被直接抛出异常, 所以unmodifiableMap是不可变的.&lt;/p>
&lt;h3 id="绝对线程安全">绝对线程安全&lt;/h3>
&lt;p>不管运行时环境如何，调用者都不需要任何额外的同步措施。&lt;/p>
&lt;h3 id="相对线程安全">相对线程安全&lt;/h3>
&lt;p>保证对这个对象单独的操作是线程安全的，在调用的时候不需要做额外的保障措施.&lt;/p>
&lt;p>但是对于特定复合操作，调用者需要额外的同步措施。&lt;/p>
&lt;p>Java的大部分&lt;strong>线程安全类&lt;/strong>, 都是这样.&lt;/p>
&lt;p>但如在Vector中, 两个线程都在遍历Vector, 一个线程删除了一个元素, 另一个线程可能会访问到一个不存在的元素.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">public class VectorUnsafeExample {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> private static Vector&amp;lt;Integer&amp;gt; vector = new Vector&amp;lt;&amp;gt;();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public static void main(String[] args) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> while (true) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> for (int i = 0; i &amp;lt; 100; i++) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> vector.add(i);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ExecutorService executorService = Executors.newCachedThreadPool();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> executorService.execute(() -&amp;gt; {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> for (int i = 0; i &amp;lt; vector.size(); i++) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> vector.remove(i);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> });
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> executorService.execute(() -&amp;gt; {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> for (int i = 0; i &amp;lt; vector.size(); i++) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> vector.get(i);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> });
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> executorService.shutdown();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>需要对删除和获取元素操作进行同步.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">executorService.execute(() -&amp;gt; {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> synchronized (vector) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> for (int i = 0; i &amp;lt; vector.size(); i++) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> vector.remove(i);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">});
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">executorService.execute(() -&amp;gt; {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> synchronized (vector) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> for (int i = 0; i &amp;lt; vector.size(); i++) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> vector.get(i);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">});
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="线程兼容">线程兼容&lt;/h3>
&lt;p>线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端使用加锁的方式来保证线程安全。&lt;/p>
&lt;p>如ArrayList, HashMap等.&lt;/p>
&lt;h3 id="线程对立">线程对立&lt;/h3>
&lt;p>线程对立是指对象本身并不是线程安全的，而且在调用端使用加锁的方式也无法保证线程安全。&lt;/p>
&lt;h2 id="线程安全的实现方式">线程安全的实现方式&lt;/h2>
&lt;h3 id="互斥同步-synchronized-和-reentrantlock">互斥同步 synchronized 和 ReentrantLock&lt;/h3>
&lt;p>互斥同步是指在同一时刻只允许一个线程访问共享资源。&lt;/p>
&lt;p>Java中提供了两种互斥同步的方式：synchronized和ReentrantLock。&lt;/p>
&lt;h4 id="synchronized">synchronized&lt;/h4>
&lt;p>synchronized是Java中的关键字，可以用来修饰方法或代码块。&lt;/p>
&lt;p>synchronized修饰方法时，表示整个方法是同步的，即同一时刻只允许一个线程访问该方法。&lt;/p>
&lt;p>synchronized修饰代码块时，需要&lt;strong>指定一个对象&lt;/strong>作为参数，表示对该对象进行同步，即同一时刻只允许一个线程访问该对象。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">public class SynchronizedExample {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public synchronized void method() {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // 代码
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">public class SynchronizedExample {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public void method() {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> synchronized (this) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // 代码
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>还可以同步一个类, 两个线程调用同一个类的&lt;strong>不同对象上的这种同步语句，也会进行同步&lt;/strong>。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">public class SynchronizedExample {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public void method() {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> synchronized (SynchronizedExample.class) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // 代码
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">public static void main(String[] args) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> SynchronizedExample e1 = new SynchronizedExample();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> SynchronizedExample e2 = new SynchronizedExample();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ExecutorService executorService = Executors.newCachedThreadPool();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> executorService.execute(() -&amp;gt; e1.func2());
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> executorService.execute(() -&amp;gt; e2.func2());
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>同步静态方法, 也是同步类的.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">public class SynchronizedExample {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public static synchronized void method() {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // 代码
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>同步语句块的实现使用的是 monitorenter 和 monitorexit 指令&lt;/p>
&lt;p>其中 &lt;strong>monitorenter 指令指向同步代码块的开始位置， monitorexit 指令则指明同步代码块的结束位置。&lt;/strong>&lt;/p>
&lt;p>在执行monitorenter时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。&lt;/p>
&lt;p>在执行 monitorexit 指令后，将锁计数器设为 0，表明锁被释放。&lt;/p>
&lt;p>如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。&lt;/p>
&lt;h4 id="reentrantlock">ReentrantLock&lt;/h4>
&lt;p>ReentrantLock是JUC包中的类，是一种可重入的互斥锁。&lt;/p>
&lt;p>ReentrantLock可以替代synchronized进行同步，ReentrantLock可以提供更多的同步操作，如中断、超时、多个条件等。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">public class ReentrantLockExample {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> private ReentrantLock lock = new ReentrantLock();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public void method() {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> lock.lock();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> try {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // 代码
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> } finally {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> lock.unlock();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">public static void main(String[] args) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ReentrantLockExample example = new ReentrantLockExample();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ExecutorService executorService = Executors.newCachedThreadPool();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> executorService.execute(() -&amp;gt; example.method());
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> executorService.execute(() -&amp;gt; example.method());
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="synchronized-和-reentrantlock-的区别">synchronized 和 ReentrantLock 的区别&lt;/h4>
&lt;ul>
&lt;li>锁的实现: synchronized是Java的关键字, 是JVM层面的锁, 是隐式的, &lt;strong>不需要用户去手动释放锁&lt;/strong>; ReentrantLock是JUC包中的类, 是API层面的锁, 是显式的, 需要用户去手动释放锁.&lt;/li>
&lt;li>性能: synchronized的性能在JDK6之后得到了很大的提升, 但是在并发量很高的情况下, ReentrantLock的性能要优于synchronized.(优化后大致相同)&lt;/li>
&lt;li>等待可中断: 使用synchronized时, 如果获取不到锁, 线程会一直等待, 不能够中断; 使用ReentrantLock时, 可以设置超时时间, 可以中断.&lt;/li>
&lt;li>公平锁: ReentrantLock&lt;strong>可以设置为公平锁&lt;/strong>, synchronized是&lt;strong>非公平锁&lt;/strong>.
&lt;ul>
&lt;li>公平锁: 多个线程按照申请锁的顺序来获取锁.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>锁绑定多个条件: ReentrantLock可以同时绑定多个Condition对象.&lt;/li>
&lt;/ul>
&lt;p>如何选择: 除非要使用ReentrantLock的高级功能, 否则优先使用synchronized.&lt;/p>
&lt;ul>
&lt;li>这是因为synchronized是JVM层面的锁, 在JDK6之后进行了很多优化, 所以性能和ReentrantLock差不多, 且更加简洁.&lt;/li>
&lt;li>并且不用担心忘记释放锁, 也不用担心死锁问题.&lt;/li>
&lt;/ul>
&lt;h3 id="非阻塞同步">非阻塞同步&lt;/h3>
&lt;p>互斥同步的主要问题是阻塞，当一个线程获取锁后，其他线程只能等待。&lt;/p>
&lt;p>互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁(实际上虚拟机会优化掉一些不必要的加锁操作)。&lt;/p>
&lt;h4 id="cas-compare-and-swap">CAS (Compare And Swap)&lt;/h4>
&lt;p>CAS是一种乐观的并发策略，它总是认为不会出现竞争，只有在真的出现竞争的时候，才通过自旋重试来解决竞争问题。&lt;/p>
&lt;p>CAS是基于冲突检测的乐观并发策略. 先进行操作, 如果检测到没有冲突, 则操作成功, 否则不断重试.&lt;/p>
&lt;p>CAS的条件是 操作和检查是原子性的. 互斥同步是无法保证的, 只能依靠硬件完成.&lt;/p>
&lt;p>CAS指令有三个操作数，分别是内存位置V、旧的预期值A和新值B。CAS指令执行时，当且仅当V的值等于A时，将V的值更新为B，否则不做任何操作。&lt;/p>
&lt;p>CAS的实现是C++中的一个原子操作, 但是Java中的CAS是通过JNI来调用C++的CAS指令实现的.&lt;/p>
&lt;p>获取当前共享变量的值和期望值：&lt;/p>
&lt;ul>
&lt;li>CAS操作的第一步是获取共享变量的当前值，同时也需要提供一个期望值，这个期望值是用来比较共享变量的当前值是否与之相等的基准。&lt;/li>
&lt;li>先获取共享变量得到旧的预期值A&lt;/li>
&lt;li>执行业务，得到新值B&lt;/li>
&lt;/ul>
&lt;p>比较共享变量的当前值和期望值是否相等：&lt;/p>
&lt;ul>
&lt;li>在这一步，CAS会比较共享变量的当前值和之前提供的期望值是否相等。如果相等，说明共享变量的值符合预期，可以进行下一步操作。&lt;/li>
&lt;/ul>
&lt;p>更新共享变量的值：&lt;/p>
&lt;ul>
&lt;li>如果共享变量的当前值与期望值相等，CAS会将共享变量的值更新为要写入的新值。这个操作是原子性的，即在这个过程中不会有其他线程对该共享变量进行干扰。&lt;/li>
&lt;/ul>
&lt;p>处理失败的情况：&lt;/p>
&lt;ul>
&lt;li>如果共享变量的当前值与期望值不相等，说明此时有其他线程已经修改了共享变量的值。在这种情况下，当前线程需要重新获取共享变量的最新值，并重新执行步骤2和3，直至操作成功。&lt;/li>
&lt;/ul>
&lt;p>CAS的应用: AtomicInteger&lt;/p>
&lt;p>JUC包中的原子类, 其中的compareAndSet方法和getAndIncrement方法都是基于CAS实现的。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-gdscript3" data-lang="gdscript3">&lt;span class="line">&lt;span class="cl">&lt;span class="o">//&lt;/span>&lt;span class="n">incrementAndGet方法&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">public&lt;/span> &lt;span class="n">final&lt;/span> &lt;span class="ne">int&lt;/span> &lt;span class="n">incrementAndGet&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">unsafe&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">getAndAddInt&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">this&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">valueOffset&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">//&lt;/span>&lt;span class="n">getAndAddInt方法&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">public&lt;/span> &lt;span class="n">final&lt;/span> &lt;span class="ne">int&lt;/span> &lt;span class="n">getAndAddInt&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="ne">Object&lt;/span> &lt;span class="n">var1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">long&lt;/span> &lt;span class="n">var2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="ne">int&lt;/span> &lt;span class="n">var4&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="ne">int&lt;/span> &lt;span class="n">var5&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">do&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">var5&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">getIntVolatile&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">var1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">var2&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="k">while&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">compareAndSwapInt&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">var1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">var2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">var5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">var5&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">var4&lt;/span>&lt;span class="p">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">var5&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="aba-cas的问题">ABA (CAS的问题)&lt;/h4>
&lt;p>CAS存在一个问题，即ABA问题。&lt;/p>
&lt;p>ABA问题是指一个值原来是A，后来被改成了B，然后又被改回为A，那么CAS检查时会认为它没有被改过，但实际上已经发生了变化。&lt;/p>
&lt;p>大部分情况下ABA问题并不会影响并发的正确性.&lt;/p>
&lt;p>如果需要解决ABA问题, 用传统的互斥同步会更好.&lt;/p>
&lt;p>JUC包中提供了一个带有标记的原子引用类AtomicStampedReference来解决ABA问题。&lt;/p>
&lt;p>它可以通过控制变量的版本来保证CAS的正确性。&lt;/p>
&lt;h3 id="无同步方案">无同步方案&lt;/h3>
&lt;p>无同步方案是指在多线程环境下，不做任何的同步措施，也不会出现线程安全问题。&lt;/p>
&lt;p>核心是: &lt;strong>不共享数据&lt;/strong>.&lt;/p>
&lt;p>通过将共享数据的访问限制在单线程内部，就可以保证线程安全。&lt;/p>
&lt;p>实现方法有: 栈封闭、线程本地存储(Thread Local Storage, TLS)&lt;/p>
&lt;h4 id="栈封闭">栈封闭&lt;/h4>
&lt;p>多个线程访问同一个方法中的局部变量不会出现线程安全问题。&lt;/p>
&lt;p>局部变量存在虚拟机栈中，属于线程私有的.&lt;/p>
&lt;h4 id="线程本地存储thread-local-storage">线程本地存储(Thread Local Storage)&lt;/h4>
&lt;p>当数据必须被多个线程共享时，看看能否将共享数据的代码封装到一个线程内部，这样就可以保证线程安全。&lt;/p>
&lt;p>例子:&lt;/p>
&lt;ul>
&lt;li>生产者消费者模式中, 每个线程都有自己的队列, 不会出现线程安全问题.&lt;/li>
&lt;li>Web服务器中, 每个请求都会创建一个线程, 也不会出现线程安全问题.&lt;/li>
&lt;/ul>
&lt;p>Java通过ThreadLocal类提供了线程本地存储的支持。&lt;/p>
&lt;p>ThreadLocal类可以让每个线程都有自己的共享变量，从而避免了线程安全问题。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">public class ThreadLocalExample1 {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public static void main(String[] args) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ThreadLocal threadLocal = new ThreadLocal();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Thread thread1 = new Thread(() -&amp;gt; {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> threadLocal1.set(1);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> threadLocal2.set(1);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> });
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Thread thread2 = new Thread(() -&amp;gt; {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> threadLocal1.set(2);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> threadLocal2.set(2);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> });
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> thread1.start();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> thread2.start();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/JUC%28Java%E5%B9%B6%E5%8F%91%29/ThreadLocalExample1%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>每个Thread都有一个ThreadLocalMap对象, 用于存储线程本地变量.&lt;/p>
&lt;p>Thread类中定义了ThreadLocal.ThreadLocalMap 成员。 &lt;code>ThreadLocal.ThreadLocalMap threadLocals = null;&lt;/code>&lt;/p>
&lt;p>当调用get set时,&lt;strong>先获取当前线程的ThreadLocalMap&lt;/strong>, 然后将ThreadLocal对象作为key, value作为value存入.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">public void set(T value) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Thread t = Thread.currentThread();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ThreadLocalMap map = getMap(t);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> if (map != null)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> map.set(this, value);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> else
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> createMap(t, value);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="threadlocal的问题----内存泄漏">ThreadLocal的问题 &amp;ndash; 内存泄漏&lt;/h5>
&lt;p>ThreadLocalMap中的&lt;strong>Entry的key是弱引用&lt;/strong>, value是强引用, 如果key被回收了, value不会被回收, 会导致内存泄漏.&lt;/p>
&lt;p>只要线程还在, ThreadLocalMap中的Entry就不会被回收.&lt;/p>
&lt;p>ThreadLocal 对象可能会被提前回收,导致使用时出现 NullPointerException。因此,开发人员在使用 ThreadLocal 时,需要注意适当的生命周期管理,比如在线程结束时主动调用 remove() 方法清理副本信息。&lt;/p>
&lt;p>解决方法: 在使用完ThreadLocal后, 调用remove方法.&lt;/p>
&lt;h4 id="可重入代码reentrant-code">可重入代码(Reentrant Code)&lt;/h4>
&lt;p>也叫纯代码, 在代码执行的任何时刻, 都可以被中断, 转而执行另一段代码, 然后再回到原来的代码.&lt;/p>
&lt;p>特征: 不依赖于任何共享的变量, 用到的状态变量都有方法的参数传递进来, 不会调用非可重入的方法.&lt;/p>
&lt;p>可重入代码(Reentrant Code)是指一个函数/方法可以被同一线程多次调用而不会产生任何问题的代码。换句话说,在执行该函数/方法的过程中,如果遇到对自身的再次调用,函数能够正确处理这种情况,不会陷入死锁或其他异常状态。&lt;/p>
&lt;p>举几个例子来说明可重入代码:&lt;/p>
&lt;ol>
&lt;li>&lt;strong>synchronized 关键字&lt;/strong>:&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">public class ReentrantExample {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public synchronized void foo() {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // 执行一些操作
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> foo(); // 可以再次调用自身
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在上述代码中,&lt;code>foo()&lt;/code> 方法使用了 &lt;code>synchronized&lt;/code> 关键字来确保线程安全。当一个线程进入 &lt;code>foo()&lt;/code> 方法时,它会获取该对象的锁。即使 &lt;code>foo()&lt;/code> 方法再次调用自身,由于线程已经持有了该对象的锁,所以不会发生死锁。这就是可重入的体现。&lt;/p>
&lt;ol start="2">
&lt;li>&lt;strong>ReentrantLock 类&lt;/strong>:&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">public class ReentrantExample {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> private final ReentrantLock lock = new ReentrantLock();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public void foo() {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> lock.lock();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> try {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // 执行一些操作
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> foo(); // 可以再次调用自身
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> } finally {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> lock.unlock();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在这个例子中,我们使用 &lt;code>ReentrantLock&lt;/code> 来实现可重入的锁定机制。当一个线程进入 &lt;code>foo()&lt;/code> 方法并成功获得锁时,即使方法再次调用自身,由于线程已经持有了该锁,所以不会发生死锁。&lt;/p>
&lt;ol start="3">
&lt;li>&lt;strong>递归算法&lt;/strong>:&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">public int factorial(int n) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> if (n == 0) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> return 1;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> return n * factorial(n - 1); // 可以递归调用自身
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在这个示例中,&lt;code>factorial()&lt;/code> 方法是一个递归算法。它可以在自身内部多次调用自身,而不会产生任何问题。这就是可重入代码的体现。&lt;/p>
&lt;p>总的来说,可重入代码可以让同一个线程多次调用同一个函数/方法,而不会产生死锁或其他异常情况。这在多线程编程中非常重要,可以避免意外的并发问题。&lt;/p>
&lt;h2 id="线程机制">线程机制&lt;/h2>
&lt;h3 id="线程基本机制">线程基本机制&lt;/h3>
&lt;h4 id="executor框架">Executor框架&lt;/h4>
&lt;p>Executor 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。&lt;/p>
&lt;p>三种Executor:&lt;/p>
&lt;ul>
&lt;li>CachedThreadPool：一个任务创建一个线程&lt;/li>
&lt;li>FixedThreadPool：所有任务只能使用固定大小的线程&lt;/li>
&lt;li>SingleThreadExecutor：相当于大小为1的FixedThreadPool&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">public class Main {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public static void main(String[] args) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ExecutorService executorService = Executors.newCachedThreadPool();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> executorService.execute(() -&amp;gt; System.out.println(&amp;#34;CachedThreadPool&amp;#34;));
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> executorService.shutdown();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="daemon线程守护线程">Daemon线程(守护线程)&lt;/h4>
&lt;p>守护线程是一种特殊的线程, 不属于程序中不可或缺的部分，当所有的非守护线程结束时，程序也就终止了，同时会杀死进程中的所有守护线程。&lt;/p>
&lt;p>main不是守护线程.&lt;/p>
&lt;p>使用setDaemon()方法将线程设置为守护线程。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">public class Main {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public static void main(String[] args) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Thread thread = new Thread(() -&amp;gt; {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> while (true) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> System.out.println(&amp;#34;守护线程&amp;#34;);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> });
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> thread.setDaemon(true);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> thread.start();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="sleep方法">sleep()方法&lt;/h4>
&lt;p>sleep()方法是Thread类的静态方法，可以让当前线程休眠一段时间。 以毫秒为单位。&lt;/p>
&lt;p>sleep可能会抛出InterruptedException异常，并且无法跨线程返回给main, 必须在当前线程中处理.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">public class Main {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public static void main(String[] args) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Thread thread = new Thread(() -&amp;gt; {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> try {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Thread.sleep(1000);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> } catch (InterruptedException e) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> e.printStackTrace();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> System.out.println(&amp;#34;sleep&amp;#34;);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> });
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> thread.start();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="yield方法">yield()方法&lt;/h4>
&lt;p>yield()方法是Thread类的静态方法. 表示该线程已经执行完了重要的部分, 可以让当前线程让出CPU，但是不代表当前线程不执行了，只是让出CPU，让CPU重新调度。&lt;/p>
&lt;p>是对线程调度器的一种建议，而不是命令。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">public class Main {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public static void main(String[] args) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Thread thread1 = new Thread(() -&amp;gt; {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> for (int i = 0; i &amp;lt; 100; i++) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> System.out.println(&amp;#34;thread1&amp;#34;);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Thread.yield();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> });
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Thread thread2 = new Thread(() -&amp;gt; {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> for (int i = 0; i &amp;lt; 100; i++) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> System.out.println(&amp;#34;thread2&amp;#34;);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Thread.yield();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> });
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> thread1.start();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> thread2.start();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="线程中断">线程中断&lt;/h3>
&lt;h4 id="interrupt方法">Interrupt()方法&lt;/h4>
&lt;p>InterruptedException是一个检查异常&lt;/p>
&lt;p>当一个线程调用一个阻塞方法时，比如sleep()、wait()、join()等，&lt;/p>
&lt;p>如果其他线程调用了该线程的interrupt()方法，那么该线程会抛出InterruptedException异常。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">public class Main {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public static void main(String[] args) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Thread thread = new Thread(() -&amp;gt; {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> try {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Thread.sleep(1000);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> } catch (InterruptedException e) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> e.printStackTrace();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> });
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> thread.start();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> thread.interrupt();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果一个线程的 run() 方法执行一个无限循环，并且没有执行 sleep() 等会抛出 InterruptedException 的操作，那么调用线程的 interrupt() 方法就无法使线程提前结束&lt;/p>
&lt;p>但调用线程的 interrupt() 方法会设置线程的中断标志，可以通过 Thread.interrupted() 方法来判断线程是否被中断。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">public class Main {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public static void main(String[] args) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Thread thread = new Thread(() -&amp;gt; {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> while (!Thread.interrupted()) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> System.out.println(&amp;#34;running&amp;#34;);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> });
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> thread.start();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> thread.interrupt();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="executor框架中的中断">Executor框架中的中断&lt;/h4>
&lt;p>Executor框架中的线程池提供了shutdown()和shutdownNow()方法来关闭线程池。&lt;/p>
&lt;p>shutdown()会等待所有线程执行完毕后再关闭，而shutdownNow()会立即关闭所有线程(相当于调用每个线程的interrupt()方法)。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">public class Main {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public static void main(String[] args) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ExecutorService executorService = Executors.newCachedThreadPool();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> executorService.execute(() -&amp;gt; {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> while (true) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> System.out.println(&amp;#34;running&amp;#34;);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> });
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> executorService.shutdownNow();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果只是想中断一个线程，可以使用submit()方法提交一个Callable任务，然后调用返回的Future对象的cancel()方法来中断线程。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">public class Main {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public static void main(String[] args) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ExecutorService executorService = Executors.newCachedThreadPool();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Future&amp;lt;?&amp;gt; future = executorService.submit(() -&amp;gt; {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> while (true) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> System.out.println(&amp;#34;running&amp;#34;);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> });
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> future.cancel(true);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="线程之间的协作">线程之间的协作&lt;/h3>
&lt;h4 id="join方法">Join方法&lt;/h4>
&lt;p>join()方法是Thread类的一个实例方法，用于等待调用join()方法的线程执行完毕。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">public class Main {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public static void main(String[] args) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Thread thread = new Thread(() -&amp;gt; {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> System.out.println(&amp;#34;thread&amp;#34;);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> });
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> thread.start();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> try {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> thread.join();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> } catch (InterruptedException e) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> e.printStackTrace();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> System.out.println(&amp;#34;main&amp;#34;);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="查看线程的执行结果怎么拿到">查看线程的执行结果，怎么拿到&lt;/h4>
&lt;p>可以通过线程的join()方法来等待线程执行完毕，并获取线程的执行结果。join()方法会阻塞当前线程，直到被调用的线程执行完毕。&lt;/p>
&lt;p>另外，可以通过线程的返回值来获取线程的执行结果。如果线程需要返回结果，可以在run()方法中返回一个值，然后在调用线程的地方通过&lt;strong>Thread对象的get()方法&lt;/strong>获取返回值。&lt;/p>
&lt;h4 id="wait和notify方法">wait()和notify()方法&lt;/h4>
&lt;p>wait()和notify()方法是Object类的实例方法，用于线程之间的协作。&lt;/p>
&lt;p>wait()方法会使当前线程等待，直到其他线程调用对象的notify()或notifyAll()方法来唤醒该线程。&lt;/p>
&lt;p>只能在同步方法或同步块中调用wait()和notify()方法。&lt;/p>
&lt;p>wait会释放锁&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">public class Main {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public static void main(String[] args) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Object object = new Object();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Thread thread1 = new Thread(() -&amp;gt; {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> synchronized (object) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> try {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> object.wait();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> } catch (InterruptedException e) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> e.printStackTrace();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> System.out.println(&amp;#34;thread1&amp;#34;);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> });
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Thread thread2 = new Thread(() -&amp;gt; {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> synchronized (object) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> object.notify();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> System.out.println(&amp;#34;thread2&amp;#34;);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> });
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> thread1.start();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> thread2.start();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="sleep方法和wait方法">sleep()方法和wait()方法&lt;/h4>
&lt;ul>
&lt;li>sleep()方法
&lt;ul>
&lt;li>Thread类的静态方法，可以让当前线程休眠一段时间&lt;/li>
&lt;li>&lt;strong>不会释放锁&lt;/strong>。&lt;/li>
&lt;li>用于暂停执行&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>wait()方法
&lt;ul>
&lt;li>Object类的方法，可以让当前线程等待&lt;/li>
&lt;li>会释放锁。&lt;/li>
&lt;li>wait()调用后, 线程不会自动唤醒, 需要调用notify()或notifyAll()方法唤醒。
&lt;ul>
&lt;li>或者使用wait(long timeout)方法，指定等待时间后自动唤醒。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>用于线程间的通信&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h5 id="为什么wait不定义在thread类中呢">为什么wait()不定义在Thread类中呢？&lt;/h5>
&lt;p>wait()方法是Object类的方法，是让获得对象锁的线程实现等待，会自动释放当前线程占有的对象锁。&lt;/p>
&lt;p>&lt;strong>每个Object都有对象锁，因此定义在Object类中。&lt;/strong>&lt;/p>
&lt;h5 id="为什么sleep不定义在object类中呢">为什么sleep()不定义在Object类中呢？&lt;/h5>
&lt;p>sleep()方法是Thread类的静态方法，是让当前线程暂停执行，不涉及到对象类，也不需要获得对象锁。&lt;/p>
&lt;h4 id="await和signal方法-condition">await()和signal()方法 (Condition)&lt;/h4>
&lt;p>JUC包中的Condition接口提供了Condition对象来实现线程之间的协作。&lt;/p>
&lt;p>在Condition上调用await()方法会使当前线程等待，直到&lt;strong>其他线程调用Condition的signal()方法 或 signalAll()方法来唤醒该线程&lt;/strong>。&lt;/p>
&lt;p>相比于wait() , await可以指定等待的条件&lt;/p>
&lt;p>使用Lock对象的newCondition()方法来获取Condition对象。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-gdscript3" data-lang="gdscript3">&lt;span class="line">&lt;span class="cl">&lt;span class="n">public&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="n">AwaitSignalExample&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">private&lt;/span> &lt;span class="n">Lock&lt;/span> &lt;span class="n">lock&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">new&lt;/span> &lt;span class="n">ReentrantLock&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">private&lt;/span> &lt;span class="n">Condition&lt;/span> &lt;span class="n">condition&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">lock&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">newCondition&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">public&lt;/span> &lt;span class="n">void&lt;/span> &lt;span class="n">before&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">lock&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">lock&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">try&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;before&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">condition&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">signalAll&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="n">finally&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">lock&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">unlock&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">public&lt;/span> &lt;span class="n">void&lt;/span> &lt;span class="n">after&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">lock&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">lock&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">try&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">condition&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">await&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;after&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="n">catch&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">InterruptedException&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">e&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">printStackTrace&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="n">finally&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">lock&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">unlock&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="可以直接调用run方法吗">可以直接调用run()方法吗？&lt;/h3>
&lt;p>可以直接调用run()方法，但是这样会导致run()方法在当前线程（main线程）中执行，不会创建新的线程。&lt;/p>
&lt;p>正常情况是调用start()方法，然后由JVM来创建新的线程并执行run()方法。&lt;/p>
&lt;p>调用 start() 方法方可启动线程并使线程进入就绪状态，直接执行 run() 方法的话不会以多线程的方式执行。&lt;/p>
&lt;h2 id="锁">锁&lt;/h2>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/JUC%28Java%E5%B9%B6%E5%8F%91%29/Java%E4%B8%BB%E6%B5%81%E9%94%81.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="乐观锁与悲观锁">乐观锁与悲观锁&lt;/h3>
&lt;p>对于同一个数据的并发操作:&lt;/p>
&lt;ul>
&lt;li>悲观锁认为对于同一个数据的并发操作，一定是会发生冲突的，因此在数据被操作时会加锁。
&lt;ul>
&lt;li>synchronized lock&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>乐观锁认为对于同一个数据的并发操作，是不会发生冲突的，所以不会加锁，只是在更新数据时会判断在此期间数据有没有被其他线程更新。
&lt;ul>
&lt;li>CAS&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/JUC%28Java%E5%B9%B6%E5%8F%91%29/%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>悲观锁适用于写操作多的场景，乐观锁适用于读操作多的场景。&lt;/p>
&lt;h3 id="自旋锁与自适应自旋">自旋锁与自适应自旋&lt;/h3>
&lt;p>自旋锁出现的原因: 阻塞或唤醒一个线程都需要从用户态转换到内核态，这个转换过程需要耗费时间, 可能比线程自旋的时间还要长.&lt;/p>
&lt;p>而在很多场景中, 同步资源的锁定时间都是非常短的, 如果线程被阻塞的时间比同步资源的锁定时间还要长, 那么线程就会白白浪费CPU资源.&lt;/p>
&lt;p>所以可以让当前线程&amp;quot;忙等&amp;quot;, 不停地循环等待, 直到获取到锁.&lt;/p>
&lt;p>缺点:&lt;/p>
&lt;ul>
&lt;li>不能代替阻塞,会消耗CPU资源&lt;/li>
&lt;/ul>
&lt;p>因此当自旋时间过长时, 可以将线程挂起, 等待一段时间后再自旋.&lt;/p>
&lt;p>自适应自旋:&lt;/p>
&lt;ul>
&lt;li>自旋的时间不再是固定的, 而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的.&lt;/li>
&lt;li>如果前一次自旋成功, 说明锁的拥有者很快就会释放锁, 那么这一次自旋的时间会更长.&lt;/li>
&lt;li>如果前一次自旋不成功, 说明锁的拥有者不会很快释放锁, 那么这一次自旋的时间会更短.&lt;/li>
&lt;/ul>
&lt;h3 id="无锁-vs-偏向锁-vs-轻量级锁-vs-重量级锁">无锁 vs 偏向锁 vs 轻量级锁 vs 重量级锁&lt;/h3>
&lt;ul>
&lt;li>无锁是指线程间不会争用共享数据，因此无需加锁。&lt;/li>
&lt;li>偏向锁&lt;strong>消除无竞争情况下的同步原语&lt;/strong>,减少不必要的系统调用,从而提高程序的性能。
&lt;ul>
&lt;li>通过对比Mark Word解决加锁问题，避免执行CAS操作。&lt;/li>
&lt;li>Mark Word中存储了偏向线程的ID，当线程访问同步块时，会先检查Mark Word中的线程ID是否为当前线程ID，如果是则直接进入同步块。&lt;/li>
&lt;li>如果不是，则通过CAS操作竞争锁。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。&lt;/li>
&lt;li>重量级锁是将除了拥有锁的线程以外的线程都阻塞。&lt;/li>
&lt;/ul>
&lt;p>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。&lt;/p>
&lt;p>1.为什么引入：在大多数情况下，锁总是由同一线程多次获得，&lt;strong>不存在多线程竞争&lt;/strong>，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。&lt;/p>
&lt;p>2.实现机制：当一个线程访问同步代码块并获取锁时，会在 Mark Word 里存储锁偏向的线程 ID。在线程进入和退出同步块时不再通过 CAS 操作来加锁和解锁，而是检测 Mark Word 里是否存储着指向当前线程的偏向锁。&lt;/p>
&lt;p>Mark Word 是 Java 对象头的一部分,用于存储对象的一些元数据信息&lt;/p>
&lt;p>引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次 CAS 原子指令，而偏向锁只需要在置换 ThreadID 的时候依赖一次 CAS 原子指令即可。&lt;/p>
&lt;h3 id="公平锁和非公平锁">公平锁和非公平锁&lt;/h3>
&lt;p>公平锁是指多个线程按照申请锁的顺序来获取锁。&lt;/p>
&lt;p>非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请锁的线程比先申请锁的线程优先获取锁。&lt;/p>
&lt;p>公平锁的实现成本较高，性能相对非公平锁要低，因为需要先判断队列中是否有其他线程等待，而非公平锁只需要判断锁是否被占用。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/JUC%28Java%E5%B9%B6%E5%8F%91%29/%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="可重入锁-vs-非可重入锁">可重入锁 vs 非可重入锁&lt;/h3>
&lt;p>可重入锁是指同一个线程在外层方法获取锁的时候，内层方法可以直接获取该锁。又叫递归锁。&lt;/p>
&lt;p>非可重入锁是指锁不可以延续使用，不可以重复获取。&lt;/p>
&lt;p>可重入锁可以避免死锁&lt;/p>
&lt;p>Java中的synchronized和ReentrantLock都是可重入锁。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">public class ReentrantLockExample {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> private ReentrantLock lock = new ReentrantLock();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public void func() {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> lock.lock();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> try {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> for (int i = 0; i &amp;lt; 3; i++) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> System.out.println(i);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> if (i == 1) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> func();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> } finally {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> lock.unlock();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/JUC%28Java%E5%B9%B6%E5%8F%91%29/%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/JUC%28Java%E5%B9%B6%E5%8F%91%29/%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/JUC%28Java%E5%B9%B6%E5%8F%91%29/%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E5%92%8C%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E5%8E%9F%E7%90%86.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="共享锁和排他锁">共享锁和排他锁&lt;/h3>
&lt;p>共享锁是读锁，排他锁是写锁。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/JUC%28Java%E5%B9%B6%E5%8F%91%29/ReentrantReadWriteLock.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="todo-synchronized-原理和核心优化">TODO: synchronized 原理和核心优化&lt;/h3>
&lt;p>synchronized 在 JDK 1.5 时性能是比较低的，然而在后续的版本中经过各种优化迭代，它的性能也得到了前所未有的提升&lt;/p>
&lt;p>synchronized 核心优化方案主要包含以下 4 个：&lt;/p>
&lt;ul>
&lt;li>锁膨胀&lt;/li>
&lt;li>锁消除&lt;/li>
&lt;li>锁粗化&lt;/li>
&lt;li>自适应自旋锁&lt;/li>
&lt;/ul>
&lt;p>锁膨胀和自适应自旋锁是 synchronized 关键字自身的优化实现，而锁消除和锁粗化是 JVM 虚拟机对 synchronized 提供的优化方案&lt;/p>
&lt;h4 id="锁膨胀">锁膨胀&lt;/h4>
&lt;p>指 synchronized 从无锁升级到偏向锁，再到轻量级锁，最后到重量级锁的过程，它叫做锁膨胀也叫做锁升级。 JDK 1.6 之前，synchronized 是重量级锁，也就是说 synchronized 在释放和获取锁时都会从用户态转换成内核态，而转换的效率是比较低的。但有了锁膨胀机制之后，synchronized 的状态就多了无锁、偏向锁以及轻量级锁了，这时候在进行并发操作时，大部分的场景都不需要用户态到内核态的转换了，这样就大幅的提升了 synchronized 的性能。&lt;/p>
&lt;p>偏向锁执行流程&lt;/p>
&lt;p>当一个线程访问同步代码块并获取锁时，会在对象头的 Mark Word 里存储锁偏向的线程 ID&lt;/p>
&lt;p>在线程进入和退出同步块时不再通过 CAS 操作来加锁和解锁， 而是检测 Mark Word 里是否存储着指向当前线程的偏向锁&lt;/p>
&lt;ul>
&lt;li>如果 Mark Word 中的线程 ID 和访问的线程 ID 一致，则可以直接进入同步块进行代码执行&lt;/li>
&lt;li>如果线程 ID 不同，则使用 CAS 尝试获取锁，如果获取成功则进入同步块执行代码，否则会将锁的状态升级为轻量级锁。 ​&lt;/li>
&lt;/ul>
&lt;p>轻量级锁 引入轻量级锁的目的是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统 Mutex Lock（互斥锁）产生的性能消耗。&lt;/p>
&lt;p>如果使用 Mutex Lock 每次获取锁和释放锁的操作都会带来用户态和内核态的切换，这样系统的性能开销是很大的。 ​ 当关闭偏向锁或者多个线程竞争偏向锁时就会导致偏向锁升级为轻量级锁，轻量级锁的获取和释放都通过 CAS 完成的，其中锁获取可能会通过一定次数的自旋来完成。 ​&lt;/p>
&lt;p>重量级锁&lt;/p>
&lt;p>依赖监视器 Monitor 实现方法同步或代码块同步的&lt;/p>
&lt;p>代码块同步使用的是 monitorenter 和 monitorexit 指令来实现的&lt;/p>
&lt;p>monitorenter 指令是在编译后插入到同步代码块的开始位置&lt;/p>
&lt;p>monitorexit 是插入到方法结束处和异常处的，任何对象都有一个 Monitor 与之关联，当且一个 Monitor 被持有后，它将处于锁定状态。&lt;/p>
&lt;p>​&lt;/p>
&lt;h4 id="锁消除">锁消除&lt;/h4>
&lt;p>锁消除指的是在某些情况下，JVM 虚拟机如果检测不到某段代码被共享和竞争的可能性，就会将这段代码所属的同步锁消除掉，从而到底提高程序性能的目的。&lt;/p>
&lt;p>锁消除的依据是&lt;strong>逃逸分析&lt;/strong>的数据支持，如 StringBuffer 的 append() 方法，或 Vector 的 add() 方法，在很多情况下是可以进行锁消除的&lt;/p>
&lt;h4 id="锁粗化">锁粗化&lt;/h4>
&lt;p>锁粗化是指，将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。&lt;/p>
&lt;p>我只听说锁“细化”可以提高程序的执行效率，也就是将锁的范围尽可能缩小，这样在锁竞争时，等待获取锁的线程才能更早的获取锁，从而提高程序的运行效率，但锁粗化是如何提高性能的呢？&lt;/p>
&lt;p>没错，锁细化的观点在大多数情况下都是成立了，但是一系列连续加锁和解锁的操作，也会导致不必要的性能开销，从而影响程序的执行效率，比如这段代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">public String method() {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> StringBuilder sb = new StringBuilder();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> for (int i = 0; i &amp;lt; 10; i++) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // 伪代码：加锁操作
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> sb.append(&amp;#34;i:&amp;#34; + i);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // 伪代码：解锁操作
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> return sb.toString();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果我们直接在 for 循环的外层加一把锁，那么对于同一个对象操作这段代码的性能就会提高很多&lt;/p>
&lt;h4 id="自适应自旋锁">自适应自旋锁&lt;/h4>
&lt;p>自适应自旋锁是指，自旋锁在 JDK 1.6 之后，引入了自适应自旋锁的机制，自旋锁的自适应性是指自旋的次数不再是固定的，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的。&lt;/p>
&lt;p>自旋锁优点在于它避免一些线程的挂起和恢复操作，因为挂起线程和恢复线程都需要从用户态转入内核态，这个过程是比较慢的，所以通过自旋的方式可以一定程度上避免线程挂起和恢复所造成的性能开销。&lt;/p>
&lt;p>但是，如果长时间自旋还获取不到锁，那么也会造成一定的资源浪费，所以我们通常会给自旋设置一个固定的值来避免一直自旋的性能开销。然而对于 synchronized 关键字来说，它的自旋锁更加的“智能”，synchronized 中的自旋锁是自适应自旋锁&lt;/p>
&lt;p>线程自旋的次数不再是固定的值，而是一个动态改变的值，这个值会根据前一次自旋获取锁的状态来决定此次自旋的次数。&lt;/p>
&lt;p>如果线程自旋成功了，则下次自旋的次数会增多，如果失败，下次自旋的次数会减少。&lt;/p>
&lt;h2 id="线程池">线程池&lt;/h2>
&lt;h3 id="线程池概念">线程池概念&lt;/h3>
&lt;p>线程池提供了一种限制和管理资源（包括执行一个任务）的方式。 每个线程池还维护一些基本统计信息，例如已完成任务的数量。&lt;/p>
&lt;p>好处:&lt;/p>
&lt;ul>
&lt;li>降低资源消耗: 通过重复利用已创建的线程降低线程创建和销毁造成的消耗。&lt;/li>
&lt;li>提高响应速度: 当任务到达时，任务可以不需要等到线程创建就能立即执行。&lt;/li>
&lt;li>提高线程的可管理性: 线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。&lt;/li>
&lt;/ul>
&lt;h3 id="创建线程池">创建线程池&lt;/h3>
&lt;ol>
&lt;li>通过ThreadPoolExecutor构造函数创建&lt;/li>
&lt;li>通过Executors工厂方法创建&lt;/li>
&lt;/ol>
&lt;h3 id="为什么不推荐使用内置线程池">为什么不推荐使用内置线程池&lt;/h3>
&lt;p>《阿里巴巴 Java 开发手册》中&lt;/p>
&lt;ul>
&lt;li>线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。&lt;/li>
&lt;li>强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 构造函数的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险&lt;/li>
&lt;/ul>
&lt;p>Java是如何实现和管理线程池的?&lt;/p>
&lt;p>从JDK 5开始，把工作单元与执行机制分离开来，工作单元包括Runnable和Callable，而执行机制由Executor框架提供。&lt;/p>
&lt;h4 id="有哪些实现好的线程池既然他们不推荐为什么java官方还要给你">有哪些实现好的线程池，既然他们不推荐，为什么Java官方还要给你&lt;/h4>
&lt;p>Java中提供了多种线程池实现，包括ThreadPoolExecutor、ScheduledThreadPoolExecutor、ForkJoinPool等。这些线程池实现都是经过优化和测试的，可以满足大部分场景的需求。&lt;/p>
&lt;p>虽然Java官方不推荐直接使用这些线程池实现，但是它们提供了一种可靠、高效的线程池实现，可以作为开发者自己实现线程池的参考。&lt;/p>
&lt;h3 id="executors工厂方法创建线程池">Executors工厂方法创建线程池&lt;/h3>
&lt;h4 id="fixedthreadpool">FixedThreadPool&lt;/h4>
&lt;p>该方法返回一个固定数量的线程池，该线程池中的线程数量始终不变。&lt;/p>
&lt;p>当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。&lt;/p>
&lt;p>弊端： 使用的是无界的LinkedBlockingQueue，可能会堆积大量的请求，从而导致OOM。&lt;/p>
&lt;h4 id="singlethreadexecutor">SingleThreadExecutor&lt;/h4>
&lt;p>该方法返回一个只有一个线程的线程池，若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。&lt;/p>
&lt;p>弊端同FixedThreadPool&lt;/p>
&lt;h4 id="cachedthreadpool">CachedThreadPool&lt;/h4>
&lt;p>该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。&lt;/p>
&lt;p>弊端： 使用的是SynchronousQueue，允许创建的线程数量为Integer.MAX_VALUE，可能会创建大量的线程，从而导致OOM。&lt;/p>
&lt;h4 id="scheduledthreadpool">ScheduledThreadPool&lt;/h4>
&lt;p>该方法返回一个固定数量的线程池，而且该线程池可以延迟或定时的执行任务。&lt;/p>
&lt;p>弊端： 使用的是无界的DelayedWorkQueue，队列最大长度为Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM。&lt;/p>
&lt;h3 id="线程池参数">线程池参数**&lt;/h3>
&lt;p>最重要的三个&lt;/p>
&lt;ul>
&lt;li>corePoolSize：核心线程数，即线程池中保留的线程数, 至少的线程数.&lt;/li>
&lt;li>maximumPoolSize：最大线程数，即线程池中允许的最大线程数。&lt;/li>
&lt;li>workQueue：任务队列，用于存储等待执行的任务。&lt;/li>
&lt;li>keepAliveTime：线程空闲时间，即当线程池中的线程空闲时间超过该值时，多余的线程会被销毁。&lt;/li>
&lt;li>unit：时间单位，用于指定keepAliveTime的时间单位。&lt;/li>
&lt;li>threadFactory：线程工厂，用于创建新的线程。&lt;/li>
&lt;li>handler：拒绝策略，用于处理无法处理的任务。&lt;/li>
&lt;/ul>
&lt;h3 id="线程池常用的阻塞队列">线程池常用的阻塞队列&lt;/h3>
&lt;p>新任务到来时，如果线程数量达到了corePoolSize，就将任务加入workQueue中.&lt;/p>
&lt;p>不同的阻塞队列对线程池的运行状态有不同的影响。&lt;/p>
&lt;ul>
&lt;li>ArrayBlockingQueue：基于数组的有界阻塞队列，按FIFO排序任务。&lt;/li>
&lt;li>LinkedBlockingQueue：基于链表的有界阻塞队列，按FIFO排序任务。&lt;/li>
&lt;li>SynchronousQueue：不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态。&lt;/li>
&lt;li>DelayQueue：基于优先级的延迟阻塞队列，按元素的延迟时间排序。&lt;/li>
&lt;/ul>
&lt;h3 id="线程池饱和策略">线程池饱和策略&lt;/h3>
&lt;p>AbortPolicy：直接抛出RejectedExecutionException异常。 CallerRunsPolicy：将任务交给调用线程来执行。 DiscardPolicy：直接丢弃任务，不做任何处理。&lt;/p>
&lt;h3 id="线程池的工作流程">线程池的工作流程&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/JUC%28Java%E5%B9%B6%E5%8F%91%29/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>新任务来了&lt;/p>
&lt;ol>
&lt;li>如果线程池中的线程数量小于corePoolSize，就创建新的线程来执行任务。&lt;/li>
&lt;li>如果线程池中的线程数量等于或大于corePoolSize，且小于maximumPoolSize，就将任务加入workQueue中。&lt;/li>
&lt;li>如果workQueue已满，且线程数量小于maximumPoolSize，就创建新的线程来执行任务。&lt;/li>
&lt;li>如果workQueue已满，且线程数量等于或大于maximumPoolSize，就执行拒绝策略。&lt;/li>
&lt;/ol>
&lt;h3 id="如何动态修改线程池参数">如何动态修改线程池参数&lt;/h3>
&lt;p>对 corePoolSize、maximumPoolSize、keepAliveTime 进行修改，可以通过 ThreadPoolExecutor 的 setCorePoolSize、setMaximumPoolSize、setKeepAliveTime 方法进行修改。&lt;/p>
&lt;p>因为这三个参数基本决定了线程池的基本行为，修改这三个参数后，线程池会重新调整线程数量。&lt;/p>
&lt;p>&lt;a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html" target="_blank" rel="noopener">美团的动态调参&lt;/a>&lt;/p>
&lt;p>从任务的优先级，任务的执行时间长短，任务的性质(CPU密集/ IO密集)，任务的依赖关系这四个角度来分析。&lt;/p>
&lt;p>并且近可能地使用有界的工作队列。性质不同的任务可用使用不同规模的线程池分开处理:&lt;/p>
&lt;p>CPU密集型: 尽可能少的线程，Ncpu+1&lt;/p>
&lt;ul>
&lt;li>保留一个线程用于处理其他辅助工作,如 I/O 操作、垃圾回收等。这样可以确保主要的 CPU 密集型任务有足够的资源,同时不会影响其他必要的工作。&lt;/li>
&lt;/ul>
&lt;p>IO密集型: 尽可能多的线程, Ncpu*2，比如数据库连接池&lt;/p>
&lt;p>混合型: CPU密集型的任务与IO密集型任务的执行时间差别较小，拆分为两个线程池；否则没有必要拆分。&lt;/p>
&lt;h3 id="如何设计根据任务优先级执行的线程池">如何设计根据任务优先级执行的线程池&lt;/h3>
&lt;p>可以使用 PriorityBlockingQueue 来存储任务，然后自定义任务类实现 Comparable 接口，根据优先级来排序。&lt;/p>
&lt;h3 id="如何解决oom">如何解决OOM&lt;/h3>
&lt;p>OOM：OutOfMemoryError 在使用线程池时，可能会因为线程池中的线程数量过多，导致内存溢出。&lt;/p>
&lt;p>解决方法：&lt;/p>
&lt;ul>
&lt;li>通过调整线程池的参数，如 corePoolSize、maximumPoolSize、keepAliveTime 等。&lt;/li>
&lt;li>通过使用有界的阻塞队列，如 ArrayBlockingQueue、LinkedBlockingQueue 等。&lt;/li>
&lt;li>通过使用拒绝策略，如 AbortPolicy、CallerRunsPolicy、DiscardPolicy、DiscardOldestPolicy 等。&lt;/li>
&lt;li>重写入队方法，实现自定义的拒绝策略。&lt;/li>
&lt;/ul>
&lt;h2 id="future">Future&lt;/h2>
&lt;p>Future接口是Java5中引入的，它用来表示异步计算的结果。&lt;/p>
&lt;p>是异步思想的体现，主要用于在一些耗时的操作中，先提交任务，然后去做其他的事情，等到任务完成后再来获取结果。&lt;/p>
&lt;p>Future模式看作是一种特殊的设计模式，思想是异步调用。&lt;/p>
&lt;p>Java中Future类是一个接口，它的实现类是FutureTask。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">// V 代表了Future执行的任务返回值的类型
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">public interface Future&amp;lt;V&amp;gt; {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // 取消任务执行
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // 成功取消返回 true，否则返回 false
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> boolean cancel(boolean mayInterruptIfRunning);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // 判断任务是否被取消
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> boolean isCancelled();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // 判断任务是否已经执行完成
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> boolean isDone();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // 获取任务执行结果
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> V get() throws InterruptedException, ExecutionException;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // 指定时间内没有返回计算结果就抛出 TimeOutException 异常
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> V get(long timeout, TimeUnit unit)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> throws InterruptedException, ExecutionException, TimeoutException;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="futuretask">FutureTask&lt;/h3>
&lt;p>FutureTask是Future的一个实现类，它实现了Runnable接口，所以它可以被线程执行。&lt;/p>
&lt;p>FutureTask可以用来包装Callable或Runnable对象。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">public class FutureTask&amp;lt;V&amp;gt; implements RunnableFuture&amp;lt;V&amp;gt; {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // 有两个构造函数
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // 1. 传入Callable对象
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public FutureTask(Callable&amp;lt;V&amp;gt; callable) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> if (callable == null)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> throw new NullPointerException();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> this.callable = callable;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> this.state = NEW; // ensure visibility of callable
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // 2. 传入Runnable对象和返回值
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public FutureTask(Runnable runnable, V result) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> this.callable = Executors.callable(runnable, result);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> this.state = NEW; // ensure visibility of callable
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>CompletableFuture是Java8中引入的一个类，它实现了Future和CompletionStage接口，可以用来表示一个异步计算的结果。&lt;/p>
&lt;p>解决了Future的局限性: 不支持组合、不支持异常处理、不支持回调机制。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">public class CompletableFuture&amp;lt;T&amp;gt; implements Future&amp;lt;T&amp;gt;, CompletionStage&amp;lt;T&amp;gt; {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="aqsreentrantlock的底层实现框架">AQS（ReentrantLock的底层实现框架）&lt;/h2>
&lt;p>AQS是AbstractQueuedSynchronizer的缩写，它是一个用来构建锁和同步器的框架。&lt;/p>
&lt;p>AQS是JUC包中的一个重要类，它是用来构建锁和同步器的框架。&lt;/p>
&lt;h3 id="aqs的设计思想">AQS的设计思想&lt;/h3>
&lt;p>AQS的设计思想是&lt;/p>
&lt;ul>
&lt;li>如果被请求的资源空闲，那么就将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。&lt;/li>
&lt;li>如果被请求的资源被占用，那么就需要一套&lt;strong>线程阻塞等待以及被唤醒时锁分配&lt;/strong>的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。&lt;/li>
&lt;/ul>
&lt;p>CLH队列是对自旋锁的一种改进，是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系），它将所有申请同步状态的线程封装成一个队列。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/JUC%28Java%E5%B9%B6%E5%8F%91%29/CLH%E9%98%9F%E5%88%97%E7%BB%93%E6%9E%84.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="aqs的实现原理">AQS的实现原理&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/JUC%28Java%E5%B9%B6%E5%8F%91%29/AQS%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>AQS 使用 int 成员变量 state 表示同步状态，通过内置的 FIFO 线程等待/等待队列 来完成获取资源线程的排队工作。&lt;/p>
&lt;p>state 变量由 volatile 修饰，用于展示当前临界资源的获锁情况。 &lt;code>private volatile int state;&lt;/code>&lt;/p>
&lt;h4 id="reentrantlock原理">ReentrantLock原理&lt;/h4>
&lt;p>以可重入的互斥锁 ReentrantLock 为例，它的内部维护了一个 state 变量，用来表示锁的占用状态。&lt;/p>
&lt;ul>
&lt;li>state 的初始值为 0，表示锁处于未锁定状态。当线程 A 调用 lock() 方法时，会尝试通过 tryAcquire() 方法独占该锁，并让 state 的值加 1。&lt;/li>
&lt;li>如果成功了，那么线程 A 就获取到了锁。&lt;/li>
&lt;li>如果失败了，那么线程 A 就会被加入到一个等待队列（CLH 队列）中，直到其他线程释放该锁。&lt;/li>
&lt;li>假设线程 A 获取锁成功了，释放锁之前，**A 线程自己是可以重复获取此锁的（state 会累加）。**这就是可重入性的体现：一个线程可以多次获取同一个锁而不会被阻塞。&lt;/li>
&lt;li>但是，这也意味着，&lt;strong>一个线程必须释放与获取的次数相同的锁&lt;/strong>，才能让 state 的值回到 0，也就是让锁恢复到未锁定状态。只有这样，其他等待的线程才能有机会获取该锁。&lt;/li>
&lt;/ul>
&lt;h2 id="juc工具类">JUC工具类&lt;/h2></description></item><item><title/><link>https://ysyyhhh.github.io/docs/language/java/jvm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/language/java/jvm/</guid><description>&lt;h1 id="jvm">JVM&lt;/h1>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/JVM/%e7%b3%bb%e7%bb%9f%e7%bb%93%e6%9e%84.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h2 id="todo类字节码">TODO:类字节码&lt;/h2>
&lt;p>JVM上运行的是字节码，而不是源代码。
字节码是一种中间代码，它是一种介于源代码和机器码之间的代码。字节码是由Java编译器编译生成的，它是一种与平台无关的代码，可以在任何支持Java虚拟机的平台上运行。&lt;/p>
&lt;p>JVM不仅支持Java语言，还支持其他语言，如Groovy、Kotlin、Scala等。这些语言都可以编译成字节码，然后在JVM上运行。&lt;/p>
&lt;h3 id="字节码文件">字节码文件&lt;/h3>
&lt;p>字节码文件是以.class为扩展名的文件，它包含了Java源代码编译生成的字节码。
字节码文件是一种二进制文件以8位字节为单位存储的，它包含了类的结构信息、字段信息、方法信息、接口信息等。&lt;/p>
&lt;p>class文件采用伪结构来存储, 有两种类型: 无符号数和表。&lt;/p>
&lt;p>无符号数: 占两个字节, 用于描述数字, 例如: u1, u2, u4, u8&lt;/p>
&lt;p>表: 由多个无符号数或其他表构成, 用于描述有层次关系的复合结构, 例如: 字段表, 方法表, 属性表&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/JVM/class%e6%96%87%e4%bb%b6%e7%bb%93%e6%9e%84.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="字节码增强技术">字节码增强技术&lt;/h3>
&lt;p>字节码增强技术是指在编译后的字节码文件中插入新的字节码，从而增强程序的功能。字节码增强技术可以用于实现AOP（Aspect-Oriented Programming）编程、动态代理、代码注入等功能。&lt;/p>
&lt;h2 id="类加载机制">类加载机制&lt;/h2>
&lt;h3 id="类的生命周期">类的生命周期&lt;/h3>
&lt;p>类的生命周期包括：加载、验证、准备、解析、初始化、使用和卸载。&lt;/p>
&lt;p>类加载的过程包括了: 加载、验证、准备、解析、初始化。&lt;/p>
&lt;p>其中解析的过程是可选的，可以在初始化阶段之后再进行。&lt;/p>
&lt;ul>
&lt;li>为了支持动态绑定&lt;/li>
&lt;/ul>
&lt;p>其余阶段按顺序开始,但是不一定按顺序结束.&lt;/p>
&lt;h3 id="类的加载">类的加载&lt;/h3>
&lt;p>类的加载是指将类的字节码文件加载到内存中，并创建一个Class对象，用于表示该类。&lt;/p>
&lt;p>在加载阶段,虚拟机需要完成:&lt;/p>
&lt;ul>
&lt;li>通过类的全限定名获取类的二进制字节流&lt;/li>
&lt;li>将字节流代表的静态存储结构转化为方法区的运行时数据结构&lt;/li>
&lt;li>在内存中生成一个代表这个类的java.lang.Class对象,作为方法区这个类的各种数据的访问入口&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/JVM/%e7%b1%bb%e7%9a%84%e5%8a%a0%e8%bd%bd.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>类加载器不需要等到&amp;quot;首次使用&amp;quot;时才加载类,而是在预料到类会被使用时就加载类. 如果在加载类的过程中遇到了错误,类加载器必须抛出异常,通知调用者类加载失败.&lt;/p>
&lt;p>加载class文件的方式:&lt;/p>
&lt;ul>
&lt;li>从本地系统中直接加载&lt;/li>
&lt;li>通过网络下载.class文件&lt;/li>
&lt;li>从zip,jar等归档文件中加载&lt;/li>
&lt;li>从数据库中读取.class文件&lt;/li>
&lt;li>将Java源文件动态编译为.class文件&lt;/li>
&lt;/ul>
&lt;h3 id="连接">连接&lt;/h3>
&lt;p>连接阶段包括了验证、准备和解析。&lt;/p>
&lt;h4 id="验证">验证&lt;/h4>
&lt;p>验证是确保加载的类符合JVM规范的过程。验证阶段的目的是确保被加载的类是合法、合理的，不会危害虚拟机的安全。&lt;/p>
&lt;p>验证阶段主要包括了四个方面的验证：&lt;/p>
&lt;ul>
&lt;li>文件格式验证：验证字节码文件是否符合JVM规范。&lt;/li>
&lt;li>元数据验证：验证字节码文件中的类、字段、方法等信息是否符合JVM规范。&lt;/li>
&lt;li>字节码验证：验证字节码文件中的字节码是否符合JVM规范。&lt;/li>
&lt;li>符号引用验证：验证字节码文件中的符号引用是否符合JVM规范。&lt;/li>
&lt;/ul>
&lt;h4 id="准备">准备&lt;/h4>
&lt;p>准备阶段是为类的&lt;strong>静态变量分配内存并设置初始值&lt;/strong>的过程。这些变量所使用的内存都将在方法区中进行分配.&lt;/p>
&lt;ul>
&lt;li>不包括实例变量,实例变量会在对象实例化时随着对象一起分配在Java堆中&lt;/li>
&lt;li>初始值是默认的零值,例如: 0, null&lt;/li>
&lt;/ul>
&lt;h4 id="解析">解析&lt;/h4>
&lt;p>解析阶段是将&lt;strong>常量池中的符号引用替换为直接引用&lt;/strong>的过程。&lt;/p>
&lt;p>解析阶段是可选的，可以在初始化阶段之后再进行。&lt;/p>
&lt;p>解析针对类或接口,字段,类方法,接口方法,方法类型,方法句柄,方法调用点限定符,动态调用点限定符这几类符号引用进行.&lt;/p>
&lt;p>符号引用包含了被引用项的名称、描述符以及其所在的类或接口的名称等信息. 但没有直接指向目标的指针, 为了使得方法调用可以实现动态连接,Java编译器会在Class文件中的常量池中留下一些符号引用,以便在运行期间将其解析为直接引用.&lt;/p>
&lt;h3 id="初始化">初始化&lt;/h3>
&lt;p>初始化阶段是执行初始化方法 &lt;clinit> ()方法的过程，是类加载的最后一步，这一步 JVM 才开始真正执行类中定义的 Java 程序代码(字节码)。&lt;/p>
&lt;!--
初始化是为类的静态变量赋予正确的初始值的过程。
对类变量进行初始值设定有两种方式:
- 声明变量时指定初始值
- 使用静态初始化块
JVM初始化步骤
- 如果这个类还没有被加载和连接,则先进行加载和连接
- 如果类的直接父类还没有被初始化,则先初始化其直接父类
- 如果类中有初始化语句,则依次执行这些初始化语句
类的初始化动机: 只有对类的主动使用才会导致类的初始化,主动使用包括:
- 创建类的实例, new
- 访问类的静态变量,或者为静态变量赋值
- 调用类的静态方法
- 反射,例如: Class.forName("com.example.Test")
- 初始化一个类的子类
- Java虚拟机启动时被标明为启动类的类,即main方法所在的类
类初始化的方式
- 构造函数
- 静态代码块 -->
&lt;h3 id="使用">使用&lt;/h3>
&lt;p>类访问方法区的数据,执行程序代码,调用方法等.&lt;/p>
&lt;p>对象是在堆中分配的,对象的实例变量也在堆中分配,但是对象的引用是在栈中分配的.&lt;/p>
&lt;h3 id="卸载">卸载&lt;/h3>
&lt;p>JVM结束声明周期的情况:&lt;/p>
&lt;ul>
&lt;li>执行了System.exit()方法&lt;/li>
&lt;li>程序正常结束&lt;/li>
&lt;li>程序异常结束&lt;/li>
&lt;li>由于操作系统错误导致JVM进程终止&lt;/li>
&lt;/ul>
&lt;h3 id="类加载器">类加载器&lt;/h3>
&lt;p>类加载器是用于加载类的对象，它负责将类的字节码文件加载到内存中，并创建一个Class对象，用于表示该类。&lt;/p>
&lt;p>分为三种:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>启动类&lt;/strong>加载器: Bootstrap ClassLoader
&lt;ul>
&lt;li>负责加载JRE/lib下, 或 -Xbootclasspath选项指定的路径中的核心类库&lt;/li>
&lt;li>由C++实现,不是Java类&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>扩展类&lt;/strong>加载器: Extension ClassLoader
&lt;ul>
&lt;li>负责加载JRE/lib/ext目录下的扩展类库,如javax.*开头的类&lt;/li>
&lt;li>由Java实现,是sun.misc.Launcher$ExtClassLoader类&lt;/li>
&lt;li>开发者可以直接使用扩展类加载器&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>应用程序类&lt;/strong>加载器: Application ClassLoader
&lt;ul>
&lt;li>负责加载用户类路径上的类库&lt;/li>
&lt;li>由Java实现,是sun.misc.Launcher$AppClassLoader类&lt;/li>
&lt;li>开发者可以直接使用应用程序类加载器&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器
因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点:&lt;/p>
&lt;ul>
&lt;li>在执行非置信代码之前，自动验证数字签名。&lt;/li>
&lt;li>动态地创建符合用户特定需要的定制化构建类。&lt;/li>
&lt;li>从特定的场所取得java class，例如数据库中和网络中。&lt;/li>
&lt;/ul>
&lt;h4 id="寻找类加载器">寻找类加载器&lt;/h4>
&lt;p>类加载器的寻找顺序是: 启动类加载器 -&amp;gt; 扩展类加载器 -&amp;gt; 应用程序类加载器&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">package&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">com.pdai.jvm.classloader&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">ClassLoaderTest&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">static&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">args&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">ClassLoader&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">loader&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Thread&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">currentThread&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="na">getContextClassLoader&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">loader&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">loader&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">getParent&lt;/span>&lt;span class="p">());&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">loader&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">getParent&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="na">getParent&lt;/span>&lt;span class="p">());&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="类的加载-1">类的加载&lt;/h3>
&lt;p>类的加载有三种方式:&lt;/p>
&lt;ul>
&lt;li>命令行启动应用时候由JVM初始化加载&lt;/li>
&lt;li>通过Class.forName()方法动态加载&lt;/li>
&lt;li>通过ClassLoader.loadClass()方法动态加载&lt;/li>
&lt;/ul>
&lt;h3 id="jvm类加载机制">JVM类加载机制&lt;/h3>
&lt;p>JVM类加载机制是指JVM在加载类的过程中所采取的策略和步骤。&lt;/p>
&lt;p>全盘负责: 一个类加载器负责加载一个类,如果一个类加载器加载了一个类,那么这个类所依赖的和引用的类也由这个类加载器负责加载.&lt;/p>
&lt;p>父类委托: 一个类加载器在加载类时,先委托给其父类加载器加载,如果父类加载器无法加载,则自己加载.&lt;/p>
&lt;p>缓存机制: 保证所有加载过的类都会被缓存,当程序中需要使用某个类时,类加载器会先从缓存中搜索这个类,只有当缓存中不存在这个类时,类加载器才会去加载这个类.&lt;/p>
&lt;h3 id="类加载器的双亲委派模型">类加载器的双亲委派模型&lt;/h3>
&lt;p>双亲委派模型是指类加载器在加载类时，会先委托给其父类加载器加载，只有在父类加载器无法加载时，才会自己加载。&lt;/p>
&lt;ol>
&lt;li>当AppClassLoader加载一个类时,它首先不会自己去尝试加载这个类,而是把类加载请求委派给父类加载器ExtClassLoader去完成&lt;/li>
&lt;li>当ExtClassLoader加载一个类时,它首先不会自己去尝试加载这个类,而是把类加载请求委派给BootstrapClassLoader去完成&lt;/li>
&lt;li>如果BootstrapClassLoader加载失败(在rt.jar中找不到所需类),会把类加载请求委派给ExtClassLoader&lt;/li>
&lt;li>如果ExtClassLoader加载失败(在jre/lib/ext中找不到所需类),会把类加载请求委派给AppClassLoader&lt;/li>
&lt;li>如果AppClassLoader加载失败(在用户类路径下找不到所需类),会抛出ClassNotFoundException&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Class&lt;/span>&lt;span class="o">&amp;lt;?&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">loadClass&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="kd">throws&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ClassNotFoundException&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">loadClass&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">false&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">protected&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">synchronized&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Class&lt;/span>&lt;span class="o">&amp;lt;?&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">loadClass&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">boolean&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">resolve&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="kd">throws&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ClassNotFoundException&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 首先判断该类型是否已经被加载&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">Class&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">findLoadedClass&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">if&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">==&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">//如果没有被加载，就委托给父类加载或者委派给启动类加载器加载&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">try&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">if&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">parent&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">!=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">//如果存在父类加载器，就委派给父类加载器加载&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">parent&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">loadClass&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">false&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">else&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">//如果不存在父类加载器，就检查是否是由启动类加载器加载的类，通过调用本地方法native Class findBootstrapClass(String name)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">findBootstrapClass0&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">catch&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ClassNotFoundException&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 如果父类加载器和启动类加载器都不能完成加载任务，才调用自身的加载功能&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">findClass&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">if&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">resolve&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">resolveClass&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>优势:&lt;/p>
&lt;ul>
&lt;li>避免类的重复加载, 防止内存中出现多份同样的字节码&lt;/li>
&lt;li>保护程序安全, 防止核心API被随意篡改&lt;/li>
&lt;/ul>
&lt;h3 id="自定义类加载器">自定义类加载器&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">package&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">com.pdai.jvm.classloader&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kn">import&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nn">java.io.*&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">MyClassLoader&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">extends&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ClassLoader&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">protected&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Class&lt;/span>&lt;span class="o">&amp;lt;?&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">findClass&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">throws&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ClassNotFoundException&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kt">byte&lt;/span>&lt;span class="o">[]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">classData&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">loadClassData&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">if&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">classData&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">==&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">throw&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ClassNotFoundException&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">else&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">defineClass&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">classData&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">classData&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">length&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">byte&lt;/span>&lt;span class="o">[]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">loadClassData&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">className&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">fileName&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">File&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">separatorChar&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">className&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">replace&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sc">&amp;#39;.&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">File&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">separatorChar&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;.class&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">try&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">InputStream&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ins&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">FileInputStream&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">fileName&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">ByteArrayOutputStream&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">baos&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ByteArrayOutputStream&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">bufferSize&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">1024&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kt">byte&lt;/span>&lt;span class="o">[]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">buffer&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">byte&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">bufferSize&lt;/span>&lt;span class="o">]&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">length&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">while&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="n">length&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ins&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">read&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">buffer&lt;/span>&lt;span class="p">))&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">!=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">baos&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">write&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">buffer&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">length&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">baos&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">toByteArray&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">catch&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">IOException&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">printStackTrace&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">getRoot&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">setRoot&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">root&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">static&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">args&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">MyClassLoader&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">classLoader&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">MyClassLoader&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">classLoader&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">setRoot&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;D:\\temp&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">Class&lt;/span>&lt;span class="o">&amp;lt;?&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">testClass&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">try&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">testClass&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">classLoader&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">loadClass&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;com.pdai.jvm.classloader.Test2&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">Object&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">object&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">testClass&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">newInstance&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">object&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">getClass&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="na">getClassLoader&lt;/span>&lt;span class="p">());&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">catch&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ClassNotFoundException&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">printStackTrace&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">catch&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">InstantiationException&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">printStackTrace&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">catch&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">IllegalAccessException&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">printStackTrace&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>自定义类加载器的核心在于对字节码文件的获取，如果是加密的字节码则需要在该类中对文件进行解密。由于这里只是演示，我并未对class文件进行加密，因此没有解密的过程。&lt;/p>
&lt;p>这里有几点需要注意 :
1、这里传递的文件名需要是类的全限定性名称，即com.pdai.jvm.classloader.Test2格式的，因为 defineClass 方法是按这种格式进行处理的。
2、最好不要重写loadClass方法，因为这样容易破坏双亲委托模式。
3、这类Test 类本身可以被 AppClassLoader 类加载，因此我们不能把com/pdai/jvm/classloader/Test2.class 放在类路径下。否则，由于双亲委托机制的存在，会直接导致该类由 AppClassLoader 加载，而不会通过我们自定义类加载器来加载。&lt;/p>
&lt;h2 id="java-内存区域">Java 内存区域&lt;/h2>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/JVM/%e8%bf%90%e8%a1%8c%e6%97%b6%e6%95%b0%e6%8d%ae%e5%8c%ba.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>线程私有的：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>程序计数器&lt;/strong>&lt;/li>
&lt;li>&lt;strong>虚拟机栈&lt;/strong>&lt;/li>
&lt;li>&lt;strong>本地方法栈&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>线程共享的：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>堆&lt;/strong>&lt;/li>
&lt;li>&lt;strong>方法区&lt;/strong>&lt;/li>
&lt;li>直接内存 (非运行时数据区的一部分)&lt;/li>
&lt;/ul>
&lt;p>Java 虚拟机规范对于运行时数据区域的规定是相当宽松的。以堆为例：堆可以是连续空间，也可以不连续。堆的大小可以固定，也可以在运行时按需扩展 。&lt;/p>
&lt;p>虚拟机实现者可以使用任何垃圾回收算法管理堆，甚至完全不进行垃圾收集也是可以的。&lt;/p>
&lt;p>程序计数器的功能是记录当前线程执行的字节码指令的地址，从而实现线程切换和恢复。&lt;/p>
&lt;p>程序计数器是线程私有的，是为了线程切换时能够正确恢复执行现场。&lt;/p>
&lt;p>虚拟机栈：每个线程在创建时都会创建一个虚拟机栈，用于存放线程的方法调用栈、局部变量表、操作数栈等信息。（执行的是Java方法）&lt;/p>
&lt;p>本地方法栈：用于支持本地方法调用，即调用C/C++编写的本地方法。&lt;/p>
&lt;p>为了保证线程的局部变量不被其他线程访问，虚拟机栈和本地方法栈是线程私有的。&lt;/p>
&lt;h3 id="程序计数器">程序计数器&lt;/h3>
&lt;p>程序计数寄存器（Program Counter Register）
JVM 中的 PC 寄存器是对物理 PC 寄存器的一种抽象模拟。&lt;/p>
&lt;p>是一块较小的内存空间，它可以看作是&lt;strong>当前线程所执行的字节码的行号指示器&lt;/strong>。&lt;/p>
&lt;h4 id="作用">作用&lt;/h4>
&lt;ul>
&lt;li>字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令。&lt;/li>
&lt;li>它是线程私有的，每个线程都有一个独立的程序计数器,生命周期与线程的生命周期一致&lt;/li>
&lt;li>任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。
&lt;ul>
&lt;li>如果当前线程正在执行的是 Java 方法，程序计数器记录的是 JVM 字节码指令地址，如果是执行 native 方法，则是未指定值（undefined）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成&lt;/li>
&lt;li>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令&lt;/li>
&lt;li>它是唯一一个在 JVM 规范中没有规定任何 OutOfMemoryError 情况的区域&lt;/li>
&lt;/ul>
&lt;h3 id="java虚拟机栈">Java虚拟机栈&lt;/h3>
&lt;p>Java虚拟机栈内部保存一个个栈帧(Stack Frame),每个栈帧对应一个被调用的方法,每个栈帧包含了局部变量表(Local Variables)、操作数栈(Operand Stack)、动态链接(Dynamic Linking)、方法返回地址和一些额外的附加信息。&lt;/p>
&lt;p>作用: 主管Java方法的运行，它保存方法的局部变量（8种基本数据类型、对象引用）、部分中间运算结果，并参与方法的调用和返回。&lt;/p>
&lt;p>特点&lt;/p>
&lt;ul>
&lt;li>快速有效的分配存储方式, 访问速度快(仅次于程序计数器)&lt;/li>
&lt;li>JVM对虚拟机栈的操作只有两种:
&lt;ul>
&lt;li>每个方法执行时,创建一个栈帧;&lt;/li>
&lt;li>每个方法执行结束时,销毁一个栈帧&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>栈不存在垃圾回收问题&lt;/li>
&lt;/ul>
&lt;p>JVM规范允许虚拟机栈的大小是动态的或者是固定的&lt;/p>
&lt;ul>
&lt;li>固定大小的虚拟机栈在创建时就被确定,不会改变
&lt;ul>
&lt;li>如果线程请求的栈深度大于虚拟机所允许的深度,将抛出StackOverflowError异常&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>动态扩展的虚拟机栈在栈扩展时无法申请到足够的内存,会抛出OutOfMemoryError异常&lt;/li>
&lt;/ul>
&lt;h4 id="栈帧----栈的存储单位">栈帧 &amp;ndash; 栈的存储单位&lt;/h4>
&lt;ul>
&lt;li>每个线程有自己的栈,栈的数据由栈帧组成&lt;/li>
&lt;li>线程中正在执行的每个方法都对应一个栈帧&lt;/li>
&lt;li>栈帧是一个内存区块,是一个数据集,维系着方法的执行状态&lt;/li>
&lt;/ul>
&lt;p>每个栈帧存储着:&lt;/p>
&lt;ul>
&lt;li>局部变量表(Local Variables)&lt;/li>
&lt;li>操作数栈(Operand Stack): 用于存储方法执行过程中的临时数据&lt;/li>
&lt;li>动态链接(Dynamic Linking): 指向运行时常量池中该栈帧所属方法的引用&lt;/li>
&lt;li>方法返回地址(Method Return Address): 指向方法的调用者&lt;/li>
&lt;li>其他信息&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/JVM/%e6%a0%88%e5%b8%a7%e7%9a%84%e7%bb%93%e6%9e%84.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>TODO:详细的栈帧结构&lt;/p>
&lt;h4 id="栈运行原理">栈运行原理&lt;/h4>
&lt;ul>
&lt;li>JVM对栈的操作:
&lt;ul>
&lt;li>每个方法执行时,创建一个栈帧;&lt;/li>
&lt;li>每个方法执行结束时,销毁一个栈帧&lt;/li>
&lt;li>遵循栈的&amp;quot;先进后出&amp;quot;原则&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>在一个活动线程的某一个时间点上,只有一个活动的栈帧,对应着当前正在执行的方法&lt;/li>
&lt;li>所有字节码指令只针对当前栈帧进行操作&lt;/li>
&lt;li>如果调用了其他方法,会创建新的栈帧,并压入栈顶
&lt;ul>
&lt;li>在方法返回之后,栈帧会被销毁,并且栈顶的栈帧会成为当前栈帧&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>有两种返回指令:
&lt;ul>
&lt;li>一种是正常的方法返回指令,&lt;/li>
&lt;li>另一种是异常返回指令&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="本地方法栈">本地方法栈&lt;/h3>
&lt;p>本地方法栈与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的 Native 方法服务。(C实现的)&lt;/p>
&lt;p>本地方法栈也是线程私有的&lt;/p>
&lt;p>允许线程请求本地方法栈的大小是动态的或者固定的&lt;/p>
&lt;p>具体做法:&lt;/p>
&lt;ul>
&lt;li>在&lt;code>Native Method Stack&lt;/code>中登记native方法&lt;/li>
&lt;li>在&lt;code>Execution Engine&lt;/code>执行时,调用&lt;code>Native Method Stack&lt;/code>中的方法&lt;/li>
&lt;li>和虚拟机有同样的权限&lt;/li>
&lt;/ul>
&lt;p>在 Hotspot JVM 中，直接将本地方法栈和虚拟机栈合二为一&lt;/p>
&lt;h3 id="java堆">Java堆&lt;/h3>
&lt;p>Java堆是Java虚拟机所管理的内存中最大的一块，是被所有线程共享的一块内存区域。&lt;/p>
&lt;p>Java堆是垃圾收集器管理的主要区域，也被称为“GC堆”。&lt;/p>
&lt;p>作用: 存放对象实例，几乎所有的对象实例都在这里分配内存。&lt;/p>
&lt;p>为了高效的进行GC, 堆内存&lt;strong>逻辑上&lt;/strong>被划分为:&lt;/p>
&lt;ul>
&lt;li>新生代(年轻代):
&lt;ul>
&lt;li>新对象&lt;/li>
&lt;li>还没到达一定年龄的对象&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>老年代:
&lt;ul>
&lt;li>被长时间使用的对象&lt;/li>
&lt;li>老年代的内存空间一般比新生代大很多&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>元空间:
&lt;ul>
&lt;li>JDK1.8前是永久代, 占用JVM内存&lt;/li>
&lt;li>JDK1.8后是元空间, 占用系统内存&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>Java 虚拟机规范规定，Java 堆可以是处于物理上不连续的内存空间中，只要逻辑上是连续的即可，像磁盘空间一样。实现时，既可以是固定大小，也可以是可扩展的，主流虚拟机都是可扩展的（通过 -Xmx 和 -Xms 控制），如果堆中没有完成实例分配，并且堆无法再扩展时，就会抛出 OutOfMemoryError 异常&lt;/p>
&lt;h4 id="年轻代">年轻代&lt;/h4>
&lt;p>年轻代分为三个部分(分配一般为8:1:1)&lt;/p>
&lt;ul>
&lt;li>Eden区(伊甸园): 存放新创建的对象&lt;/li>
&lt;li>Survivor区(幸存者区): 存放经过一次GC后仍然存活的对象
&lt;ul>
&lt;li>Survivor区一般有两个, 一个是From, 一个是To&lt;/li>
&lt;li>每次GC后, Eden区和From Survivor区中的存活对象会被复制到To Survivor区&lt;/li>
&lt;li>每次GC后, From Survivor区和To Survivor区会交换角色&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>过程&lt;/p>
&lt;ul>
&lt;li>新创建的对象会被分配到Eden区&lt;/li>
&lt;li>当Eden区满时,会触发一次Minor GC,将Eden区中的存活对象复制到Survivor区&lt;/li>
&lt;li>Minor GC检查Survivor区中的存活对象,将存活对象复制到另一个Survivor区, 所以每次都有一个Survivor区是空的&lt;/li>
&lt;li>经过多次Minor GC后,存活时间较长的对象会被移动到老年代, 通过设定年龄阈值来实现.&lt;/li>
&lt;/ul>
&lt;h4 id="老年代">老年代&lt;/h4>
&lt;p>老年代主要存放经过多次GC仍然存活的对象。&lt;/p>
&lt;p>老年代垃圾收集称为主GC&lt;/p>
&lt;p>大对象直接进入老年代, 这样可以避免在Eden区和两个Survivor区之间来回复制大对象&lt;/p>
&lt;h4 id="元空间">元空间&lt;/h4>
&lt;p>可以看作是 Java 虚拟机规范中方法区的实现。&lt;/p>
&lt;p>虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫 Non-Heap（非堆），目的应该是与 Java 堆区分开。&lt;/p>
&lt;h4 id="设置堆大小-和-oom">设置堆大小 和 OOM&lt;/h4>
&lt;p>通过-Xmx 和 -Xms 控制堆的大小&lt;/p>
&lt;ul>
&lt;li>-Xmx: 最大堆大小&lt;/li>
&lt;li>-Xms: 初始堆大小&lt;/li>
&lt;/ul>
&lt;p>如果堆中没有完成实例分配，并且堆无法再扩展时，就会抛出 OutOfMemoryError 异常&lt;/p>
&lt;p>通常这两个参数设置成一样的值，可以减少堆大小调整的次数，从而提高性能。&lt;/p>
&lt;p>默认情况下，Xmx是物理内存的1/4，Xms是1/64&lt;/p>
&lt;p>堆内存的分配:&lt;/p>
&lt;ul>
&lt;li>新生代:老年代 = 1:2, 通过-XX:NewRatio设置&lt;/li>
&lt;li>新生代中的Eden:From:To = 8:1:1, 通过-XX:SurvivorRatio设置&lt;/li>
&lt;/ul>
&lt;p>每次GC后会重新计算Eden区和Survivor区的大小
计算依据是GC过程中统计的GC时间、吞吐量、内存占用量&lt;/p>
&lt;h4 id="对象在堆的声明周期">对象在堆的声明周期&lt;/h4>
&lt;ul>
&lt;li>对象的创建&lt;/li>
&lt;li>对象被定义了一个 年轻对象计数器&lt;/li>
&lt;li>当Eden空间不足时, Minor GC
&lt;ul>
&lt;li>Eden移动到Survivor区&lt;/li>
&lt;li>所有对象年龄+1&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>如果超过了-XX:PetenureSizeThreshold(默认15次), 分配到老年区&lt;/li>
&lt;/ul>
&lt;h4 id="对象的分配过程">对象的分配过程&lt;/h4>
&lt;ul>
&lt;li>老年区内存不足时, 触发Major GC&lt;/li>
&lt;li>如果Major GC后, 仍然没有足够的内存, 抛出OOM异常&lt;/li>
&lt;/ul>
&lt;h4 id="minor-gcmajor-gcfull-gc">Minor GC、Major GC、Full GC&lt;/h4>
&lt;p>见&lt;a href="###%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e4%b8%8e%e5%9b%9e%e6%94%b6%e7%ad%96%e7%95%a5">内存分配与回收&lt;/a>&lt;/p>
&lt;h4 id="tlabthread-local-allocation-buffer">TLAB(Thread Local Allocation Buffer)&lt;/h4>
&lt;p>从内存模型角度, 对Eden区继续划分, 为每个线程分配一个私有的缓冲区, 在TLAB中分配对象, 减少线程间的竞争
这种内存分配方式称为快速分配策略&lt;/p>
&lt;p>TLAB的意义&lt;/p>
&lt;ul>
&lt;li>堆是线程共享的, 多线程并发分配对象时, 会出现竞争&lt;/li>
&lt;li>对象实例的创建非常频繁, 因此在并发环境下从堆区中划分内存空间是线程不安全的&lt;/li>
&lt;li>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度&lt;/li>
&lt;/ul>
&lt;p>尽管不是所有的对象实例都能够在 TLAB 中成功分配内存，但 JVM 确实是将 TLAB 作为内存分配的首选。&lt;/p>
&lt;h4 id="堆是分配对象的唯一选择吗逃逸分析">堆是分配对象的唯一选择吗？(逃逸分析)&lt;/h4>
&lt;p>不是, 有些对象不会分配到堆中.&lt;/p>
&lt;p>逃逸分析(Escape Analysis)是可以有效减少 Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法.&lt;/p>
&lt;p>通过逃逸分析, 可以分析出一个新的对象的引用的使用范围, 如果发现一个对象的引用并没有逃逸出方法的话, 那么就可以将这个对象在栈上分配, 而不是在堆上分配.&lt;/p>
&lt;p>基本行为, 分析对象动态作用域:&lt;/p>
&lt;ul>
&lt;li>只在方法内部使用, 没有发生逃逸&lt;/li>
&lt;li>被外部方法引用, 发生逃逸
&lt;ul>
&lt;li>如返回值, 赋值给全局变量等&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">static&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">StringBuffer&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">craeteStringBuffer&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s2&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">StringBuffer&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">sb&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">StringBuffer&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">sb&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s1&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">sb&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s2&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">sb&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样是发生逃逸的, 虽然它是一个局部变量,但还有可能被其他方法引用,所以会分配到堆上.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">static&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">createStringBuffer&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s2&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">StringBuffer&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">sb&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">StringBuffer&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">sb&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s1&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">sb&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s2&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">sb&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">toString&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>不直接返回StringBuffer, 而是返回String, 这样就不会发生逃逸, 可以分配到栈上.&lt;/p>
&lt;p>在 JDK 6u23 版本之后，HotSpot 中默认就已经开启了逃逸分析&lt;/p>
&lt;p>编译器可以对代码做优化：&lt;/p>
&lt;ul>
&lt;li>栈上分配：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配&lt;/li>
&lt;li>同步省略：如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步分离对象或&lt;/li>
&lt;li>标量替换：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而存储在 CPU 寄存器&lt;/li>
&lt;/ul>
&lt;h3 id="方法区">方法区&lt;/h3>
&lt;p>方法区(Method Area)是各个线程共享的内存区域，它用于存储&lt;strong>已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码&lt;/strong>等数据。&lt;/p>
&lt;p>Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是方法区有一个别名叫 Non-Heap（非堆），目的应该是与 Java 堆区分开。&lt;/p>
&lt;p>常量池是方法区的一部分，用于存放编译期生成的各种字面量和符号引用。&lt;/p>
&lt;p>方法区的大小可以固定也可以扩展&lt;/p>
&lt;p>方法区（method area）只是 JVM 规范中定义的一个概念，用于存储类信息、常量池、静态变量、JIT编译后的代码等数据，并没有规定如何去实现它，不同的厂商有不同的实现。而永久代（PermGen）是 Hotspot 虚拟机特有的概念， Java8 的时候又被元空间取代了，永久代和元空间都可以理解为方法区的落地实现。&lt;/p>
&lt;p>永久代物理是堆的一部分，和新生代，老年代地址是连续的（受垃圾回收器管理），而元空间存在于本地内存（我们常说的堆外内存，不受垃圾回收器管理），这样就不受 JVM 限制了，也比较难发生OOM（都会有溢出异常）&lt;/p>
&lt;h4 id="方法区的内部结构">方法区的内部结构&lt;/h4>
&lt;p>方法区用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。&lt;/p>
&lt;p>类型信息: 类型的全限定名、字段、方法、接口等信息&lt;/p>
&lt;p>域信息: 域的名称、类型、修饰符等信息&lt;/p>
&lt;p>方法信息: 方法的名称、参数、返回值、修饰符等信息&lt;/p>
&lt;h4 id="运行时常量池">运行时常量池&lt;/h4>
&lt;p>JVM 为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的&lt;/p>
&lt;h4 id="todo-方法区的垃圾回收">TODO: 方法区的垃圾回收&lt;/h4>
&lt;h3 id="java对象在内存中的布局">Java对象在内存中的布局&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/JVM/Java%e5%af%b9%e8%b1%a1%e5%9c%a8%e5%86%85%e5%ad%98%e4%b8%ad%e7%9a%84%e5%b8%83%e5%b1%80.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;ul>
&lt;li>对象头(Header)
&lt;ul>
&lt;li>Mark Word: 存储对象的hashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等信息&lt;/li>
&lt;li>Class Metadata Address: 类型指针指向对象的类元数据，JVM通过这个指针确定该对象是哪个类的实例&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>实例数据(Instance Data)
&lt;ul>
&lt;li>存储对象真正有效的数据信息&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>对齐填充(Padding)
&lt;ul>
&lt;li>由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，填充数据不是必然存在的，仅仅是为了字节对齐&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="jvm垃圾回收机制">JVM垃圾回收机制&lt;/h2>
&lt;h3 id="判断一个对象是否可被回收">判断一个对象是否可被回收&lt;/h3>
&lt;h4 id="引用计数法">引用计数法&lt;/h4>
&lt;p>引用计数法是一种最直观的判断对象是否可被回收的方法，它的基本思想是通过引用计数来判断一个对象是否可袝回收。&lt;/p>
&lt;p>但由于循环引用的存在，这种方法并不可靠,JVM不使用&lt;/p>
&lt;h4 id="可达性分析法">可达性分析法&lt;/h4>
&lt;p>通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/JVM/GC%20Roots.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>GC Roots 一般包括:&lt;/p>
&lt;ul>
&lt;li>虚拟机栈中引用的对象&lt;/li>
&lt;li>本地方法栈中引用的对象&lt;/li>
&lt;li>方法区中类静态属性引用的对象&lt;/li>
&lt;li>方法区中常量引用的对象&lt;/li>
&lt;/ul>
&lt;h4 id="方法区的回收">方法区的回收&lt;/h4>
&lt;p>因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，因此在方法区上进行回收性价比不高。&lt;/p>
&lt;p>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型。&lt;/p>
&lt;p>在大量使用反射、动态代理、CGLib 等 ByteCode 框架、动态生成 JSP 以及 OSGi 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载功能，以保证不会出现内存溢出。&lt;/p>
&lt;p>方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近 Java 语言层次的常量概念，如文本字符串、被声明为 final 的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：类和接口的全限定名字段的名称和描述符方法的名称和描述符&lt;/p>
&lt;p>HotSpot 虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收&lt;/p>
&lt;p>判定一个类型是否属于“不再被使用的类”，需要同时满足三个条件：&lt;/p>
&lt;ul>
&lt;li>该类所有的实例都已经被回收，也就是堆中不存在该类的任何实例。&lt;/li>
&lt;li>加载该类的 ClassLoader 已经被回收。&lt;/li>
&lt;li>该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。&lt;/li>
&lt;/ul>
&lt;h4 id="finalize方法">finalize()方法&lt;/h4>
&lt;p>finalize() 类似于 C++中的析构函数，用于对象在被垃圾收集器回收之前调用。&lt;/p>
&lt;p>当一个对象可被回收时，垃圾收集器会调用该对象的 finalize() 方法，然后回收该对象。&lt;/p>
&lt;p>通过finalize()方法，可以使对象在被回收之前进行一些清理工作，比如关闭文件、释放资源等。(自救,但只能进行一次)&lt;/p>
&lt;h3 id="引用类型">引用类型&lt;/h3>
&lt;h4 id="强引用">强引用&lt;/h4>
&lt;p>强引用是指在程序代码之中普遍存在的，类似“Object obj = new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收被引用的对象。&lt;/p>
&lt;h4 id="软引用">软引用&lt;/h4>
&lt;p>被软引用关联的对象，只有在内存不足的时候才会被回收。&lt;/p>
&lt;p>通过 SoftReference 类来实现软引用。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="n">SoftReference&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Object&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">softRef&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">SoftReference&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Object&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Object&lt;/span>&lt;span class="p">());&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="弱引用">弱引用&lt;/h4>
&lt;p>被弱引用关联的对象，只能生存到下一次垃圾收集发生之前。&lt;/p>
&lt;p>通过 WeakReference 类来实现弱引用。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="n">WeakReference&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Object&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">weakRef&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">WeakReference&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Object&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Object&lt;/span>&lt;span class="p">());&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="虚引用">虚引用&lt;/h4>
&lt;p>虚引用是最弱的一种引用关系，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获取一个对象实例。&lt;/p>
&lt;p>为一个对象设置虚引用的唯一目的是能在这个对象被收集器回收时收到一个系统通知。&lt;/p>
&lt;p>通过 PhantomReference 类来实现虚引用。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="n">ReferenceQueue&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Object&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">rq&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ReferenceQueue&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Object&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">PhantomReference&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Object&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">pr&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">PhantomReference&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Object&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Object&lt;/span>&lt;span class="p">(),&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">rq&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="垃圾收集算法">垃圾收集算法&lt;/h3>
&lt;h4 id="标记-清除算法">标记-清除算法&lt;/h4>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/JVM/%e6%a0%87%e8%ae%b0%e6%b8%85%e9%99%a4.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>将所有存活的对象标记，然后清除所有未标记的对象。&lt;/p>
&lt;p>缺点:&lt;/p>
&lt;ul>
&lt;li>标记和清除的效率都不高&lt;/li>
&lt;li>标记清除之后会产生大量不连续的内存碎片&lt;/li>
&lt;/ul>
&lt;h4 id="标记-整理算法">标记-整理算法&lt;/h4>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/JVM/%e6%a0%87%e8%ae%b0%e6%95%b4%e7%90%86.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>标记-整理算法是标记-清除算法的升级版，它在标记阶段完成后，会将存活的对象向一端移动，然后直接清理掉边界外的内存。&lt;/p>
&lt;h4 id="复制算法">复制算法&lt;/h4>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/JVM/%e5%a4%8d%e5%88%b6.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>将内存分为两块，每次只使用其中一块，当这一块内存用完了，就将还存活的对象复制到另一块内存上，然后清理掉原来的内存。&lt;/p>
&lt;p>缺点:&lt;/p>
&lt;ul>
&lt;li>内存使用率低&lt;/li>
&lt;li>适用于新生代&lt;/li>
&lt;/ul>
&lt;h4 id="分代收集算法">分代收集算法&lt;/h4>
&lt;p>根据对象存活周期的不同将内存划分为几块，一般是把堆分为新生代和老年代，根据各个年代的特点采用最适当的收集算法。&lt;/p>
&lt;h3 id="垃圾收集器">垃圾收集器&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/JVM/HotSpot%e7%9a%84%e4%b8%83%e4%b8%aa%e5%9e%83%e5%9c%be%e6%94%b6%e9%9b%86%e5%99%a8.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>可以从两个维度来划分：&lt;/p>
&lt;ul>
&lt;li>单线程和多线程: 单线程收集器只会使用一个线程进行垃圾回收，而多线程收集器则会使用多个线程进行垃圾回收。&lt;/li>
&lt;li>串行和并行: 串行收集器是指在垃圾回收时只使用一个线程，而并行收集器则是指在垃圾回收时使用多个线程。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。&lt;/li>
&lt;/ul>
&lt;h4 id="serial收集器">Serial收集器&lt;/h4>
&lt;p>单线程、串行、Client模型的默认新生代收集器&lt;/p>
&lt;p>优点：简单高效，对于单个CPU环境来说，没有线程交互的开销，可以获得最高的单线程收集效率。&lt;/p>
&lt;h4 id="parnew收集器">ParNew收集器&lt;/h4>
&lt;p>Serial收集器的多线程版本，Server模式下的默认新生代收集器&lt;/p>
&lt;p>除了Serial外，只有它能和CMS收集器配合工作&lt;/p>
&lt;h4 id="parallel-scavenge收集器">Parallel Scavenge收集器&lt;/h4>
&lt;p>其它收集器关注点是尽可能&lt;strong>缩短垃圾收集时用户线程的停顿时间&lt;/strong>，而它的目标是达到一个&lt;strong>可控制的吞吐量&lt;/strong>，它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户代码的时间占总时间的比值。&lt;/p>
&lt;p>缩短停顿时间是以牺牲吞吐量和新生代空间来换取的: 新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。&lt;/p>
&lt;p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。&lt;/p>
&lt;h4 id="serial-old收集器">Serial Old收集器&lt;/h4>
&lt;p>Serial收集器的老年代版本，使用单线程进行垃圾回收&lt;/p>
&lt;h4 id="parallel-old收集器">Parallel Old收集器&lt;/h4>
&lt;p>Parallel Scavenge收集器的老年代版本，使用多线程进行垃圾回收&lt;/p>
&lt;h4 id="cms收集器">CMS收集器&lt;/h4>
&lt;p>CMS（Concurrent Mark-Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，它非常符合那些集中在互联网站或者 B/S 系统的服务端上的 Java 应用，这些应用都非常重视服务的响应速度。&lt;/p>
&lt;p>Mark-Sweep（标记-清除）算法是 CMS 收集器的核心，它是一种获取最短回收停顿时间为目标的收集算法。&lt;/p>
&lt;p>流程：&lt;/p>
&lt;ul>
&lt;li>初始标记: 仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿&lt;/li>
&lt;li>并发标记: 进行 GC Roots Tracing 的过程， 耗时最长，不需要停顿&lt;/li>
&lt;li>重新标记: 为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，需要停顿&lt;/li>
&lt;li>并发清除: 与标记过程并发执行，不需要停顿&lt;/li>
&lt;/ul>
&lt;p>缺点&lt;/p>
&lt;ul>
&lt;li>吞吐量低&lt;/li>
&lt;li>无法处理浮动垃圾&lt;/li>
&lt;li>由于 CMS 收集器是基于标记-清除算法实现的，所以在清除阶段会产生大量的空间碎片&lt;/li>
&lt;/ul>
&lt;h4 id="g1收集器">G1收集器&lt;/h4>
&lt;p>G1（Garbage-First）收集器是一种面向服务端应用的垃圾收集器，适用于多核处理器和大容量内存的环境。&lt;/p>
&lt;p>G1 收集器的设计目标是取代 CMS 收集器，它同样是一种并发并行的垃圾收集器。&lt;/p>
&lt;p>堆被分为新生代和老年代，G1引入了Region的概念，将堆内存分为多个大小相等的Region，每个Region都有一个分代的角色，新生代和老年代不再是物理隔离的，而是逻辑上的概念。&lt;/p>
&lt;p>G1 收集器的运作大致可划分为以下几个步骤:&lt;/p>
&lt;ul>
&lt;li>初始标记&lt;/li>
&lt;li>并发标记&lt;/li>
&lt;li>最终标记: 为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。&lt;/li>
&lt;li>筛选回收: 首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。&lt;/li>
&lt;/ul>
&lt;p>具备如下特点:&lt;/p>
&lt;ul>
&lt;li>空间整合: 整体来看是基于“&lt;strong>标记-整理&lt;/strong>”算法实现的收集器，从局部(两个 Region 之间)上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。&lt;/li>
&lt;li>可预测的停顿: 能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。&lt;/li>
&lt;/ul>
&lt;p>CMS更适合低延迟、对停顿时间敏感的应用,如web服务器、交易系统等。
G1更适合中大型堆、需要良好的吞吐量和可预测停顿时间的应用,如大数据处理系统、游戏服务器等。&lt;/p>
&lt;h3 id="内存分配与回收策略">内存分配与回收策略&lt;/h3>
&lt;p>针对HotSpot虚拟机,按照回收区域分为两大类:&lt;/p>
&lt;ul>
&lt;li>部分收集
&lt;ul>
&lt;li>Minor GC/Young GC: 新生代的GC&lt;/li>
&lt;li>Major GC/Old GC: 老年代的GC
&lt;ul>
&lt;li>目前,只有CMS GC会有单独的Major GC&lt;/li>
&lt;li>很多时候, Major GC会和Full GC混在一起&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Mixed GC: 混合收集, 收集整个新生代和部分老年代
&lt;ul>
&lt;li>目前只有G1收集器会有Mixed GC&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>整堆收集
&lt;ul>
&lt;li>Full GC: 整堆收集,整个Java堆和方法区的垃圾&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>Major GC（Major Garbage Collection）和Mixed GC（Mixed Garbage Collection）是两种不同的垃圾回收机制，它们在执行时的行为和目标有所不同。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-md" data-lang="md">&lt;span class="line">&lt;span class="cl"> Major GC（也称为Full GC）是一种针对整个堆内存执行的垃圾回收操作。它的目标是清理整个堆内存，并回收无用对象。Major GC通常在堆内存空间不足或触发显式的垃圾回收请求时执行。它会停止应用程序的执行，并对整个堆内存进行标记和清理。Major GC的过程包括标记阶段和清理阶段，通过标记可达对象和清理未标记的对象来回收内存空间。
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Mixed GC（也称为Incremental GC）是一种结合了部分收集和全收集的垃圾回收操作。它的目标是在不完全停止应用程序的情况下，尽可能回收垃圾对象。Mixed GC通过将堆内存划分为多个区域（如年轻代和老年代的不同区域）来实现增量的回收。它会在应用程序执行的同时，对某些区域进行标记和清理操作。这样可以减少垃圾回收的停顿时间，提高应用程序的响应性能。
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 区别总结如下：
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 范围：Major GC是对整个堆内存执行的垃圾回收操作，而Mixed GC是对部分堆内存区域执行的垃圾回收操作。
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 目标：Major GC的目标是清理整个堆内存，并回收无用对象；Mixed GC的目标是在不完全停止应用程序的情况下，尽可能回收垃圾对象。
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 执行方式：Major GC会停止应用程序的执行，执行全面的标记和清理操作；Mixed GC会在应用程序执行的同时，对某些区域进行增量式的标记和清理操作。
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 停顿时间：Major GC的停顿时间较长，会导致应用程序的暂停；Mixed GC采用增量式的回收，可以减少垃圾回收的停顿时间，提高应用程序的响应性能。
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Java虚拟机和垃圾收集器的实现可以根据具体的需求和性能目标选择使用Major GC、Mixed GC或它们的组合来进行垃圾回收操作。
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="内存分配策略">内存分配策略&lt;/h4>
&lt;ul>
&lt;li>对象优先在Eden区分配&lt;/li>
&lt;li>大对象直接进入老年代&lt;/li>
&lt;li>长期存活的对象进入老年代&lt;/li>
&lt;li>动态对象年龄判定
&lt;ul>
&lt;li>如果在Eden区中经过一次Minor GC后,存活对象会被移动到Survivor区&lt;/li>
&lt;li>经过多次Minor GC后,存活时间较长的对象会被移动到老年代, 通过设定年龄阈值来实现.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>空间分配担保
&lt;ul>
&lt;li>在发生Minor GC之前,虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间&lt;/li>
&lt;li>如果条件成立,则Minor GC可以确保是安全的&lt;/li>
&lt;li>如果不成立,则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败
&lt;ul>
&lt;li>如果允许,则进行一次Full GC&lt;/li>
&lt;li>如果不允许,则改为进行一次Full GC&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="full-gc-的触发条件">Full GC 的触发条件&lt;/h4>
&lt;ul>
&lt;li>调用 System.gc() 方法&lt;/li>
&lt;li>老年代空间不足&lt;/li>
&lt;li>空间分配担保失败&lt;/li>
&lt;li>CMS GC时出现Promotion Failure&lt;/li>
&lt;/ul>
&lt;h2 id="jvm的内存模型">jvm的内存模型&lt;/h2>
&lt;h3 id="什么叫零拷贝">什么叫零拷贝&lt;/h3>
&lt;p>零拷贝（Zero Copy）是一种数据传输技术，它可以在不需要将数据从一个缓冲区复制到另一个缓冲区的情况下，将数据从一个地方传输到另一个地方。在零拷贝技术中，数据可以直接从磁盘、网络或其他设备中读取，然后通过DMA（Direct Memory Access）技术直接写入内存中，从而避免了数据的多次复制，提高了数据传输的效率。&lt;/p>
&lt;p>在Java中，零拷贝技术可以通过NIO（New I/O）来实现。NIO提供了一种基于通道（Channel）和缓冲区（Buffer）的I/O模型，可以直接将数据从通道中读取到缓冲区中，或者将缓冲区中的数据直接写入通道中，从而避免了数据的多次复制。&lt;/p>
&lt;h3 id="为什么用常量池有哪些常量池">为什么用常量池，有哪些常量池&lt;/h3>
&lt;p>&lt;a href="https://blog.csdn.net/qq_41376740/article/details/80338158" target="_blank" rel="noopener">https://blog.csdn.net/qq_41376740/article/details/80338158&lt;/a>&lt;/p>
&lt;p>常量池是Java中的一种特殊的内存区域，用于存储常量和符号引用。在Java中，常量池主要有以下几种：&lt;/p>
&lt;ol>
&lt;li>字面量常量池：用于存储字符串、数字等字面量常量。&lt;/li>
&lt;li>符号引用常量池：用于存储类、方法、字段等符号引用。&lt;/li>
&lt;li>运行时常量池：用于存储在类加载时解析的常量池信息，包括字面量常量池和符号引用常量池中的内容。&lt;/li>
&lt;/ol>
&lt;p>使用常量池的主要目的是为了提高程序的性能和减少内存的占用。由于常量池中的常量是唯一的，因此可以避免重复创建相同的常量对象，从而减少内存的占用。同时，由于常量池中的常量是在编译期间就确定的，因此可以在运行时直接使用，避免了重复计算和创建对象的开销，提高了程序的性能。&lt;/p></description></item></channel></rss>