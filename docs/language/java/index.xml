<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>java | Ysyy's</title><link>https://ysyyhhh.github.io/docs/language/java/</link><atom:link href="https://ysyyhhh.github.io/docs/language/java/index.xml" rel="self" type="application/rss+xml"/><description>java</description><generator>Hugo Blox Builder (https://hugoblox.com)</generator><language>en-us</language><image><url>https://ysyyhhh.github.io/media/logo.svg</url><title>java</title><link>https://ysyyhhh.github.io/docs/language/java/</link></image><item><title/><link>https://ysyyhhh.github.io/docs/language/java/javaio/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/language/java/javaio/</guid><description>&lt;h1 id="java-io">Java IO&lt;/h1>
&lt;h2 id="java-io流介绍">Java IO流介绍&lt;/h2>
&lt;p>Java IO流主要分为字节流和字符流，字节流主要用于处理二进制文件，字符流主要用于处理文本文件。&lt;/p>
&lt;p>四个抽象类：&lt;/p>
&lt;ul>
&lt;li>InputStream：字节输入流&lt;/li>
&lt;li>OutputStream：字节输出流&lt;/li>
&lt;li>Reader：字符输入流&lt;/li>
&lt;li>Writer：字符输出流&lt;/li>
&lt;/ul>
&lt;h3 id="字节流">字节流&lt;/h3>
&lt;p>字节流主要用于处理二进制文件，如图片、视频、音频等。&lt;/p>
&lt;p>FileInputStream和FileOutputStream是两个基本的字节流，用于读写文件。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">FileInputStreamTest&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">static&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">args&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">try&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">FileInputStream&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">fis&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">FileInputStream&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;test.txt&amp;#34;&lt;/span>&lt;span class="p">))&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">while&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">fis&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">read&lt;/span>&lt;span class="p">())&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">!=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">print&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="kt">char&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">catch&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">IOException&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">printStackTrace&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">FileOutputStreamTest&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">static&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">args&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">try&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">FileOutputStream&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">fos&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">FileOutputStream&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;test.txt&amp;#34;&lt;/span>&lt;span class="p">))&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">str&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;Hello, World!&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kt">byte&lt;/span>&lt;span class="o">[]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">bytes&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">str&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">getBytes&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">fos&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">write&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">bytes&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">catch&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">IOException&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">printStackTrace&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="字符流">字符流&lt;/h3>
&lt;p>字符流主要用于处理文本文件，如txt文件。&lt;/p>
&lt;p>为什么会有字符流&lt;/p>
&lt;ul>
&lt;li>字节流是以字节为单位读写数据，而字符流是以字符为单位读写数据&lt;/li>
&lt;li>字节流读取中文字符时可能会出现乱码，而字符流不会出现乱码&lt;/li>
&lt;/ul>
&lt;p>字符流默认采用unicode编码，可以指定编码格式。&lt;/p>
&lt;p>常用字符编码所占字节数&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>编码格式&lt;/th>
&lt;th>中文字符所占字节数&lt;/th>
&lt;th>英文字符所占字节数&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>GBK&lt;/td>
&lt;td>2&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>UTF-8&lt;/td>
&lt;td>3&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>UTF-16&lt;/td>
&lt;td>2&lt;/td>
&lt;td>2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>unicode&lt;/td>
&lt;td>2&lt;/td>
&lt;td>2&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>FileReader和FileWriter是两个基本的字符流，用于读写文件。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">FileReaderTest&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">static&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">args&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">try&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">FileReader&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">fr&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">FileReader&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;test.txt&amp;#34;&lt;/span>&lt;span class="p">))&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">while&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">fr&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">read&lt;/span>&lt;span class="p">())&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">!=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">print&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="kt">char&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">catch&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">IOException&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">printStackTrace&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">FileWriterTest&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">static&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">args&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">try&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">FileWriter&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">fw&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">FileWriter&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;test.txt&amp;#34;&lt;/span>&lt;span class="p">))&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">str&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;Hello, World!&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">fw&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">write&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">str&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">catch&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">IOException&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">printStackTrace&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="字节缓冲流">字节缓冲流&lt;/h3>
&lt;p>字节缓冲流主要用于提高读写文件的效率。&lt;/p>
&lt;p>BufferedInputStream和BufferedOutputStream是两个基本的字节缓冲流，用于读写文件。&lt;/p>
&lt;p>BufferedInputStream 内部维护了一个缓冲区，这个缓冲区实际就是一个字节数组，通过阅读 BufferedInputStream 源码即可得到这个结论.
缓冲器默认大小为 8192 字节，也就是 8KB，这个大小是可以通过构造函数来指定的。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">BufferedInputStream&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">extends&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">FilterInputStream&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 内部缓冲区数组&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">protected&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">volatile&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">byte&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="o">[]&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 缓冲区的默认大小&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">static&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">DEFAULT_BUFFER_SIZE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">8192&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 使用默认的缓冲区大小&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">BufferedInputStream&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">InputStream&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">in&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">in&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">DEFAULT_BUFFER_SIZE&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 自定义缓冲区大小&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">BufferedInputStream&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">InputStream&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">in&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">size&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">super&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">in&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">if&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">size&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;lt;=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">throw&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">IllegalArgumentException&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Buffer size &amp;lt;= 0&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">byte&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">size&lt;/span>&lt;span class="o">]&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="字符缓冲流">字符缓冲流&lt;/h3>
&lt;p>字符缓冲流主要用于提高读写文件的效率。&lt;/p>
&lt;h3 id="打印流">打印流&lt;/h3>
&lt;p>PrintStream和PrintWriter是两个基本的打印流，用于打印数据。&lt;/p>
&lt;p>System.out实际是获取了一个PrintStream对象，System.out.println()实际是调用了PrintStream对象的println()方法。&lt;/p>
&lt;h3 id="随机访问流">随机访问流&lt;/h3>
&lt;p>RandomAccessFile是一个基本的随机访问流，用于读写文件, 支持随机访问文件。
RandomAccessFile 的构造方法如下&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">RandomAccessFile&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">mode&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">throws&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">FileNotFoundException&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">!=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">?&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">File&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">mode&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>mode 参数指定了 RandomAccessFile 的访问模式，有 &amp;ldquo;r&amp;rdquo;、&amp;ldquo;rw&amp;rdquo;、&amp;ldquo;rws&amp;rdquo;、&amp;ldquo;rwd&amp;rdquo; 四种模式，分别表示：&lt;/p>
&lt;ul>
&lt;li>&amp;ldquo;r&amp;rdquo;：以只读方式打开&lt;/li>
&lt;li>&amp;ldquo;rw&amp;rdquo;：以读写方式打开&lt;/li>
&lt;li>&amp;ldquo;rws&amp;rdquo;：以读写方式打开，对文件的内容或元数据的每个更新都同步写入到底层存储设备&lt;/li>
&lt;li>&amp;ldquo;rwd&amp;rdquo;：以读写方式打开，对文件内容的每个更新都同步写入到底层存储设备&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">RandomAccessFileTest&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">static&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">args&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">try&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">RandomAccessFile&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">raf&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">RandomAccessFile&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;test.txt&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;rw&amp;#34;&lt;/span>&lt;span class="p">))&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">raf&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">write&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Hello, World!&amp;#34;&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">getBytes&lt;/span>&lt;span class="p">());&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">raf&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">seek&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kt">byte&lt;/span>&lt;span class="o">[]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">bytes&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">byte&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">1024&lt;/span>&lt;span class="o">]&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">len&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">while&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="n">len&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">raf&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">read&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">bytes&lt;/span>&lt;span class="p">))&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">!=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">bytes&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">len&lt;/span>&lt;span class="p">));&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">catch&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">IOException&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">printStackTrace&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="io中的设计模式">IO中的设计模式&lt;/h2>
&lt;h3 id="装饰器模式">装饰器模式&lt;/h3>
&lt;p>装饰器模式是一种结构型设计模式，允许你通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。&lt;/p>
&lt;p>装饰器模式的主要优点有：&lt;/p>
&lt;ul>
&lt;li>可以在不修改现有对象的情况下，动态地给一个对象增加一些额外的功能&lt;/li>
&lt;li>可以使用多个装饰器包装一个对象，得到功能更加强大的对象&lt;/li>
&lt;/ul>
&lt;p>字节流和字符流的装饰器模式
FilterInputStream和FilterOutputStream是两个基本的装饰器，用于装饰字节流。&lt;/p>
&lt;h3 id="适配器模式">适配器模式&lt;/h3>
&lt;p>适配器模式是一种结构型设计模式，它能使接口不兼容的对象能够相互合作。&lt;/p>
&lt;p>InputStreamReader和OutputStreamWriter是两个基本的适配器，用于适配字节流和字符流。&lt;/p>
&lt;p>InputStreamReader是字节流到字符流的适配器，OutputStreamWriter是字符流到字节流的适配器。&lt;/p>
&lt;h3 id="观察者模式">观察者模式&lt;/h3>
&lt;p>观察者模式是一种行为型设计模式，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。&lt;/p>
&lt;p>NIO中的文件监听器就是观察者模式的一种应用。&lt;/p>
&lt;p>NIO中的文件监听器基于WatchService接口和Watchable接口.&lt;/p>
&lt;h3 id="工厂模式">工厂模式&lt;/h3>
&lt;p>Files类的newInputStream()和newOutputStream()方法就是工厂模式的一种应用。&lt;/p>
&lt;h2 id="io模型">IO模型&lt;/h2>
&lt;p>IO操作的本质是数据的输入和输出，而IO模型是操作系统对IO操作的抽象。
平时接触最多的是磁盘IO和网络IO。&lt;/p>
&lt;p>UNIX系统下, IO模型有五种：&lt;/p>
&lt;ul>
&lt;li>同步阻塞IO&lt;/li>
&lt;li>同步非阻塞IO&lt;/li>
&lt;li>IO复用&lt;/li>
&lt;li>信号驱动IO&lt;/li>
&lt;li>异步IO&lt;/li>
&lt;/ul>
&lt;h3 id="java中的三种常见io">Java中的三种常见IO&lt;/h3>
&lt;ul>
&lt;li>BIO（Blocking IO）：同步阻塞IO&lt;/li>
&lt;li>NIO（Non-blocking IO）：同步非阻塞IO&lt;/li>
&lt;li>AIO（Asynchronous IO）：异步IO&lt;/li>
&lt;/ul>
&lt;p>BIO（Blocking IO）：同步阻塞IO&lt;/p>
&lt;ul>
&lt;li>一个线程只能处理一个连接&lt;/li>
&lt;li>适用于连接数较少的场景&lt;/li>
&lt;/ul>
&lt;p>当有大量的连接时，BIO的效率会很低，因为每个连接都需要一个线程来处理。&lt;/p>
&lt;p>IO多路复用（IO Multiplexing）：IO复用
线程首先发起IO请求，然后阻塞在IO复用器上，当IO复用器检测到有IO事件时，线程才会被唤醒。&lt;/p>
&lt;p>NIO（Non-blocking IO）：同步非阻塞IO&lt;/p>
&lt;p>NIO是一种同步非阻塞IO模型，适用于连接数较多的场景。
NIO的核心是Selector，Selector可以同时监控多个通道的IO事件。&lt;/p>
&lt;p>AIO（Asynchronous IO）：异步IO
AIO是一种异步IO模型，适用于连接数较多且数据量较大的场景。&lt;/p>
&lt;h2 id="javanio">JavaNIO&lt;/h2>
&lt;p>NIO的核心组件&lt;/p>
&lt;ul>
&lt;li>Channel: 通道, 用于读写数据&lt;/li>
&lt;li>Buffer: 缓冲区, 用于存储数据&lt;/li>
&lt;li>Selector: 多路复用器, 用于监控多个通道的IO事件&lt;/li>
&lt;/ul>
&lt;h3 id="nio零拷贝">NIO零拷贝&lt;/h3>
&lt;p>零拷贝是指数据在内存和磁盘之间传输时，不需要在中间进行数据拷贝。&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/language/java/java%E9%9B%86%E5%90%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/language/java/java%E9%9B%86%E5%90%88/</guid><description>&lt;h1 id="java集合体系">Java集合体系&lt;/h1>
&lt;p>Java 集合， 也叫作容器，主要是由两大接口派生而来：一个是 Collection接口，主要用于存放单一元素；另一个是 Map 接口，主要用于存放键值对。对于Collection 接口，下面又有三个主要的子接口：List、Set 和 Queue。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Java%e9%9b%86%e5%90%88/Java%e9%9b%86%e5%90%88%e7%9a%84%e7%bb%93%e6%9e%84.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>List: 有序，可重复&lt;/p>
&lt;ul>
&lt;li>ArrayList: Object[] 数组, 查询快, 增删慢&lt;/li>
&lt;li>Vector: Object[] 数组, 线程安全(与ArrayList区别)&lt;/li>
&lt;li>LinkedList: 双向链表, 查询慢, 增删快&lt;/li>
&lt;/ul>
&lt;p>Set: 元素不可重复&lt;/p>
&lt;ul>
&lt;li>HashSet: 基于HashMap实现, 无序&lt;/li>
&lt;li>TreeSet: 红黑树(自平衡的二叉查找树), 有序&lt;/li>
&lt;li>LinkedHashSet: 基于LinkedHashMap实现, 是HashSet的子类, 有序&lt;/li>
&lt;/ul>
&lt;p>Queue: 有序，可重复, 用于存放队列元素&lt;/p>
&lt;ul>
&lt;li>PriorityQueue: 优先级队列, Object[] 数组&lt;/li>
&lt;li>DelayQueue: 延迟队列, 用于存放延迟元素&lt;/li>
&lt;li>ArrayDeque: 双端队列, Object[] 数组&lt;/li>
&lt;/ul>
&lt;p>Map: 无序，不可重复，键值对&lt;/p>
&lt;ul>
&lt;li>HashMap: JDK1.8之前是数组+链表, JDK1.8之后是数组+链表/红黑树&lt;/li>
&lt;li>LinkedHashMap: 基于HashMap实现, 有序&lt;/li>
&lt;li>TreeMap: 红黑树(自平衡的二叉查找树), 有序&lt;/li>
&lt;li>Hashtable: 数组(主体)+链表(解决哈希冲突), 线程安全&lt;/li>
&lt;/ul>
&lt;p>如何选用集合&lt;/p>
&lt;ul>
&lt;li>要键值对 - Map
&lt;ul>
&lt;li>需要排序 - TreeMap&lt;/li>
&lt;li>不需要排序 - HashMap&lt;/li>
&lt;li>需要线程安全 - Hashtable&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>不需要键值对 - Collection
&lt;ul>
&lt;li>保证元素唯一 - Set
&lt;ul>
&lt;li>需要排序 - TreeSet&lt;/li>
&lt;li>不需要排序 - HashSet&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>允许重复元素 - List
&lt;ul>
&lt;li>需要高效的增删 - LinkedList&lt;/li>
&lt;li>需要高效的查询 - ArrayList&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="list">List&lt;/h2>
&lt;p>ArrayList 与 Array比较&lt;/p>
&lt;ul>
&lt;li>ArrayList是数组的封装，可以动态扩容，而数组是静态的&lt;/li>
&lt;li>ArrayList允许使用泛型&lt;/li>
&lt;/ul>
&lt;p>ArrayList 与 Vector比较&lt;/p>
&lt;ul>
&lt;li>ArrayList是非线程安全的，而Vector是线程安全的&lt;/li>
&lt;li>ArrayList是JDK1.2引入的(主要实现类,新)，而Vector是JDK1.0引入的&lt;/li>
&lt;/ul>
&lt;p>ArrayList&lt;/p>
&lt;ul>
&lt;li>底层是数组,支持随机访问&lt;/li>
&lt;li>可以添加null元素&lt;/li>
&lt;li>插入:
&lt;ul>
&lt;li>头部插入: O(n)&lt;/li>
&lt;li>尾部插入: O(1), 扩容时O(n),每次扩容是原来的1.5倍&lt;/li>
&lt;li>指定位置插入: O(n)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>删除:
&lt;ul>
&lt;li>只有尾部删除是O(1), 其他都是O(n)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>LinkedList&lt;/p>
&lt;ul>
&lt;li>底层是双向链表, 不支持随机访问&lt;/li>
&lt;li>头部和尾部的插入删除都是O(1)&lt;/li>
&lt;li>一般不使用,作者都不使用&lt;/li>
&lt;/ul>
&lt;h2 id="set">Set&lt;/h2>
&lt;p>对集合进行排序时,需要实现Comparable接口,重写compareTo方法&lt;/p>
&lt;p>集合的不可重复性是通过equals方法来判断的, 需要重写equals方法和hashCode方法&lt;/p>
&lt;h4 id="hashset了解过吗">hashset了解过吗&lt;/h4>
&lt;p>HashSet是一种基于哈希表的Set实现，其底层实现与HashMap类似，只不过HashSet中存储的是不重复的元素。HashSet中的元素是无序的，不保证元素的插入顺序和遍历顺序一致。&lt;/p>
&lt;h4 id="判断某对象是否在set中存在需要重写哪些方法">判断某对象是否在set中存在，需要重写哪些方法&lt;/h4>
&lt;p>为了判断某个对象是否在Set中存在，需要重写该对象的hashCode()和equals()方法。hashCode()方法用于计算对象的哈希值，equals()方法用于比较两个对象是否相等。在重写这两个方法时，需要保证相等的对象具有相同的哈希值，否则会导致Set中出现重复元素。&lt;/p>
&lt;h2 id="queue">Queue&lt;/h2>
&lt;p>ArrayDeque 和 LinkedList的区别&lt;/p>
&lt;ul>
&lt;li>都实现了Deque接口&lt;/li>
&lt;li>ArrayDeque是数组实现的双端队列, 随机访问快, 队列操作慢；LinkedList是双向链表实现的双端队列, 队列操作快&lt;/li>
&lt;li>ArrayDeque不支持null元素, LinkedList支持&lt;/li>
&lt;li>ArrayDeque存在扩容，但均摊快；LinkedList不存在，每次插入需要申请空间，均摊慢。&lt;/li>
&lt;/ul>
&lt;h3 id="priorityqueue">PriorityQueue&lt;/h3>
&lt;p>JDK1.5 引入的&lt;/p>
&lt;ul>
&lt;li>底层是堆, 默认是小顶堆, 可以通过传入Comparator来实现大顶堆&lt;/li>
&lt;li>是插入删除是O(logn)，查顶推是O(1)&lt;/li>
&lt;li>是非线程安全的，不支持null元素&lt;/li>
&lt;/ul>
&lt;p>典型算法题的应用&lt;/p>
&lt;ul>
&lt;li>推排序&lt;/li>
&lt;li>第k大数（不过这个一般用快排O(n)实现）&lt;/li>
&lt;li>带权图的遍历&lt;/li>
&lt;/ul>
&lt;h3 id="blockingqueue-阻塞队列">BlockingQueue 阻塞队列&lt;/h3>
&lt;p>是一个接口，继承于Qeueu。&lt;/p>
&lt;p>阻塞的原因是，支持当队列没用元素时一直阻塞，直到有元素。
如果队列已满，则等到队列有空间时再插入元素。&lt;/p>
&lt;p>常用于生产者消费者模型。&lt;/p>
&lt;h2 id="map">Map**&lt;/h2>
&lt;h3 id="hashmap">HashMap&lt;/h3>
&lt;p>HashMap 和 HashTable的区别&lt;/p>
&lt;ul>
&lt;li>HashMap是非线程安全的，而HashTable是线程安全的&lt;/li>
&lt;li>HashMap允许使用null作为键和值，而HashTable不允许&lt;/li>
&lt;li>效率：HashMap效率高，HashTable效率低&lt;/li>
&lt;li>容量大小：HashMap默认大小为16，HashTable默认大小为11&lt;/li>
&lt;li>扩容：HashMap扩容是原来的2倍，HashTable扩容是原来的2倍+1&lt;/li>
&lt;li>底层数据结构：HashMap是数组+链表/红黑树，HashTable是数组+链表
&lt;ul>
&lt;li>JDK1.8 HashMap在链表长度超过8时，链表会自动转化为红黑树，优化查询速度&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>HashMap 和 TreeMap的区别&lt;/p>
&lt;ul>
&lt;li>HashMap是无序的，而TreeMap是有序的&lt;/li>
&lt;/ul>
&lt;h4 id="hashmap原理">HashMap原理&lt;/h4>
&lt;p>HashMap是一种基于哈希表的Map实现，其底层实现主要包括数组和链表（或红黑树）两部分。数组用来存储哈希桶，链表（或红黑树）用来解决哈希冲突。&lt;/p>
&lt;p>数组+链表+红黑树。&lt;/p>
&lt;p>那么在jdk1.8的HashMap中，当链表的长度超过8时，链表会自动转化为红黑树，优化查询速度。&lt;/p>
&lt;p>put原理&lt;/p>
&lt;p>同时还有一个区别：发生“hash冲突”时，我们上面的做法是“头插法”，这是jdk1.7的做法，而在jdk1.8中，使用的是“尾插法”。&lt;/p>
&lt;h4 id="hashmap底层实现">hashmap底层实现&lt;/h4>
&lt;p>HashMap是一种基于哈希表的Map实现，其底层实现主要包括数组和链表（或红黑树）两部分。数组用来存储哈希桶，链表（或红黑树）用来解决哈希冲突。&lt;/p>
&lt;p>具体来说，HashMap中的每个元素都是一个键值对，其中键和值都可以为null。当向HashMap中添加元素时，首先根据键的哈希值计算出该元素在数组中的位置，如果该位置上已经有元素了，则需要使用链表（或红黑树）来解决哈希冲突。如果链表（或红黑树）中已经存在该键，则更新该键对应的值，否则将该键值对添加到链表（或红黑树）的末尾。&lt;/p>
&lt;p>当链表（或红黑树）的长度超过一定阈值时，链表（或红黑树）会被转换为红黑树（或链表），以提高查询效率。当链表（或红黑树）的长度小于等于6时，会使用链表来存储元素，当长度大于6时，会使用红黑树来存储元素。&lt;/p>
&lt;p>在HashMap中，数组的长度是2的幂次方，这是为了使哈希值的高位和低位都能够参与到计算中，提高哈希值的均匀性。同时，数组的长度也决定了HashMap中哈希桶的数量，当哈希桶的数量过少时，容易导致哈希冲突，影响查询效率；当哈希桶的数量过多时，会浪费内存空间。因此，在创建HashMap时，需要根据实际情况来选择合适的数组长度。&lt;/p>
&lt;h4 id="hashmap17和18区别">hashmap1.7和1.8区别&lt;/h4>
&lt;p>HashMap1.7和1.8的主要区别在于底层实现方式的改变。1.7中使用的是数组+链表的方式来解决哈希冲突，而1.8中引入了红黑树来优化链表过长的情况，提高了查询效率。此外，1.8中还引入了一些新的方法和特性，如forEach()方法、Lambda表达式等。&lt;/p>
&lt;h4 id="hashmap怎么让他线程安全的方法">hashmap怎么让他线程安全的方法&lt;/h4>
&lt;p>HashMap本身是非线程安全的，如果需要在多线程环境下使用HashMap，可以使用以下几种方法来保证线程安全：&lt;/p>
&lt;ol>
&lt;li>使用Collections.synchronizedMap()方法将HashMap转换为线程安全的Map。&lt;/li>
&lt;li>使用ConcurrentHashMap代替HashMap，ConcurrentHashMap是一种线程安全的Map实现。&lt;/li>
&lt;li>使用读写锁来保证HashMap的线程安全性，即使用ReentrantReadWriteLock来控制读写操作的并发访问。&lt;/li>
&lt;/ol>
&lt;h3 id="concurrenthashmap">ConcurrentHashMap&lt;/h3>
&lt;h4 id="concurrenthashmap原理">ConcurrentHashMap原理&lt;/h4>
&lt;p>红黑树可用别的数据结构代替吗&lt;/p>
&lt;p>跳表与红黑树比较&lt;/p>
&lt;p>线程安全的类有哪些，为什么线程安全&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/language/java/jucjava%E5%B9%B6%E5%8F%91/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/language/java/jucjava%E5%B9%B6%E5%8F%91/</guid><description>&lt;h1 id="java-多线程">Java 多线程&lt;/h1>
&lt;h2 id="线程与进程">线程与进程&lt;/h2>
&lt;p>一个Java程序的运行是一个进程，包括一个main线程和多个其他线程&lt;/p>
&lt;p>Java的线程和操作系统的线程的区别&lt;/p>
&lt;ul>
&lt;li>JDK1.2之前使用的是JVM模拟的用户级线程，JDK1.2之后使用的是操作系统的内核级线程&lt;/li>
&lt;/ul>
&lt;p>用户级线程和内核级线程的区别&lt;/p>
&lt;ul>
&lt;li>用户线程：由用户空间程序管理和调度的线程，运行在用户空间（专门给应用程序使用）。&lt;/li>
&lt;li>内核线程：由操作系统内核管理和调度的线程，运行在内核空间（只有内核程序可以访问）。&lt;/li>
&lt;/ul>
&lt;p>线程模型是用户线程和内核线程之间的关联方式，常见的线程模型有这三种：&lt;/p>
&lt;ul>
&lt;li>一对一（一个用户线程对应一个内核线程）&lt;/li>
&lt;li>多对一（多个用户线程映射到一个内核线程）&lt;/li>
&lt;li>多对多（多个用户线程映射到多个内核线程）&lt;/li>
&lt;/ul>
&lt;p>Java采用的是一对一的线程模型，即一个用户线程对应一个内核线程。这种线程模型的优点是可以充分利用多核处理器的性能，缺点是创建和销毁线程的开销较大。&lt;/p>
&lt;p>JDK21正式引入了虚拟线程&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/JUC%28Java%e5%b9%b6%e5%8f%91%29/Java%e7%ba%bf%e7%a8%8b%e7%bb%93%e6%9e%84.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="为什么程序计数器虚拟机栈和本地方法栈是线程私有的呢">为什么程序计数器、虚拟机栈和本地方法栈是线程私有的呢？&lt;/h3>
&lt;p>程序计数器的功能：&lt;/p>
&lt;ul>
&lt;li>记录当前线程执行的字节码指令的地址，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。&lt;/li>
&lt;li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。&lt;/li>
&lt;/ul>
&lt;p>程序计数器是线程私有的，是为了线程切换时能够正确恢复执行现场。&lt;/p>
&lt;p>虚拟机栈&lt;/p>
&lt;ul>
&lt;li>每个线程在创建时都会创建一个虚拟机栈，用于存放线程的方法调用栈、局部变量表、操作数栈等信息。（执行的是Java方法）&lt;/li>
&lt;/ul>
&lt;p>本地方法栈&lt;/p>
&lt;ul>
&lt;li>用于支持本地方法调用，即调用C/C++编写的本地方法。&lt;/li>
&lt;/ul>
&lt;p>为了保证&lt;strong>线程的局部变量不被其他线程访问&lt;/strong>，虚拟机栈和本地方法栈是线程私有的。&lt;/p>
&lt;h3 id="为什么堆和方法区是线程共享的呢">为什么堆和方法区是线程共享的呢？&lt;/h3>
&lt;p>堆：是进程中所有线程共享的内存区域，用于存放对象实例。&lt;/p>
&lt;p>方法区：是进程中所有线程共享的内存区域，用于存放类的元数据信息、常量池、静态变量等。&lt;/p>
&lt;p>堆和方法区是线程共享的，是为了&lt;strong>方便线程之间共享数据&lt;/strong>。&lt;/p>
&lt;h3 id="并发并行同步异步">并发并行、同步异步&lt;/h3>
&lt;p>并发：指多个线程交替执行，从宏观上看是同时执行的。&lt;/p>
&lt;p>并行：指多个线程同时执行，从微观上看是同时执行的。&lt;/p>
&lt;p>同步：指多个线程按照一定的顺序执行。&lt;/p>
&lt;p>异步：指多个线程按照不确定的顺序执行。&lt;/p>
&lt;h2 id="多线程">多线程&lt;/h2>
&lt;h3 id="为什么要使用多线程">为什么要使用多线程？&lt;/h3>
&lt;p>多线程的主要优点有以下几点：&lt;/p>
&lt;ul>
&lt;li>线程间的切换开销小&lt;/li>
&lt;li>多线程高并发是高并发量的基础&lt;/li>
&lt;li>现在的CPU都是多核的，多线程可以充分利用CPU的性能&lt;/li>
&lt;/ul>
&lt;h3 id="多线程带来的问题">多线程带来的问题？&lt;/h3>
&lt;p>多线程的主要问题有以下几点：&lt;/p>
&lt;ul>
&lt;li>线程安全问题&lt;/li>
&lt;li>死锁问题&lt;/li>
&lt;li>内存泄漏问题&lt;/li>
&lt;/ul>
&lt;p>线程安全：&lt;/p>
&lt;ul>
&lt;li>线程安全是指多个线程访问共享资源时不会出现数据不一致的问题。&lt;/li>
&lt;/ul>
&lt;p>死锁：&lt;/p>
&lt;ul>
&lt;li>死锁是指两个或多个线程互相等待对方释放资源，导致所有线程都无法继续执行的问题。&lt;/li>
&lt;li>四个条件： 互斥条件、请求与保持条件、不剥夺条件、循环等待条件&lt;/li>
&lt;/ul>
&lt;p>内存泄漏：&lt;/p>
&lt;ul>
&lt;li>内存泄漏是指程序中的对象无法被垃圾回收器回收，导致内存占用过多的问题。&lt;/li>
&lt;/ul>
&lt;h3 id="单核上的多线程效率">单核上的多线程效率&lt;/h3>
&lt;p>单核上的多线程效率，取决于线程的类型&lt;/p>
&lt;ul>
&lt;li>CPU密集型线程：多线程效率不高，因为多个线程会争夺CPU资源，导致线程切换开销大。&lt;/li>
&lt;li>IO密集型线程：多线程效率较高，因为线程在等待IO时会释放CPU资源，不会争夺CPU资源。&lt;/li>
&lt;/ul>
&lt;h3 id="多线程的实现方式">多线程的实现方式&lt;/h3>
&lt;p>Java中实现多线程主要有两种方式：&lt;/p>
&lt;ol>
&lt;li>继承Thread类并重写run()方法。&lt;/li>
&lt;li>实现Runnable接口并实现run()方法，然后将其作为参数传递给Thread类的构造方法。&lt;/li>
&lt;/ol>
&lt;p>严格来说，这两种都是实现Runnable接口的方式，只不过一种是直接继承Thread类，另一种是将Runnable接口的实现类作为参数传递给Thread类的构造方法。&lt;/p>
&lt;h3 id="查看线程的执行结果怎么拿到">查看线程的执行结果，怎么拿到&lt;/h3>
&lt;p>可以通过线程的join()方法来等待线程执行完毕，并获取线程的执行结果。join()方法会阻塞当前线程，直到被调用的线程执行完毕。&lt;/p>
&lt;p>另外，可以通过线程的返回值来获取线程的执行结果。如果线程需要返回结果，可以在run()方法中返回一个值，然后在调用线程的地方通过Thread对象的get()方法获取返回值。&lt;/p>
&lt;h2 id="线程的生命周期和状态">线程的生命周期和状态&lt;/h2>
&lt;p>线程的生命周期主要包括以下几个状态：&lt;/p>
&lt;ul>
&lt;li>新建状态（New）：线程对象被创建后的状态。&lt;/li>
&lt;li>运行状态（Runable）：线程对象调用run()方法后的状态。&lt;/li>
&lt;li>就绪状态（Waiting）：线程对象调用start()方法后的状态。&lt;/li>
&lt;li>阻塞状态（Blocked）：线程对象调用sleep()、wait()、join()等方法后的状态。&lt;/li>
&lt;li>死亡状态（Terminated）：线程对象执行完run()方法后的状态。&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/JUC%28Java%e5%b9%b6%e5%8f%91%29/Java%e7%ba%bf%e7%a8%8b%e7%8a%b6%e6%80%81%e5%8f%98%e5%8c%96.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="上下文切换">上下文切换&lt;/h3>
&lt;p>上下文切换是指CPU从一个线程切换到另一个线程时，需要保存当前线程的上下文信息，然后加载另一个线程的上下文信息。&lt;/p>
&lt;p>发生上下文切换的原因主要有以下几点：&lt;/p>
&lt;ul>
&lt;li>时间片耗尽&lt;/li>
&lt;li>调用阻塞类型的中断，如请求IO、sleep、wait、join等&lt;/li>
&lt;li>被终止&lt;/li>
&lt;/ul>
&lt;p>上下文切换的开销主要包括以下几个方面：&lt;/p>
&lt;ul>
&lt;li>保存和恢复寄存器&lt;/li>
&lt;li>保存和恢复程序计数器&lt;/li>
&lt;li>保存和恢复内存映射表&lt;/li>
&lt;/ul>
&lt;h3 id="线程死锁">线程死锁&lt;/h3>
&lt;p>四个条件： 互斥条件、请求与保持条件、不剥夺条件、循环等待条件&lt;/p>
&lt;h4 id="预防和避免">预防和避免&lt;/h4>
&lt;p>预防死锁是破坏死锁的后三个条件。&lt;/p>
&lt;ul>
&lt;li>破坏请求与保持条件：一次性申请所有资源。&lt;/li>
&lt;li>破坏不剥夺条件：如果一个线程申请不到资源，就释放已经占有的资源。&lt;/li>
&lt;li>破坏循环等待条件：按序申请资源。&lt;/li>
&lt;/ul>
&lt;p>避免死锁是通过银行家算法来实现的。&lt;/p>
&lt;ul>
&lt;li>银行家算法是一种避免死锁的算法，它通过判断系统是否处于安全状态来避免死锁。&lt;/li>
&lt;li>银行家算法的核心思想是：当一个进程申请资源时，系统会先判断该进程申请资源后系统是否处于安全状态，如果是则分配资源，否则等待。&lt;/li>
&lt;/ul>
&lt;h3 id="sleep方法和wait方法">sleep()方法和wait()方法&lt;/h3>
&lt;ul>
&lt;li>sleep()方法
&lt;ul>
&lt;li>Thread类的静态方法，可以让当前线程休眠一段时间&lt;/li>
&lt;li>不会释放锁。&lt;/li>
&lt;li>用于暂停执行&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>wait()方法
&lt;ul>
&lt;li>Object类的方法，可以让当前线程等待&lt;/li>
&lt;li>会释放锁。&lt;/li>
&lt;li>wait()调用后, 线程不会自动唤醒, 需要调用notify()或notifyAll()方法唤醒。
&lt;ul>
&lt;li>或者使用wait(long timeout)方法，指定等待时间后自动唤醒。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>用于线程间的通信&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="为什么wait不定义在thread类中呢">为什么wait()不定义在Thread类中呢？&lt;/h4>
&lt;p>wait()方法是Object类的方法，是让获得对象锁的线程实现等待，会自动释放当前线程占有的对象锁。&lt;/p>
&lt;p>每个Object都有对象锁，因此定义在Object类中。&lt;/p>
&lt;h4 id="为什么sleep不定义在object类中呢">为什么sleep()不定义在Object类中呢？&lt;/h4>
&lt;p>sleep()方法是Thread类的静态方法，是让当前线程暂停执行，不涉及到对象类，也不需要获得对象锁。&lt;/p>
&lt;h3 id="可以直接调用run方法吗">可以直接调用run()方法吗？&lt;/h3>
&lt;p>可以直接调用run()方法，但是这样会导致run()方法在当前线程（main线程）中执行，不会创建新的线程。&lt;/p>
&lt;p>正常情况是调用start()方法，然后由JVM来创建新的线程并执行run()方法。&lt;/p>
&lt;p>调用 start() 方法方可启动线程并使线程进入就绪状态，直接执行 run() 方法的话不会以多线程的方式执行。&lt;/p>
&lt;h2 id="jmm">JMM&lt;/h2>
&lt;p>JMM是Java内存模型的缩写，是一种抽象的概念，用于描述Java程序中的内存访问规则。&lt;/p>
&lt;p>定义了一个线程之间如何通过内存进行通信的规范，即线程之间如何访问共享内存。&lt;/p>
&lt;p>JMM是Java解决多线程并发问题的核心，它定义了一套规范，用于保证多线程环境下的内存可见性、原子性和有序性。&lt;/p>
&lt;h3 id="并发问题的原因">并发问题的原因&lt;/h3>
&lt;p>CPU、内存、I/O 设备的速度是有极大差异的，为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系结构、操作系统、编译程序都做出了贡献，同时导致了并发问题。&lt;/p>
&lt;ul>
&lt;li>CPU 增加了缓存，以均衡与内存的速度差异.
&lt;ul>
&lt;li>导致可见性问题&lt;/li>
&lt;li>可见性是指当多个线程访问共享变量时，一个线程修改了共享变量的值，其他线程&lt;strong>能够看到修改后的值。&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异
&lt;ul>
&lt;li>导致原子性问题&lt;/li>
&lt;li>原子性: 是指一个操作是不可中断的，要么全部执行成功，要么全部不执行。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。// 导致 有序性问题&lt;/li>
&lt;/ul>
&lt;h4 id="可见性问题">可见性问题&lt;/h4>
&lt;p>可见性问题,就是看不到修改后的值, 由CPU缓存导致.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c1">//线程1执行&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="c1">//1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">10&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="c1">//2&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c1">//线程2执行&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="c1">//3&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>假设,有两个CPU, CPU1执行线程1, CPU2执行线程2.
线程1执行语句2时, 会先把a=0这个初始值从主内存中加载到CPU1的高速缓存中, 然后在CPU1的高速缓存中赋值a=10, 并没有立即写入到主存.&lt;/p>
&lt;p>线程2 如果在 线程1写入主存之前,执行了语句3, 那么就会读取到a=0这个初始值, 而不是修改后的值10.&lt;/p>
&lt;h4 id="原子性问题">原子性问题&lt;/h4>
&lt;p>原子性问题由分时复用CPU导致.&lt;/p>
&lt;p>Java中只有对基本数据类型的&lt;strong>读取和赋值&lt;/strong>操作是原子性的，其他的操作都不是原子性的。
下面语句1是原子性的, 其他都不是原子性的.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="n">x&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">10&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//语句1: 直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//语句2: 包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//语句3： x++包括3个操作：读取x的值，进行加1操作，写入新的值。&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//语句4： 同语句3&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>因此在执行一些常见,但不是原子性的操作时,会导致原子性问题.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-Java" data-lang="Java">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c1">// 线程1执行&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">+=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c1">// 线程2执行&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">+=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>i += 1需要三条 CPU 指令&lt;/p>
&lt;ol>
&lt;li>将变量 i 从内存读取到 CPU寄存器；&lt;/li>
&lt;li>在CPU寄存器中执行 i + 1 操作；&lt;/li>
&lt;li>将最后的结果i写入内存（缓存机制导致可能写入的是 CPU 缓存而不是内存）。&lt;/li>
&lt;/ol>
&lt;p>如果线程1执行完1后, 轮到线程2执行三条指令, 线程1再执行2,3. 会导致&lt;/p>
&lt;h3 id="cpu缓存模型">CPU缓存模型&lt;/h3>
&lt;p>CPU缓存模型主要包括以下几种：&lt;/p>
&lt;p>线程池&lt;/p>
&lt;p>线程池的使用&lt;/p>
&lt;p>1个10G大小文件，如何得前100个最大数字&lt;/p>
&lt;h2 id="锁">锁&lt;/h2>
&lt;p>volatile关键字
保证了变量的可见性，但是不保证原子性。&lt;/p>
&lt;p>synchornized关键字
保证了变量的可见性和原子性，但是会导致线程阻塞。&lt;/p>
&lt;p>如何禁止指令重排&lt;/p>
&lt;h3 id="乐观锁与悲观锁">乐观锁与悲观锁&lt;/h3>
&lt;h3 id="synchronized关键字">synchronized关键字&lt;/h3>
&lt;h3 id="reentrantlock">ReentrantLock&lt;/h3>
&lt;h3 id="reentrantreadwritelock">ReentrantReadWriteLock&lt;/h3>
&lt;h3 id="atomic-原子类">Atomic 原子类&lt;/h3>
&lt;h2 id="线程池">线程池&lt;/h2>
&lt;h3 id="threadlocal">ThreadLocal&lt;/h3>
&lt;h3 id="线程池-1">线程池&lt;/h3>
&lt;h3 id="future">Future&lt;/h3>
&lt;h3 id="aqs">AQS&lt;/h3>
&lt;h4 id="有哪些实现好的线程池既然他们不推荐为什么java官方还要给你">有哪些实现好的线程池，既然他们不推荐，为什么Java官方还要给你&lt;/h4>
&lt;p>Java中提供了多种线程池实现，包括ThreadPoolExecutor、ScheduledThreadPoolExecutor、ForkJoinPool等。这些线程池实现都是经过优化和测试的，可以满足大部分场景的需求。&lt;/p>
&lt;p>虽然Java官方不推荐直接使用这些线程池实现，但是它们提供了一种可靠、高效的线程池实现，可以作为开发者自己实现线程池的参考。&lt;/p>
&lt;h4 id="阻塞队列有哪些">阻塞队列有哪些&lt;/h4>
&lt;p>Java中提供了多种阻塞队列实现，包括ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue等。这些阻塞队列实现都是线程安全的，可以在多线程环境下使用。&lt;/p>
&lt;h4 id="线程池的工作流程">线程池的工作流程&lt;/h4>
&lt;p>线程池的工作流程如下：&lt;/p>
&lt;ol>
&lt;li>当有任务需要执行时，线程池会从线程池中获取一个空闲线程来执行任务。&lt;/li>
&lt;li>如果线程池中没有空闲线程，则会根据线程池的配置创建新的线程来执行任务。&lt;/li>
&lt;li>当任务执行完毕后，线程会返回线程池，并等待下一次任务的分配。&lt;/li>
&lt;/ol>
&lt;h4 id="线程池拒绝策略有哪些">线程池拒绝策略有哪些&lt;/h4>
&lt;p>线程池的拒绝策略主要有以下几种：&lt;/p>
&lt;ol>
&lt;li>AbortPolicy：直接抛出RejectedExecutionException异常。&lt;/li>
&lt;li>CallerRunsPolicy：将任务交给调用线程来执行。&lt;/li>
&lt;li>DiscardPolicy：直接丢弃任务，不做任何处理。&lt;/li>
&lt;li>DiscardOldestPolicy：丢弃队列中最老的任务，然后尝试重新提交任务。&lt;/li>
&lt;/ol>
&lt;h4 id="线程池的参数有哪些">线程池的参数有哪些&lt;/h4>
&lt;p>线程池的参数主要包括以下几个：&lt;/p>
&lt;ol>
&lt;li>corePoolSize：核心线程数，即线程池中保留的线程数。&lt;/li>
&lt;li>maximumPoolSize：最大线程数，即线程池中允许的最大线程数。&lt;/li>
&lt;li>keepAliveTime：线程空闲时间，即当线程池中的线程空闲时间超过该值时，多余的线程会被销毁。&lt;/li>
&lt;li>unit：时间单位，用于指定keepAliveTime的时间单位。&lt;/li>
&lt;li>workQueue：任务队列，用于存储等待执行的任务。&lt;/li>
&lt;li>threadFactory：线程工厂，用于创建新的线程。&lt;/li>
&lt;li>handler：拒绝策略，用于处理无法处理的任务。&lt;/li>
&lt;/ol></description></item><item><title/><link>https://ysyyhhh.github.io/docs/language/java/jvm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/language/java/jvm/</guid><description>&lt;h1 id="jvm">JVM&lt;/h1>
&lt;h2 id="java-内存区域">Java 内存区域&lt;/h2>
&lt;p>线程私有的：&lt;/p>
&lt;ul>
&lt;li>程序计数器&lt;/li>
&lt;li>虚拟机栈&lt;/li>
&lt;li>本地方法栈
线程共享的：&lt;/li>
&lt;li>堆&lt;/li>
&lt;li>方法区&lt;/li>
&lt;li>直接内存 (非运行时数据区的一部分)&lt;/li>
&lt;/ul>
&lt;p>Java 虚拟机规范对于运行时数据区域的规定是相当宽松的。以堆为例：堆可以是连续空间，也可以不连续。堆的大小可以固定，也可以在运行时按需扩展 。虚拟机实现者可以使用任何垃圾回收算法管理堆，甚至完全不进行垃圾收集也是可以的。&lt;/p>
&lt;p>程序计数器的功能是记录当前线程执行的字节码指令的地址，从而实现线程切换和恢复。&lt;/p>
&lt;p>程序计数器是线程私有的，是为了线程切换时能够正确恢复执行现场。&lt;/p>
&lt;p>虚拟机栈：每个线程在创建时都会创建一个虚拟机栈，用于存放线程的方法调用栈、局部变量表、操作数栈等信息。（执行的是Java方法）&lt;/p>
&lt;p>本地方法栈：用于支持本地方法调用，即调用C/C++编写的本地方法。&lt;/p>
&lt;p>为了保证线程的局部变量不被其他线程访问，虚拟机栈和本地方法栈是线程私有的。&lt;/p>
&lt;h2 id="jvm垃圾回收机制">JVM垃圾回收机制&lt;/h2>
&lt;h2 id="jvm的内存模型">jvm的内存模型&lt;/h2>
&lt;h3 id="integer-a--128b128两个相等吗">integer a = 128,b=128，两个相等吗&lt;/h3>
&lt;p>&lt;a href="https://blog.csdn.net/qq_42208194/article/details/117536553" target="_blank" rel="noopener">https://blog.csdn.net/qq_42208194/article/details/117536553&lt;/a>&lt;/p>
&lt;p>在Java中，对于Integer类型的对象，如果其值在-128到127之间，会被缓存到常量池中，因此当创建值在该范围内的Integer对象时，会直接从常量池中获取已有的对象。而对于值不在该范围内的Integer对象，则会创建新的对象。&lt;/p>
&lt;p>因此，对于Integer a = 128, b = 128，由于128不在-128到127之间，因此会创建两个不同的Integer对象，即a和b不相等。而对于Integer a = 127, b = 127，由于127在-128到127之间，因此会从常量池中获取同一个Integer对象，即a和b相等。&lt;/p>
&lt;h3 id="什么叫零拷贝">什么叫零拷贝&lt;/h3>
&lt;p>零拷贝（Zero Copy）是一种数据传输技术，它可以在不需要将数据从一个缓冲区复制到另一个缓冲区的情况下，将数据从一个地方传输到另一个地方。在零拷贝技术中，数据可以直接从磁盘、网络或其他设备中读取，然后通过DMA（Direct Memory Access）技术直接写入内存中，从而避免了数据的多次复制，提高了数据传输的效率。&lt;/p>
&lt;p>在Java中，零拷贝技术可以通过NIO（New I/O）来实现。NIO提供了一种基于通道（Channel）和缓冲区（Buffer）的I/O模型，可以直接将数据从通道中读取到缓冲区中，或者将缓冲区中的数据直接写入通道中，从而避免了数据的多次复制。&lt;/p>
&lt;h3 id="为什么用常量池有哪些常量池">为什么用常量池，有哪些常量池&lt;/h3>
&lt;p>&lt;a href="https://blog.csdn.net/qq_41376740/article/details/80338158" target="_blank" rel="noopener">https://blog.csdn.net/qq_41376740/article/details/80338158&lt;/a>&lt;/p>
&lt;p>常量池是Java中的一种特殊的内存区域，用于存储常量和符号引用。在Java中，常量池主要有以下几种：&lt;/p>
&lt;ol>
&lt;li>字面量常量池：用于存储字符串、数字等字面量常量。&lt;/li>
&lt;li>符号引用常量池：用于存储类、方法、字段等符号引用。&lt;/li>
&lt;li>运行时常量池：用于存储在类加载时解析的常量池信息，包括字面量常量池和符号引用常量池中的内容。&lt;/li>
&lt;/ol>
&lt;p>使用常量池的主要目的是为了提高程序的性能和减少内存的占用。由于常量池中的常量是唯一的，因此可以避免重复创建相同的常量对象，从而减少内存的占用。同时，由于常量池中的常量是在编译期间就确定的，因此可以在运行时直接使用，避免了重复计算和创建对象的开销，提高了程序的性能。&lt;/p></description></item></channel></rss>