<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>spring | Ysyy's</title><link>https://ysyyhhh.github.io/docs/language/java/spring/</link><atom:link href="https://ysyyhhh.github.io/docs/language/java/spring/index.xml" rel="self" type="application/rss+xml"/><description>spring</description><generator>Hugo Blox Builder (https://hugoblox.com)</generator><language>en-us</language><image><url>https://ysyyhhh.github.io/media/logo.svg</url><title>spring</title><link>https://ysyyhhh.github.io/docs/language/java/spring/</link></image><item><title/><link>https://ysyyhhh.github.io/docs/language/java/spring/springaop/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/language/java/spring/springaop/</guid><description>&lt;h1 id="spring-aop">Spring AOP&lt;/h1>
&lt;h2 id="什么是aop">什么是AOP&lt;/h2>
&lt;p>AOP（Aspect-Oriented Programming）面向切面编程，是一种编程范式，它的主要目的是提高代码的模块化程度，使得代码更加易于维护和扩展。&lt;/p>
&lt;p>将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。&lt;/p>
&lt;p>Manager层的事务管理、日志管理、权限控制等功能，都是与业务逻辑无关的，但是却是业务逻辑所必须的，这些功能可以通过AOP来实现。&lt;/p>
&lt;p>AOP的实现方式有两种：动态代理和CGLIB字节码增强。&lt;/p>
&lt;ul>
&lt;li>如果目标对象实现了接口，Spring就会使用JDK的动态代理&lt;/li>
&lt;li>如果目标对象没有实现接口，Spring就会使用CGLIB字节码增强&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/SpringAOP/AOP%20Process.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h2 id="切面和filter什么区别">切面和filter什么区别&lt;/h2></description></item><item><title/><link>https://ysyyhhh.github.io/docs/language/java/spring/springioc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/language/java/spring/springioc/</guid><description>&lt;p>Spring IOC&lt;/p>
&lt;p>什么是IOC&lt;/p>
&lt;ul>
&lt;li>Inversion of Control 控制反转&lt;/li>
&lt;li>控制权由程序员转交给了Spring容器，由Spring容器来实例化对象，而不是由程序员来实例化对象&lt;/li>
&lt;/ul>
&lt;p>控制：对象创建（实例化、管理）的控制权
反转：由程序员转交给了外部环境（Spring，IOC容器）&lt;/p>
&lt;p>当我们需要创建一个对象时，只需要配置好配置文件/注解&lt;/p>
&lt;h2 id="spring-ioc容器">Spring IOC容器&lt;/h2>
&lt;p>IOC容器是Map类型的对象，存储了所有的bean对象，key是bean的id，value是bean对象&lt;/p>
&lt;p>两种配置Bean的方式：&lt;/p>
&lt;ul>
&lt;li>XML配置&lt;/li>
&lt;li>注解配置&lt;/li>
&lt;/ul>
&lt;h2 id="spring-bean">Spring Bean&lt;/h2>
&lt;p>Bean是被IoC容器管理的对象，Bean是一个Java对象，由Spring容器实例化、装配、管理&lt;/p>
&lt;h2 id="声明为bean的注解">声明为Bean的注解&lt;/h2>
&lt;p>@Component&lt;/p>
&lt;ul>
&lt;li>用于标注一个普通的bean&lt;/li>
&lt;li>不区分是哪个层的&lt;/li>
&lt;/ul>
&lt;p>@Repository&lt;/p>
&lt;ul>
&lt;li>用于标注一个DAO层的bean&lt;/li>
&lt;li>但很多时候都不用这种方式&lt;/li>
&lt;li>一般直接通过MapperScan注解扫描mapper接口（在mybatis中）&lt;/li>
&lt;/ul>
&lt;p>@Service&lt;/p>
&lt;ul>
&lt;li>用于标注一个Service层的bean&lt;/li>
&lt;/ul>
&lt;p>@Controller&lt;/p>
&lt;ul>
&lt;li>用于标注一个Controller层的bean&lt;/li>
&lt;/ul>
&lt;p>@Component和@Bean的区别&lt;/p>
&lt;ul>
&lt;li>@Component是用于标注一个普通的bean，作用于类；而@Bean是用于标注一个方法，作用于方法&lt;/li>
&lt;li>@Component是被Spring扫描到之后（@ComponentScan），自动注册到Spring容器中；而@Bean是在配置类中，手动注册到Spring容器中&lt;/li>
&lt;li>@Bean自定义性强，比如在引用第三方库的时候，可以使用@Bean注解，将第三方库的对象注册到Spring容器中&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-Java" data-lang="Java">&lt;span class="line">&lt;span class="cl">&lt;span class="nd">@Configuration&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">AppConfig&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nd">@Bean&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">TransferService&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">transferService&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">TransferServiceImpl&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-xml" data-lang="xml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;bean&lt;/span> &lt;span class="na">id=&lt;/span>&lt;span class="s">&amp;#34;transferService&amp;#34;&lt;/span> &lt;span class="na">class=&lt;/span>&lt;span class="s">&amp;#34;com.example.TransferServiceImpl&amp;#34;&lt;/span>&lt;span class="nt">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>不能通过@Component实现的例子&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-Java" data-lang="Java">&lt;span class="line">&lt;span class="cl">&lt;span class="nd">@Configuration&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">AppConfig&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nd">@Bean&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">TransferService&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">transferService&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">TransferServiceImpl&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nd">@Bean&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">TransferService&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">transferService2&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">TransferServiceImpl&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>为什么不能使用@Component&lt;/p>
&lt;ul>
&lt;li>因为@Component是用于标注一个普通的bean，作用于类；而@Bean是用于标注一个方法，作用于方法&lt;/li>
&lt;/ul>
&lt;h2 id="注入bean的注解">注入Bean的注解&lt;/h2>
&lt;p>Spring内置的@Autowired注解
JDK内置的@Resource注解和@Inject注解&lt;/p>
&lt;p>@Autowired和@Resource的区别&lt;/p>
&lt;ul>
&lt;li>AutoWired的默认是按照类型注入
&lt;ul>
&lt;li>如果有多个类型一样的bean，会变成按照名称注入&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Resource默认是按照名称注入，如果没有指定name属性，会按照类型注入&lt;/li>
&lt;li>如果存在多个实现类, Autowired需要@Qualifier指定具体的实现类，而Resource需要name指定具体的实现类&lt;/li>
&lt;li>@Autowired 支持在构造函数、方法、字段和参数上使用。&lt;/li>
&lt;li>@Resource 主要用于字段和方法上的注入，&lt;strong>不支持在构造函数或参数上使用&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>SmsService 接口有两个实现类: SmsServiceImpl1和 SmsServiceImpl2，且它们都已经被 Spring 容器所管理&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 报错，byName 和 byType 都无法匹配到 bean&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nd">@Autowired&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">SmsService&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">smsService&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c1">// 正确注入 SmsServiceImpl1 对象对应的 bean&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nd">@Autowired&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">SmsService&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">smsServiceImpl1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c1">// 正确注入 SmsServiceImpl1 对象对应的 bean&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c1">// smsServiceImpl1 就是我们上面所说的名称&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nd">@Autowired&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nd">@Qualifier&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;smsServiceImpl1&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">SmsService&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">smsService&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-Java" data-lang="Java">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 报错，byName 和 byType 都无法匹配到 bean&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nd">@Resource&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">SmsService&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">smsService&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c1">// 正确注入 SmsServiceImpl1 对象对应的 bean&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nd">@Resource&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">SmsService&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">smsServiceImpl1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c1">// 正确注入 SmsServiceImpl1 对象对应的 bean（比较推荐这种方式）&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nd">@Resource&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;smsServiceImpl1&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">SmsService&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">smsService&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="怎么动态获取spring容器里面的bean从哪个类中获取">怎么动态获取spring容器里面的bean，从哪个类中获取&lt;/h2>
&lt;p>从ApplicationContext中获取Bean&lt;/p>
&lt;h2 id="bean的作用域">Bean的作用域&lt;/h2>
&lt;ul>
&lt;li>singleton：单例模式，一个Spring容器中只有一个bean实例，默认值&lt;/li>
&lt;li>prototype：原型模式，每次从容器中获取bean时，都会创建一个新的实例&lt;/li>
&lt;li>request：每次HTTP请求都会创建一个新的bean，该bean仅在当前HTTP request内有效&lt;/li>
&lt;li>session：每次HTTP请求都会创建一个新的bean，该bean仅在当前HTTP session内有效&lt;/li>
&lt;li>global session：全局session作用域，仅在基于portlet的Web应用中才有意义，Spring5废弃&lt;/li>
&lt;li>application：全局作用域，Spring5废弃&lt;/li>
&lt;li>websocket：全局作用域，Spring5废弃&lt;/li>
&lt;/ul>
&lt;p>配置Bean的作用域&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-xml" data-lang="xml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;bean&lt;/span> &lt;span class="na">id=&lt;/span>&lt;span class="s">&amp;#34;user&amp;#34;&lt;/span> &lt;span class="na">class=&lt;/span>&lt;span class="s">&amp;#34;com.example.User&amp;#34;&lt;/span> &lt;span class="na">scope=&lt;/span>&lt;span class="s">&amp;#34;prototype&amp;#34;&lt;/span>&lt;span class="nt">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-Java" data-lang="Java">&lt;span class="line">&lt;span class="cl">&lt;span class="nd">@Component&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nd">@Scope&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;prototype&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">User&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="bean的线程安全问题">Bean的线程安全问题&lt;/h2>
&lt;p>与作用域有关&lt;/p>
&lt;ul>
&lt;li>singleton：线程不安全, IoC容器中只有一个bean实例，多个线程共享一个bean实例, 如果bean中有状态，会出现线程安全问题&lt;/li>
&lt;li>prototype：线程安全, 每次从容器中获取bean时，都会创建一个新的实例&lt;/li>
&lt;li>其他的都是线程安全的&lt;/li>
&lt;/ul>
&lt;p>解决办法:&lt;/p>
&lt;ul>
&lt;li>不要在bean中定义状态&lt;/li>
&lt;li>使用ThreadLocal(推荐)&lt;/li>
&lt;/ul>
&lt;h2 id="bean的生命周期">Bean的生命周期&lt;/h2>
&lt;p>Bean的生命周期包括初始化和销毁两个阶段&lt;/p>
&lt;p>Bean的初始化&lt;/p>
&lt;ul>
&lt;li>通过构造方法创建bean&lt;/li>
&lt;li>为bean的属性设置值 set()&lt;/li>
&lt;li>如果实现了*.Aware接口，调用相应的方法
&lt;ul>
&lt;li>BeanNameAware&lt;/li>
&lt;li>BeanFactoryAware&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>如果有相应的初始化方法就调用
&lt;ul>
&lt;li>如果有Spring 容器相关BeanPostProcessor，调用postProcessBeforeInitialization方法&lt;/li>
&lt;li>如果有InitializingBean，调用afterPropertiesSet方法&lt;/li>
&lt;li>如果有init-method属性，调用init-method方法&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>bean初始化完成&lt;/li>
&lt;/ul>
&lt;p>Bean的销毁&lt;/p>
&lt;ul>
&lt;li>调用bean的销毁方法
&lt;ul>
&lt;li>如果实现了 DisposableBean 接口，调用destroy方法&lt;/li>
&lt;li>如果有destroy-method属性，调用destroy-method方法&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>bean销毁完成&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/SpringIOC/Bean%e7%9a%84%e5%a3%b0%e6%98%8e%e5%91%a8%e6%9c%9f.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/language/java/spring/spring%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/language/java/spring/spring%E5%9F%BA%E7%A1%80/</guid><description>&lt;h1 id="spring-基础">Spring 基础&lt;/h1>
&lt;h3 id="spring常见的一些模块">Spring常见的一些模块&lt;/h3>
&lt;p>Spring 支持&lt;/p>
&lt;ul>
&lt;li>IoC（Inversion of Control:控制反转）&lt;/li>
&lt;li>AOP(Aspect-Oriented Programming:面向切面编程)&lt;/li>
&lt;/ul>
&lt;p>Spring模块：&lt;/p>
&lt;ul>
&lt;li>Spring Core Container：核心容器， 提供IoC容器的基本功能
&lt;ul>
&lt;li>spring-core：Spring 框架基本的核心工具类。&lt;/li>
&lt;li>spring-beans：提供对 bean 的创建、配置和管理等功能的支持。&lt;/li>
&lt;li>spring-context：提供对国际化、事件传播、资源加载等功能的支持。&lt;/li>
&lt;li>spring-expression：提供对表达式语言（Spring Expression Language） SpEL 的支持，只依赖于 core 模块，不依赖于其他模块，可以单独使用。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Spring AOP：提供面向切面编程的功能
&lt;ul>
&lt;li>spring-aop：提供对 AOP 的支持。&lt;/li>
&lt;li>spring-aspects：提供对 AspectJ 的支持。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Spring Data Access/Integration：提供对数据库操作、事务管理、消息处理等功能的支持
&lt;ul>
&lt;li>spring-jdbc：提供对 JDBC 的支持。&lt;/li>
&lt;li>spring-tx：提供对事务管理的支持。&lt;/li>
&lt;li>spring-orm：提供对 ORM 工具的支持。&lt;/li>
&lt;li>spring-oxm：提供对 Object/XML 映射的支持。&lt;/li>
&lt;li>spring-jms：提供对 JMS 的支持。&lt;/li>
&lt;li>spring-web：提供对 Web 应用的支持。&lt;/li>
&lt;li>spring-webmvc：提供对 Web MVC 的支持。&lt;/li>
&lt;li>spring-websocket：提供对 Web Socket 的支持。&lt;/li>
&lt;li>spring-webflux：提供对 Web Flux 的支持。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Spring Web：提供对 Web 应用的支持
&lt;ul>
&lt;li>spring-web：提供对 Web 应用的支持。&lt;/li>
&lt;li>spring-webmvc：提供对 Web MVC 的支持。&lt;/li>
&lt;li>spring-websocket：提供对 Web Socket 的支持。&lt;/li>
&lt;li>spring-webflux：提供对 Web Flux 的支持。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Spring Test：提供对单元测试和集成测试的支持
&lt;ul>
&lt;li>spring-test：提供对测试的支持。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="spring-spring-mvc-spring-boot的关系">Spring Spring MVC Spring Boot的关系&lt;/h3>
&lt;p>Spring是一个开源框架
Spring MVC是Spring框架的一个模块
Spring Boot是Spring框架的一个子项目。&lt;/p>
&lt;ul>
&lt;li>简化了Spring MVC的配置&lt;/li>
&lt;/ul>
&lt;h4 id="介绍一下springboot">介绍一下springboot&lt;/h4>
&lt;p>简化spring应用的创建及部署&lt;/p>
&lt;p>Spring Boot通过自动配置功能，降低了复杂性，同时支持基于JVM的多种开源框架，可以缩短开发时间，使开发更加简单和高效。&lt;/p>
&lt;h4 id="3mvc的dispatcherservlet的分派原理">3.mvc的dispatcherservlet的分派原理&lt;/h4>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="4.13%e6%bb%b4%e6%bb%b4%e5%87%86%e5%a4%87/img/image-20230413193651300.png" alt="image-20230413193651300" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;ol>
&lt;li>用户发送 请求到 前端控制器（DispatcherServlet）。&lt;/li>
&lt;li>前端控制器 请求 &lt;strong>处理器映射器&lt;/strong>（HandlerMapping）去 查找 处理器（Handler）。&lt;/li>
&lt;li>找到以后 处理器映射器（HandlerMappering）向 前端控制器 返回 执行链（HandlerExecutionChain）。&lt;/li>
&lt;li>前端控制器（DispatcherServlet）调用 &lt;strong>处理器适配器&lt;/strong>（HandlerAdapter） 去执行 处理器（Handler）。&lt;/li>
&lt;li>处理器适配器 去执行 处理器Handler。&lt;/li>
&lt;li>处理器 执行完给 处理器适配器 返回ModelAndView。&lt;/li>
&lt;li>&lt;strong>处理器适配器&lt;/strong> 向 前端控制器 返回ModelAndView。&lt;/li>
&lt;li>前端控制器 请求 &lt;strong>视图解析器&lt;/strong>（ViewResolver）去进行 视图解析。&lt;/li>
&lt;li>视图解析器 向 前端控制器返回View。&lt;/li>
&lt;li>前端控制器 对 &lt;strong>视图进行渲染&lt;/strong>。&lt;/li>
&lt;li>前端控制器 向用户&lt;strong>响应结果&lt;/strong>。&lt;/li>
&lt;/ol>
&lt;h4 id="restful风格在mvc的分派如何解析参数这个我不知道瞎答的">restful风格在mvc的分派，如何解析参数（这个我不知道瞎答的）&lt;/h4>
&lt;p>restful 即 URL表示资源， + GET POST PUT DELETE 表示行为&lt;/p>
&lt;p>Restful风格的请求是使用 &lt;strong>url+请求方式&lt;/strong> 表示一次请求目的的，并且规范了一些的状态码，使得看到接口就知道请求要干嘛。&lt;/p>
&lt;p>RequestMappingURL&lt;/p>
&lt;p>PathVariable 获取参数&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>@Controller&lt;/code>声名一个处理请求的控制器&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>@RequestMapping&lt;/code>请求映射地址，它存在几个子注解对于实现&lt;code>REST&lt;/code>风格来说更加具有语义性&lt;/p>
&lt;/li>
&lt;li>
&lt;ul>
&lt;li>&lt;code>GETMapping&lt;/code> GET请求&lt;/li>
&lt;li>&lt;code>PUTMapping&lt;/code> PUT请求&lt;/li>
&lt;li>&lt;code>POSTMapping&lt;/code> POST请求&lt;/li>
&lt;li>&lt;code>DELETEMapping&lt;/code> DELETE请求&lt;code>sponseBody&lt;/code> 将响应内容转换为&lt;code>JSON&lt;/code>格式&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;code>@RequestBody&lt;/code> 请求内容转换为&lt;code>JSON&lt;/code>格式&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>@PathVariable(&amp;quot;id&amp;quot;)&lt;/code>用于绑定一个参数&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>@RESTController&lt;/code> 等同于&lt;code>@Controller&lt;/code>+&lt;code>@ResponseBody&lt;/code>在类上写了这个注解，标识这个类的所有方法只返回数据，而不进行视图跳转&lt;/p>
&lt;/li>
&lt;/ul></description></item></channel></rss>