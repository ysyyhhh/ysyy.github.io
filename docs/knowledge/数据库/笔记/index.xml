<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>笔记 | Ysyy's</title><link>https://ysyyhhh.github.io/docs/knowledge/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/</link><atom:link href="https://ysyyhhh.github.io/docs/knowledge/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/index.xml" rel="self" type="application/rss+xml"/><description>笔记</description><generator>Hugo Blox Builder (https://hugoblox.com)</generator><language>en-us</language><image><url>https://ysyyhhh.github.io/media/logo.svg</url><title>笔记</title><link>https://ysyyhhh.github.io/docs/knowledge/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/</link></image><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/sql%E5%AE%9E%E4%BE%8B%E8%A7%A3%E6%9E%90%E4%B8%8E%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/sql%E5%AE%9E%E4%BE%8B%E8%A7%A3%E6%9E%90%E4%B8%8E%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F/</guid><description>&lt;p>示例表：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230309100013301.png" alt="image-20230309100013301" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h2 id="1sql实例处理字符串">1.SQL实例处理：字符串&lt;/h2>
&lt;p>SQL不专门用于处理复杂的字符串，但内置了很多有用的字符串。&lt;/p>
&lt;h3 id="11遍历字符串">1.1遍历字符串&lt;/h3>
&lt;p>SQL没有Loop功能, 需要使用数据透视表&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227163824652.png" alt="image-20230227163824652" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>循环的次数是字符串的长度, 用where来终止.&lt;/p>
&lt;h3 id="12嵌入引号">1.2嵌入引号&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227163859353.png" alt="image-20230227163859353" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="13统计字符出现的次数">1.3统计字符出现的次数&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227163927154.png" alt="image-20230227163927154" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>sql server 是用len&lt;/p>
&lt;h3 id="14删除不想要的字符">1.4删除不想要的字符&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227164016283.png" alt="image-20230227164016283" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>替换多个字符时可以使用: &lt;strong>translate&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227164049652.png" alt="image-20230227164049652" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>先全部一致替换为a,再把a给删除.&lt;/p>
&lt;p>但mysql中没有translate.&lt;/p>
&lt;p>阿里的OceanBase同时支持replace和translate&lt;/p>
&lt;h3 id="15判断是否只含有字母和数字">1.5判断是否只含有字母和数字&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227164123913.png" alt="image-20230227164123913" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>Mysql可以直接使用正则表达式. [] 内表示范围 ^ 表示否定&lt;/p>
&lt;p>OceanBase 的0 1相反&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230309101159648.png" alt="image-20230309101159648" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>思考题&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227164306073.png" alt="image-20230227164306073" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>​&lt;/p>
&lt;h2 id="2sql实例解析-数值处理">2.SQL实例解析 数值处理&lt;/h2>
&lt;p>虽然SQL不容易处理，但硬要在SQL中完成比如字符串，比如日期，比如今天的数值计算。&lt;/p>
&lt;p>数值处理在数据库完成，可以减少数据库和服务器的交互。&lt;/p>
&lt;p>能在数据库中，写个&lt;strong>完整功能的SQL&lt;/strong>，让查询优化器统一优化，一般来说对整个系统的吞吐量会有非常大的提升.&lt;/p>
&lt;h3 id="21计算平均值">2.1计算平均值&lt;/h3>
&lt;p>空值默认是忽略&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227164534143.png" alt="image-20230227164534143" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>coalesce 空值设置为0&lt;/strong>&lt;/p>
&lt;p>当使用聚合函数时通常要考虑空值的处理.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227164603887.png" alt="image-20230227164603887" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>不能把group by 子句中没有的列放到select语句中.&lt;/p>
&lt;h3 id="22查找最大值和最小值">2.2查找最大值和最小值&lt;/h3>
&lt;p>空值没有影响.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227164620369.png" alt="image-20230227164620369" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="23求和">2.3求和&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227164639158.png" alt="image-20230227164639158" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="24计算行数">2.4计算行数&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227164719491.png" alt="image-20230227164719491" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>count(*)计算了空值.&lt;/strong>&lt;/p>
&lt;p>&lt;strong>针对某一列时会跳过空值&lt;/strong>&lt;/p>
&lt;h3 id="25累计求和-running-total">2.5累计求和 Running Total&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227164847493.png" alt="image-20230227164847493" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>Sum( ) over ()&lt;/p>
&lt;p>over 中的 order by 需要具有唯一性.&lt;/p>
&lt;p>否则, WARD 会和 MARTIN一样是5350&lt;/p>
&lt;p>即建立&lt;strong>唯一的排他序列得到正确的累加值&lt;/strong>.&lt;/p>
&lt;p>在以前的mysql不支持窗口函数,所以要使用标量子查询.&lt;/p>
&lt;h3 id="26计算众数">2.6计算众数&lt;/h3>
&lt;p>oracle 使用 max + keep&lt;/p>
&lt;p>如果max相同,则按照keep中的排序规则保留其最大的.&lt;/p>
&lt;p>keep从右向左执行, 先对每一个cnt降序排序,然后执行rank函数,保留rank1的值.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227164934043.png" alt="image-20230227164934043" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>mysql只能用通用做法.group by + having&lt;/p>
&lt;p>思考题:&lt;/p>
&lt;p>累计乘法和累计减法&lt;/p>
&lt;h2 id="3sql实例分析-日期处理">3.SQL实例分析 日期处理&lt;/h2>
&lt;h3 id="31日期加减法">3.1日期加减法&lt;/h3>
&lt;p>Oracle中，对天数来说，对天数来说可以直接加减，如果要加减若干月或者年，需要用一个函数，add months.&lt;/p>
&lt;p>MySQL日期加减法类似，使用&lt;strong>INTERVAL关键字&lt;/strong>指定要加上或者减去时间
的单位，不必使用单引号。
第二种方法: 使用date add函数，一样的作用。&lt;/p>
&lt;p>OceanBase的add和mysql一模一样&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230309103225068.png" alt="image-20230309103225068" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="32计算两个日期之间的天数">3.2计算两个日期之间的天数&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227165217187.png" alt="image-20230227165217187" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>mysql 和 OceanBase datediff(较晚的日期,较早的日期)&lt;/p>
&lt;p>sql server 是datediff(较早的,较晚的)&lt;/p>
&lt;h3 id="33两个日期的工作日天数">3.3两个日期的工作日天数&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227165324649.png" alt="image-20230227165324649" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>这样统计天数就变成了计算行数的问题.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230309103757837.png" alt="image-20230309103757837" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>1.计算出开始日期和结束日期之间相隔多少天。 x视图&lt;/p>
&lt;p>2.排除掉周末，统计有多少个工作日，计算满足条件的记录。&lt;/p>
&lt;p>Oracle 和 mysql的差异是函数使用的不同.&lt;/p>
&lt;h3 id="34判断闰年">3.4判断闰年&lt;/h3>
&lt;p>判断闰年的最简单方式&lt;/p>
&lt;p>检查2月份最后一天，如
果是29号，就是闰年;如
果是28号，就不是闰年;
如果既不是28号，也不是
29号，程序写错。&lt;/p>
&lt;p>orcale 有trunc函数找到&lt;strong>当前年份的第一天&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230309104059402.png" alt="image-20230309104059402" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>先算出当前日期是当前年份的第几天, 找到当前年的第一天.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227165617940.png" alt="image-20230227165617940" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="35识别重叠的日期区间">3.5识别重叠的日期区间&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227165658575.png" alt="image-20230227165658575" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>自连接方法, 复制出另一份表,然后找到重叠的项目&lt;/p>
&lt;p>窗口比自联结快,但需要限定项目的个数.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227165731407.png" alt="image-20230227165731407" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>思考题: 当前月份的第一个和最后一个星期一&lt;/p>
&lt;h2 id="4常见的sql连接模式">4.常见的SQL连接模式&lt;/h2>
&lt;p>查询有时候并不只需要等值连接.&lt;/p>
&lt;p>4.1叠加行集(Union &amp;amp;Union all)&lt;/p>
&lt;p>4.2查找只存在于一张表的数据 (差)&lt;/p>
&lt;p>4.3从一个表检索另一个不相关的行(外连接&lt;/p>
&lt;p>4.4从多个表中返回缺失值 (全外连接)&lt;/p>
&lt;p>4.5连接与聚合函数的使用&lt;/p>
&lt;h3 id="41叠加行集union--union-all">4.1叠加行集(Union &amp;amp; Union all)&lt;/h3>
&lt;p>使用连接的情况，就是想返回保存至多个表中的数据
理论上需要将一个结果集叠加到另一个之上，甚至这些表&lt;strong>可以没有相同的键&lt;/strong>，有一个前提条件是，它们&lt;strong>列的数据类型必须相同&lt;/strong>。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227165935617.png" alt="image-20230227165935617" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>Union all是将多个表中的行并入结果集. 列的数目和类型必须匹配,名字可以不一样. Union all 会包括重复项, union会去除重复项.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227170009502.png" alt="image-20230227170009502" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>union的问题 : &lt;strong>有排序操作&lt;/strong>以删除重复项,慎用.&lt;/p>
&lt;p>排序是非关系操作,大数据量的排序对性能是一个灾难.&lt;/p>
&lt;h3 id="42查找只存在于一张表的数据差">4.2查找只存在于一张表的数据(差)&lt;/h3>
&lt;p>使用差函数, 但不同数据库的差函数关键字不一样.&lt;/p>
&lt;p>minus限制条件, 列必须相同个数和数据类型,且不返回重复值. 空值不问产生任何问题.&lt;/p>
&lt;p>except 对结果进行去重.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227170147073.png" alt="image-20230227170147073" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>使用not in时用空值的问题,一遍要加上exists 或 not exists&lt;/p>
&lt;h3 id="43从一个表检索另一个不相关的行外连接">4.3从一个表检索另一个不相关的行(外连接)&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227170229988.png" alt="image-20230227170229988" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>outer可写可不写&lt;/p>
&lt;h3 id="44从多个表中返回每个表的缺失值全外连接">4.4从多个表中返回每个表的缺失值(全外连接)&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227170250386.png" alt="image-20230227170250386" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="45连接与聚合函数的使用">4.5连接与聚合函数的使用&lt;/h3>
&lt;p>确保表之间的连接查询不会干扰到聚合操作.&lt;/p>
&lt;p>左边是员工奖金表,&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227170339432.png" alt="image-20230227170339432" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>奖金总额正确,但工资总额是错的.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230309105955183.png" alt="image-20230309105955183" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>是因为连接查询导致某行的工资出现两次.&lt;/p>
&lt;p>解决方法, 使用distinct.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227170437389.png" alt="image-20230227170437389" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>如果表中, 部门编号为10的人只有部分人有奖金.此时计算总额会少算.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e5%ae%9e%e4%be%8b%e8%a7%a3%e6%9e%90%e4%b8%8e%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f/image-20230227170454013.png" alt="image-20230227170454013" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>提示: 需要选择连接方式.用&lt;strong>外连接把员工全包括&lt;/strong>.&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/sql%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/sql%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/</guid><description>&lt;p>4.1关系代数&lt;/p>
&lt;p>4.2查询优化器&lt;/p>
&lt;p>4.3使用SQL需要考虑的因素&lt;/p>
&lt;p>4.4查询的过滤条件&lt;/p>
&lt;p>4.5高效过滤条件举例&lt;/p>
&lt;p>4.6 SQL优化的其它问题-where子的比较运算符&lt;/p>
&lt;p>4.7 SQL优化的其它问题-SQL连接&lt;/p>
&lt;h2 id="1关系代数">1.关系代数&lt;/h2>
&lt;p>代数的作用： 表达式的等价代换&lt;/p>
&lt;p>2、3、4 这些数字对应的就是 关系(表)&lt;/p>
&lt;p>+-x/这些运算符对应的就是 关系操作&lt;/p>
&lt;p>SQL语句的本质是关系表达式&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309153407418.png" alt="image-20230309153407418" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>查询优化器 的作用 ： 就是在数据库中间进行关系表达式等价变化后找到最优路径&lt;/p>
&lt;p>关系代数是&lt;strong>以数学为基础&lt;/strong>的，是一个科学
在写代码时，像一个工匠。
关系数据库不一样，写的SQL只是向数据库提出取什么样数据的要求，具体怎么找到最快速的执行方式，是数据库的查询优化器的事情。&lt;/p>
&lt;p>关系数据库还有一个科学的地方，它&lt;strong>存在简单模式，实现冗余最小的设计&lt;/strong>。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>没有简单通用的规则，实现数据库冗余最小。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>windows的资源管理器的目录结构、XML这种树形结构，这种文件组织方式是最习惯但不科学的&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>no sql 是 not only sql&lt;/p>
&lt;h2 id="2查询优化器">2.查询优化器&lt;/h2>
&lt;p>&lt;strong>sql 关系理论 查询优化器的关系&lt;/strong>：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309153946870.png" alt="image-20230309153946870" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>关系理论适用于理论意义上无限大的集合。&lt;/p>
&lt;p>在不同大小的数据集在不同物理环境中间，如何实现更有效率地读取，&lt;strong>将无限收缩到有限的环境中&lt;/strong>，这就是查询优化器干的事情。&lt;/p>
&lt;p>优化器借助关系理论提供的&lt;strong>语义无误的原始查询进行有效的等价变换&lt;/strong>。&lt;/p>
&lt;p>优化器的工作：&lt;/p>
&lt;ul>
&lt;li>优化是在数据真正要被执行的时候才发生的;&lt;/li>
&lt;li>有相同结果，但写法不同的关系表达式在实际环境下执行的效率相差很大:&lt;/li>
&lt;li>OceanBase的查询优化则是一个&lt;strong>规则优化和代价优化相结合&lt;/strong>的过程，其主体是基于成本进行查询优化，并在查询优化过程中通过规则进行启发和剪枝。
&lt;ul>
&lt;li>以前更多是基于规则的优化器 RBO, 现在大多数用的是基于成本的优化器 CBO&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>sql的执行顺序&lt;/strong>&lt;/p>
&lt;p>&lt;strong>解析是SQL优化是最消耗资源的过程.&lt;/strong>&lt;/p>
&lt;p>从解析中选择执行计划&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309155255554.png" alt="image-20230309155255554" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;ul>
&lt;li>你的&lt;strong>SQL仍然是它优化的起点&lt;/strong>，是它选择优化路径的提示，不同的SQL写法，会对查询优化器最终选择的路径产生影响。&lt;/li>
&lt;li>查询优化器不知道一些&lt;strong>影响实际执行效率的重要的信息&lt;/strong>，而这只有写SOL的程序员知道。&lt;/li>
&lt;/ul>
&lt;h3 id="21查看查询优化器的执行计划">2.1查看查询优化器的执行计划&lt;/h3>
&lt;p>&lt;strong>Oracle的执行计划&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309155531599.png" alt="image-20230309155531599" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>在使用explain plan for语句时，跟在后面的SQL并不真正执行，执行计划表中的数据和操作都是预估的，&lt;/p>
&lt;p>好处是，方便快捷，不影响数据库数据.&lt;/p>
&lt;p>缺点是，没有输出相关统计信息。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309155611613.png" alt="image-20230309155611613" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>MySql的执行计划&lt;/strong>:&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309155731369.png" alt="image-20230309155731369" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>第七列key:实际使用的索引;&lt;/p>
&lt;p>第十列rows:估算的找到所需数据需读取的行数:&lt;/p>
&lt;p>第十一列filtered:返回结果的行数占读取行数的百分比，值越大越好:&lt;/p>
&lt;p>&lt;strong>OceanBase的执行计划&lt;/strong>:&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309155810560.png" alt="image-20230309155810560" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="22查询优化器的有效范围">2.2查询优化器的有效范围&lt;/h3>
&lt;ol>
&lt;li>&lt;strong>1优化器需要借助数据库中找到的信息&lt;/strong>。&lt;/li>
&lt;/ol>
&lt;p>一是&lt;strong>普通统计数据&lt;/strong>，二是数据定义中重要的&lt;strong>声明信息&lt;/strong>&lt;/p>
&lt;p>尽量要把数据约束的语义信息在&lt;strong>数据库的声明中体现&lt;/strong>，这样优化器就可以利用数据取值范围这样的语义信息来做优化决策.&lt;/p>
&lt;ol start="2">
&lt;li>
&lt;p>只有能够进行数学意义上的&lt;strong>等价变换&lt;/strong>，优化效果才最佳。&lt;/p>
&lt;p>对于查询中的非关系部分优化器可借助的理论基础不多，优化结果和原始语句写法所指定的方式相差无几&lt;/p>
&lt;/li>
&lt;li>
&lt;p>一个独立执行的查询，优化效果可能很好，但把它嵌入一个更为复杂的查询内部，可能优化的效果就变差了&lt;/p>
&lt;p>优化器需要考虑&lt;strong>整体响应时间&lt;/strong>&lt;/p>
&lt;p>&lt;strong>预计需要查询越久的,查询优化器会花更多的时间去找优化路径.&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>优化器改善的是&lt;strong>独立查询&lt;/strong>&lt;/p>
&lt;p>优化器无法使独立的查询联系在一起进行统一优化，所以，如果通过过程化的编程提取了数据，再将数据传递到后续查询中，优化器是没有办法进行统一优化的&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="3使用sql需要考虑的因素">3.使用SQL需要考虑的因素&lt;/h2>
&lt;p>需要考虑的五大要素:&lt;/p>
&lt;ul>
&lt;li>获得结果集所需访问的数据量&lt;/li>
&lt;li>定义结果集所需的查询条件&lt;/li>
&lt;li>结果集的大小获得&lt;/li>
&lt;li>结果集所涉及的表的数量&lt;/li>
&lt;li>同时修改这些数据用户的多少&lt;/li>
&lt;/ul>
&lt;h3 id="31数据总量">3.1数据总量&lt;/h3>
&lt;p>SQL考虑&lt;strong>最重要因素:必须访问的数据总量&lt;/strong>&lt;/p>
&lt;p>没有&lt;strong>确定目标数据容量&lt;/strong>之前，很难断定查询执行的效率,这是后续所有工作的基础.&lt;/p>
&lt;h3 id="32定义结果集的查询条件">3.2定义结果集的查询条件&lt;/h3>
&lt;p>一个或几个数据表，经过Join操作，再通过查询条件的选择，会产生一个SQL查询的结果集，完成我们的查询。&lt;/p>
&lt;p>&lt;strong>从数据表到 结果集 发生的变化就是 查询条件&lt;/strong>&lt;/p>
&lt;p>查询条件是SQL优化的关键因素，也是写SQL的重要部分&lt;/p>
&lt;p>过滤条件的效率有高有低，受到其它因素的影响很大&lt;/p>
&lt;p>如果一个查询条件能剔除掉更多的数据，也就是满足这个查询条件的记录数很少，我们就称之为&lt;strong>高效的过滤条件&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>寻找高效的过滤条件是程序员写SQL需要重点考虑的问题&lt;/strong>&lt;/p>
&lt;h3 id="33结果集的大小">3.3结果集的大小&lt;/h3>
&lt;p>查询所返回的数据量，重要而被忽略&lt;/p>
&lt;p>取决于表的大小和&lt;strong>过滤条件的细节&lt;/strong>&lt;/p>
&lt;p>例外是 若干个&lt;strong>独立使用效率不高的条件结合起来效率非常高&lt;/strong>, 如双学位&lt;/p>
&lt;p>从技术角度来看，查询结果集的&lt;strong>大小并不重要&lt;/strong>，&lt;strong>重要的是用户的感觉&lt;/strong>&lt;/p>
&lt;p>熟练的开发者应该努力使&lt;strong>响应时间与返回的记录数成正比&lt;/strong>.&lt;/p>
&lt;h3 id="34表的数量">3.4表的数量&lt;/h3>
&lt;p>from中间连接表的数量对性能有很大影响,尽管现在的DBMS都可以高效地连接多个表.&lt;/p>
&lt;p>表的 join连接&lt;/p>
&lt;ul>
&lt;li>(太)多表连接该质疑设计的正确性了&lt;/li>
&lt;li>对于&lt;strong>优化器&lt;/strong>，随着表数量的增加，复杂度将呈指数增长&lt;/li>
&lt;li>编写 (太)多表的复杂查询时，&lt;strong>多种方式连接的选择失误的几率很高&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>在一个查询中间, 避免连接太多的表&lt;/p>
&lt;h3 id="35并发用户数">3.5并发用户数&lt;/h3>
&lt;p>设计sql时,随时&lt;strong>要关注并发性&lt;/strong>, 并发量大会导致原先并发量小时效率高的设计变得极低.&lt;/p>
&lt;ul>
&lt;li>数据块访问争用(block-accesscontention)&lt;/li>
&lt;li>阻塞(locking)&lt;/li>
&lt;li>闩定(latching)&lt;/li>
&lt;li>保证读取一致性(read consistency)&lt;/li>
&lt;/ul>
&lt;p>警惕多米诺骨牌一样的现象, 如内存不够用导致硬盘资源争夺, 进而导致其他cpu负载过重.&lt;/p>
&lt;p>也会有反例:&lt;/p>
&lt;p>DBA增加物理I/0操作，反而会使任务执行效率更高，因为某些计算密集型操作的并发执行程度很高，一个进程刚刚因等待I/O操作而阻塞，它释放出来的CPU就被另一个进程占用了，这样CPU的资源反而被充分利用了。&lt;/p>
&lt;p>必须要&lt;strong>考虑整体吞吐量,而不是个人响应时间&lt;/strong>.&lt;/p>
&lt;h2 id="4查询的过滤条件">4.查询的过滤条件&lt;/h2>
&lt;h3 id="41过滤条件的分类">4.1过滤条件的分类&lt;/h3>
&lt;p>如何限定结果集是最为关键的因素.&lt;/p>
&lt;p>过滤条件主要是指Where子句中的各种各样的条件 也包括having&lt;/p>
&lt;p>有些过滤条件直接作用于select运算符. 如某字段是否满足条件.&lt;/p>
&lt;p>还有其他用于连接表的. 可以分成如下两种:&lt;/p>
&lt;ul>
&lt;li>Join过滤条件&lt;/li>
&lt;li>Select过滤条件&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309162132327.png" alt="image-20230309162132327" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>不一定哪个效率快, 运行效率和优化器有关系，不同的写法首先是影响了优化器&lt;strong>进行路径选择的起始点&lt;/strong>.&lt;/p>
&lt;p>在没有效率问题的情况下，SQL的写法无关紧要，但是在&lt;strong>有效率问题的情况下，SQL的写法就会导致效率有很大差别。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>其他类型的条件&lt;/strong>:&lt;/p>
&lt;p>检查另一个表内是否存在特定数据的条件&lt;/p>
&lt;p>sql语法上类似,但语义上完全不同.&lt;/p>
&lt;h3 id="42过滤条件的含义">4.2过滤条件的含义&lt;/h3>
&lt;p>过滤条件的计算顺序有时候会影响效率.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309162532396.png" alt="image-20230309162532396" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>此时计算顺序无关紧要,但再加入一个条件:&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309162644909.png" alt="image-20230309162644909" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>在有些数据库中，试图把非数字字符串转化为整数的时候，会造成运行错误的问题.&lt;/p>
&lt;p>一般来说，数据库有一个基本的原则，就是对于where子句的条件如果优化器在优化的过程中没有什么理由和原因的话，一般是&lt;strong>按照顺序执行的&lt;/strong>&lt;/p>
&lt;p>&lt;strong>mysql是从左到右, Oracle 是从右到左.&lt;/strong>&lt;/p>
&lt;p>where&lt;strong>的顺序是很重要的&lt;/strong>&lt;/p>
&lt;h3 id="43基本原则">4.3基本原则&lt;/h3>
&lt;p>好的过滤条件要先做&lt;/p>
&lt;p>能过滤掉更多数据的条件也就是满足这个条件的记录越少，这个条件越好&lt;/p>
&lt;p>因为中间结果集的大小会不一样, 会影响性能.&lt;/p>
&lt;p>在复杂的高并发大数据量的系统中，一个查询的执行计划往往要做很多步骤，&lt;strong>中间结果集的大小&lt;/strong>，会从整体上影响整个系统的吞吐量中间结果集过大，会对缓存、硬盘、CPU都造成压力。&lt;/p>
&lt;p>更重要的是，哪个过滤条件好，哪个过滤条件坏，查询优化器不一定知道，这是只有知道业务需求的程序员才知道的事情。&lt;/p>
&lt;p>写SQL前要对过滤条件排序，去寻找高效的过滤条件&lt;/p>
&lt;p>真正高效的过滤条件是查询的主要驱动力，低效条件只是为了业务要求的正确性对高效的过滤条件起到辅助筛选的作用。&lt;/p>
&lt;p>定义高效过滤条件的准则:是否能够尽快减少必须处理的数据总量&lt;/p>
&lt;p>思考题:你能列举出哪些where字句中用于过滤的关键字呢?&lt;/p>
&lt;h2 id="5高效过滤条件的举例">5.高效过滤条件的举例&lt;/h2>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309163212559.png" alt="image-20230309163212559" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309163223970.png" alt="image-20230309163223970" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>和join on指定的条件相关,也和过滤条件的顺序相关.&lt;/p>
&lt;p>古老的方式:&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309163403832.png" alt="image-20230309163403832" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>没有适用于所有情况的解决方案.&lt;/p>
&lt;p>但上面的用了distinct,会把同名的人给合并.&lt;/p>
&lt;p>避免在最高层distinct应该是一条基本规则; 因为即便遗漏了连接的条件,仍然会正常允许.&lt;/p>
&lt;p>现实中,应该返回具有唯一性的客户ID和客户名，以保证得到BMW买家的完整清单&lt;/p>
&lt;p>&lt;strong>摆脱distinct的方法&lt;/strong>&lt;/p>
&lt;p>&lt;strong>关联子查询&lt;/strong>:&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309163645545.png" alt="image-20230309163645545" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>缺点, 子查询执行很多次. 取决于 第一个过滤条件的好坏.&lt;/p>
&lt;p>&lt;strong>非关联子查询&lt;/strong>:&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309163825049.png" alt="image-20230309163825049" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>找到分辨率最强的条件&lt;/p>
&lt;ul>
&lt;li>解决方案不止一种，查询和数据隐含的假设密切相关&lt;/li>
&lt;li>预先考虑优化器的工作，以确定它能找到所需要的数据&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309163932229.png" alt="image-20230309163932229" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h2 id="6sql优化的其他问题">6.SQL优化的其他问题&lt;/h2>
&lt;h3 id="61sql的连接问题">6.1SQL的连接问题&lt;/h3>
&lt;p>第一个问题是&lt;strong>滥用子查询&lt;/strong>,&lt;/p>
&lt;p>子查询有两个好处:&lt;/p>
&lt;ul>
&lt;li>分辨过滤条件的好坏&lt;/li>
&lt;li>避免顶层的distinct&lt;/li>
&lt;/ul>
&lt;p>但如果没有以上两个好处,不如把选择权交给查询优化器.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309164152188.png" alt="image-20230309164152188" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>但还有一种情况,&lt;strong>杜绝使用子查询&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309164315664.png" alt="image-20230309164315664" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>以上方法性能很差.,因为是要选择没有分配的.&lt;/p>
&lt;p>应该用out join&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309164344992.png" alt="image-20230309164344992" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="把聚合子查询转化为join或内嵌视图">把聚合子查询转化为JOIN或内嵌视图&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309164543277.png" alt="image-20230309164543277" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309164638238.png" alt="image-20230309164638238" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>上面orderstatus被访问了多次&lt;/p>
&lt;p>可以做成非关联嵌套子查询&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309164738725.png" alt="image-20230309164738725" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>但性能还有问题.&lt;/p>
&lt;p>要告诉优化器,先获得子查询的结果集再连接这个表.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309164849679.png" alt="image-20230309164849679" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>最好是使用内嵌的视图.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309164936407.png" alt="image-20230309164936407" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>虽然做了一次大表遍历,但省了连接.&lt;/p>
&lt;p>但如果状态很多,还需要用OLAP或者SQL引擎来进行优化.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/Sql%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96/image-20230309165102184.png" alt="image-20230309165102184" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">select&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">from&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">select&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">max&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">totalitems&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">as&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">mx&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">custid&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">from&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">orders&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">group&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">by&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">custid&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">o1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">join&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">orders&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">o2&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">where&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">o1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">mx&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">o2&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">totalitems&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">and&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">o1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">custid&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">o2&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">custid&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%A4%84%E7%90%86%E5%8F%8A%E5%8F%8D%E8%8C%83%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%A4%84%E7%90%86%E5%8F%8A%E5%8F%8D%E8%8C%83%E5%BC%8F/</guid><description>&lt;p>数据库表结构设计&lt;/p>
&lt;ul>
&lt;li>不同设计对相同的查询会产生什么样不同的效率影响。&lt;/li>
&lt;li>打破范式可以提高效率.&lt;/li>
&lt;/ul>
&lt;h2 id="1处理层次结构">1.处理层次结构&lt;/h2>
&lt;p>以人类最熟悉的数据存储组织的方式最早出现
层次数据库存储数据存在一种逻辑嵌套，不是一种对数据的线性排列. 后续还出现了多重层次连接的网状数据库.&lt;/p>
&lt;p>直到关系理论出现, 使得操控的灵活性，数据的组织，以及数据访问的效率上，找到了一个非常好的平衡&lt;/p>
&lt;p>但层次组织数据的方式还是有很多的使用. 如:XML,LDAP都是基于树状结构的层次组织.&lt;/p>
&lt;p>&lt;strong>层次结构复杂的原因&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>访问数据的方式，本质是一个访问树的方式，需要访问树的全部或者
部分节点。&lt;/li>
&lt;li>通常需要按照访问顺序返回这些数据.&lt;/li>
&lt;li>&lt;strong>过程化的访问方式，是违背关系理论&lt;/strong>的，造成了一种&lt;strong>mismatch&lt;/strong>。&lt;/li>
&lt;li>在关系结构中，构建层次数据的存储和访问都很困难。&lt;/li>
&lt;/ul>
&lt;p>树状结构有三种表结构的设计方式，都是满足三范式三种完全不同的设计方式&lt;/p>
&lt;h3 id="11邻接模型">1.1邻接模型&lt;/h3>
&lt;p>层次中父记录ID作为子记录(childrow) 的一个属性，树中两个相邻的节点&lt;/p>
&lt;p>因而被明确关联在一一起。&lt;/p>
&lt;p>设计直观简单,但会导致&lt;strong>递归的查询&lt;/strong>。&lt;/p>
&lt;h3 id="12物化路径模型">1.2物化路径模型&lt;/h3>
&lt;p>把树中的每个节点、与它
在树中的位置的描述数据相结合。&lt;/p>
&lt;p>1代表第一章;&lt;/p>
&lt;ol>
&lt;li>2代表第一章第二节;
1.2.3代表第一章第二节
第三小节。&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>与邻接模型的差别&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>邻接模型的子节点是平等的&lt;/li>
&lt;li>物化路径模型可以指出&lt;strong>兄弟的排名&lt;/strong>。&lt;/li>
&lt;li>且可以无限扩展,扩展很多层。&lt;/li>
&lt;/ul>
&lt;h3 id="13嵌套集合模型">1.3嵌套集合模型&lt;/h3>
&lt;p>每个节点被赋予了一对数字，其中父节点的两个数字包含其所有的子节点的左右数字，然后一层一层
这样包含下去。&lt;/p>
&lt;h3 id="14嵌套间隔模型nested-interval">1.4嵌套间隔模型(nested interval)&lt;/h3>
&lt;p>思想是以两个数字为特定节点的&lt;strong>路径编码&lt;/strong>，这两个数字被解释成有理数(就是分数)的&lt;strong>分子和分母&lt;/strong>。 太复杂了不讲.&lt;/p>
&lt;h3 id="15树状结构的三种方式访问的比较">1.5树状结构的三种方式访问的比较&lt;/h3>
&lt;p>例子 &lt;strong>军队结构&lt;/strong>.&lt;/p>
&lt;p>&lt;strong>邻接模型&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230309190604145.png" alt="image-20230309190604145" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230227192057736.png" alt="image-20230227192057736" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>物化路径模型&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230309190631784.png" alt="image-20230309190631784" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230227192122633.png" alt="image-20230227192122633" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>嵌套集合模型&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230227192142928.png" alt="image-20230227192142928" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>特征:节点[left_num,right_num]值必定介于其任一个祖先的[left_num,right_num]值之间，这就是“嵌套集合”的由来。(nested set)&lt;/p>
&lt;p>叶子结点即right_num = left_num + 1&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230227192211959.png" alt="image-20230227192211959" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h2 id="2层次结构的自顶向下查询">2.层次结构的自顶向下查询&lt;/h2>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230227192330951.png" alt="image-20230227192330951" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230309190847607.png" alt="image-20230309190847607" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>以下用oracle&lt;/p>
&lt;h3 id="邻接模型">邻接模型&lt;/h3>
&lt;p>oracle专有关键词：ocean base也支持&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230309190953499.png" alt="image-20230309190953499" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>使用了虚拟的level字段。&lt;/p>
&lt;p>不用connect by时，需要使用with as来递归&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230309191109258.png" alt="image-20230309191109258" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230309191120429.png" alt="image-20230309191120429" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230227192536512.png" alt="image-20230227192536512" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>with as 实现。但是层次遍历，不是深度优先遍历。&lt;/p>
&lt;p>需要&lt;strong>定义层次&lt;/strong>来进行重新的排序。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230309191243402.png" alt="image-20230309191243402" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>便捷的方法是用connectted by&lt;/p>
&lt;p>&lt;strong>mysql的问题&lt;/strong>&lt;/p>
&lt;p>MySQL8.0添加了CTE支持with as&lt;/p>
&lt;p>8.0之前版本;两个方法手动union在一个查询中多次连接&lt;/p>
&lt;h3 id="物化路径模型">物化路径模型&lt;/h3>
&lt;ul>
&lt;li>查询编写不困难&lt;/li>
&lt;li>计算由路径导出的&lt;/li>
&lt;li>层次不方便假设&lt;/li>
&lt;li>mp_depth(函数返回当前节点深度) 用字符串处理&amp;quot;.&amp;quot;&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230227192847984.png" alt="image-20230227192847984" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="嵌套集合模型">嵌套集合模型&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230309191511744.png" alt="image-20230309191511744" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>兄弟节点要排序就很复杂。&lt;/p>
&lt;p>计算节点数量无法从leftnum和right_num导出.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230309191542150.png" alt="image-20230309191542150" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="比较性能的方法">比较性能的方法&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230227193009108.png" alt="image-20230227193009108" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>影响物化路径模型的因素&lt;/strong>&lt;/p>
&lt;p>1.计算深度
计算两个字符串函数的差，所带来的代价;&lt;/p>
&lt;p>2.缩排函数
物化路径模型需&lt;strong>不断地处理字符串&lt;/strong>，在where子句中不断的执行字符
串操作，处理速度比邻接模型更慢。&lt;/p>
&lt;p>&lt;strong>嵌套集合模型&lt;/strong>&lt;/p>
&lt;p>找后代方面胜于其他两个模型，但为&lt;strong>缩排&lt;/strong>付出更大代价;&lt;/p>
&lt;p>性能的降低和额外连接，以及group by所做的深度有关&lt;/p>
&lt;p>改善嵌套集合模型性能,其代价巨大&lt;/p>
&lt;h2 id="5自底向上的查询-hightland查询">5.自底向上的查询 Hightland查询&lt;/h2>
&lt;p>&lt;strong>自底向上查询的特点&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>自顶向下查询只有一个起点; 而自底向上查询&lt;strong>可能有多个出发点&lt;/strong>。
·多个记录都包含highland查询。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在description字段中查找“Highland”字符,
必然&lt;strong>导致完整表扫描&lt;/strong>.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>自底向上查询效率慢于自顶向下查询&lt;/strong>&lt;/p>
&lt;h3 id="51邻接模型">5.1邻接模型&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230309192326051.png" alt="image-20230309192326051" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>connect by 不是关系操作, 是基于过程的关键词,&lt;strong>不存储中间结果集&lt;/strong>,&lt;/p>
&lt;h3 id="52物化路径模型">5.2物化路径模型&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230309192441538.png" alt="image-20230309192441538" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>重复项和记录顺序的问题的解决方式&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230309192517555.png" alt="image-20230309192517555" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>另一种方式把节点的物化路径分解成路径列表，即列转行的方式.&lt;/p>
&lt;p>树状结构表增加到千行以上，like比较方法性能风险可能会大大提升&lt;/p>
&lt;h3 id="53嵌套集合查询">5.3嵌套集合查询&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230227193634675.png" alt="image-20230227193634675" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="54比较效率">5.4比较效率&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230227193659877.png" alt="image-20230227193659877" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>结果 connect by 查询效果依旧卓越.&lt;/p>
&lt;p>物化路径和嵌套集合模型都只有邻接模型的一半的效率。&lt;/p>
&lt;ul>
&lt;li>物化路径不该是主键，即使它们有唯一性。字符串不适合做主键且主键最好不要更新.&lt;/li>
&lt;li>所选择的编码方式不需要完全中立
&lt;ul>
&lt;li>F.3.1.1 变成 F030101&lt;/li>
&lt;li>但这种方法不通用.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="4聚合来自树的值">4.聚合来自树的值&lt;/h2>
&lt;p>一.对保存于&lt;strong>叶节点中的值做聚合&lt;/strong>; 简单的树,单一父节点&lt;/p>
&lt;p>二.计算某个值散布在树中各层次的百分比。&lt;/p>
&lt;h3 id="41第一个查询">4.1第一个查询&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230309193055261.png" alt="image-20230309193055261" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>对于邻接模型&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230227194121906.png" alt="image-20230227194121906" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>对于物化路径模型&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230309193243048.png" alt="image-20230309193243048" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>性能差异&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230309193319263.png" alt="image-20230309193319263" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="42第二个问题-多父节点时无法在一张表中解决">4.2第二个问题 多父节点时,无法在一张表中解决&lt;/h3>
&lt;p>邻接模型和物化路径模型设计仍然存在局限性;&lt;/p>
&lt;p>物料单位问题 BOM问题&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230227194421886.png" alt="image-20230227194421886" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>出现的问题&lt;/strong>:&lt;/p>
&lt;p>一、龙蛋壳成分有多个父
节点，5号魔药和9号基础魔药都是它的父亲节点。&lt;/p>
&lt;p>二、计算龙蛋壳在5号魔
药中占比，不仅要计算5号魔药本身的龙蛋壳的百
分比，还要加上9号魔药
中龙蛋壳的含量。&lt;/p>
&lt;p>&lt;strong>解决方案:&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230227194512062.png" alt="image-20230227194512062" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>一个components包含多个composition，一个处方，也包含多个composition。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230309193629175.png" alt="image-20230309193629175" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>用with as 做递归&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230309193641103.png" alt="image-20230309193641103" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="43树状结构问题">4.3树状结构问题&lt;/h3>
&lt;p>关系型数据库非常难处理树状结构&lt;/p>
&lt;p>因为性能非常差，处理层次型数据很困难。
SQL缺乏处理树结构的
强大的、可伸缩的手段。&lt;/p>
&lt;p>不同的表结构设计，在相同的查询下，性能也会差距甚大.&lt;/p>
&lt;p>不建议对关系模型不建议对屡遭诟病的缓慢本性 反规范化，这很容易遮掩程序设计中的问题&lt;/p>
&lt;h2 id="5对冗余的控制反范式">5.对冗余的控制（反范式）&lt;/h2>
&lt;h3 id="51范式的概念">5.1范式的概念&lt;/h3>
&lt;p>1NF:一个字段，只有一
个值。&lt;/p>
&lt;p>2NF:一条记录，可以被唯一的主键所区分，是一个实体有唯一的标识。&lt;/p>
&lt;p>3NF :字段和字段之间不存在函数依赖。&lt;/p>
&lt;p>设置范式的原因： &lt;strong>控制冗余&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>如果一个值，在关系型数据库中存在多个地方，那么他们应该一起被修改，否则数据完整性就没有办法保障了&lt;/li>
&lt;li>但数据访问压力大，需从数据库设计入手，通过打破三范式提高数据库访问的性能。&lt;/li>
&lt;/ul>
&lt;p>打破范式的根本逻辑在于&lt;strong>降低表连接数量&lt;/strong>。
提升了查询效率，降低了SQL优化器的优化难度。&lt;/p>
&lt;h3 id="52第一范式">5.2第一范式&lt;/h3>
&lt;p>含义：一个字段只有一个值;
不仅仅是存储的要求，也同样是&lt;strong>使用的要求&lt;/strong>。&lt;/p>
&lt;p>满足一范式的本质:把这个字段&lt;strong>只当成一个值&lt;/strong>来使用，不能拆散使用。&lt;/p>
&lt;p>如：身份证号码不和 生日 产生依赖。&lt;/p>
&lt;p>&lt;strong>判断三范式&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>一个字段的全部，不能和其它字段产生函数依赖。&lt;/li>
&lt;li>而不是一个字段的一-部分是不是和其它字段产生函数依赖。&lt;/li>
&lt;li>任何拆分字段的使用方式，本质上都是打破了一范式。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>三范式的实践基础&lt;/strong>&lt;/p>
&lt;p>一个字段只当成一个值使用。
生日和年龄是函数依赖关系，身份证号码和生日在实践意义上并不构成函数依赖。&lt;/p>
&lt;h3 id="53打破范式的本质">5.3打破范式的本质&lt;/h3>
&lt;p>引入&lt;strong>受控的冗余&lt;/strong>，确定是否通过放松规范化规则来提高系统的性能。&lt;/p>
&lt;p>规范化的结果是一个结构上拥有&lt;strong>一致且最少冗余&lt;/strong>的逻辑数据库设计。&lt;/p>
&lt;p>有必要放弃完全规范化而得到某些性能上的好处。&lt;/p>
&lt;p>&lt;strong>一旦打破范式需要考虑的三因素&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>规范弱化使得&lt;strong>实现变得更加复杂&lt;/strong>，因为需要&lt;strong>手动保持数据的完整性&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>规范弱化会&lt;strong>降低灵活性&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>规范弱化会加快元组检索的速度，但却会&lt;strong>使更新速度变慢&lt;/strong>。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>通常的经验&lt;/strong>：&lt;/p>
&lt;p>80%的性能问题来自于开发和对数据库的使用不当，&lt;/p>
&lt;p>&lt;strong>但如果系统具有低修改性和高查询率，规范弱化可能是提高数据库&lt;/strong>
&lt;strong>查询效率一种可行的选择。&lt;/strong>&lt;/p>
&lt;p>用复制的方式打破范式，比如将某些属性或者将某些关系连
接起来，以&lt;strong>减少执行查询时所需要的连接操作&lt;/strong>。&lt;/p>
&lt;p>规范弱化取决于系统具体情况。&lt;/p>
&lt;h3 id="规范弱化模式">规范弱化模式&lt;/h3>
&lt;p>了解打破范式的几种手段，按照相应模式需求，构建手动的方式保证数据的完整性&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230227195347207.png" alt="image-20230227195347207" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>打破范式的步骤：&lt;/p>
&lt;p>画好ER模型→分辨一对一、一对多和多对多关系→构建三范式表结构设计。&lt;/p>
&lt;h2 id="6反范式的实现">6.反范式的实现&lt;/h2>
&lt;h3 id="61合并一对一关系">6.1合并一对一关系&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230309194735438.png" alt="image-20230309194735438" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>合并：基于全部参与的实体为主，引入部分参与的表。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230227195601373.png" alt="image-20230227195601373" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>产生空值。&lt;/p>
&lt;h3 id="62复制一对多关系中的非键列来减少连接">6.2复制一对多关系中的非键列来减少连接&lt;/h3>
&lt;p>在子表中复制一个或更多的&lt;strong>父表中非键列来减少或删除链接&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230227195721370.png" alt="image-20230227195721370" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>此时最需要关注更新，可能需要&lt;strong>使用触发器&lt;/strong>。&lt;/p>
&lt;h3 id="3复制一对多关系中的外键列来减少连接">3.复制一对多关系中的外键列来减少连接&lt;/h3>
&lt;p>为减少或删除常用或关键查询的连接，复制关系中一个或多个外键列来提高
查询的效率。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230309194939656.png" alt="image-20230309194939656" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230227195815024.png" alt="image-20230227195815024" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="64复制多对多的列">6.4复制多对多的列&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230227195834238.png" alt="image-20230227195834238" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="65引入重复组">6.5引入重复组&lt;/h3>
&lt;p>重复组：一组地址，一组电话号码，用户有多个。&lt;/p>
&lt;p>满足范式要求:单独建一张地址或者电话的表，做连接查询。&lt;/p>
&lt;p>打破方法：&lt;/p>
&lt;ul>
&lt;li>把重复组全部打包放在主表中，增加n列
&lt;ul>
&lt;li>1)重复组的绝对数量是已知的&lt;/li>
&lt;li>2该数量是静态的，不会改变&lt;/li>
&lt;li>
&lt;ol start="3">
&lt;li>该数量并不是很大，通常不大于10&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>主表中存储缺省的电话和地址，所有地址和电话都单独存在地址表和电
话表中。
&lt;ul>
&lt;li>大部分查询，只需要缺省值。&lt;/li>
&lt;li>优点:通用性和效率都可以达到很好的平衡&lt;/li>
&lt;li>缺点：需要在UI中分开&lt;/li>
&lt;li>缺省值的读取和全部值的读取都在不同页面。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="66创建提取表">6.6创建提取表&lt;/h3>
&lt;p>将查询慢需要的表连接成
大表并储存下来。&lt;/p>
&lt;p>查询可以访问派生数据并
在同一组基表上执行多表联接。&lt;/p>
&lt;p>不能做实时计算，得到数据可能是&lt;strong>相对静态&lt;/strong>
的，也可能不一定是最新的。&lt;/p>
&lt;p>好处大，缺点非常大&lt;/p>
&lt;p>带来非常大的复杂性，导致数据库中存在各种同步的、异步的、有用的没用的提取表。
数据更新耗费后续人员极长时间&lt;/p>
&lt;h3 id="67关于打破范式">6.7关于打破范式&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230227200214330.png" alt="image-20230227200214330" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>受控的冗余引入，冗余不可怕，但需要受控。&lt;/p>
&lt;h3 id="68总结">6.8总结&lt;/h3>
&lt;p>四个角度讨论查询优化的问题：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e5%a4%84%e7%90%86%e5%8f%8a%e5%8f%8d%e8%8c%83%e5%bc%8f/image-20230309195507718.png" alt="image-20230309195507718" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E9%97%AE%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E9%97%AE%E9%A2%98/</guid><description>&lt;h2 id="1黑盒问题">1.黑盒问题&lt;/h2>
&lt;p>不能当作黑盒。&lt;/p>
&lt;p>因为数据库其实不存在独立性。&lt;/p>
&lt;h3 id="11体系结构的巨大差异">1.1体系结构的巨大差异&lt;/h3>
&lt;p>会导致数据库的连接，数据库并发处理等差异&lt;/p>
&lt;p>数据库迁移会出现很多问题。&lt;/p>
&lt;h3 id="12黑盒与数据库独立性的问题">1.2黑盒与数据库独立性的问题&lt;/h3>
&lt;p>数据库有脱离实现级别的使用方法。&lt;/p>
&lt;ul>
&lt;li>要构建一个完全的数据库独立应用，而且是高度可扩展的应用是极其-
&lt;ul>
&lt;li>困难不依赖于任何一个数据库，既可在Oracle上运行，也可在MySQL上运行实际上几乎不可能&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>要构建一个完全独立的数据库应用:
&lt;ul>
&lt;li>必须真正了解每个数据库具体如何工作&lt;/li>
&lt;li>如果清楚每个数据库工作的具体细节，数据库独立性可能并不满足&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>如&lt;strong>Null值&lt;/strong>造成的&lt;strong>数据库迁移障碍&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>在Sybase中间（is NULL）返回的是true&lt;/li>
&lt;li>在Oracle中间返回的仍然是空&lt;/li>
&lt;/ul>
&lt;h2 id="2不同数据库中的差异--并发控制">2.不同数据库中的差异 —— 并发控制&lt;/h2>
&lt;p>并发控制是用于保护数据库完整性的技术&lt;/p>
&lt;ul>
&lt;li>产生并发问题主要原因: 事务的隔离性没控制好，一致性不能得到保证&lt;/li>
&lt;li>并发机制不正确可能导致脏读、幻读和不可重复读等此类问题&lt;/li>
&lt;/ul>
&lt;h3 id="21不同数据库的并发控制不同">2.1不同数据库的并发控制不同&lt;/h3>
&lt;p>如果不了解数据库如何实现并发控制，就没有办法做&lt;strong>性能优异的并发系统&lt;/strong>，就&lt;strong>一定会有不好的结果&lt;/strong>。&lt;/p>
&lt;p>车辆排队时间随着数量增加，后续会呈现&lt;strong>指数增长&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>一方面要花费更大的额外时间来管理，需要划线，需要维持现场秩序。&lt;/li>
&lt;li>另一方面，收费站问题，最终可能引起整个&lt;strong>高速公路连锁反应&lt;/strong>。&lt;/li>
&lt;li>在数据库中间把它称之为&lt;strong>上下文切换&lt;/strong>。&lt;/li>
&lt;li>现实存在并发，需保持&lt;strong>数据一致性&lt;/strong>，所以要做并发控制。‘&lt;/li>
&lt;/ul>
&lt;h3 id="22当前数据库系统如何使用锁机制">2.2当前数据库系统如何使用锁机制&lt;/h3>
&lt;p>数据库通过锁机制来处理并发问题。&lt;/p>
&lt;p>行级锁：乐观锁、二段锁。&lt;/p>
&lt;p>不同数据库的&lt;strong>锁机制不一致&lt;/strong>、&lt;strong>差异性&lt;/strong>将极大程度地影响数据库的并发控制机制。&lt;/p>
&lt;ul>
&lt;li>有些数据可能有页级锁、另外一些有行级锁，有些实现会把行级锁升级为页级锁，另外一些则不然; 有些使用读锁，另外一些不使用。&lt;/li>
&lt;li>有些通过锁定实现&lt;strong>串行化事务&lt;/strong>，另外一些则通过数据库的**“读一致”视图**来实现(没有锁）。&lt;/li>
&lt;/ul>
&lt;p>不了解锁机制有时将导致致命的bug。&lt;/p>
&lt;h3 id="23orcale数据库的锁机制有时无法读正确数据-特别地">2.3Orcale数据库的锁机制有时无法读正确数据。 特别地&lt;/h3>
&lt;p>Orcale的多版本控制、读一致性模型：&lt;/p>
&lt;ul>
&lt;li>读一致性：对一个时间点的查询结果是一致的。&lt;/li>
&lt;li>非阻塞性读：读不会被写阻塞。//但其他数据库可能会&lt;/li>
&lt;/ul>
&lt;p>Orcale锁机制的好处：&lt;/p>
&lt;ul>
&lt;li>因为没有读锁，读和写可以并发，并发效率提高。&lt;/li>
&lt;li>&lt;strong>其他数据库&lt;/strong>使用了&lt;strong>读共享锁&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%bc%80%e5%8f%91%e4%b8%ad%e7%9a%84%e6%95%b0%e6%8d%ae%e5%ba%93%e9%97%ae%e9%a2%98/image-20230308141957218.png" alt="image-20230308141957218" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>充分了解锁机制、才能发挥数据库管理系统的最大潜能。&lt;/p>
&lt;h2 id="3数据库的并发控制对程序员影响">3.数据库的并发控制——对程序员影响&lt;/h2>
&lt;h3 id="31-orcale的读一致性">3.1 Orcale的读一致性&lt;/h3>
&lt;p>特点：对一个时间点的查询结果是一致的。读和写可以并发，并发效率提高。&lt;/p>
&lt;p>Orcale的无阻塞设计的&lt;strong>副作用&lt;/strong>：&lt;/p>
&lt;p>当要保证一次最多只有一个用户访问一行数据，需要开发人员做工作。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%bc%80%e5%8f%91%e4%b8%ad%e7%9a%84%e6%95%b0%e6%8d%ae%e5%ba%93%e9%97%ae%e9%a2%98/image-20230308142438375.png" alt="image-20230308142438375" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>因为where中查询时，两条数据都是合法的，都能插入，此时会出现业务逻辑错误。&lt;/p>
&lt;p>&lt;strong>修改方式&lt;/strong>：&lt;/p>
&lt;p>使用FOR UPDATE关键字，表示这个读是用来修改的，此时有个共享锁机制。&lt;/p>
&lt;h3 id="32-不能把数据库当成黑盒使用">3.2 不能把数据库当成黑盒使用&lt;/h3>
&lt;p>HIBERNATE
·对可持续化的类直接连接数据库，进行可持续化的存储。&lt;/p>
&lt;ul>
&lt;li>Hibernate并不会为 sqlserver，DB2，oracle生成不同的代码，而每个数据库的特征又是如此的不一样。&lt;/li>
&lt;li>数据库有时跟编译器一样，只能做语法检查&lt;/li>
&lt;li>很难对一个数据库的操作进行对错的判断，&lt;strong>很难debug&lt;/strong>&lt;/li>
&lt;li>因此需要在每个环节尽量&lt;strong>避免引入bug&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>oracle mysql SqlServer数据库上差异，导致了并发处理上的差别&lt;/p>
&lt;h3 id="33程序员通过程序来考虑并发问题的情况">3.3程序员通过程序来考虑并发问题的情况：&lt;/h3>
&lt;p>回答：不知道、看情况。&lt;/p>
&lt;ul>
&lt;li>并发控制
90%的情况下，
并发都是完全透明，无需担心。&lt;/li>
&lt;li>10%的情况下，必须清楚哪些情况下需要自己考虑
并发控制。&lt;/li>
&lt;/ul>
&lt;p>需要做什么：&lt;/p>
&lt;ul>
&lt;li>了解每个feature的
结构和实现，避免犯错。&lt;/li>
&lt;li>测试，而且要&lt;strong>学会在多用户环境下&lt;/strong>对代码进行不断的测试。&lt;/li>
&lt;/ul>
&lt;h2 id="4为性能而设计">4.为性能而设计&lt;/h2>
&lt;h3 id="41-性能调优">4.1 性能调优&lt;/h3>
&lt;p>避免依赖专家调优。因为专家调优不靠谱。&lt;/p>
&lt;h3 id="性能调优的两种方式">性能调优的两种方式：&lt;/h3>
&lt;ul>
&lt;li>根据当前CPU能力、可用内存、I/O子系统等资源情况来设置相应参数。数据库管理员（专家）要做的事情，大概提高20-30%。&lt;/li>
&lt;li>通过索引、物理结构、SQL的优化，具体提高某&amp;ndash;个查询的性能。本身是程序员要做的事情。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>决定性能的根本原因—— 设计（提高性能的基础）&lt;/strong>&lt;/p>
&lt;p>体系结构设计决定了数据库系统的性能上限（&lt;strong>性能级别&lt;/strong>）。&lt;/p>
&lt;p>比如：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>动态页面：对于百万量级访问负担重。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>静态页面：还需要额外的内容管理系统。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>修改对顺序文件是极大的性能障碍，所以这些系统都不提供修改功能。&lt;/p>
&lt;p>&lt;strong>设计决定了性能指标&lt;/strong>，性能拙劣的罪魁祸首都是错误的设计。&lt;/p>
&lt;p>性能指标都是有成本的，性能设计是在安全和优化中寻找平衡&lt;/p>
&lt;h3 id="42性能指标--要考虑整体性">4.2性能指标 —— 要考虑整体性&lt;/h3>
&lt;ul>
&lt;li>以前的，查询事务，多少s能够返回数据&lt;/li>
&lt;li>以&lt;strong>吞吐量&lt;/strong>为核心。每秒&lt;strong>处理多少事务&lt;/strong>。（&lt;strong>整体性&lt;/strong>）&lt;/li>
&lt;li>数据库环境，web服务器的环境，只能支持3000个并发&lt;/li>
&lt;li>比如OceanBase的成绩单上写，它承载了双十一峰值6100万次/秒的数据库访问这就是针对访问吞吐量的指标&lt;/li>
&lt;/ul>
&lt;p>一个&lt;strong>具体的sql的性能提升&lt;/strong>，也许会&lt;strong>导致其它操作性能的下降&lt;/strong>，使整个&lt;strong>系统吞吐量&lt;/strong>下降。‘性能指标要考虑整体性：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>任何一个技术可以解决一个问题，但必然存在另一个问题的风险&lt;/p>
&lt;/li>
&lt;li>
&lt;p>debug能力和使用优化工具的能力，是每个数据库工程师应该有的。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%bc%80%e5%8f%91%e4%b8%ad%e7%9a%84%e6%95%b0%e6%8d%ae%e5%ba%93%e9%97%ae%e9%a2%98/image-20230201115754595.png" alt="image-20230201115754595" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="43-整体层面考虑性能优化">4.3 整体层面考虑性能优化&lt;/h3>
&lt;p>数据的&lt;strong>性能直接指标&lt;/strong>就是&lt;strong>CPU或者是I/O的负载&lt;/strong>的问题.所以要监控CPU，IO负载。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>CPU负载高，I/O负载低&lt;/p>
&lt;ul>
&lt;li>内存不够&lt;/li>
&lt;li>磁盘性能差(磁盘问题、RAID设计不好，
RAID降级)&lt;/li>
&lt;li>&lt;strong>SQL的问题&lt;/strong>&lt;/li>
&lt;li>&lt;strong>并发锁机制的问题&lt;/strong>&lt;/li>
&lt;li>&lt;strong>事务设计问题，大量小数据I/O&lt;/strong>&lt;/li>
&lt;li>&lt;strong>大量的全表扫描&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>I/O负载高，CPU负载低&lt;/p>
&lt;ul>
&lt;li>&lt;strong>大量小的I/O执行写操作&lt;/strong>&lt;/li>
&lt;li>**Autocommit，产生大量小/0 **自动提交&lt;/li>
&lt;li>&lt;strong>大量大的I/O执行写操作&lt;/strong>&lt;/li>
&lt;li>&lt;strong>SQL的问题&lt;/strong>&lt;/li>
&lt;li>IOPS: 磁盘每秒的读写次数&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>都高&lt;/p>
&lt;ul>
&lt;li>硬件不够用&lt;/li>
&lt;li>&lt;strong>SQL存在明显问题&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>性能问题 90%是程序员问题，开发环境到生产环境容易出问题。&lt;/p>
&lt;p>&lt;strong>数据库应用要从自己身上找原因&lt;/strong>&lt;/p>
&lt;p>sql优化的方向：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e5%bc%80%e5%8f%91%e4%b8%ad%e7%9a%84%e6%95%b0%e6%8d%ae%e5%ba%93%e9%97%ae%e9%a2%98/image-20230201120131053.png" alt="image-20230201120131053" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E5%92%8C%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E5%92%8C%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8F/</guid><description>&lt;p>并发问题: 单独一个session执行的时候，很多问题不会暴露，但多个
session一起访问的时候，就会遇到问题。&lt;/p>
&lt;p>并发用户遇到最多的是更新问题，即&lt;strong>多个用户更新相同资源的时候&lt;/strong>，会
产生数据冲突的问题，以及随后会采用的各种级别的锁的问题。&lt;/p>
&lt;p>并发也会涉及&lt;strong>读取问题&lt;/strong> （各种资源竞争）&lt;/p>
&lt;p>一、并发读取和并发修改的常见问题和解决方案;&lt;/p>
&lt;p>二、数据库事务隔离级别:&lt;/p>
&lt;p>三、大数据量的一些处理手段。&lt;/p>
&lt;h2 id="1处理并发和大数据量">1.处理并发和大数据量&lt;/h2>
&lt;h3 id="11并发读取问题">1.1并发读取问题&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227200500826.png" alt="image-20230227200500826" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>有索引和没索引对数据访问的差距&lt;/strong>：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227200620323.png" alt="image-20230227200620323" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>5000数据量太少，所以单次查询的测试感觉不明显。&lt;/p>
&lt;p>单位时间内，随机间隔执行若干次。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230309200022761.png" alt="image-20230309200022761" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230309200051642.png" alt="image-20230309200051642" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227200824602.png" alt="image-20230227200824602" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="12排队">1.2排队&lt;/h3>
&lt;p>单个查询的时间慢，队会越排越长，性能也越来越差。&lt;/p>
&lt;p>队伍的增长速度与查询的执行频率和查询所需平均时间之间的比例有关,比例拉高，查询越来越快，&lt;strong>队伍就越拉越长&lt;/strong>。&lt;/p>
&lt;p>即&lt;strong>阈值效应&lt;/strong>。数据库是非常典型的具备闯值效应的东西.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230309200313192.png" alt="image-20230309200313192" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h2 id="2并发修改数据-加锁">2.并发修改数据-加锁&lt;/h2>
&lt;p>&lt;strong>并发真正影响的是写&lt;/strong>。&lt;/p>
&lt;p>保证每个sesssion，:每个事务，都有不被别人影响的写的权力，此时要使用锁。&lt;/p>
&lt;p>并发过程中，有多少用户会相互产生影响&lt;strong>取决于锁的粒度&lt;/strong>。&lt;/p>
&lt;h3 id="21看锁的粒度">2.1看锁的粒度&lt;/h3>
&lt;p>不同的DBMS支持不同的锁类型。支持何种粒度的锁，在大型系统和小规模系统之间
存在极大的差异。&lt;/p>
&lt;p>大型系统对于锁的粒度选择非常谨慎，而在小规模系统中往往不是那么计较锁的粒度。&lt;/p>
&lt;p>加锁的数据量小的锁，称之为细粒度锁。&lt;/p>
&lt;p>行锁是粒度很细的锁，只锁一条记录行。
在行锁的环境下，多个并发进程就可能同时修改同一表中的不同行的数据,
而不会造成阻塞。&lt;/p>
&lt;p>&lt;strong>行锁不同进程之间可以有一定的重叠&lt;/strong>，不一定要等到一个进程执行的事务结束才可以执行。&lt;/p>
&lt;p>而&lt;strong>表锁则必须等到上一个对本表执行操作的事务执行结束后才能执行&lt;/strong>，粒度较大;所以一般选择粒度更小的锁。&lt;/p>
&lt;p>更小的锁意味着处理器有更多的工作要做，从而提高硬件资源的利用率。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230309200551574.png" alt="image-20230309200551574" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227201240507.png" alt="image-20230227201240507" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>加锁处理的原则&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>不要随便使用表级锁&lt;/li>
&lt;li>尽量缩短加锁时间&lt;/li>
&lt;li>缩小事务的大小&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>编程上的处理原则&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>尽可能&lt;strong>避免&lt;/strong>SQL语句上的&lt;strong>循环处理&lt;/strong>，在程序体中，不能有一个循环体，循环体中
包含一个SQL语句。
&lt;ul>
&lt;li>SQL本身就是集合读取的过
程，不需要放在循环中。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>尽可能&lt;strong>减少程序和数据库之间的交互次数&lt;/strong>，尽可
能一个SQL就能完成所有的工作，或者一-次查询就读
到尽量多的数据，再本地
处理;&lt;/li>
&lt;li>&lt;strong>跨机器的交互次数越少越好&lt;/strong>。&lt;/li>
&lt;li>未来工作中读取或更新了错误信息，错误处理顺序应该是，&lt;strong>先rolIback，&lt;/strong>
&lt;strong>结束事务，再去查询错误信息表。&lt;/strong>
&lt;ul>
&lt;li>先结束事务，可以先解锁。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="22加锁与提交">2.2加锁与提交&lt;/h3>
&lt;p>这里的频繁提交，是指可以减小事务的大小。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227201458385.png" alt="image-20230227201458385" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>这个和物理组织形式有关。&lt;/p>
&lt;ul>
&lt;li>事务越大，提交越不频繁，资源被锁住的时间越少，&lt;strong>并发出现冲突的概率就越小&lt;/strong>。&lt;/li>
&lt;li>事务越小，提交越频繁，处理事务付出的平均代价就越大&lt;/li>
&lt;/ul>
&lt;p>对于批处理程序，并发控制不是问题，&lt;strong>避免频繁提交才是明智的做法&lt;/strong>。&lt;/p>
&lt;p>对于用户交互程序，则需要&lt;strong>高频提交，加快释放锁&lt;/strong>。&lt;/p>
&lt;h2 id="3资源竞争">3.资源竞争&lt;/h2>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227201626952.png" alt="image-20230227201626952" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230309201216936.png" alt="image-20230309201216936" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230309201243791.png" alt="image-20230309201243791" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>真正的问题是“是否可以更好地利用这些资源。&lt;/p>
&lt;p>进程之间仍然会发生资源竞争，竞争发生在两个地方: 表和索引。&lt;/p>
&lt;p>系统层次也可能发生资源竞争，但通常由数据库层面的竞争引起。&lt;/p>
&lt;p>数据库层面资源竞争消耗CPU，因为处理竞争问题要执行一些代码在等待另一个处理器上执行的进程释放资源时，还可能出现“活动等待”或“闲置循环”&lt;/p>
&lt;p>解决资源竞争的手段，比解决锁的方法多。除了降低锁的粒度外，还可以：&lt;/p>
&lt;p>DBA、架构、开发三方法&lt;/p>
&lt;h3 id="31dba解决方案">3.1DBA解决方案&lt;/h3>
&lt;p>DBA——数据库管理员的解决方案。&lt;/p>
&lt;p>DBA的解决方案，是解决插入的问题，对其它事务的影响比较少&lt;/p>
&lt;p>手段针对对象：事务空间](Transaction space. 可用列表(Freelist)&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227201851918.png" alt="image-20230227201851918" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227201904695.png" alt="image-20230227201904695" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="32架构解决方案">3.2架构解决方案&lt;/h3>
&lt;ul>
&lt;li>分区(Partitioning)&lt;/li>
&lt;li>逆序索引(Reverseindex )&lt;/li>
&lt;li>索引组织表 (Indexorganized table)&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227201930658.png" alt="image-20230227201930658" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="33开发解决方案">3.3开发解决方案&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>调节并发数&lt;/p>
&lt;ul>
&lt;li>限制session个数为最高性能的session个数，使周转更快&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>不使用系统产生值&lt;/p>
&lt;ul>
&lt;li>连续值只在范围查询中使用，在连续值本身毫无现实意义的情况下，范围查询的场景也不多见;&lt;/li>
&lt;li>可以只使用随机数来做主键，遇到随机数碰撞，就再生成一个随机数。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="34比较">3.4比较&lt;/h3>
&lt;p>&lt;strong>session比较多时&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227202036432.png" alt="image-20230227202036432" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230309201842351.png" alt="image-20230309201842351" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>违反主键约束必须到插入主键值之时才可发现，索引保存的是物理地址此时记录已被插入表中，所以需要undo，产生额外的时间成本。&lt;/p>
&lt;p>产生随机数的范围比最糟情况大100倍时，&lt;strong>性能显著改善&lt;/strong>。&lt;/p>
&lt;p>如果要设置随机值作为主键来解决资源竞争的问题，只要range足够大效率就会得到足够的改善。&lt;/p>
&lt;p>&lt;strong>session比较少时&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227202207498.png" alt="image-20230227202207498" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227202235452.png" alt="image-20230227202235452" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h2 id="4事务的隔离级别">4.事务的隔离级别*&lt;/h2>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230309202246087.png" alt="image-20230309202246087" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227202341188.png" alt="image-20230227202341188" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227202437445.png" alt="image-20230227202437445" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>另一个事务是修改但没成果提交，读到错误数据&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227202506641.png" alt="image-20230227202506641" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>另一个事务是修改后并提交，两次读到的数据不同&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227203100328.png" alt="image-20230227203100328" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>另一个事务是插入后并提交，第二次读的时候数据量不一样&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227202536809.png" alt="image-20230227202536809" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>对应MySql四种事务隔离级别&lt;/p>
&lt;p>未提交读(READ UNCOMMITTED)：脏读&lt;/p>
&lt;p>已提交读(READ COMMITTED)：解决脏读产生不可重复读&lt;/p>
&lt;p>可重复读(REPEATABLE READS)：解决不可重复读，产生幻读&lt;/p>
&lt;p>可串行化(Serializable )：解决幻读&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227202730759.png" alt="image-20230227202730759" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>更新时只加了个读锁。其他人不能写但还可以读，会读到自己产生的脏数据。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227202800296.png" alt="image-20230227202800296" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>加了个写锁。自己写完后（即使失败），别人才能读。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227203130428.png" alt="image-20230227203130428" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>提交后锁解开了，仍能有不可重复读。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227203156244.png" alt="image-20230227203156244" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227203250209.png" alt="image-20230227203250209" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>此时情况，既防重复读也防止了幻读。&lt;/p>
&lt;p>&lt;strong>它是怎么做到的&lt;/strong>?&lt;/p>
&lt;p>MVCC(多版本并发控制)&lt;/p>
&lt;p>在InnoDB中，会在每行数据后&lt;strong>添加两个额外的隐藏的值来实现MVCC&lt;/strong>,&lt;/p>
&lt;p>这两个值一
个记录这行数据&lt;strong>何时被创建&lt;/strong>，另外一个记录这行数据&lt;strong>何时过期(或者被删除)。&lt;/strong>&lt;/p>
&lt;p>在实际操作中，存储的不是时间，而是&lt;strong>事务版本号&lt;/strong>，每开启一个新事务，&lt;strong>事务版本号就会递增。&lt;/strong> 用一个乐观锁实现。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230309203313708.png" alt="image-20230309203313708" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>此外，Mysql还有&lt;strong>邻键锁&lt;/strong>。&lt;/p>
&lt;h3 id="42next-key锁">4.2Next-Key锁&lt;/h3>
&lt;p>也属于行锁的一种，且&lt;strong>是INNODB的行锁默认算法&lt;/strong>，临键锁会把查询出
的记录锁住，也会把&lt;strong>该范围查询内的所有间隙空间也会锁住&lt;/strong>，再之它会&lt;strong>把相邻的下一个区间也会锁住&lt;/strong>。&lt;/p>
&lt;p>Next-Key是记录锁 + 间隙锁&lt;/p>
&lt;p>记录锁：记录锁是对索引记录的锁，注意，它是针对索引记录，即它只锁定记录这一行数据。&lt;/p>
&lt;p>间隙锁会所上一个区间&lt;/p>
&lt;p>首先我们来看看 Next-Key Lock 的加锁规则：&lt;/p>
&lt;p>锁的范围是左开右闭。
如果是唯一非空索引的等值查询，Next-Key Lock 会退化成 Record Lock。
普通索引上的等值查询，向后遍历时，最后一个不满足等值条件的时候，Next-Key Lock 会退化成 Gap Lock。&lt;/p>
&lt;p>临键锁避免了在范围查询时出现脏读、重复读、幻读问题。
加了临键锁之后，&lt;strong>在范围区间内数据不允许被修改和插入。&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227203503925.png" alt="image-20230227203503925" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227203452959.png" alt="image-20230227203452959" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h2 id="5数据量增加的不同影响">5.数据量增加的不同影响&lt;/h2>
&lt;p>如何高效搜索庞大的表。&lt;/p>
&lt;p>如何避免数据量稍有增长就可能出现的性能下降。&lt;/p>
&lt;p>5.1应用面临 “要处理的数据量会大幅度增长&amp;quot;的问题。&lt;/p>
&lt;ul>
&lt;li>某一个应用突然火了，数据量暴增，或者业务时间很长，数据库存放了好多年的不经常被用到的数据。&lt;/li>
&lt;li>很多原本能快速处理批处理程序，消耗的时间越来越大，甚至会干扰其它正常操作的查询速度。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>不同的sql操作对于数据量增加的敏感性不同&lt;/strong>&lt;/p>
&lt;h3 id="51影响不大的情况">5.1影响不大的情况&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227203832407.png" alt="image-20230227203832407" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227203924260.png" alt="image-20230227203924260" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230309204022976.png" alt="image-20230309204022976" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="52常见是线性影响">5.2&lt;strong>常见是线性影响&lt;/strong>&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227204139562.png" alt="image-20230227204139562" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="53非线性影响">5.3非线性影响&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227204203453.png" alt="image-20230227204203453" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>现代数据库的处理方式&lt;/strong>：&lt;/p>
&lt;p>比如聚簇索引，比如很多有序的索引，除了为了快速检索，也同样为了简单的排序逻辑依照索引读出数据的顺序就是有序的。&lt;/p>
&lt;p>注意：排序性能降低常间歇发生，时快时慢，较小型排序全部在内存中执行，较大型排序(涉及多个有序子集的合并) 则需将有序子集临时存储到硬盘中&lt;/p>
&lt;p>通过调整&lt;strong>分配排序内存大小&lt;/strong>，
来改善排序密集型操作的性能
是&lt;strong>常见有效的调优技巧。&lt;/strong>&lt;/p>
&lt;h2 id="6大数据量的处理逻辑">6.大数据量的处理逻辑&lt;/h2>
&lt;p>是否需要在需求之外，添加一个格外的查询条件，来限制需要查询的数据规模。这是一个普遍的原则。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227204418997.png" alt="image-20230227204418997" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>排序主要是读写硬盘的影响。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227204526760.png" alt="image-20230227204526760" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227204539957.png" alt="image-20230227204539957" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>SQL优化中： 必须限制SQL查询中&lt;strong>非关系层部分&lt;/strong>，因为非关系层与操作数据数
量、复杂度有关，排序、limit
都是非关系层操作。&lt;/p>
&lt;p>遇到非关系操作，SQL会把一个查询，在关系和非关系操作边界上切一刀，内层是一个sql进行优化，外层是另一个sql进行优化，这样避免查询优化器对语义理解的错误。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227204629339.png" alt="image-20230227204629339" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="消除关联子查询">消除关联子查询&lt;/h3>
&lt;p>exists是关联嵌套子查询&lt;/p>
&lt;p>它和非关联嵌套子查询in的最大的差异:子查询要执行多次。&lt;/p>
&lt;p>它想效率高只有一个方式: 外层查询的条件足够的好，否则有风险。&lt;/p>
&lt;p>关联嵌套子查询在计算每一条返回记录时，&lt;strong>都被调用一次&lt;/strong>。&lt;/p>
&lt;p>死亡sql：但常见&lt;/p>
&lt;p>随数据量增加，减少关联子查询，否则风险很大。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%95%b0%e6%8d%ae%e5%ba%93%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98/image-20230227204741869.png" alt="image-20230227204741869" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/%E7%B4%A2%E5%BC%95%E5%8F%8A%E7%89%A9%E7%90%86%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/%E7%B4%A2%E5%BC%95%E5%8F%8A%E7%89%A9%E7%90%86%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84/</guid><description>&lt;p>索引概述&lt;/p>
&lt;p>&lt;strong>索引与目录&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>目录和索引是两种不同的机制&lt;/li>
&lt;li>索引是一种以原子粒度访问数据的手段，而不是为
了检索大量数据的&lt;/li>
&lt;/ul>
&lt;h2 id="1b树索引的结构和应用">1.B+树索引的结构和应用&lt;/h2>
&lt;h3 id="11b树的结构">1.1B+树的结构&lt;/h3>
&lt;p>必须关注关键数据的读取，并为它们提供&lt;strong>最高效的访问路径&lt;/strong>，而&lt;strong>建立索引可能是你第一个能想到的策略&lt;/strong>。&lt;/p>
&lt;p>几乎所有关系型数据库的缺省索引都是B+树索引，OceanBase也用了。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e7%b4%a2%e5%bc%95%e5%8f%8a%e7%89%a9%e7%90%86%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84/image-20230308150235556.png" alt="image-20230308150235556" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>数据库引擎&lt;strong>读取的方式&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>是从硬盘上&lt;strong>整块整块地读取&lt;/strong>数据到内存里&lt;/p>
&lt;/li>
&lt;li>
&lt;p>接着在内存中把块中的某一条记录提取出来
再进行使用。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>一个块大概4k，存多条记录。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>数据库引擎的某次读取&lt;strong>只是为了读取一条记录&lt;/strong>，但是它&lt;strong>会首先读一个完整的块&lt;/strong>而这个过程就叫&lt;strong>物理IO读取&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>数据库性能最大的消耗，就是在物理IO上。一个查询的物理IO次数越多，这个查询的速度就越慢&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>B+树索引为什么能够降低物理IO次数&lt;/p>
&lt;ul>
&lt;li>索引结构是一个树状结构，一个层次化的结构。&lt;/li>
&lt;li>根节点，会把节点上的数值分成几个区间，每个区间用指针指向下一层节点，在下一层节点上也划分成几个区间，再指向下一层，直到最下层的叶节点。&lt;/li>
&lt;li>叶节点会记录索引字段的值，以及这个值所对应的记录&lt;strong>在基本表上的存放地址&lt;/strong>，我们把这个地址叫作rowid。&lt;/li>
&lt;li>物理IO次数 = 经过的结点数量 + 1次基本表查询。&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e7%b4%a2%e5%bc%95%e5%8f%8a%e7%89%a9%e7%90%86%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84/image-20230308150733243.png" alt="image-20230308150733243" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;ul>
&lt;li>&lt;strong>叶节点到根节点的距离叫深度&lt;/strong>，例子深度是3，一般B树索引的深度都是3，有些是4&lt;/li>
&lt;li>B树索引要提高查询效率&lt;strong>首先要控制的就是树的深度&lt;/strong>&lt;/li>
&lt;li>本质上B树索引通常意味着数据存储是有序的，每个叶子页到根的距离都是一样的&lt;/li>
&lt;li>B树索引的&lt;strong>叶节点&lt;/strong>就构成了一个&lt;strong>顺序存储的数据结构&lt;/strong>它们对于范围查询，也就是&lt;strong>搜索范围数据很有用&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;h3 id="12b树索引的应用-能做什么">1.2B树索引的应用 能做什么&lt;/h3>
&lt;p>1、&lt;strong>全键值查询&lt;/strong>&lt;/p>
&lt;p>比如&lt;strong>字段x上有索引&lt;/strong>，where子 句中的条件是&lt;strong>x=123&lt;/strong>，就可以使用B树索引做高速的查询。&lt;/p>
&lt;p>2、&lt;strong>键值范围查询&lt;/strong>&lt;/p>
&lt;p>比如x在45-123之间，先进行x==45这个等值查询，查询到相关的地址,
是顺序存储，&lt;strong>横向直接顺序读取叶节点&lt;/strong>，直到找到最右侧x=123对应的地址。&lt;/p>
&lt;p>&lt;strong>读完索引之后，再去基本表去读那些地址相关的块&lt;/strong>。&lt;/p>
&lt;p>3、键值的前缀查询 与键值类似&lt;/p>
&lt;h3 id="13索引的另一面">1.3索引的另一面&lt;/h3>
&lt;p>B+树索引是最典型的索引结构。&lt;/p>
&lt;p>索引可以大幅提高查询的速度; 但与此同时，我们也不能忽略&lt;strong>索引带来的沉重的成本&lt;/strong>&lt;/p>
&lt;p>&lt;strong>存储的成本&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>很多业务系统，&lt;strong>索引数据量远大于被索引的实际数据量&lt;/strong>，也就是基本表的数据量。&lt;/li>
&lt;li>索引&lt;strong>通常是镜像的&lt;/strong>，还需要在热备、灾备、甚至是物理备份中存储，&lt;strong>存储成本非常高&lt;/strong>。&lt;/li>
&lt;li>当需要备份恢复的时候，索引还大大地增加了从备份中&lt;strong>恢复的停机时间&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>而最大的问题&lt;strong>不在于存储&lt;/strong>，&lt;strong>在于处理的开销&lt;/strong>&lt;/p>
&lt;p>基本表数据更改时，索引也需要更新。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e7%b4%a2%e5%bc%95%e5%8f%8a%e7%89%a9%e7%90%86%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84/image-20230308151320663.png" alt="image-20230308151320663" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>在并发访问的环境中，更多的索引将意味着&lt;strong>更多的并发冲突&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>更新操作&lt;strong>需要更新数据本身和更新索引数据&lt;/strong>&lt;/li>
&lt;li>索引通常是一种比数据库表&lt;strong>更紧凑&lt;/strong>的结构。&lt;/li>
&lt;li>在更新索引时，在更小的区间中&lt;strong>并发操作产生冲突的概率就会更大&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>索引在&lt;strong>物理存储上&lt;/strong>、在&lt;strong>更新处理开销上&lt;/strong>以及&lt;strong>在并发冲突的概率&lt;/strong>上，都会大幅度地影响系统的效率&lt;/p>
&lt;p>但索引仍然是最重要的组成部分，因为在实际业务中，&lt;strong>查询的次数一般比更新次数要多得多&lt;/strong>。&lt;/p>
&lt;p>索引也&lt;strong>不一定能提高查询效率&lt;/strong>&lt;/p>
&lt;h2 id="2建立索引的基础--让索引发挥作用">2.建立索引的基础 —— 让索引发挥作用&lt;/h2>
&lt;h3 id="21索引发挥作用的指标">2.1索引发挥作用的指标&lt;/h3>
&lt;p>基本表很小的时候，B+树索引还不如全表查询。&lt;/p>
&lt;ul>
&lt;li>索引只是一种特殊的访问数据的方式，它并不是一定会提高查询效率，要看具体的情况&lt;/li>
&lt;li>这种访问数据的手段是一种&lt;strong>原子粒度的，直接读取记录的&lt;/strong>，它&lt;strong>不是为了检索大量数据而存在的技术&lt;/strong>.&lt;/li>
&lt;li>如果数据是沙滩中的沙子，全表遍历是一把铲子，用来大块大块地读取数据，那么索引就像一个小勺子，一勺一勺地取数据&lt;/li>
&lt;/ul>
&lt;p>每建立一个索引，都需要这个索引能发挥所需要的作用，否则就不该建立，这是&lt;strong>建立索引的基本原则&lt;/strong>.&lt;/p>
&lt;p>判断建立一个&lt;strong>索引到底有没有作用的指标&lt;/strong>，最常用的就是&lt;strong>检索比例&lt;/strong>，
也就是查询检索到的数据占总数据的百分比，往往这个百分比被设
置为10%。&lt;/p>
&lt;ul>
&lt;li>也就是说,如果你查询到的结果集占整个源数据集的10%以下，
那么&lt;strong>在这个查询中使用索引是有效的&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>这也称之为索引的选择性，检索出来的&lt;strong>数据占总数据的百分比越低&lt;/strong>、&lt;strong>索引越有选择性&lt;/strong>。&lt;/p>
&lt;p>这里是&lt;strong>从索引的有效性来说&lt;/strong>.&lt;/p>
&lt;h3 id="22胖表和瘦表的问题">2.2胖表和瘦表的问题&lt;/h3>
&lt;p>胖表是一条记录很长的表，长的原因，很可能是字段数量很多，也可能是每个字段的长度很长&lt;/p>
&lt;p>瘦表的特点与胖表相反它的字段很少，每个字段长度很短。&lt;/p>
&lt;ul>
&lt;li>它们决定了基本表中一个块，能存储的记录的数量。&lt;/li>
&lt;li>瘦表中，一个块能存储更多的行，而胖表中，&lt;strong>一个块能存储的行数就少于瘦表&lt;/strong>。&lt;/li>
&lt;li>原则上，瘦表的&lt;strong>检索比例会更低一些&lt;/strong>，比如5%，而胖表相对来说索引的&lt;strong>检索比例会更高&lt;/strong>，对索引的使用更宽容。（低于检索比例，索引才被认为是有效的）&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>检索比例没有明确的分界线&lt;/strong>，判断索引是否可以被使用，只能&lt;strong>进行实际的测试与验证&lt;/strong>。即只访问基本表中的&lt;strong>少量行是适合使用索引&lt;/strong>的。&lt;/p>
&lt;h3 id="23只使用索引不使用表">2.3只使用索引不使用表&lt;/h3>
&lt;p>即使你需要访问基本表中的&lt;strong>很多行也可以使用索引&lt;/strong>，这种情况就是&lt;strong>只使用索引不使用表&lt;/strong>。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>单键值索引：只对一个字段建立索引。如B+树索引就是典型。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>复合键索引，本质上&lt;strong>是按照第一个字段构建的索引&lt;/strong>，区别是&lt;strong>页节点上增加y的顺序存储&lt;/strong>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e7%b4%a2%e5%bc%95%e5%8f%8a%e7%89%a9%e7%90%86%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84/image-20230308153818080.png" alt="image-20230308153818080" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>●虽然要检索很多行，
但是可以只使用索引不使用基本表。&lt;/p>
&lt;p>●即&lt;strong>只查询索引的值&lt;/strong>，此时&lt;strong>不需要读取基本表&lt;/strong>。&lt;/p>
&lt;p>以上可以总结&lt;strong>使用B+树索引的两个条件（索引可用性）&lt;/strong>:&lt;/p>
&lt;p>1、只需要获取少量的行;&lt;/p>
&lt;p>2、即便获取很多行，但是可以只使用索引不使用基本表。&lt;/p>
&lt;p>但索引读取是复杂的事情，记录的位置也会导致索引效率的不同。&lt;/p>
&lt;p>下图是5条记录在同一块，和不在同一块的索引次数对比：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e7%b4%a2%e5%bc%95%e5%8f%8a%e7%89%a9%e7%90%86%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84/image-20230308154251969.png" alt="image-20230308154251969" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>为什么很多查询在开发环境中运行效率都比生产环境高呢?&lt;/strong>&lt;/p>
&lt;p>因为往往生成的记录是按顺序一起插入的，&lt;strong>记录的存储顺序和索引的顺序非常相似&lt;/strong>，所以当读完索引后就能用最小的代价读取所检索到的记录。&lt;/p>
&lt;p>但是&lt;strong>生产环境下&lt;/strong>，由于并发、修改以及各种情况的产生，真实的数据很可能是&lt;strong>混乱地分散在硬盘的不同块中&lt;/strong>的，这时查询效率必然会下降。&lt;/p>
&lt;p>&lt;strong>解决办法：&lt;/strong>&lt;/p>
&lt;p>只有在&lt;strong>开发环境测试并且远超过需求的性能标准&lt;/strong>，这样才能在&lt;strong>生产环境达到需求的性能指标&lt;/strong>&lt;/p>
&lt;p>&lt;strong>总结&lt;/strong>&lt;/p>
&lt;p>索引是一个非常复杂的存在。虽然它的结构很简单，但是使用中会&lt;strong>受到很多复杂因素的影响&lt;/strong>。&lt;/p>
&lt;p>因为索引的成本很大，所以我们要&lt;strong>谨慎地选择构建索引&lt;/strong>，务必让索引变得可用。&lt;/p>
&lt;h2 id="3哈希索引和函数索引">3.哈希索引和函数索引&lt;/h2>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e7%b4%a2%e5%bc%95%e5%8f%8a%e7%89%a9%e7%90%86%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84/image-20230308154630283.png" alt="image-20230308154630283" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>学习索引的方法：&lt;/p>
&lt;ol>
&lt;li>学习结构&lt;/li>
&lt;li>根据结构找出特点和作用&lt;/li>
&lt;/ol>
&lt;h3 id="31哈希索引">3.1哈希索引&lt;/h3>
&lt;p>&lt;strong>哈希索引的结构&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e7%b4%a2%e5%bc%95%e5%8f%8a%e7%89%a9%e7%90%86%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84/image-20230308154825502.png" alt="image-20230308154825502" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>所有的数据类型，通过哈希函数变成一个&lt;strong>等长的哈希值&lt;/strong>。&lt;/p>
&lt;p>将这个&lt;strong>等长的哈希值&lt;/strong>作为&lt;strong>组织成索引的结构 —— 哈希链表&lt;/strong>。&lt;/p>
&lt;p>哈希链表的结点上，储存哈希值 和 指向记录哈希值的地址 uid（索引行的地址）。&lt;/p>
&lt;p>&lt;strong>哈希索引能做什么不能做什么？&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>哈希索引只能用来进行&lt;strong>全键值&lt;/strong>的查询
&lt;ul>
&lt;li>不能前缀查询&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>哈希索引只支持&lt;strong>击中运算符&lt;/strong>
&lt;ul>
&lt;li>击中运算符：= , != , in&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>哈希索引&lt;strong>不支持对字段排序&lt;/strong>&lt;/li>
&lt;li>哈希索引&lt;strong>不支持范围查询&lt;/strong>&lt;/li>
&lt;li>哈希索引&lt;strong>读取效率高于B树索引&lt;/strong>
&lt;ul>
&lt;li>哈希索引结构非常紧凑.&lt;/li>
&lt;li>哈希索引&lt;strong>使用数值的比较&lt;/strong>,远高于字符串比较速度.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>碰撞率的问题&lt;/strong>&lt;/p>
&lt;p>碰撞指不同的字段值，通过计算得到了相同的哈希值，而碰撞发生的频繁程度就是碰撞率。&lt;/p>
&lt;p>当发生碰撞时，存储引擎必须访问链表中相同哈希值的&lt;strong>每一个行&lt;/strong>指针，然后&lt;strong>逐行进行数据比较&lt;/strong>，以确定正确的数据。&lt;/p>
&lt;ul>
&lt;li>如果有很多碰撞，一些索引维护操作就有可能会变慢。如果在一个&lt;strong>选择性很低的列&lt;/strong>(&lt;strong>列的基数占总行数&lt;/strong>的比例低) 上创建哈希索引就会产生很多碰撞.&lt;/li>
&lt;li>这时假如从表中删除一行,那么从索引中&lt;strong>找到这一行的代价会很高&lt;/strong>。存储引擎将&lt;strong>不得不检查哈希键链表中的每一行&lt;/strong>，以找到和移除被删除行的索引。&lt;/li>
&lt;/ul>
&lt;p>数据仓库层面中的&lt;strong>星型结构&lt;/strong>, 在查找很多表的连接时, 哈希索引正是其所需要的.&lt;/p>
&lt;p>&lt;strong>mysql中不同引擎 对哈希索引的支持&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>只有Memory引擎有显式的哈希索引&lt;/li>
&lt;li>NBD cluster存储引擎支持唯一的哈希索引&lt;/li>
&lt;li>InnoDB引擎有&lt;strong>自适应哈希索引&lt;/strong>
&lt;ul>
&lt;li>当存储引擎发现一些索引值被频率很高访问时,将自动在B+树的顶端构建哈希索引.&lt;/li>
&lt;li>这时的B+树索引有哈希索引的特征 &amp;mdash;- 很快的哈希索引.&lt;/li>
&lt;li>但是自动的过程,不能控制也不能配置.&lt;/li>
&lt;li>即&lt;strong>越使用某个查询, 查询越快&lt;/strong>.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="32函数索引">3.2函数索引&lt;/h3>
&lt;p>B树索引是对一个字段构建索引,而函数索引是对&lt;strong>这个字段上的一个函数值&lt;/strong>构建索引.&lt;/p>
&lt;p>&lt;strong>结构同样是B+树索引,只是叶节点的值是函数的值而不是字段值.&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>B+树索引 , B+树上对X构建索引,&lt;/li>
&lt;li>函数索引, B+树上对F(x)的值构建索引&lt;/li>
&lt;li>但他们叶子结点指向的地址,&lt;strong>都是字段对应的地址&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>是最具创造力的索引结构,用得好可用解决并发冲突,优化存储结构.等很多事情.&lt;/p>
&lt;p>&lt;strong>能用在哪&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>不区分大小写&lt;/strong>查询&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>T、F比例巨大差异&lt;/strong>的查询&lt;/p>
&lt;blockquote>
&lt;p>有一个事务处理的表，处理过的事务记录，flag取值为T或者Y,而没有处理的
就是F或者N。时间一久，表中大部分记录都是T,而少部分记录是F。&lt;/p>
&lt;p>怎么才能在
索引中不记录T的记录，只把flag的值 等于F的记录记在索引结构中呢?&lt;/p>
&lt;p>答案:给flag做&amp;ndash;个函数索引。&lt;/p>
&lt;p>解析:编写一个函数，如果是T，就返回NULL;如果是F，就返回一个非NULL的
值。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>有选择的唯一性&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e7%b4%a2%e5%bc%95%e5%8f%8a%e7%89%a9%e7%90%86%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84/image-20230308161603917.png" alt="image-20230308161603917" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>项目表有两个状态, active和inactive.&lt;/p>
&lt;p>要求active的项目,必须要有唯一名. 而inactive没有这个要求.&lt;/p>
&lt;p>解决方法: &lt;strong>函数索引上构建唯一索引&lt;/strong>.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="4位图索引和位图连续索引">4.位图索引和位图连续索引&lt;/h2>
&lt;h3 id="41-位图索引-oracle独有的">4.1 位图索引 oracle独有的&lt;/h3>
&lt;p>结构: 用一个&lt;strong>索引键条目存储指向多行&lt;/strong>的指针。01图&lt;/p>
&lt;ul>
&lt;li>B树索引中，索引键和表中的行存在着对应关系，-一个索引就指向一行;&lt;/li>
&lt;li>位图索引中，可能&lt;strong>只有很少的索引条目&lt;/strong>，但&lt;strong>每个索引指向多行&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e7%b4%a2%e5%bc%95%e5%8f%8a%e7%89%a9%e7%90%86%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84/image-20230227155733844.png" alt="image-20230227155733844" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>统计行数非常快&lt;/strong>.压缩地很紧凑&lt;/p>
&lt;p>&lt;strong>位图索引适合&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>相异基数(distinct cardinality)低&lt;/strong>的字段进行快速查询 (复合查询)
&lt;ul>
&lt;li>可以取的值的范围小: 性别、真假,年龄段 等.&lt;/li>
&lt;li>使用B树索引,需要复合索引时 组合数多. 且共同的值多, 可能使得叶子结点远少于索引结点.&lt;/li>
&lt;li>使用哈希索引,碰撞率贼高.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>大量临时查询的聚合&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e7%b4%a2%e5%bc%95%e5%8f%8a%e7%89%a9%e7%90%86%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84/image-20230308162526006.png" alt="image-20230308162526006" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>缺点&lt;/strong>: &lt;strong>对于写操作非常不友好&lt;/strong>&lt;/p>
&lt;p>&lt;strong>原因&lt;/strong>: 位图索引的&lt;strong>键值指向多行&lt;/strong>, 如果一个session修改了一个索引的数据,则&lt;strong>该索引指向的所有行都会被查找到&lt;/strong>.无法锁定单独一个条目,&lt;strong>可能在修改时要锁住整个目录&lt;/strong>,导致并发性下降严重 几乎变成串行化.&lt;/p>
&lt;p>这就是位图索引&lt;strong>不能应用在OLTP&lt;/strong>应用中的原因.&lt;/p>
&lt;h3 id="42-位图连结索引--bitmap-join-index">4.2 位图连结索引 bitmap join index&lt;/h3>
&lt;p>oracle 九代? 之后,出现的.&lt;/p>
&lt;p>一般情况下,我们都是在 &lt;strong>一张表上建立索引,且只使用这个表上的列&lt;/strong>.&lt;/p>
&lt;p>而位图联结索引:&lt;/p>
&lt;ul>
&lt;li>允许使用&lt;strong>另外某个表的列&lt;/strong> 对 &lt;strong>一个给定表&lt;/strong> 建立索引。&lt;/li>
&lt;li>实际上，这就是允许&lt;strong>对一个索引结构&lt;/strong>(而不是表本身)中的数据进行&lt;strong>逆规范化&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>下图的例子,常常需要对多个表进行联结后进行查询.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e7%b4%a2%e5%bc%95%e5%8f%8a%e7%89%a9%e7%90%86%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84/image-20230308164014658.png" alt="image-20230308164014658" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>一般的索引方法:&lt;/p>
&lt;ul>
&lt;li>在部门表的部门名称上构建一个索引,,&lt;/li>
&lt;li>并用它来查询 部门名称为&amp;quot;销售&amp;quot; 的所有部门编号id&lt;/li>
&lt;li>再回到员工表使用索引 查找根据部门编号匹配的行.&lt;/li>
&lt;/ul>
&lt;p>位图联结索引:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>对部门名称建立索引后,指向员工表&lt;/strong>.&lt;/li>
&lt;/ul>
&lt;p>位图联结索引的&lt;strong>前提条件&lt;/strong>:&lt;/p>
&lt;p>&lt;strong>必须连接到另一张表的主键/唯一键&lt;/strong>&lt;/p>
&lt;h3 id="43mysql没有位图索引该怎么办">&lt;strong>4.3Mysql没有位图索引,该怎么办&lt;/strong>&lt;/h3>
&lt;p>1.优化替代&lt;strong>索引组合&lt;/strong>:(&lt;strong>传统办法&lt;/strong>)&lt;/p>
&lt;ul>
&lt;li>Select * from profiles where sex= &amp;lsquo;M’ order by rating limit 10;
可以添加sex，rating列上的&lt;strong>复合索引&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>2.&lt;strong>低选择性添加特殊索引&lt;/strong> 最重要的手段&lt;/p>
&lt;ul>
&lt;li>select * from profiles wheresex= &amp;lsquo;M’ order by rating limit 100000, 10;
依旧很慢，更好的策略是&lt;strong>限制用户查看的页数&lt;/strong>。&lt;/li>
&lt;li>也可以: Select * from t inner join (
Select id from t
Where x.sex = &amp;rsquo;m&amp;rsquo; order by rating limit 100000, 10) AS x USING id;&lt;/li>
&lt;/ul>
&lt;p>Google刚发布时用了limit限制, 如果看很后面的页数还是会很卡. 后面直接最多限制20页.&lt;/p>
&lt;h2 id="5索引使用的典型问题">5.索引使用的典型问题&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>使不使用索引大部分情况&lt;/strong>由数据库引擎自己决定&lt;/li>
&lt;li>程序员&lt;strong>只负责构建索引&lt;/strong>，数据库&lt;strong>引擎判断是否应该使用索引&lt;/strong>&lt;/li>
&lt;li>&lt;strong>如果索引不被查询使用&lt;/strong>，将产生巨大的负担，就不该被构建&lt;/li>
&lt;/ul>
&lt;p>索引使用的典型问题&lt;/p>
&lt;ul>
&lt;li>函数和类型转化对索引的影响&lt;/li>
&lt;li>索引和外键&lt;/li>
&lt;li>同一个字段，多个索引&lt;/li>
&lt;li>系统生成键&lt;/li>
&lt;/ul>
&lt;h3 id="51函数和类型转化对索引的影响">5.1函数和类型转化对索引的影响&lt;/h3>
&lt;p>Where f(indexed_col)=some value&lt;/p>
&lt;p>这种检索条件会使索引无法发挥作用&lt;/p>
&lt;ul>
&lt;li>&lt;strong>函数&lt;/strong>&lt;/li>
&lt;li>&lt;strong>隐式类型转化&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>例:&lt;strong>字符串列和数字比较时&lt;/strong>，大多数数据库引擎不会立即生成运行时错误，
而是&lt;strong>隐式地将字符串列转换为数字&lt;/strong>。此时会&lt;strong>跳过索引&lt;/strong>。&lt;/p>
&lt;h3 id="52外键索引的问题">5.2外键索引的问题&lt;/h3>
&lt;p>系统对外键建立索引很&lt;strong>普遍&lt;/strong>。&lt;/p>
&lt;p>为什么要对外键建立索引？&lt;/p>
&lt;ul>
&lt;li>删除操作时，可以快速通过外键的索引找到要删除的行。&lt;/li>
&lt;li>并发时需要 A表加锁/B表加锁。 添加索引能够让上锁后操作的时间边短。&lt;/li>
&lt;li>&lt;strong>例外&lt;/strong>：表B只是一个字典表，就不需要对表A的外键建立索引。
&lt;ul>
&lt;li>因为字典表不容易被修改。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>建立索引必须有理由
, 无论是对外键，或是其他字段都是如此.&lt;/p>
&lt;h3 id="53同一字段多个索引">5.3同一字段，多个索引&lt;/h3>
&lt;p>索引中字段顺序影响大，但表中顺序无影响。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e7%b4%a2%e5%bc%95%e5%8f%8a%e7%89%a9%e7%90%86%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84/image-20230308193218951.png" alt="image-20230308193218951" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>如这个Order_details是由两个外键构成. 且Article是字典表,因此article_id不需要构建索引.&lt;/p>
&lt;p>如果Order_id 在前面,article_id在后, 则自动构建的索引是复合索引(Order_id,article_id),此时只需要一个索引.&lt;/p>
&lt;p>如果article_id在前,Order_id 在后, 则自动构建的索引是复合索引(article_id,order_id),此时还需要一个外键索引order_id, 共有两个索引.性能下降.&lt;/p>
&lt;h3 id="54系统生成键">5.4系统生成键&lt;/h3>
&lt;p>构建数据库时经常使用&lt;strong>系统提供自增字段&lt;/strong>,作为主键 它性能也最高。&lt;/p>
&lt;p>系统生成键:&lt;/p>
&lt;ul>
&lt;li>系统生产序列号远好于
寻找当前最大值并加1
并 用一个专用表保存“下一个值”且加锁更新&lt;/li>
&lt;/ul>
&lt;p>但系统生成键作为主键仍然存在并发的问题:&lt;/p>
&lt;ul>
&lt;li>主键索引的主要用途是&lt;strong>确保主键的唯一性&lt;/strong>.&lt;/li>
&lt;li>并发插入时 &lt;strong>生成的序列号非常接近&lt;/strong>,将&lt;strong>键值插入到主键索引中同一个块&lt;/strong>的可能性变大了.&lt;/li>
&lt;li>此时进程将竞争同一个索引页,插入并发性大幅度下降.&lt;/li>
&lt;/ul>
&lt;p>解决方案：反向键索引,此时属于同一个结点的块几率更小.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e7%b4%a2%e5%bc%95%e5%8f%8a%e7%89%a9%e7%90%86%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84/image-20230227161032966.png" alt="image-20230227161032966" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="总结为什么查询优化器没有使用我创建的索引">总结:为什么查询优化器没有使用我创建的索引?&lt;/h3>
&lt;p>情况1:&lt;strong>索引列不在使用的最前列(复合索引时)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>假设: T, T(X,Y)上有索引，做SELECT * FROM T WHERE Y=5&lt;/li>
&lt;/ul>
&lt;p>情况2: B树索引&lt;strong>不能为NULL建立索引条目&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>使用SELECT COUNT(*) FROMT,而且T上有索引，但是优化器仍然全表扫描&lt;/li>
&lt;/ul>
&lt;p>情况3:函数值问题&lt;/p>
&lt;p>情况4:隐形函数转化&lt;/p>
&lt;p>情况5:使用索引，实际反而会更慢.&lt;/p>
&lt;ul>
&lt;li>当做了测试后,证明索引确实能提高查询效率时,才建立索引.&lt;/li>
&lt;/ul>
&lt;p>情况6:查询优化器做出了错误的判断&lt;/p>
&lt;ul>
&lt;li>优化器根据统计信息来判断索引的使用.&lt;/li>
&lt;li>没有正确的统计信息，造成查询优化器无法做出正确的选择&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>不使用索引原因&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>不能使用索引，使用索引会返回不正确的结果&lt;/li>
&lt;li>不该使用索引，如果使用了索引就会变得更慢&lt;/li>
&lt;/ul>
&lt;p>总结: 根据索引访问的不同特点, 充分理解要处理的数据做出合理的判断，才能获得高效方案。&lt;/p>
&lt;h2 id="6数据库的物理组织形式">6.数据库的物理组织形式&lt;/h2>
&lt;p>这里的物理实现是讲基本概念, cmu15-445更详细.&lt;/p>
&lt;p>&lt;strong>关系型数据库的核心特点: 读写冲突&lt;/strong>&lt;/p>
&lt;p>在并发用户数很大的系统时,选择&lt;/p>
&lt;ul>
&lt;li>尽量以紧凑的方式存储数据,利于读&lt;/li>
&lt;li>尽量将数据分散存储,利于并发写入&lt;/li>
&lt;/ul>
&lt;p>数据库基本的物理存储细节&lt;/p>
&lt;ul>
&lt;li>数据查询要快, 要建立索引&lt;/li>
&lt;li>数据更新要快, 不要建立索引&lt;/li>
&lt;/ul>
&lt;p>但没有两全其美的&lt;strong>并发的修改密集型&lt;/strong>, 即不能做到 查询快时更新也快.&lt;/p>
&lt;p>核心思想：&lt;/p>
&lt;p>所有&lt;strong>有利于读的技术一定不利于写&lt;/strong>，&lt;strong>有利于写的技术一定不利于读&lt;/strong>.&lt;/p>
&lt;p>如果都有利于,则会丧失一些特征. 如 NoSOL放弃的是关系型数据库的强一致性的特点.&lt;/p>
&lt;h3 id="61-页模式">6.1 页模式&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e7%b4%a2%e5%bc%95%e5%8f%8a%e7%89%a9%e7%90%86%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84/image-20230227161540696.png" alt="image-20230227161540696" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>行迁移&lt;/strong>: 块被填满 且 修改记录变大时, 一个块会分裂成两个块.也就是一条记录存在两个块中. 物理IO读次数增加到2.&lt;/p>
&lt;p>如果记录继续变大填满了两个块, 则数据库会找一个非常大的块来容纳该条记录 并 删除原来两个块. 以防多次行迁移.&lt;/p>
&lt;p>多次行迁移的发生,是数据库使用越久越慢的原因.&lt;/p>
&lt;p>&lt;strong>为了避免行迁移&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>数据库使用更为冗余的策略:
保持大概30%的空间来处理未来的更新。&lt;/p>
&lt;ul>
&lt;li>也就是说, 块被填满70%的空间时，对数据库引擎来说，不能再插入记录。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>每一页将通过前后指针, 将块组织成链表模式, 其目的是优化全表查询效率&lt;/p>
&lt;/li>
&lt;li>
&lt;p>目录页的本质也是页，普通页中存的数据是项目数据，而目录页中
存的数据是普通页的地址。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>表的物理存储是一一个树状的结构。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>所有的叶节点都是&lt;strong>随机文件&lt;/strong>，是&lt;strong>堆文件的组织形式&lt;/strong>。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>以上也是数据库基本的物理存储细节.&lt;/p>
&lt;h3 id="62把索引当成数据仓库">6.2把索引当成数据仓库&lt;/h3>
&lt;p>把尽量在索引中多存储数据的原则扩展到极限，构建一个&lt;strong>以主键为首位的索引&lt;/strong>，&lt;strong>存储表中所有的数据&lt;/strong>。 即(复合索引包括所有列)&lt;/p>
&lt;p>即索引本身就是表.&lt;/p>
&lt;p>Oracle中的对应的数据存储模式: IOT， &lt;strong>索引组织表&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>比较索引组织表与只有主键索引的表插入的开销&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e7%b4%a2%e5%bc%95%e5%8f%8a%e7%89%a9%e7%90%86%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84/image-20230308200056061.png" alt="image-20230308200056061" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;ul>
&lt;li>IOT是一种&lt;strong>顺序文件&lt;/strong>，麻烦的两件事是&lt;strong>宽表的随机插入(复合索引字段多)&lt;strong>和&lt;/strong>数据包含长字符串&lt;/strong>。&lt;/li>
&lt;li>对于正常的事务型数据库使用IOT是得不偿失的.&lt;/li>
&lt;/ul>
&lt;p>IOT最大的优点：&lt;strong>内部已经排好序&lt;/strong>，利于范围的查询 如时间范围搜寻.&lt;/p>
&lt;h3 id="记录强制排序">记录强制排序&lt;/h3>
&lt;p>为了使得&lt;strong>表中数据有序&lt;/strong>, 很多数据库使用了&lt;strong>聚簇索引&lt;/strong>.&lt;/p>
&lt;p>聚簇索引
-clustered index
或者 -clustering index&lt;/p>
&lt;ul>
&lt;li>
&lt;p>范围查询效率非常高&lt;/p>
&lt;/li>
&lt;li>
&lt;p>代价:非范围查询也要进行范围扫描&lt;/p>
&lt;/li>
&lt;li>
&lt;p>主键更新会导致记录的重新排序，从而导致记录物理位置的变化&lt;/p>
&lt;/li>
&lt;li>
&lt;p>为了更加安全, 聚簇索引可以和索引组织表一样，根据主键来定义. 因为主键被更新的概率小,或者说不应该被更新.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>聚簇索引也可以是非主键索引,这是和索引组织表不一样的地方.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e7%b4%a2%e5%bc%95%e5%8f%8a%e7%89%a9%e7%90%86%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84/image-20230227162104411.png" alt="image-20230227162104411" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>一旦出现&lt;strong>范围查询&lt;/strong>,聚簇索引的性能是非聚簇索引的二十倍.&lt;/p>
&lt;h3 id="总结">总结&lt;/h3>
&lt;p>聚簇索引, 索引组织表, 这种从物理结构上的优化, 必然存在明显的缺点.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e7%b4%a2%e5%bc%95%e5%8f%8a%e7%89%a9%e7%90%86%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84/image-20230227162152856.png" alt="image-20230227162152856" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>聚簇结构&lt;/strong>&lt;/p>
&lt;p>优点:某些情况下能成倍地，一个数量级地提高效率。&lt;/p>
&lt;p>缺点:会使其它操作的效率降低。&lt;/p>
&lt;p>&lt;strong>优化方案&lt;/strong>:&lt;/p>
&lt;p>可以和社交网络, nosql一样.&lt;/p>
&lt;p>用顺序文件实现数据组织, 同时需要禁止一切更新操作.&lt;/p>
&lt;h2 id="7分区的介绍">7.分区的介绍&lt;/h2>
&lt;p>分区(partition)也是一种最常用的物理组织技术. 也是数据分组的方式.&lt;/p>
&lt;p>可以很好的应对大数据量和高并发.&lt;/p>
&lt;p>分区，简单地讲，就是将一个大型的表，在物理上分成多个小型的表。但借助数据库引擎，看到的仍是一张完整的表.&lt;/p>
&lt;p>分区使得查询效率和并发(concurrency)效率在很多情况下得到提升. 并且这种方式是可以自然扩充的. 即系统架构的可伸缩性 (scalable)&lt;/p>
&lt;p>分区采用的是分而治之思想, 但分而治之不一定对所有事情有帮助, 比如对于售后来说基本上没有什么差别.&lt;/p>
&lt;p>要从以下几点了解分区:&lt;/p>
&lt;ul>
&lt;li>分区的底层逻辑是什么?&lt;/li>
&lt;li>有哪几种分区的方式?&lt;/li>
&lt;li>每种分区方式能解决什么样的问题?&lt;/li>
&lt;li>不同的分区方式对项目会带来怎么样的影响?&lt;/li>
&lt;/ul>
&lt;h3 id="71循环分区">7.1循环分区&lt;/h3>
&lt;p>分区技术的由来&lt;/p>
&lt;p>最早由sybase提出分区这个概念，把60G的数据分成10个区，也就是10个
物理文件。这样，每次备份，相当于顺序备份十个文件，每个文件6分钟。&lt;/p>
&lt;p>因此分区最早&lt;strong>用于数据库高效管理&lt;/strong>的而不是数据管理.&lt;/p>
&lt;p>那个时候使用的是&lt;strong>循环分区&lt;/strong>, 不受数据影响的内部机制。&lt;/p>
&lt;ul>
&lt;li>分区定义为各个磁盘的存储区域，插入数据时，数据会按照某种方法循环的加载到各个分区上，以保持插入时磁盘IO操作的平衡。&lt;/li>
&lt;li>对并发的随机查询很有帮助(&lt;strong>即越分散越适合并发&lt;/strong>)，循环分区可以看作是随机分布数据的一
种机制。&lt;/li>
&lt;/ul>
&lt;p>和循环分区很像, 分布式，也是一种分散的方式，也是一种&lt;strong>透明分散&lt;/strong>的逻辑。&lt;/p>
&lt;p>循环分区是为了方便管理,但开发者发现了分区的好处, 为了方便开发者, 出现了数据驱动分区.&lt;/p>
&lt;h3 id="72-数据驱动分区">7.2 数据驱动分区&lt;/h3>
&lt;p>数据驱动的分区，最核心的一个概念是&lt;strong>分区键(partition key)&lt;/strong>,&lt;/p>
&lt;p>也就是说, 分区时根据&lt;strong>一个或多个字段的值&lt;/strong>，来决定这条记录应该放入哪个分区中。此时不同分区的数据有 或强或弱的联系.&lt;/p>
&lt;blockquote>
&lt;p>就像范围查询一样: 如果某一个&lt;strong>范围的数据都集中在一个页&lt;/strong>中，那么&lt;strong>查询的效率将大幅度提高&lt;/strong>。&lt;/p>
&lt;/blockquote>
&lt;p>分区也一样，只不过粒度从页扩展到了分区。&lt;/p>
&lt;p>&lt;strong>滑动窗口&lt;/strong>是 &lt;strong>最早数据驱动分区&lt;/strong>方式。&lt;/p>
&lt;p>最大的数据库一般都是金融业, 电信, 移动互联网, 社交网络.&lt;/p>
&lt;p>&lt;strong>大量的历史数据&lt;/strong> 就是其数据库庞大的主要原因.&lt;/p>
&lt;p>但现实往往对&lt;strong>最新的数据比较感兴趣&lt;/strong>, 随着数据的增加, 对历史数据的兴趣会消退.&lt;/p>
&lt;p>&lt;strong>最常被查询的往往是那些可把比较新的数据&lt;/strong>。&lt;/p>
&lt;p>因此，&lt;strong>以根据日期/时间进行分区&lt;/strong>，&lt;strong>常用的数据和不常用的数据分别放在不同的分区当中.&lt;/strong>&lt;/p>
&lt;p>&lt;strong>总结&lt;/strong>:&lt;/p>
&lt;p>分区实现的本质: 逻辑上是一张表，物理上是多个物理文件，甚至是多个物理环境.&lt;/p>
&lt;p>&lt;strong>OB的表分区就是生成多个副本，存储在不同区域的OB服务器中&lt;/strong>&lt;/p>
&lt;h2 id="8分区的方式和应用">8.分区的方式和应用&lt;/h2>
&lt;h3 id="81数据驱动分区的实现方式">8.1数据驱动分区的实现方式&lt;/h3>
&lt;p>用数据值来划分分区&lt;/p>
&lt;p>&lt;strong>哈希分区(Hash-partitioning)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>对&lt;strong>分区键进行哈希运算&lt;/strong>，根据运算结果进行分区.&lt;/li>
&lt;li>能保证&lt;strong>根据分区键可以快速找到记录&lt;/strong>，但对范围搜索没有任何帮助。&lt;/li>
&lt;li>其实更接近与循环分区, 只是它还能 负载均衡提高并发的能力.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>范围分区(Range- partitioning)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>滑动窗口，就是范围分区，根据连续数据的范围对数据进行分区。&lt;/li>
&lt;li>&lt;strong>非常适合处理历史数据&lt;/strong>，每一个分区专门用来存储特定范围内的数据。&lt;/li>
&lt;li>一般系统还会设定else分区,来存储所有&lt;strong>可能漏网的数据&lt;/strong>(其他)&lt;/li>
&lt;li>应用: 时间范围, 字母范围&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>列表分区(List-partitioning)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>是一种最具手工风格的分区类型，适合&lt;strong>定制某种特殊的解决方案&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>分区键必须明确指定&lt;/strong>，但&lt;strong>分区键只能有一列&lt;/strong>，不能像范围或者哈希分区那样同时指定多个列做为分区键，但它的&lt;strong>单个分区对应值可以是多个&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>一旦插入的列值不在分区范围内，则插入/更新就会失败.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>因此
通常建议使用列表分区时，要创建一个&lt;strong>default分区&lt;/strong>存储那些&lt;strong>不在指定列表内的记录&lt;/strong>。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>很多数据库中分区可以嵌套，即分区可以再建立子分区，叫sub partition.子分区是分区内的分区。&lt;/p>
&lt;ul>
&lt;li>一种二位分区处理的方法，比如在时间的分区中，建立哈希分区等&lt;/li>
&lt;li>&lt;strong>OB把它叫做二级分区&lt;/strong>，再举个例子，&lt;strong>类似于用户账单领域，会按照user id做哈希分区，按照账单创建时间做范围分区&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>数据驱动的分区是最常使用的分区方式，用数据值本身作为分区的基础，这时候&lt;strong>数据分区最具有开发使用的价值&lt;/strong>。&lt;/p>
&lt;h3 id="82分区是把双刃剑">8.2分区是把双刃剑&lt;/h3>
&lt;p>&lt;strong>数据驱动的分区并没有全部地解决并发问题&lt;/strong>.&lt;/p>
&lt;p>例如，一个表如果按照时间分区，把一年的数据按星期分入五十二个不同的分区中，&lt;strong>查询起来确实非常快&lt;/strong>, &lt;strong>但更新呢?&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>如果滑动窗口是52个星期, 则每个星期的事务将&lt;strong>涌入同一个分区&lt;/strong> 来插入新数据库.&lt;/li>
&lt;li>此时,并发开销，内存争用都会大幅度提升，因为大型表中的其它数据都不访问&lt;strong>只访问最近的区域&lt;/strong>.&lt;/li>
&lt;/ul>
&lt;p>有时候，52个分区这样的滑动窗口也没有任何问题，比如数据仓库中，所有的数据都是通过单一进程进行插入，根本毫无并发压力。&lt;/p>
&lt;p>按照地理分区来方便插入时, 一旦进行时间范围查询, 反而此时数据分散, 效率很低.&lt;/p>
&lt;p>但最常使用的方式是多层分区的方式, 先时间分区,再地区分区.&lt;/p>
&lt;p>&lt;strong>IOT类似的问题:“冲突”&lt;/strong>&lt;/p>
&lt;p>A.通过分区键将数据聚集，利于高速检索;&lt;/p>
&lt;p>B.对于并发执行的插入操作，分散的数据可以避免访问过于集中的问题。&lt;/p>
&lt;p>在时间空间中, AB目标可能是相互矛盾的. 所以需要搞清楚主要问题是什么,并且根据主要问题进行分区. 同时计算两方面的得失,看看结果是否可以接受.&lt;/p>
&lt;p>因为&lt;strong>数据库的性能是以吞吐量为指标,而不是某一类型的操作效率.&lt;/strong>&lt;/p>
&lt;h3 id="83分区与数据分布">8.3分区与数据分布&lt;/h3>
&lt;p>表非常大，且希望避免并发写入数据的冲突就一定要用分区吗?&lt;/p>
&lt;ul>
&lt;li>假设有一个客户订单明细表，该表中大部分数据都来自于同一个客户20%的客户贡献了80%的销量，&lt;/li>
&lt;li>那么&lt;strong>按照客户的ID对数据进行分区&lt;/strong>，就&lt;strong>不会有太大的帮助&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>查询小客户数据: 在客户ID上的索引可选择性就会很高，因此查询效率也会很高。&lt;/p>
&lt;ul>
&lt;li>此时&lt;strong>完全不需要分区&lt;/strong>.&lt;/li>
&lt;li>聪明的查询优化器在获得关于键值分布的统计数据
之后，就可以检测到数据分布的不均衡，&lt;strong>而选择使用索引&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>查询大客户数据:&lt;/p>
&lt;ul>
&lt;li>优化器也知道&lt;strong>扫描表是效率最高的处理方式&lt;/strong>，由于
大客户的数据在表中占很大的比例，比如80%， 仅仅扫描该客户所在的分区&lt;strong>并不比全表扫描快多少&lt;/strong>，
所以性能提升也不大。&lt;/li>
&lt;/ul>
&lt;p>对分区表进行查询时，当&lt;strong>数据按分区键均匀分布时，&lt;/strong>
&lt;strong>收益最大&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>比如时间分区，往往一年
中多个分区的数据相对比较&lt;strong>均衡&lt;/strong>，&lt;strong>均衡分布，使用分区的收益才是最大的&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;h3 id="84数据分区的最佳方法">8.4数据分区的最佳方法&lt;/h3>
&lt;p>整体改善业务处理的操作,才是&lt;strong>选择分区的目标&lt;/strong>. 也就是说,改善不合理的业务流程,才是设计的重中之重.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>当有多个处理执行时，解决方案就不应该过度偏袒其中任何一个.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>只要是&lt;strong>根据数据值决定物理位置的存储方式&lt;/strong>，如聚簇索引、分区, &lt;strong>更新数据的代价都非常高&lt;/strong>。&lt;/p>
&lt;ul>
&lt;li>对普通表的更新，几乎是&lt;strong>在物理地址不变&lt;/strong>的情况下进行，最多只是修改和移动表中的一些字节。&lt;/li>
&lt;li>但&lt;strong>如果选择了索引和分区&lt;/strong>，更新很可能导致一系列的删除、插入和
相关的索引、分区的维护工作。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>一旦更新分区键，就像更新索引键值一样，都会&lt;strong>引起数据的移动&lt;/strong>。&lt;/p>
&lt;ul>
&lt;li>分区数据移动的代价更大,因为不同分区的数据移动&lt;strong>可能是不同物理区域,甚至是不同机器的传输和拷贝&lt;/strong>, 一般来说,要&lt;strong>避免不同分区的数据移动&lt;/strong>.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>除了**默认存储方式(堆文件, 单库单表)**外，都会带来复杂性。如果复杂性超过好处,就坚决避免.&lt;/p>
&lt;p>选错存储方式会带来大幅度的性能降低.&lt;/p>
&lt;p>任何需求都会有变化，任何商业的流程都会发生改变，&lt;strong>任何计划周详数据库设计都可能被推倒重来.&lt;/strong>&lt;/p>
&lt;p>在表不段变大的过程中,分区基本上是必然的处理手段,但还是谨慎地选择物理模式 并且小心地测试. 由于最初物理设计不佳而导致大型数据库推倒重来的代价是巨大的.&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/%E9%AB%98%E6%80%A7%E8%83%BD%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E5%8E%9F%E5%88%99/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/%E9%AB%98%E6%80%A7%E8%83%BD%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E5%8E%9F%E5%88%99/</guid><description>&lt;p>计算机程序首要目标完成业务需求。&lt;/p>
&lt;p>容易只重视技术手段，忽略了商业活动的数据质量，仅仅想按期交付完成需求功能的程序。&lt;/p>
&lt;p>&lt;strong>需要关注的问题：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>数据代表了什么&lt;/li>
&lt;li>数据之间有什么关系&lt;/li>
&lt;li>数据能推导出什么有价值的结论&lt;/li>
&lt;li>数据的质量到底怎么样&lt;/li>
&lt;li>怎么提高数据质量&lt;/li>
&lt;/ul>
&lt;p>未来是数据的世界。&lt;/p>
&lt;p>强调良好的模型和合理的数据库设计是任何信息系统的基础，是互联网企业的钱袋子&lt;/p>
&lt;h2 id="1规范化设计">1.规范化设计&lt;/h2>
&lt;p>学习任何数据库产品，无论是关系的，还是非关系的，本质上是对现实世界的一种模型。&lt;/p>
&lt;p>不同类型的数据库，本质上存储数据的模型是不一样。&lt;/p>
&lt;p>和任何模型一样，数据库也不是精确的模型，而仅仅是对纷繁复杂的现实世界有限的描述，对特定的一个业务活动的描述往往不止一种方法。这些在技术上都可以是语义正确的。&lt;/p>
&lt;p>但通常只有一种办法最贴近业务需求。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227205706284.png" alt="image-20230227205706284" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>被接受为真理不需要证明的事实，就是公理体系，其它学科叫原理而推演出来的新事实，就是定理。&lt;/p>
&lt;p>关系表中的一行，就是一个对事实的描述。&lt;/p>
&lt;p>表就相当于公理，通过一张表或者多张表的join操作，获得的其它事实，就是从公理推导出的定理。&lt;/p>
&lt;p>&lt;strong>表是公理系统，视图和查询是定理系统&lt;/strong>。&lt;/p>
&lt;p>保证数据的一致性，即保证基于数据库的任何查询与原始数据具有同样有效性。&lt;/p>
&lt;p>NoSql 无法在数学上保持一致性。&lt;/p>
&lt;h3 id="11关系理论与实现的差异">1.1关系理论与实现的差异&lt;/h3>
&lt;ul>
&lt;li>关系理论中，&lt;strong>关系是不包含重复数据&lt;/strong>的。
&lt;ul>
&lt;li>现实中间结果集包含重复数据。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>关系是处理&lt;strong>无限数据集&lt;/strong>的
&lt;ul>
&lt;li>关系数据库再大，它也是处理有限数据集的，有限数据集不仅要保证正确，
还要提高效率。&lt;/li>
&lt;li>中间结果集的产生，就是不需要把多个表完整的做完笛卡尔积再进行条件的筛选和投影，而是一步一步进行，以提高效率，&lt;strong>中间结果集未必包含全部的字段或者记录&lt;/strong>，有可能出现重复数据。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>关系理论中，&lt;strong>记录之间没有顺序的&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>规范化的原理&lt;/strong>：按照严格的逻辑要求，将不同的数据项组织在一起，变成结构化信息。&lt;/p>
&lt;p>数据库设计的三大范式：为了建立冗余较小、结构合理的数据库，设计数据库时必须遵循一定的规则。&lt;/p>
&lt;p>数据库领域的理想主义者认为数据的分析应超越三范式，至少要满足BC范式，甚至是五范式。&lt;/p>
&lt;p>规范化为什么重要：规范化能让混沌变得有序
数据库的表经过规范化之后，结构非常自然。&lt;/p>
&lt;p>严格逻辑规则的三范式：为清晰地获得常识，提供清单指南。&lt;/p>
&lt;p>&lt;strong>表结构如果没有规范化就会面临天大的风险?&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>主要是数据的不一致性&lt;/li>
&lt;li>不满足规范化，或者模型出现一些问题，会导致数据处理的代码在性能很庞大的数据库应用中犯错率大大提高&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227210328227.png" alt="image-20230227210328227" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h2 id="2字段设计---地址和空值处理">2.字段设计 - 地址和空值处理&lt;/h2>
&lt;p>第一范式
数据库表中的所有字段都是&lt;strong>单一属性，不可再分&lt;/strong>。&lt;/p>
&lt;p>第二范式
数据库的表中不存在非关键字段对任一候选关键字段的&lt;strong>部分函数依赖&lt;/strong>。&lt;/p>
&lt;p>第三范式
在第二范式的基础之上定义的。如果数据表中不存在非关键字段对任意候选关键字段的传递函数依赖则符合第三范式。&lt;/p>
&lt;h3 id="21地址">2.1地址&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227210531541.png" alt="image-20230227210531541" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>把地址拆分成什么程度，取决于要如何使用地址，&lt;strong>业务需求决定原子级的地址属性&lt;/strong>。&lt;/p>
&lt;p>拆分不是凭空揣测，也不是根据书上的或者其它组织项目的拆分的方式，而&lt;strong>只取决于项目的实际情况&lt;/strong>。&lt;/p>
&lt;p>如果将地址继续拆分为小区、楼栋、门牌号等原子型数据项，很多时候会无法处理，甚至需要合并几个字段，会制造麻烦&lt;/p>
&lt;h3 id="22空值的处理">2.2空值的处理&lt;/h3>
&lt;p>空值的核心含义是 &lt;strong>我不知道&lt;/strong>&lt;/p>
&lt;p>一般认为，数据表中，存在空值意味着关系模型设计上存在问题,
因为它会动摇查询优化的基础。&lt;/p>
&lt;p>本质上，关系模型的&lt;strong>完备性是以二值逻辑为基础&lt;/strong>。真或者假。&lt;/p>
&lt;p>如where需要。&lt;/p>
&lt;p>数据库不得不处理这种三值模型，T，F，再加上is null&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230309210351915.png" alt="image-20230309210351915" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>如果在需求中间，有80%的客户，这&lt;strong>三个地址都是一种&lt;/strong>公冒，一个，不是那种公司、是在一起的小公司，那该如何处理？&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227210853582.png" alt="image-20230227210853582" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>隐含逻辑会导致程序逻辑变复杂，代码出错风险提高。&lt;/p>
&lt;p>几乎没有任何十全十美的设计，每一种设计都有麻烦
根据数据的情况，不同类型公司的比例，查询和更新事务的比例，一定存在一个可能最适合的方案，但一定不存在一个一定适合的方案。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227211013862.png" alt="image-20230227211013862" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>空值对程序逻辑是危险的，如果必须使用空值，要清楚它在特定情况的影响，做出最佳性能的设计。&lt;/strong>&lt;/p>
&lt;h2 id="3布尔类型和历史数据">3.布尔类型和历史数据&lt;/h2>
&lt;h3 id="31限用布尔类型">3.1限用布尔类型&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227211205919.png" alt="image-20230227211205919" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>还可以用不同的表来跟踪订单。&lt;/p>
&lt;p>追求数据密度极端的例子:四个属性取值都是T/F， 可以用0-15这16个数值代表
四个属性所有组合状态。但可能违反了原子性的原则。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227211351061.png" alt="image-20230227211351061" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>只有程序员知道，优化器不知道。&lt;/p>
&lt;p>特别是若字符串型的字段&lt;strong>有时包含字符有时包含数字&lt;/strong>，对数据库设计来说不是技巧，而是说明最初的数据库设计，对领域的定义比较混乱。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227211434846.png" alt="image-20230227211434846" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>用更通用的表，然后建立子类型。&lt;/p>
&lt;p>例如:“如果账单寄送地址是null，就是用总部地址
” 不好&lt;/p>
&lt;p>尽可能多的&lt;strong>定义约束&lt;/strong>，把语义的约束通过字段类型
和字段长度放在DBMS中去
检查去约束。&lt;/p>
&lt;p>提高健壮性、可读性扩展性，&lt;strong>数据的语义属于DBMS，别放到应用程序&lt;/strong>中&lt;/p>
&lt;h3 id="32历史数据">3.2历史数据&lt;/h3>
&lt;p>关系设计的真正难题：处理&lt;strong>时间段&lt;/strong>的数据。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227211559404.png" alt="image-20230227211559404" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>可以设置&lt;strong>价值终止时间&lt;/strong>。当前价值有效，终止时间为空。&lt;/p>
&lt;p>但在查询方面有根本缺陷。&lt;/p>
&lt;p>如双十一的价格自动变化。&lt;/p>
&lt;p>当前的价格由当前日期之前的最大日期决定。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230309211503210.png" alt="image-20230309211503210" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>也可用非规范化建模&lt;/p>
&lt;p>当前价格的选择，是每一个产品页面刷新的必须进行的一个数据库操作，操
作非常频繁，为了提高这
个操作的效率，非规范化
打破范式是一个好的选择。&lt;/p>
&lt;p>同时&lt;strong>保存价格失效和生效日期，或者同时保存价格生效日期和有效天数&lt;/strong>。&lt;/p>
&lt;p>此时可以在数据插入或者更新时，增加更多检查以维护数据的完整性，但代价是性能下降。&lt;/p>
&lt;p>&lt;strong>另一种方式&lt;/strong>&lt;/p>
&lt;p>分别创建当前价格表和历史价格表，并定义一个操作触发器，当价格改变时
将数据从当前价格表移到历史价格表。 适合特定应用，但不适合预设价格。&lt;/p>
&lt;p>也可以通过分区的方式
把失效的历史价格丢到历史的分区中，然后所谓的
price_ history表就客观上小多了，查询更快。&lt;/p>
&lt;h2 id="4数据的处理模式和存储设计">4.数据的处理模式和存储设计&lt;/h2>
&lt;h3 id="41处理模式操作模式">4.1处理模式（操作模式）&lt;/h3>
&lt;p>操作模式：指数据应该以&lt;strong>异步模式&lt;/strong>处理(例如批处理系统)
，
还是&lt;strong>同步模式处理&lt;/strong>(例如
实时交易系统)&lt;/p>
&lt;p>操作模式&lt;/p>
&lt;ul>
&lt;li>
&lt;p>异步模式处理(批处理) :是所有数据处理方式的先驱。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>同步模式处理(实时交易)&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>处理数据的方式会影响物理结构的设计&lt;/p>
&lt;ul>
&lt;li>如果某些操作过于复杂，要跨很多系统很多物理环境时，等待同步实时交易，不可控因素会很大，这时需采用异步方式，放弃实时性的好处，而追求更直接的健壮和稳定性&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>大规模的批处理，我们需要关注吞吐量&lt;/strong>&lt;/p>
&lt;p>&lt;strong>如何选择异步和同步&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>选择不同模式，是整个系统需求，以及所处理数据所在的&lt;strong>物理结构所决定&lt;/strong>的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>从性能的角度来说，如果&lt;strong>无需必要，可以不选择同步&lt;/strong>的方式。&lt;/p>
&lt;p>比如网络爬虫，天生就应该使用异步的方式，数据库多库之间的数据传输，也大概率应该采用异步的方式。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>往往采用批处理这种异步方式时，&lt;strong>很容易发现某些事情&lt;/strong>花的时间太长，也
就是异步的批处理方式，比较&lt;strong>容易发现问题&lt;/strong>，批处理系统一-直在压榨系统的
性能。&lt;/p>
&lt;p>&lt;strong>同步不容易发现问题&lt;/strong>，只有在高并发和大数据量时暴露，在最糟的时候才会暴露，会极大影响业务。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>尽量只在必须要同步的时候，才设计成同步，否则都可尝试使用异步模式&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="42存储层面的设计">4.2存储层面的设计&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227212319650.png" alt="image-20230227212319650" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>不需要考虑节点的协调问题。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227212331338.png" alt="image-20230227212331338" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>网格集群包括现在最重要的云计算等皆是采用数据分布式的模式，
经常提到的&lt;strong>OB数据库就是典型的分布式数据库&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>结构越复杂，健壮性越低&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>性能的杀手:对远程数据的透明访问&lt;/strong>&lt;/p>
&lt;p>原因:&lt;/p>
&lt;ul>
&lt;li>无论看起来有多透明，跨多个软件层或者网络层的代价都很高&lt;/li>
&lt;li>试试执行一个在本地数据表中插入几千行数据的代码，相对比的是，执行另一个跨机器的同样程序通过指向连接进行操作。差异是几倍的。&lt;/li>
&lt;li>来自不同数据源的分布式数据结合起来非常困难。比较数据源A和数据源B的数据，必须&lt;strong>拷贝A的数据到B&lt;/strong>，或者反过来，拷贝B的数据到A，无论怎样都要面对开销很大的数据传输的代价。&lt;/li>
&lt;/ul>
&lt;p>远程的数据拷贝，&lt;strong>脱离了数据源环境&lt;/strong>，就&lt;strong>不能从数据规划中获益&lt;/strong>&lt;/p>
&lt;p>理论上来说，查询本地数据最有效的方式是嵌套的循环，程序员知道最佳过滤条件分布，
优化器能快速定位和找到最好的查询计划。&lt;/p>
&lt;p>但如果部分数据位于远程，只能选择：&lt;/p>
&lt;ul>
&lt;li>使用嵌套的循环，每次循环开销很大&lt;/li>
&lt;li>建立远程数据的本地副本，然后操作该副本，但此副本没有任何索引&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>数据库该如何部署？&lt;/strong>&lt;/p>
&lt;p>&lt;strong>平衡&lt;/strong>，离数据越近，访问越快。&lt;/p>
&lt;p>&lt;strong>那为什么说分布式比集中式更快？&lt;/strong>&lt;/p>
&lt;p>因为&lt;strong>吞吐量&lt;/strong>，分布式吞吐量的上限高于集中式。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227212606684.png" alt="image-20230227212606684" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>分布式吞吐量优&lt;/p>
&lt;p>&lt;strong>总结&lt;/strong>&lt;/p>
&lt;p>讨论了进行数据库规划的基础知识，包括数据建模的基本原则，特别是规范化、字段设计、历史数据等等问题。&lt;/p>
&lt;p>以及在不同情况下，错误的设计是如何导致各种后果的。&lt;/p>
&lt;p>忽视基本设计原则，会导致性能问题，而解决这些问题会浪费惊人的精力和智慧。&lt;/p>
&lt;h2 id="81大尺度的问题">8.1大尺度的问题&lt;/h2>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227212741617.png" alt="image-20230227212741617" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>如果一个系统很大，可是还使用过去小尺度下的规则，就会出问题。&lt;/p>
&lt;p>一旦尺度变大，&lt;strong>就需要用工程化的方式去组织，花费更多的成本去协调。&lt;/strong>&lt;/p>
&lt;p>不可能用没有并发的系统，去应付高并发、大数据量场景。&lt;/p>
&lt;p>绝大多数人的编程技术和数据处理能力，都需要在更大的项目中去领悟去提高。&lt;/p>
&lt;p>一个软件系统，一个复杂的数据库，太容易出错。系统越复杂，出错的频率就不成比例地增加。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227212917499.png" alt="image-20230227212917499" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>timestamp不确定&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227212937661.png" alt="image-20230227212937661" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>一个数据库系统整体的工作如果是100%，实现业务需求，所需要的工作大概只有20%，剩下80%的工作是性能、监控、审计、备份、恢复、错误处理安全机制等一系列的工作。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227213016939.png" alt="image-20230227213016939" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227213036444.png" alt="image-20230227213036444" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227213052829.png" alt="image-20230227213052829" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227213106792.png" alt="image-20230227213106792" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227213124961.png" alt="image-20230227213124961" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227213214194.png" alt="image-20230227213214194" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227213226552.png" alt="image-20230227213226552" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>棘手问题
棘手问题不是用来解决的，它也许根本解决不了，只能应付。&lt;/p>
&lt;p>好的判断来自经验
而经验来自坏的判断&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e9%ab%98%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e5%8f%91%e5%8e%9f%e5%88%99/image-20230227213342294.png" alt="image-20230227213342294" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p></description></item></channel></rss>