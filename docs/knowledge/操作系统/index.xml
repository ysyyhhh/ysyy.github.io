<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>操作系统 | Ysyy's</title><link>https://ysyyhhh.github.io/docs/knowledge/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link><atom:link href="https://ysyyhhh.github.io/docs/knowledge/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.xml" rel="self" type="application/rss+xml"/><description>操作系统</description><generator>Hugo Blox Builder (https://hugoblox.com)</generator><language>en-us</language><image><url>https://ysyyhhh.github.io/media/logo.svg</url><title>操作系统</title><link>https://ysyyhhh.github.io/docs/knowledge/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link></image><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E5%91%BD%E4%BB%A4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E5%91%BD%E4%BB%A4/</guid><description>&lt;h1 id="linux命令">Linux命令&lt;/h1>
&lt;h2 id="常用命令">常用命令&lt;/h2>
&lt;h2 id="qa">QA&lt;/h2>
&lt;p>文件过滤用什么
grep?&lt;/p></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E7%BC%96%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E7%BC%96%E7%A8%8B/</guid><description>&lt;h1 id="linux">Linux&lt;/h1>
&lt;h4 id="epoll底层实现">epoll底层实现&lt;/h4>
&lt;p>epoll是Linux内核提供的一种高效的I/O多路复用机制，其底层实现主要包括以下几个部分：&lt;/p>
&lt;ol>
&lt;li>内核事件表：epoll使用一个内核事件表来存储所有的I/O事件，包括读、写和异常事件等。&lt;/li>
&lt;li>文件描述符表：epoll使用一个文件描述符表来存储所有需要监控的文件描述符，每个文件描述符都对应一个epoll_event结构体，用于存储该文件描述符上的事件信息。&lt;/li>
&lt;li>回调函数：当有I/O事件发生时，内核会调用注册的回调函数来处理该事件，回调函数可以是用户自定义的函数，也可以是系统提供的函数。&lt;/li>
&lt;/ol>
&lt;h4 id="五种io模型">五种IO模型&lt;/h4>
&lt;ol>
&lt;li>阻塞式I/O模型：当应用程序调用I/O操作时，如果数据没有准备好，应用程序会一直等待，直到数据准备好为止。&lt;/li>
&lt;li>非阻塞式I/O模型：当应用程序调用I/O操作时，如果数据没有准备好，应用程序会立即返回，不会等待数据准备好。&lt;/li>
&lt;li>I/O复用模型：应用程序使用select、poll或epoll等系统调用来监控多个文件描述符，当有数据准备好时，应用程序会被通知。&lt;/li>
&lt;li>信号驱动式I/O模型：应用程序使用sigaction系统调用来注册一个信号处理函数，当数据准备好时，内核会向应用程序发送一个信号，应用程序在信号处理函数中处理数据。&lt;/li>
&lt;li>异步I/O模型：应用程序调用aio_read或aio_write等异步I/O函数来发起I/O操作，内核会在I/O操作完成后通知应用程序。&lt;/li>
&lt;/ol>
&lt;h4 id="解释同步阻塞">解释同步，阻塞&lt;/h4>
&lt;p>同步是指应用程序在执行某个操作时，必须等待该操作完成后才能继续执行下一步操作。&lt;/p>
&lt;p>阻塞是指应用程序在执行某个操作时，如果该操作不能立即完成，应用程序会被挂起，直到该操作完成为止。&lt;/p>
&lt;p>在阻塞式I/O模型中，应用程序调用I/O操作时，如果数据没有准备好，应用程序会一直等待，直到数据准备好为止，这就是阻塞。而在非阻塞式I/O模型中，应用程序调用I/O操作时，如果数据没有准备好，应用程序会立即返回，这就是非阻塞。&lt;/p>
&lt;h4 id="nio和bio区别">NIO和BIO区别&lt;/h4>
&lt;p>BIO（Blocking I/O）是阻塞式I/O模型，应用程序调用I/O操作时，如果数据没有准备好，应用程序会一直等待，直到数据准备好为止。NIO（Non-blocking I/O）是非阻塞式I/O模型，应用程序调用I/O操作时，如果数据没有准备好，应用程序会立即返回，不会等待数据准备好。&lt;/p>
&lt;h4 id="nio的底层">NIO的底层&lt;/h4>
&lt;p>NIO的底层实现主要包括以下几个部分：&lt;/p>
&lt;ol>
&lt;li>缓冲区：NIO使用缓冲区来存储数据，包括读缓冲区和写缓冲区。&lt;/li>
&lt;li>通道：NIO使用通道来进行数据的读写操作，通道类似于流，但是可以双向传输数据。&lt;/li>
&lt;li>选择器：NIO使用选择器来监控多个通道的状态，当有数据准备好时，选择器会通知应用程序。&lt;/li>
&lt;/ol></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%A0%94/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%A0%94/</guid><description>&lt;h1 id="操作系统基础">操作系统基础&lt;/h1>
&lt;h2 id="第章-计算机系统概述">第⼀章 计算机系统概述&lt;/h2>
&lt;h3 id="01-操作系统的概念定义">01 操作系统的概念（定义）&lt;/h3>
&lt;p>概念（定义）&lt;/p>
&lt;ul>
&lt;li>负责管理协调硬件、软件等计算机资源的⼯作&lt;/li>
&lt;li>为上层⽤户、应⽤程序提供简单易⽤的服务&lt;/li>
&lt;li>是⼀种系统软件&lt;/li>
&lt;/ul>
&lt;p>资源的管理者&lt;/p>
&lt;ul>
&lt;li>处理机管理&lt;/li>
&lt;li>存储管理&lt;/li>
&lt;li>⽂件管理&lt;/li>
&lt;li>设备管理&lt;/li>
&lt;/ul>
&lt;p>命令接⼝&lt;/p>
&lt;ul>
&lt;li>联机命令接⼝：直接在命令⾏输⼊&lt;/li>
&lt;li>脱机命令接⼝：写命令脚本&lt;/li>
&lt;/ul>
&lt;h3 id="02-操作系统的四个特征">02 操作系统的四个特征&lt;/h3>
&lt;p>操作系统的特征
并发（Concurrence）——最基本的特征
概念：指两个或多个事件在同⼀时间间隔内发⽣。这些时间宏观上是同时发⽣
的，微观上是交替发⽣的。
并⾏：指两个或多个事件在同⼀时刻同时发⽣。
单核与多核
单核CPU同⼀时刻只能运⾏⼀个程序，并发执⾏程序
多核CPU同⼀时刻可以执⾏多个程序，并⾏执⾏程序
共享（Sharing）——最基本的特征，⼆者互为存在条件
概念：即资源共享，是指系统中的资源可供内存中多个并发执⾏的进程共同使
⽤。
两种资源共享⽅式
互斥共享⽅式
⼀个时间段内只允许⼀个进程访问该资源啊
例⼦：摄像头，QQ和微信不能同时使⽤
同时访问⽅式
允许⼀个时间段内由多个进程“同时”对他们进⾏访问（宏观同时）
例⼦：发送⽂件、扬声器（真同时）
如果失去并发性，系统中只有⼀个程序正在运⾏，共享性失去意义。
如果失去共享性，QQ和微信不能同时访问硬盘资源，⽆法实现同时发送⽂
件，也就⽆法并发。
虚拟（Virtual）
概念：把⼀个物理上的实体变为若⼲个逻辑上的对应物。物理实体（前者）是实
际存在的，⽽逻辑上对应物（后者）是⽤户感受到的。
虚拟存储器技术，内存划分给多个程序使⽤：虚拟技术中的“空分复⽤技术”
虚拟处理器，处理器被多个程序使⽤：虚拟技术中的“时分复⽤”技术，微观上交
替执⾏。
没有并发性，也就谈不上虚拟性
异步（Asynchronism）
概念：在多道程序环境下，允许多个程序并发执⾏，但由于资源有限，进程的执
⾏不是⼀贯到底的，⽽是⾛⾛停停，以不可预知的速度向前推进。
如果失去并发性，系统只能串⾏执⾏各个程序，当程序执⾏完毕后才会归还。只
有系统拥有并发性，才有可能导致异步性。&lt;/p>
&lt;h3 id="03-os的发展与分类">03 OS的发展与分类&lt;/h3>
&lt;p>⼿⼯操作阶段
纸带
输⼊输出速度较慢，处理速度快，⽤户独占全机，⼈机速度⽭盾，导致资源利⽤率极
低
批处理阶段
单道批处理系统
主要特征
⾃动性，磁带上的作业能⾃动逐个运⾏
顺序性，作业的完成顺序与进⼊内存的顺序应完全相同
单道性，内存中仅有⼀道程序运⾏，即监督程序每次从磁带上只调⼊⼀道程
序进⼊内存运⾏，当该程序完成或发⽣异常时，才换⼊其后继程序进⼊内存运⾏。
外围机
引⼊脱机输⼊/输出技术（⽤外围机+磁带），并由监督程序负责控制作业的输
⼊、输出
监督程序——操作系统的雏形
优点
缓解⼈及速度⽭盾，提升资源利⽤率
缺点
内存中只能有⼀道程序运⾏
CPU有⼤量时间是在空闲等待I/O完成，利⽤率依然较低
多道批处理系统（操作系统开始出现）
优点
多道程序并发执⾏，共享计算机资源。资源利⽤率⼤幅提升，CPU和其他资
源更能保持“忙碌”状态，系统吞吐量增⼤。
缺点
没有⼈机交互功能，提交作业后只能等待计算机处理，⽆法对中间过程进⾏
⼲预，⽐如调试，输⼊参数
⼯作示意图
分时操作系统
概念：计算机以时间⽚为单位轮流为每个⽤户/作业服务，各个⽤户可通过终端与计
算机进⾏交互。
优点
⽤户的请求可以被即时相应，解决了⼈机交互问题。
允许多个⽤户同时使⽤⼀台计算机，并且⽤户对计算机的操作相互独⽴，感受不
到别⼈的存在。
⽤户感觉独占全机
缺点
不能优先处理紧急任务。
操作系统对每个⽤户/作业都是完全公平的，循环地为每个⽤户/作业服务⼀个时
间⽚，不区分任务点⽽紧急⾏。
实时操作系统
计算机系统接收到外部信号后及时进⾏处理，并且要在严格的时限内处理完事件。实
时操作系统的主要特点是及时性和可靠性。
优点
能够响应⼀些紧急任务，某些紧急任务不需时间⽚排队。
硬实时系统
必须在绝对严格的规定时间内完成处理。
（导弹控制系统、⾃动驾驶系统
软实时系统
能接受偶尔违反事件规定
⽹络操作系统
把⽹络中的各个计算机有机地结合起来，实现数据传输等功能。
实现⽹络中各种资源的共享（如⽂件共享）和个台计算机之间的通信。
Windows NT就是⼀种典型的⽹络操作系统，⽹站服务器就可以使⽤。
分布式操作系统
主要特点是：分布性和并⾏性。
系统中各台计算机地位相同，任何⼯作都可以⽤分布在这些计算机上，由它们并⾏、
协同完成这个任务。
个⼈计算机操作系统
Windows XP、MacOS&lt;/p>
&lt;h3 id="04-操作系统的运机制">⭐04 操作系统的运⾏机制&lt;/h3>
&lt;p>程序是如何运⾏的
C语⾔代码➡编译➡机器指令（⼆进制）
CPU执⾏机器指令
两种程序
内核程序
执⾏⼀些特权指令
应⽤程序
只能执⾏⾮特权指令
两种指令
特权指令
如：内存清零指令，这些指令影响重⼤，只允许管理者（操作系统内核）使⽤。
⾮特权指令
如：加法指令、减法指令。
两种处理器状态
⽤于区分此时正在运⾏的是内核程序 or 应⽤程序
内核态（核⼼态、管态）
运⾏的是内核程序
可以执⾏特权指令
⽤户态（⽬态）
运⾏的是应⽤程序
只能执⾏⾮特权指令
如何区分这两种状态？
CPU中的PSW寄存器（程序状态字寄存器），其中有个⼆进制位，1表示“内核
态”，0表示“⽤户态”
⭐两种状态的切换
内核态➡⽤户态
执⾏⼀条特权指令——修改PSW的标志位为⽤户态，操作系统主动让出CPU控
制权
⽤户态➡内核态
由“中断”引发，CPU 硬件⾃动完成变态过程，触发中断信号意味着操作系统
将强⾏夺回CPU的使⽤权&lt;/p>
&lt;h3 id="05-中断和异常">05 中断和异常&lt;/h3>
&lt;p>中断的作⽤
中断会使CPU由⽤户态变为内核态，使操作系统重新夺回对CPU的控制权
如果没⽤中断机制，就⽆法进⾏并发
中断是操作系统内核夺回CPU使⽤权的唯⼀途径
中断的类型
内中断（也称 异常、例外）
与当前执⾏的指令有关，中断信号来源于CPU内部
由某个指令引发的中断
陷阱、陷⼊（trap）
由陷⼊指令引发的，是应⽤程序故意引发的
如：系统调⽤
故障（fault）
由错误条件引起，可能被内核程序修复。
如：缺⻚故障
终⽌（abort）
由致命错误引起，内核程序⽆法修复该错误。
如：整数除0、⾮法使⽤特权指令
外中断（也称 中断）
与当前执⾏的指令⽆关，中断信号来源于CPU外部
时钟中断
由时钟部件发来的中断信号
时钟部件每隔⼀个时间⽚，归给CPU发送⼀个时钟中断信号
I/O中断
由输⼊输出设备发来的中断信号
中断机制的基本原理
不同的中断信号，需要⽤不同的中断处理程序来处理
内中断：CPU在执⾏指令时会检查是否有异常发⽣
外中断：每个指令周期末尾，CPU都会检查是否有外中断信号需要处理。
中断向量表
CPU检测到中断后，根据中断信号的类型去查询中断向量表，找到相应的中断处
理程序（运⾏在 内核态）在内存中的存放位置&lt;/p>
&lt;h3 id="06-系统调">06 系统调⽤&lt;/h3>
&lt;p>什么是系统调⽤？
概念：操作系统提供给应⽤程序（程序员/编程⼈员）使⽤的接⼝，可以理解为⼀种
可供应⽤系统调⽤的特殊函数，应⽤系统可以通过系统调⽤来请求获得操作系统内核
的服务。
程序接⼝由系统调⽤组成。
系统调⽤与库函数的区别
普通应⽤程序
直接进⾏系统调⽤
使⽤库函数（有的库函数会涉及系统调⽤）
编程语⾔
向上提供库函数
或把系统调⽤封装为库函数
操作系统
向上提供系统调⽤
⼩例⼦：为什么系统调⽤是必须的？
⽤户通过系统调⽤请求资源，由操作系统内核进⾏统⼀管理分配，避免混乱。
什么功能要⽤系统调⽤实现？
系统调⽤（按功能分类）
设备管理
完成设备的 请求/释放/启动 等功能
⽂件管理
完成⽂件的 读/写/创建/删除 等功能
进程控制
完成进程的 创建/撤销/阻塞/唤醒 等功能
进程通信
完成进程之间的 消息传递/信号传递 等功能
内存管理
完成内存的 分配/回收 等功能
系统调⽤的过程
传递系统调⽤参数
执⾏陷⼊/trap/访管指令（⽤户态）
内核程序处理系统调⽤（核⼼态）
返回应⽤程序&lt;/p>
&lt;h3 id="07-操作系统的体系结构">07 操作系统的体系结构&lt;/h3>
&lt;p>内核
对系统资源进⾏管理的功能
进程管理
存储器管理
设备管理
时钟管理
利⽤时钟中断实现计时功能
中断处理
原语（设备驱动、CPU切换等）
⼀种特殊的程序，具有原⼦性。这段程序的运⾏不能被中断。
变态的过程是有成本的，消耗时间，频繁地变态会降低系统性能
⾮内核功能
如：GUI
Ubuntu、CentOS主要⼯作是实现⾮内核功能，内核都是使⽤Linux内核
⼤内核
将操作系统的主要功能模块都作为系统内核，运⾏在核⼼态
优点：⾼性能
缺点：内核代码庞⼤，结构混乱，难以维护。
典型的 ⼤内核/宏内核/单内核 操作系统
Linux、Unix
微内核
只把最基本的功能保留在内核
优点：内核功能说好，结构清晰，⽅便维护
缺点：需要频繁地在核⼼态和⽤户态之间切换，性能低
典型的 微内核 操作系统
Windows NT&lt;/p>
&lt;h2 id="第章-进程管理">第⼆章 进程管理&lt;/h2>
&lt;h3 id="01-进程的-概念组成特征">01 进程的 概念、组成、特征&lt;/h3>
&lt;p>概念
进程 和 程序 的区别
程序：是静态的，就是个存放在磁盘⾥的可执⾏⽂件，就是⼀系列的指令集合。
进程（Process）：是动态的，是程序的⼀次执⾏过程。
操作系统如何区分进程
当进程被创建时，操作系统会为该进程分配⼀个唯⼀的、不重复的PID（Process
ID，进程ID）
组成
⼀个进程实体（进程映像）由PCB、程序段、数据段组成
进程是动态的，进程实体是静态的
进程是进程实体的运⾏过程，是系统进⾏资源分配和调度的⼀个独⽴单位。
PCB是进程存在的唯⼀标志！
进程控制块（PCB）
进程描述信息
进程标识符PID
⽤户标识符UID
进程控制和管理信息
CPU、磁盘、⽹络流量使⽤情况统计
进程当前状态：就绪态/阻塞态/运⾏态&amp;hellip;
资源分配清单
正在使⽤哪些⽂件
正在使⽤哪些内存区域
正在使⽤哪些I/O设备
处理机相关信息
PSW、PC等等各种寄存器的值（⽤于实现进程切换）
程序段
三个QQ进程的程序段相同，数据段、PCB不同
数据段
特征
动态性（进程最基本的特征）
进程是程序的⼀次执⾏过程，是动态地产⽣、变化和消亡的。
并发性
内存中有多个进程实体，各进程可并发执⾏
独⽴性
进程是能独⽴运⾏、独⽴获得资源、独⽴接受调度的基本单位
异步性
各进程按各⾃独⽴的、不可预知的速度向前推进，操作系统要提供“进程同步机
制”来解决异步问题。
结构性
每个进程都会配置⼀个PCB。结构上看，进程由程序段、数据段、PCB组成。
02 进程的状态与转换
状态
运⾏状态（Runing）
占有CPU，并在CPU上运⾏
单核CPU同⼀时刻只会有⼀个进程处于运⾏态，多核CPU可能有多个进程处于运
⾏态
就绪状态（Ready）
具备运⾏条件，但由于没有空闲CPU，⽽暂时不能运⾏
阻塞状态（Waiting/Blocked，⼜称：等待态）（三种基本状态）
因等待某⼀事件⽽暂时不能运⾏
创建状态（New，⼜称新建态）
进程正在被创建，操作系统为进程分配资源、初始化PCB
终⽌状态（Terminated，⼜称：结束态）
进程正在从系统中撤销，操作系统会回收进程拥有的资源、撤销PCB
state变量，1表示创建态，2表示就绪态，3表示运⾏态
状态间的转换
就绪态➡运⾏态
进程被调度
运⾏态➡就绪态
时间⽚到
处理机被抢占
运⾏态➡阻塞态
等待系统资源分配
或等待某时间发⽣（进程主动⾏为）
阻塞态➡就绪态
资源分配到位，等待的事件发⽣（被动⾏为），操作系统发起
进程的组织⽅式
链接⽅式
按照进程状态将PCB分为多个队列
操作系统持有指向各个队列的指针
过程
索引⽅式
根据进程状态的不同，建⽴⼏张索引表
操作系统持有指向各个索引表的指针
过程
03 进程控制
基本概念
概念：进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进
程、撤销已有进程、实现进程状态转换等功能。
实质：实现进程状态转换
过程图
如何实现进程控制：⽤“原语”实现
如何实现原语的“原⼦性”
⽤关中断指令和开中断指令这两个特权指令实现原⼦性
进程控制相关的原语
进程的创建
创建原语
申请空⽩PCB
为新进程分配所需资源
初始化PCB
将PCB插⼊就绪队列（创建态➡就绪态）
引起进程创建的事件
⽤户登录
分时系统中，⽤户登录成功，系统会为其建⽴⼀个新的进程
作业调度
多道批处理系统中，有新的作业放⼊内存时，会为其建⽴⼀个新的进程
提供服务
⽤户向操作系统提出某些请求时，会新建⼀个进程处理该请求
应⽤请求
由⽤户进程主动请求创建⼀个⼦进程
进程的终⽌
就绪态/阻塞态/运⾏态➡终⽌态➡⽆
撤销原语
从PCB集合中找到终⽌进程的PCB
若进程正在运⾏，⽴即剥夺CPU，将CPU分配给其他进程
终⽌其所有⼦进程
进程间的关系是树形结构
将该进程拥有的所有资源归还给⽗进程或操作系统
删除PCB
引起进程终⽌的事件
正常结束
进程⾃⼰请求终⽌（exit系统调⽤）
异常结束
整数除0、⾮法使⽤特权指令，然后被操作系统强⾏杀掉
外界⼲预
Ctrl + Alt + delete，⽤户选择杀掉进程
进程的阻塞
阻塞原语（运⾏态➡阻塞态）
找到要阻塞的进程对应的PCB
保护进程运⾏现场，将PCB状态信息设置为“阻塞态”，暂时停⽌进程运⾏
将PCB插⼊响应时间的等待队列
引起进程阻塞的事件
需要等待系统分配某种资源
需要等待相互合作的其他进程完成⼯作
进程的唤醒（成对出现）
唤醒原语（阻塞态➡就绪态）
在事件等待队列中找到PCB
将PCB从等待队列移除，设置进程为就绪态
将PCB插⼊就绪队列，等待被调度
引起进程唤醒的时间
等待事件发⽣（因何事阻塞，就应由何事唤醒）
进程的切换
切换原语（运⾏态➡就绪态、就绪态➡运⾏态）
将运⾏环境信息存⼊PCB
PCB移⼊相应队列
选择另⼀个进程执⾏，并更新其PCB
根据PCB恢复新进程所需的运⾏环境
引起进程切换的事件
当前进程时间⽚到
有更⾼优先的进程到达
当前进程主动阻塞
当前进程终⽌
04 进程通信
进程之间的信息交换
共享存储器系统
设置⼀个共享空间
要互斥地访问共享空间
两种⽅式
基于数据结构的共享（低级）
基于存储区的共享（⾼级）
消息传递系统
进程间的数据交换以格式化的消息（Message）为单位。
进程通过操作系统提供的“发送消息/接收消息”两个原语进⾏数据交换
消息头，消息体
直接通信⽅式
消息直接挂到接收进程的消息缓冲队列上
间接通信⽅式
消息要先发送到中间实体（信箱）中，因此也称（信箱通信⽅式）。
例⼦：电⼦邮件系统
管道通信系统
只能采⽤半双⼯通信，某⼀时间段内只能实现单向的传输
各进程要互斥地访问管道
数据以字节流写⼊管道，当管道写满时，写进程的write()系统调⽤将被阻塞，等待读
进程将数据取⾛。当数据被全部取⾛，管道变空，读进程的read()系统调⽤将被阻
塞。
如果没写满，就不允许读。如果没读空，就不允许写。
数据⼀旦被读出，就被抛弃，因此，读进程最多只能有⼀个
05 线程
什么是线程，为什么要引⼊线程？
线程是⼀个基本的CPU执⾏单元，也是程序执⾏流的最⼩单元。
引⼊线程后，进程之间可以并发，进程内的各线程之间也可以并发
引⼊线程后，进程只作为除CPU之外的系统资源的分配单位
打印机、内存地址空间都是分配给进程的
引⼊线程机制后，有什么变化
资源分配、调度
传统进程机制中，进程是资源分配、调度的基本单位
引⼊线程后，进程是资源分配的基本单位，线程是调度的基本单位
并发性
传统进程机制中，只能进程间并发
引⼊线程后，各线程间也能并发，提⾼了并发度
系统开销
传统的进程间并发，需要切换进程的运⾏环境，系统开销很⼤
线程间并发，如果是统⼀进程内的线程切换，不需要切换进程环境，开销⼩
引⼊线程后，并发所带来的系统开销减⼩
线程有哪些重要的属性
线程是处理机调度的单位
多CPU计算机中，各个线程可占⽤不同的CPU
每个线程都有⼀个线程id，线程控制块（TCB）
线程也有就绪、阻塞、运⾏三种基本状态
线程⼏乎不⽤系统资源
同⼀进程的不同线程间共享进程的资源
由于共享内存地址空间，同⼀进程中的线程间通信甚⾄⽆需系统⼲预
同⼀进程中的线程切换，不会引起进程切换
不同进程中的线程切换，会引起进程切换
切换同进程内的线程，系统开销很⼩
切换进程，系统开销较⼤
06 线程的实现⽅式——多线程模型
线程实现的⽅式
⽤户级线程（User-Level-thread，ULT）
线程库
优点
开销⼩，效率⾼
缺点
如果单个线程被阻塞，整个进程都会被阻塞，并发度不⾼。
多个线程⽆法在多核处理机上并⾏运⾏。
内核级线程
操作系统会为每个内核级线程建⽴相应的TCB (Thread Control Block，线程控制
块)，通过TCB对线程进⾏管理。“内核级线程”就是“从操作系统内核视⻆看能看到
的线程”
优点
当⼀个线程被阻塞后，别的线程还可以继续执⾏，并发能⼒强。
多线程可在多核处理机上并⾏执⾏。
缺点
⼀个⽤户进程会占⽤多个内核级线程，线程切换由操作系统内核完成，需要
切换到核⼼态，因此线程管理的成本⾼，开销⼤。
多线程模型
⼀对⼀模型
⼀个⽤户级线程映射到⼀个内核级线程。每个⽤户进程有与⽤户级线程同数量的
内核级线程。
优点
当⼀个线程被阻塞后，别的线程还可以继续执⾏，并发能⼒强。
多线程可在多核处理机上并⾏执⾏。
缺点
⼀个⽤户进程会占⽤多个内核级线程，线程切换由操作系统内核完成，需要
切换到核⼼态，因此线程管理的成本⾼，开销⼤。
多对⼀模型
多个⽤户级线程映射到⼀个内核级线程。且⼀个进程只被分配⼀个内核级线程。
优点
⽤户级线程的切换在⽤户空间即可完成，不需要切换到核⼼态，线程管理的
系统开销⼩，效率⾼
缺点
当⼀个⽤户级线程被阻塞后，整个进程都会被阻塞，并发度低。多个线程不
可在多核处理机上并⾏运⾏
操作系统只“看得⻅”内核级线程，因此只有内核级线程才是处理机分配的单位。
多对多模型
n⽤户及线程映射到m个内核级线程(n&amp;gt;=m)。每个⽤户进程对应m个内核级线程。
克服了多对⼀模型并发度不⾼的缺点(⼀个阻塞全体阻塞)，⼜克服了⼀对⼀模型
中⼀个⽤户进程占⽤太多内核级线程，开销太⼤的缺点。
⽤户级线程是“代码逻辑”的载体
内核级线程是“运⾏机会”的载体
07 处理机调度概念、层次
处理机调度
基本概念
当有⼀堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定
某种规则来决定处理这些任务的顺序，这就是“调度”研究的问题。
三个层次
⾼级调度（作业调度）
按⼀定的原则从外存的作业后备队列中挑选⼀个作业调⼊内存，并创建进
程，每个作业只调⼊⼀次，调出⼀次。作业调⼊时会建⽴PCB， 调出时才撒
销PCB。
中级调度（内存调度）
按照某种策略决定将哪个处于挂起状态的进程重新调⼊内存。
内存不够时，可将某些进程的数据调出外存。等内存空闲或者进程需要运⾏
时再重新调⼊内存。
暂时调到外存等待的进程状态为挂起状态（挂起态，suspend）。被挂起的进
程PCB会被组织成挂起队列
⾼频
低级调度（进程调度/处理机调度）
按照某种策略从就绪队列中选取⼀⼀个进程，将处理机分配给它。
进程调度是操作系统中最基本的⼀种调度，在⼀般的操作系统中都必须配置
进程调度。
三层调度的联系、对⽐
补充知识
进程的“挂起态”
就绪挂起
阻塞挂起
七状态模型
08 进程调度的时机、切换与过程调度⽅式
时机
什么时候需要进程调度?
主动放弃
进程正常终⽌
运⾏过程中发⽣异常⽽终⽌
进程主动请求阻塞（如等待I/O）
被动放弃
分给进程的时间⽚⽤完
有更紧急的事需要处理（如I/O中断）
有更⾼优先级的进程进⼊就绪队列
什么时候不能进⾏进程调度?
在处理中断的过程中。中断处理过程复杂，与硬件密切相关，很难做到在中断处
理过程中进⾏进程切换。
进程在操作系统内核程序临界区中。
在原⼦操作过程中（原语）。原⼦操作不可中断，要⼀⽓呵成（如之前讲过的修
改PCB中进程状态标志，并把PCB放到相应队列）
2012年联考真题
进程在操作系统内核程序临界区中不能进⾏调度与切换✅
进程处于临界区时不能进⾏处理机调度❌
普通临界区/内核临界区
临界资源
⼀个时间段内只允许⼀个进程使⽤的资源。各进程需要互斥地访问临界资
源。
临界区
访问临界资源的那段代码。
内核程序临界区
⼀般是⽤来访问某种内核数据结构的
如：进程的就绪队列(由各就绪进程的PCB组成)
切换与过程
&amp;ldquo;狭义的调度&amp;quot;与&amp;quot;切换”的区别
狭义的进程调度
指的是从就绪队列中选中⼀个要运⾏的进程。(这 个进程可以是刚刚被暂停执
⾏的进程，也可能是另⼀个进程，后⼀种情况就需要进程切换)
进程切换
指⼀个进程让出处理机，由另⼀个进程占⽤处理机的过程。
⼴义的进程调度包含了选择⼀个进程和进程切换两个步骤。
进程切换的过程需要做什么?
过程
对原来运⾏进程各种数据的保存
对新的进程各种数据的恢复(如:程序计数器、程序状态字、各种数据寄存器等
处理机现场信息，这些信息⼀般保存在进程控制块)
有代价的，如果过于频繁进⾏进程调度、切换，系统的效率会降低。
⽅式
⾮剥夺调度⽅式(⾮抢占式)
⾮剥夺调度⽅式，⼜称⾮抢占⽅式。即，只允许进程主动放弃处理机。在运⾏过
程中即便有更紧迫的任务到达，当前进程依然会继续使⽤处理机，直到该进程终
⽌或主动要求进⼊阻塞态。
实现简单，系统开销⼩但是⽆法及时处理紧急任务，适合于早期的批处理系统
剥夺调度⽅式(抢占式)
剥夺调度⽅式，⼜称抢占⽅式。当⼀个进程正在处理机上执⾏时，如果有⼀个更
重要或更紧迫的进程需要使⽤处理机，则⽴即暂停正在执⾏的进程，将处理机分
配给更重要紧迫的那个进程。
可以优先处理更紧急的进程，也可实现让各进程按时间⽚轮流执⾏的功能( 通过
时钟中断)。适合于分时操作系统、实时操作系统
09 调度算法的评价指标（计算）
CPU利⽤率
指CPU“忙碌”的时间占总时间的⽐例。
利⽤率 = 忙碌的时间/总时间（道/秒）
⽢特图
系统吞吐量
单位时间内完成作业的数量
系统吞吐量 = 总共完成了多少道作业 / 总共花了多少时间
周转时间
周转时间
指从作业被提交给系统开始，到作业完成为⽌的这段时间间隔。
（作业）周转时间 = 作业完成时间 - 作业提交时间
四部分
作业在外存后备队列上等待作业调度(⾼级调度)的时间
进程在就绪队列上等待进程调度( 低级调度)的时间
进程在CPU上执⾏的时间
进程等待I/O操作完成的时间
后三项在⼀个作业的整个处理过程中，可能发⽣多次。
平均周转时间
平均周转时间 = 各作业周转时间之和 / 作业数
带权周转时间
带权周转时间 = 作业周转时间 / 作业实际运⾏的时间
平均带权周转时间
平均带权周转时间 = 各作业带权周转时间之和 / 作业数
等待时间
指进程/作业处于等待处理机状态时间之和。
对于进程来说，等待时间就是指进程建⽴后等待被服务的时间之和，在等待I/O完成
的期间其实进程也是在被服务的，所以不计⼊等待时间。
对于作业来说，不仅要考虑建⽴进程后的等待时间，还要加上作业在外存后备队列中
等待的时间。
调度算法只会影响作业/进程的等待时间。
平均等待时间即各个 进程/作业 等待时间的平均值
响应时间
指从⽤户提交请求到⾸次产⽣响应所⽤的时间。
10 调度算法 先来先服务、最短作业优先、最⾼响应⽐优先
先来先服务（FCFS，First Come First Serve）
算法规则
按照作业/进程到达的先后顺序进⾏服务
⽤于作业/进程调度
⽤于作业调度时，考虑的是哪个作业先到达后备队列
⽤于进程调度时，考虑的是哪个进程先到达就绪队列
⾮抢占式
优点
公平、算法实现简单
缺点
排在⻓作业(进程)后⾯的短作业需要等待很⻓时间，带权周转时间很⼤，对短作
业来说⽤户体验不好。即，FCFS算法对⻓作业有利，对短作业不利
例如：排队买奶茶
最短作业优先（SJF）
思想
追求最少的平均等待时间，最少的平均周转时间、最少的平均平均带权周转时间
算法规则
最短的作业/进程优先得到服务(所谓“最短”，是指要求服务时间最短)
每次调度时选择当前已到达且运⾏时间最短的作业/进程
⽤于作业/进程调度
即可⽤于作业调度，也可⽤于进程调度。
⽤于进程调度时称为“短进程优先(SPF, Shortest Process First)算法
⾮抢占式
SJF和SPF是⾮抢占式的算法。但是也有抢占式的版本——最短剩余时间优先算法(
SRTN, Shortest Remaining Time Next )
最短剩余时间优先算法：每当有进程加⼊就绪队列改变时就需要调度，如果
新到达的进程剩余时间⽐当前运⾏的进程剩余时间更短，则由新进程抢占处
理机，当前运⾏进程重新回到就绪队列。另外，当⼀个进程完成时也需要调
度。
细节
如果未特别说明，短作业/进程优先算法默认是⾮抢占式的
在所有进程都⼏乎同时到达时，采⽤SJF调度算法的平均等待时间、平均周转
时间最少
抢占式的短作业/进程优先调度算法(最短剩余时间优先, SRNT算法)的平均等
待时间、平均周转时间最少”
缺点
对短作业有利，⻓作业不利。
可能产⽣饥饿现象。
最⾼响应⽐优先（HRRN，Highest Reponse Ratio Next）
思想
要综合考虑作业/进程的等待时间和要求服务的时间
算法规则
在每次调度时先计算各个作业/进程的响应⽐，选择响应⽐最⾼的作业/进程为其
服务
响应⽐ = （等待时间 + 要求服务时间）/ 要求服务时间
⽤于作业/进程调度
既可⽤于作业调度，也可⽤于进程调度
是否可抢占
⾮抢占式的算法。因此只有当前运⾏的作业/进程主动放弃处理机时，才需要调
度，才需要计算响应⽐
优缺点
综合考虑了等待时间和运⾏时间(要求服务时间)等待时间相同时，要求服务时间
短的优先(SJF 的优点)要求服务时间相同时，等待时间⻓的优先(FCFS 的优点)对于
⻓作业来说，随着等待时间越来越久，其响应⽐也会越来越⼤，从⽽避免了⻓作
业饥饿的问题
是否饥饿
不会导致饥饿
三种算法的⽐较
适⽤性
适⽤于早起的批处理系统，FCFS算法也常结合其他的算法使⽤
11 调度算法——时间⽚轮转、优先级调度、多级反馈队列
时间⽚轮转调度算法（RR，Round-Robin）
算法规则
按照各进程到达就绪队列的顺序，轮流让各个进程执⾏⼀个时间⽚(如100ms)。若
进程未在⼀个时间⽚内执⾏完，则剥夺处理机，将进程重新放到就绪队列队尾重
新排队。
⽤于作业/进程调度
是否可抢占
若进程未能在时间⽚内运⾏完，将被强⾏剥夺处理机使⽤权，因此时间⽚轮转调
度算法属于抢占式的算法。
由时钟装置发出时钟中断来通知CPU时间⽚已到。
优缺点
不会饥饿
时间⽚过⼤的影响
优先级调度算法
算法思想
随着计算机的发展，特别是实时操作系统的出现，越来越多的应⽤场景需要根据
任务的紧急程度来决定处理顺序。
调度规则
调度时选择优先级最⾼的作业/进程
⽤于作业调度/进程调度
既可⽤于作业调度，也可⽤于进程调度。甚⾄，还会⽤于在之后会学习的I/O调度
中
是否可抢占
抢占式、⾮抢占式都有。做题时的区别在于：⾮抢占式只需在进程主动放弃处理
机时进⾏调度即可，⽽抢占式还需在就绪队列变化时，检查是否会发⽣抢占。
优缺点
优点
⽤优先级区分紧急程度、重要程度，适⽤于实时操作系统。可灵活地调整对
各种作业/进程的偏好程度。
缺点
若源源不断地有⾼优先级进程到来，则可能导致饥
会导致饥饿
多级反馈队列调度算法
算法思想
对其他调度算法的折中权衡
算法规则
设置多级就绪队列，各级队列优先级从⾼到低，时间⽚从⼩到⼤
新进程到达时先进⼊第1级队列，按FCFS原则排队等待被分配时间⽚。若⽤完时
间⽚进程还未结束，则进程进⼊下⼀级队列队尾。如果此时已经在最下级的队
列，则重新放回最下级队列队尾
只有第k级队列为空时，才会为k+1级队头的进程分配时间⽚
抢占式
在k级队列的进程运⾏过程中，若更上级的队列(1~k-1级)中进⼊了⼀个新进程，则
由于新进程处于优先级更⾼的队列中，因此新进程会抢占处理机，原来运⾏的进
程放回k级队列队尾。
优点
对各类型进程相对公平(FCFS的优点) ；
每个新到达的进程都可以很快就得到响应(RR的优点)；
短进程只⽤较少的时间就可完成(SPF的优点) ；
不必实现估计进程的运⾏时间(避免⽤户作假) ;
可灵活地调整对各类进程的偏好程度，⽐如CPU密集型进程、I/0密集型进程(拓
展:可以将因I/O⽽阻塞的进程重新放回原队列，这样I/O型进程就可以保持较⾼优
先级)
会饥饿
综合⽐较
适合于交互式系统，⽐如：Unix
12 进程同步、进程互斥
进程同步
并发性带来了异步性，有时需要通过进程同步解决这种异步问题。
有的进程之间需要相互配合地完成⼯作，各进程的⼯作推进需要遵循- -定的先后顺
序。
进程互斥
对临界资源的访问，需要互斥的进⾏。即同⼀时间段内只能允许⼀个进程访问该资源
四个部分
进⼊区
检查是否可进⼊临界区，若可进⼊，需要“上锁”
临界区
访问临界资源的那段代码
退出区
负责&amp;quot;解锁&amp;rdquo;
剩余区
其余代码部分
需要遵循的原则
空闲让进
临界区空闲时，应允许⼀个进程访问
忙则等待
如临界区正在被访问时， 其他试图访问的进程需要等待
有限等待
要在有限时间内进⼊临界区，保证不会饥饿
让权等待
如进不了 临界区的进程，要释放处理机，防⽌忙等
13 进程互斥的软件实现⽅法
单标志法
算法思想
两个进程在访问完临界区后会把使⽤临界区的权限转交给另⼀个进程。也就是说
每个进程进⼊临界区的权限只能被另⼀个进程赋予。
int turn = 0; //turn表示当前允许进⼊临界区的进程号
同⼀时刻最多只允许⼀个进程访问临界区
双标志先检查
算法思想
设置⼀个布尔型数组flag[]， 数组中各个元素⽤来标记各进程想进⼊临界区的意
愿，⽐如“flag[0] = ture” 意味着0号进程PO现在想要进⼊临界区。每个进程在进⼊
临界区之前先检查当前有没有别的进程想进⼊临界区，如果没有，则把⾃身对应
的标志flag[]设为true,之后开始访问临界区。
双标志后检查
算法思想
双标志先检查法的改版。前⼀个算法的问题是先“检查”后“上锁”，但是这两个操
作⼜⽆法⼀⽓呵成，因此导致了两个进程同时进⼊临界区的问题。因此，⼈们⼜
想到先“上锁”后“检查”的⽅法，来避免上述问题。
优劣
解决了“忙则等待”的问题，违背了“空闲让进”和“有限等待”原则，会产⽣饥饿。
Peterson算法
算法思想
结合双标志法、单标志法的思想。如果双⽅都争着想进⼊临界区，那可以让进程
尝试“孔融让梨”(谦让)。做⼀个有礼貌的进程。
bool flag[2]; // 表示进⼊临界区意愿的数组，初始值都是false
int turn = 0; // turn表示优先让哪个进程进⼊临界区
图解
优劣
⽤软件⽅法解决了进程互斥问题，遵循了空闲让进、忙则等待、有限等待三个原
则，但是依然未遵循让权等待的原则。
14 进程互斥的硬件实现⽅法
中断屏蔽⽅法
使⽤“开关中断”指令实现
优点
简单⾼效
缺点
只适⽤于单处理机
只适⽤于操作系统内核进程
TestAndSet（TS指令/TSL指令）
过程：
old记录是否被上锁
再将lock设为true
检查临界区是否已被上锁（若已上锁，则循环重复前⼏步）
优点
实现简单
适⽤于多处理机环境
缺点
不满⾜“让权等待”
Swap指令（XCHG指令）
同TSL
15 信号量机制
⽤户进程可以通过使⽤操作系统提供的⼀对原语来对信号量进⾏操作，从⽽很⽅便的实
现了进程互斥、进程同步。
信号量其实就是⼀个变量(可以是⼀个整数，也可以是更复杂的记录型变量)，可以⽤
⼀个信号量来表示系统中某种资源的数量，⽐如：系统中只有⼀台打印机，就可以设
置⼀个初值为1的信号量。
原语是⼀种特殊的程序段，其执⾏只能⼀⽓呵成，不可被中断。原语是由关中断/开
中断指令实现的。软件解决⽅案的主要问题是由“进⼊区的各种操作⽆法⼀⽓呵成”，
因此如果能把进⼊区、退出区的操作都⽤“原语”实现，使这些操作能“⼀⽓呵成”就能
避免问题。
⼀对原语：wait(S)原语和signal(S)原语，可以把原语理解为我们⾃⼰写的函数，函数
名分别为wait和signal，括号⾥的信号量S其实就是函数调⽤时传⼊的⼀个参数。
wait、signal 原语常简称为P、V操作(来⾃荷兰语proberen和verhogen)。因此，做题的
时候常把wait(S)、signal(S)两个操作分别写为P(S)、V(S)
整型信号量
⽤⼀个整数型的变量作为信号量，⽤来表示系统中某种资源的数量。
整型信号量与普通整型变量的区别:对信号量只能执⾏初始化、P、V三种操作
存在的问题
不满⾜“让权等待”原则，会发⽣“忙等”
记录型信号量（⾼频考点）
即⽤记录型数据结构表示的信号量。
S.value表示某种资源数, S.L 指向等待该资源的队列
P 操作中，⼀定是先S.value&amp;ndash;，之后可能需要执⾏block原语
V 操作中，⼀定是先S.value++,之后可能需要执⾏wakeup原语
注意
要能够⾃⼰推断在什么条件下需要执⾏block或wakeup
功能
可以⽤记录型信号量实现系统资源的&amp;quot;申请&amp;quot;和&amp;quot;释放&amp;quot;
可以⽤记录型信号量实现进程互斥、进程同步
过程
16 ⽤信号量机制实现进程互斥、同步、前驱关系
⼀个信号量对应⼀种资源
实现进程互斥
过程
分析并发进程的关键活动，划定临界区（如：对临界资源打印机的访问就应该放
在临界区）
设置互斥信号量mutex，初值为1（semaphore mutex = 1; // 初始化信号量，默认
是记录型信号量）
在进⼊区P(mutex)——申请资源
在退出区V(mutex)——释放资源
注意：
对不同的临界资源需要设置不同的互斥信号量。
P、V操作必须成对出现。
实现进程同步
过程
1.分析什么地⽅需要实现“同步关系”，即必须保证“⼀前⼀后”执⾏的两个操作(或
两句代码)
2.设置同步信号量S，初始为0&lt;/p>
&lt;ol>
&lt;li>在“前操作”之后执⾏V(S)
4.在“后操作”之前执⾏P(S)
前V后P
演示
实现进程的前驱关系
过程
要为每⼀对前驱关系各设置⼀个同步信号量
在“前操作”之后对相应的同步信号量执⾏V操作
在“后操作”之前对相应的同步信号量执⾏P操作
实现进程的前驱关系
17 ⽣产者消费者问题
如何实现
⽣产者、消费者共享⼀个初始为空、⼤⼩为n的缓冲区。
只有缓冲区没满时，⽣产者才能把产品放⼊缓冲区，否则必须等待。
只有缓冲区不空时，消费者才能从中取出产品，否则必须等待。
缓冲区是临界资源，各进程必须互斥地访问。
实现图解
思考：能否改变相邻P、V操作的顺序？
会发⽣死锁
实现互斥的P操作⼀定要在实现同步的P操作之后
V操作不会导致进程阻塞，因此，两个V操作顺序可以交换
易错点
实现互斥和实现同步的两个P操作的先后顺序（死锁问题）
两对同步关系
18 多⽣产者-多消费者
加上互斥信号量。互斥的P操作⼀定要在实现同步的P操作之后，否则可能引起“死锁”
解题思路
1.关系分析。找出题⽬中描述的各个进程，分析它们之间的同步、互斥关系。&lt;/li>
&lt;li>整理思路。根据各进程的操作流程确定P、V操作的⼤致顺序。&lt;/li>
&lt;li>设置信号量。设置需要的信号量，并根据题⽬条件确定信号量初值。 (互斥信号量
初值⼀般为1，同步信号量的初始值要看对应资源的初始值是多少)
解决“多⽣产者-多消费者问题”的关键在于理清复杂的同步关系。
在分析同步问题(⼀前⼀后问题)的时候不能从单个进程⾏为的⻆度来分析，要把“⼀前
⼀后”发⽣的事看做是两种“事件”的前后关系。
过程关系
19 吸烟者问题
代码分析
20 读者-写者问题
实现
两种问题的区别与使⽤
21 哲学家进餐问题
每个进程需要同时持有多个临界资源
防⽌死锁的发⽣
⽅案①、②
⽅案③
22 管程
为什么要引⼊管程
信号量机制存在的问题
编写程序困难、易出错
⾼级同步机制
封装的思想
定义
管程是⼀种特殊的软件模块
组成部分&lt;/li>
&lt;li>局部于管程的共享数据结构说明；&lt;/li>
&lt;li>对该数据结构进⾏操作的⼀组过程；&lt;/li>
&lt;li>对局部于管程的共享数据设置初始值的语句；&lt;/li>
&lt;li>管程有⼀个名字。
基本特征&lt;/li>
&lt;li>局部于管程的数据只能被局部于管程的过程所访问;&lt;/li>
&lt;li>⼀个进程只有通过调⽤管程内的过程才能进⼊管程访问共享数据;&lt;/li>
&lt;li>每次仅允许⼀个进程在管程内执⾏某个内部过程。
拓展1：⽤管程解决⽣产者消费者问题
各进程必须互斥访问管程的特性是由编译器实现的
实现⽅法
具体过程&lt;/li>
&lt;li>需要在管程中定义共享数据(如⽣产者消费者问题的缓冲区)&lt;/li>
&lt;li>需要在管程中定义⽤于访问这些共享数据的“⼊⼝”——其实就是⼀-些函数(如⽣
产者消费者问题中，可以定义⼀个函数⽤于将产品放⼊缓冲区，再定义⼀个函数
⽤于从缓冲区取出产品)&lt;/li>
&lt;li>只有通过这些特定的“⼊⼝”才能访问共享数据&lt;/li>
&lt;li>管程中有很多“⼊⼝”，但是每次只能开放其中⼀个“⼊⼝”，并且只能让⼀个进
程或线程进⼊(如⽣产者消费者问题中，各进程需要互斥地访问共享缓冲区。管程
的这种特性即可保证⼀个时间段内最多只会有⼀个进程在访问缓冲区。注意:这种
互斥特性是由编译器负责实现的，程序员不⽤关⼼) 。&lt;/li>
&lt;li>可在管程中设置条件变量及等待/唤醒操作以解决同步问题。可以让⼀个进程或
线程在条件变量上等待(此时，该进程应先释放管程的使⽤权，也就是让出“⼊
⼝”) ；可以通过唤醒操作将等待在条件变量上的进程或线程唤醒。
程序员可以⽤某种特殊的语法来定义⼀个管程monitor，之后其他程序员可以使⽤这
个管程提供的⼊⼝，⽅便实现进程同步/互斥
拓展2：Java中类似于管程的机制
Java中的synchronized
23 死锁的概念
什么是死锁
在并发环境下，各进程因竞争资源⽽造成的⼀种互相等待对⽅⼿⾥的资源，导致各进
程都阻塞，都⽆法向前推进的现象，就是“死锁”。
发⽣死锁后若⽆外⼒⼲涉，这些进程都将⽆法向前推进。
进程死锁、饥饿、死循环的区别
死锁
各进程互相等待对⽅⼿⾥的资源，导致各进程都阻塞，⽆法向前推进的现象。
饥饿
由于⻓期得不到想要的资源，某进程⽆法向前推进的现象。⽐如：在短进程优先
(SPF) 算法中，若有源源不断的短进程到来，则⻓进程将⼀直得不到处理机， 从
⽽发⽣⻓进程“饥饿”。
死循环
某进程执⾏过程中⼀直跳不出某个循环的现象。有时是因为程序逻辑bug导致
的，有时是程序员故意设计的。
三者的区别
死锁产⽣的必要条件
互斥条件
只有对必须互斥使⽤的资源的争抢才会导致死锁(如哲学家的筷⼦、打印机设
备)。像内存、扬声器这样可以同时让多个进程使⽤的资源是不会导致死锁的(因
为进程不⽤阻塞等待这种资源)。
不剥夺条件
进程所获得的资源在未使⽤完之前，不能由其他进程强⾏夺⾛，只能主动释放。
请求和保持条件
进程已经保持了⾄少⼀个资源，但⼜提出了新的资源请求，⽽该资源⼜被其他进
程占有，此时请求进程被阻塞，但⼜对⾃⼰已有的资源保持不放。
循环等待条件
存在⼀种进程资源的循环等待链，链中的每⼀个进程已获得的资源同时被下⼀个
进程所请求。
发⽣死锁时⼀定有循环等待，但是发⽣循环等待时未必死锁
什么时候会发⽣死锁
对不可剥夺资源的不合理分配，可能导致死锁&lt;/li>
&lt;li>对系统资源的竞争。各进程对不可剥夺的资源( 如打印机)的竞争可能引起死锁，对
可剥夺的资源(CPU)的竞争是不会引起死锁的。&lt;/li>
&lt;li>进程推进顺序⾮法。请求和释放资源的顺序不当，也同样会导致死锁。例如，并发
执⾏的进程P1、P2分别申请并占有了资源R1、R2，之后进程P1⼜紧接着申请资源
R2，⽽进程P2⼜申请资源R1,两者会因为申请的资源被对⽅占有⽽阻塞，从⽽发⽣死
锁。
3.信号量的使⽤不当也会造成死锁。如⽣产者-消费者问题中，如果实现互斥的P操作
在实现同步的P操作之前，就有可能导致死锁。( 可以把互斥信号量、同步信号量也看
做是⼀&amp;ldquo;种抽象的系统资源)
死锁的处理逻辑
预防死锁
破坏死锁产⽣的四个必要条件
避免死锁
避免系统进⼊不安全状态（银⾏家算法）
死锁的检测和解除
允许死锁发⽣，系统负责检测出死锁并解除
24 死锁的处理策略——预防死锁（静态策略）
破坏互斥条件
只有对必须互斥使⽤的资源的争抢才会导致死锁。
SPOOLing技术把独占设备在逻辑上改造成共享设备
破坏不剥夺条件
不剥夺条件：
进程所获得的资源在未使⽤完之前，不能由其他进程强⾏夺⾛，只能主动释放。
⽅案⼀
某些资源上位使⽤完，也要主动释放，从⽽破坏不可剥夺条件。
⽅案⼆
当某个进程需要的资源被其他进程所占有的时候，由操作系统协助，将想要的资
源强⾏剥夺。
缺点
实现复杂
可能会造成前⼀阶段⼯作的失效。只适⽤于易保存和恢复状态的资源，如CPU
增加系统开销，降低系统吞吐量
可能导致某个进程饥饿
破坏请求和保持条件
请求和保持条件：
进程已经保持了⾄少⼀个资源，但⼜提出了新的资源请求，⽽该资源⼜被其他进
程占有，此时请求进程被阻塞，但⼜对⾃⼰已有的资源保持不放。
采⽤静态分配⽅法，即进程在运⾏前⼀次申请完它所需要的全部资源，在它的资源未
满⾜前，不让它投⼊运⾏。⼀旦投⼊运⾏后，这些资源就⼀直归它所有， 该进程就
不会再请求别的任何资源了。
缺点
资源利⽤率低。导致某些进程饥饿。
破坏循环等待条件
循环等待条件
存在⼀种进程资源的循环等待链，链中的每⼀- 个进程已获得的资源同时被下⼀
⼀个进程所请求。
可采⽤顺序资源分配法。
⾸先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类
资源(即编号相同的资源)⼀次申请完。
原理分析
⼀个进程只有已占有⼩编号的资源时，才有资格申请更⼤编号的资源。按此规
则，已持有⼤编号资源的进程不可能逆向地回来申请⼩编号的资源，从⽽就不会
产⽣循环等待的现象。
缺点
不⽅便增加新设备
会导致资源浪费
⽤户变成麻烦
25 死锁的处理策略——避免死锁（动态策略）
什么是安全序列
如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要找出⼀个安全序
列，系统就是安全状态，安全序列可能有多个。
什么是系统的不安全状态，与死锁有何联系
如果分配了资源之后，系统中找不出任何⼀个安全序列，系统就进⼊了不安全状态。
可能会导致所有进程都⽆法顺利的执⾏下去，也有可能冲洗你回到安全状态。
如果处于安全状态，就⼀定不会发⽣死锁。如果进⼊不安全状态，可能会导致死锁。
如何避免系统进⼊不安全状态——银⾏家算法
数据结构
⻓度为m的⼀-维数组Available 表示还有多少可⽤资源
n&lt;em>m矩阵Max表示各进程对资源的最⼤需求数
n&lt;/em>m矩阵Allocation表示已经给各进程分配了多少资源
Max-Allocation=Need矩阵表示各进程最多还需要多少资源
⽤⻓度为m的⼀-位数组Request表示进程此次申请的各种资源数
银⾏家算法步骤
①检查此次申请是否超过了之前声明的最⼤需求数
②检查此时系统剩余的可⽤资源是否还能满⾜这次请求
③试探着分配，更改各数据结构
④⽤安全性算法检查此次分配是否会导致系统进⼊不安全状态
安全性算法步骤
检查当前的剩余可⽤资源是否能满⾜某个进程的最⼤需求，如果可以，就把该进
程加⼊安全序列,并把该进程持有的资源全部回收。
不断重复上述过程，看最终是否能让所有进程都加⼊安全序列。
系统处于不安全状态未必死锁，但死锁时⼀定处于不安全状态。系统处于安全状态⼀定
不 会死锁。
26 死锁的处理策略——检测和解除（允许死锁的发⽣）
死锁的检测
数据结构资源分配图
两种结点
进程结点
对应⼀个进程
资源结点
对应⼀类资源，⼀类资源可能有多个
两种边
进程结点——&amp;gt;资源结点
表示进程想申请⼏个资源（每条边代表⼀个）
资源结点——&amp;gt;进程结点
表示已经为进程分配了⼏个资源（每条边代表⼀个）
是否可以消除所有边
检测死锁的算法
1)在资源分配图中，找出既不阻塞⼜不是孤点的进程Pi (即找出⼀条有向边与它相
连，且该有向边对应资源的申请数量⼩于等于系统中已有空闲资源数量。如下图
中，R1没有空闲资源，R2有⼀个空闲资源。若所有的连接该进程的边均满⾜上述
条件，则这个进程能继续运⾏直⾄完成，然后释放它所占有的所有资源)。消去它
所有的请求边和分配边，使之称为孤⽴的结点。在下图中，P1是满⾜这⼀条件的
进程结点，于是将P1的所有边消去。
2)进程Pi所释放的资源，可以唤醒某些因等待这些资源⽽阻塞的进程，原来的阻
塞进程可能变为⾮阻塞进程。在下图中，P2就满⾜这样的条件。根据1)中的⽅法
进⾏⼀系列简化后，若能消去途中所有的边，则称该图是可完全简化的。
死锁定理
如果某时刻系统的资源分配图是不可完全简化的，那么此时系统死锁。
死锁的解除
⼀旦检测出死锁的发⽣，就应该⽴即解除死锁
并不是系统中所有的进程都是死锁状态。⽤死锁检测算法化简资源分配图后，还连着
边的那些进程就是死锁进程
解除死锁的主要⽅法有&lt;/li>
&lt;li>资源剥夺法。挂起( 暂时放到外存上)某些死锁进程，并抢占它的资源，将这些
资源分配给其他的死锁进程。但是应防⽌被挂起的进程⻓时间得不到资源⽽饥
饿。&lt;/li>
&lt;li>撤销进程法(或称终⽌进程法)。强制撤销部分、甚⾄全部死锁进程，并剥夺这
些进程的资源。这种⽅式的优点是实现简单，但所付出的代价可能会很⼤。因为
有些进程可能已经运⾏了很⻓时间，已经接近结束了，⼀旦被终⽌可谓功亏⼀
篑，以后还得从头再来。&lt;/li>
&lt;li>进程回退法。让⼀个或多个死锁进程回退到⾜以避免死锁的地步。这就要求系
统要记录进程的历史信息，设置还原点。
如何决定“对谁动⼿”
1.进程优先级
2.已执⾏多⻓时间
3.还要多久能完成
4.进程已经使⽤了多少资源
5.进程是交互式的还是批处理式的
第三章 内存管理
01 内存的基础知识
什么是内存，有何作⽤
内存可存放数据。
程序执⾏前需要先放到内存中才能被CPU处理——缓冲CPU与硬盘之间的速度⽭盾
按字节编址
每个存储单元⼤⼩为1字节
按字编址
如果字⻓为16位，按字编址，每个存储单元⼤⼩为1个字；16个⼆进制位
进程运⾏的基本原理
指令的⼯作原理
操作码+参数
MOV, A, B
逻辑地址VS物理地址
相对地址
绝对地址
如何实现地址转换
装⼊的三种⽅式
绝对装⼊
编译时产⽣绝对地址
可重定位装⼊（静态重定位）
⼀次分配完所需要的内存空间
动态运⾏时装⼊（动态重定位）
动态重定位
重定位寄存器
从写程序到程序运⾏的过程
编译
由编译程序将⽤户源代码编译成若千个⽬标模块(编译就是把⾼级语⾔翻译为
机器语⾔)
链接
由链接程序将编译后形成的⼀-组⽬标模块，以及所需库函数链接在⼀起，形
成-⼀个完整的装⼊模块
装⼊(装载)
由装⼊程序将装⼊模块装⼊内存运⾏
链接的三种⽅式
静态链接
在程序运⾏之前，先将各⽬标模块及它们所需的库函数连接成⼀个完整的可
执⾏⽂件(装⼊模块) ，之后不再拆开。
装⼊时动态链接
将各⽬标模块装⼊内存时，边装⼊边链接的链接⽅式。
运⾏时动态链接
在程序执⾏中需要该⽬标模块时，才对它进⾏链接。其优点是便于修改和更
新，便于实现对⽬标模块的共享。
02 内存管理的概念
内存空间的分配与回收
内存空间的扩充
地址转换
逻辑地址与物理地址的转换
三种装⼊⽅式
绝对装⼊（单道程序阶段，⽆操作系统）
编译时产⽣绝对地址
可重定位装⼊（早期多道批处理阶段）
装⼊时将逻辑地址转换为物理地址
动态运⾏时装⼊（现代操作系统）
运⾏时将逻辑地址转换为物理地址，需设置重定位寄存器
存储保护
保证各进程在⾃⼰的内存空间内运⾏，不会越界访问
两种⽅式
设置上下限寄存器
利⽤重定位寄存器、界地址寄存器进⾏判断
03 覆盖与交换（内存空间的扩充）
覆盖技术
解决 程序⼤⼩超过物理内存总和
必须由程序员声明覆盖结构，操作系统完成⾃动覆盖。
缺点
对⽤户不透明，增加了⽤户编程负担
交换（对换）技术
内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运⾏条
件的进程换⼊内存(进程在内存与磁盘间动态调度)
中级调度（内存调度）
决定将哪个处于挂起状态的进程重新调⼊内存
在外存的什么位置保存被换出的进程
具有对换功能的操作系统中，通常把磁盘空间分为⽂件区和对换区两部分。
⽂件区
主要⽤于存放⽂件，主要追求存储空间的利⽤率，因此对⽂件区空间的管理
采⽤离散分配⽅式。
对换区
对换区空间只占磁盘空间的⼩部分，被换出的进程数据就存放在对换区。由
于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求
换⼊换出速度，因此通常对换区采⽤连续分配⽅式( 学过⽂件管理章节后即可
理解)。总之，对换区的I/O速度⽐⽂件区的更快。
什么时候交换
内存吃紧时进⾏，系统负荷降低就暂停
例如
在发现许多进程运⾏时经常发⽣缺⻚，就说明内存紧张，此时可以换出⼀些
进程:
如果缺⻚率明显下降，就可以暂停换出。
应该换出哪些进程
优先换出阻塞进程
可换出优先级低的进程
防⽌优先级低的进程在被调⼊内存后很快被换出，还需考虑进程在内存的驻留时
间
PCB会常驻内存
虚拟存储技术
04 连续分配管理⽅式
单⼀连续分配
内存被分为系统区、⽤户区
内存中只能有⼀道⽤户程序，⽤户程序独占整个⽤户区
优点
实现简单
⽆外部碎⽚
可以采⽤覆盖技术扩充内存
不⼀定需要采取内存保护
缺点
只能⽤于单⽤户、单任务操作系统
有内部碎⽚（有些内部空间没有被利⽤到）
存储利⽤率极低
固定分区分配
分区⼤⼩相等
缺乏灵活性，适⽤于⼀台计算机控制多个相同对象的场合
将程序分段
固定区
调⼊后就不再调出，直⾄运⾏结束
覆盖区
覆盖区中的程序段在运⾏过程中会根据需要调⼊调出
分区⼤⼩不等
增加了灵活性，满⾜不同⼤⼩的进程需求，操作系统根据作业⼤⼩情况进⾏划分
⽆外部碎⽚，有内部碎⽚
动态分区分配
根据进程⼤⼩动态地建⽴分区
分区的⼤⼩和数⽬是可变的
采⽤什么数据结构记录内存的使⽤情况
空闲分区表
空闲分区链
动态分区分配算法
动态分区分配没有内部碎⽚，但是有外部碎⽚
内部碎⽚，分配给某进程的内存区域中，有些部分没有⽤上
外部碎⽚，内存中的某些空闲分区由于太⼩⽽难以利⽤
外部碎⽚可⽤“紧凑”技术来解决
回收内存的四种情况
回收区之后有相邻的空闲分区
回收区之前有相邻的空闲分区
回收区前、后都有相邻的空闲分区
回收区前、后都没有相邻的空闲分区
05 动态分区分配算法
⾸次适应算法（FF，First Fit）
算法思想
每次都从低地址开始查找，找到第⼀个能满⾜⼤⼩的空闲分区。
如何实现
空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链(或空闲分
区表)，找到⼤⼩能满⾜要求的第⼀个空闲分区。
最佳适应算法（BF，Best Fit）
算法思想
由于动态分区分配是⼀种连续分配⽅式，为各进程分配的空间必须是连续的⼀整
⽚区域。因此为了保证当“⼤进程”到来时能有连续的⼤⽚空间，可以尽可能多地
留下⼤⽚的空闲区即，优先使⽤更⼩的空闲区。
如何实现
空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链( 或空闲分
区表)，找到⼤⼩能满⾜要求的第⼀个空闲分区。
缺点
每次都选最⼩的分区进⾏分配，会留下越来越多的、很⼩的、难以利⽤的内存
块。因此这种⽅法会产⽣很多的外部碎⽚。
最坏适应算法（WF，Worst Fit）
⼜称最⼤适应算法（Largest Fit）
算法思想
为了解决最佳适应算法的问题⼀&amp;mdash;即留下太多难以利⽤的⼩碎⽚，可以在每次分
配时优先使⽤最⼤的连续空闲区，这样分配后剩余的空闲区就不会太⼩，更⽅便
使⽤。
如何实现
空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区
表)，找到⼤⼩能满⾜要求的第⼀个空闲分区。
邻近适应算法（NF，Next Fit）
算法思想
如何实现
优点
⾸次适应算法效果最好
⽐较
06 基本分⻚存储管理的基本概念
内存空间的分配与回收
连续分配管理⽅式
连续分配：为⽤户进程分配的必须是⼀⼀个连续的内存空间。
⾮连续分配管理⽅式
⾮连续分配：为⽤户进程分配的可以是-⼀些分散的内存空间。
基本分⻚存储管理
什么是分⻚存储
内存空间分为⼀个个⼤⼩相等的分区，每个分区就是⼀个“⻚框”（⻚框=
⻚帧=内存块=物理块=物理⻚⾯）。每个⻚框有⼀个编号，即“⻚框
号”（⻚框号=⻚帧号=内存块号=物理块号=物理⻚号），⻚框号从0开
始。
将进程的逻辑地址空间也分为与⻚框⼤⼩相等的⼀个个部分，每个部分
称为⼀个“⻚”或“⻚⾯”。每个⻚⾯也有⼀个编号，即“⻚号”，⻚号也是从
0开始
进程的⻚⾯与内存的⻚框有⼀⼀对应的关系。
各个⻚⾯不必连续存放，可以放到不相邻的各个⻚框中。
易混淆
⻚、⻚⾯ vs ⻚框、⻚帧、物理⻚；
⻚号、⻚⾯号 vs ⻚框号、⻚帧号、物理⻚号
⻚表
⻚表通常存在PCB中
⼀个进程对应⼀张⻚表
进程的每个⻚⾯对应⼀个⻚表项
每个⻚表项由“⻚号”和“块号”组成
⻚表记录进程⻚⾯和实际存放的内存块之间的映射关系
具体关系图
已知内存⼤⼩，⻚⾯⼤⼩，计算每个⻚表项需要多⼤
内存⼤⼩/⻚⾯⼤⼩，换算为⽐特位，再转换为字节
计算⽅法
如何实现地址转换&lt;/li>
&lt;li>计算出逻辑地址对应的【⻚号，业内偏移量】&lt;/li>
&lt;li>找到对应⻚⾯在内存中的存放位置（查⻚表）&lt;/li>
&lt;li>物理地址 = ⻚⾯始址 + ⻚内偏移量
逻辑地质结构——可拆分为【⻚号P，⻚内偏移量W】
⻚号 = 逻辑地址 / ⻚⾯⼤⼩；
⻚内偏移量 = 逻辑地址 % ⻚⾯⼤⼩
如果⻚⾯⼤⼩刚好是2的整数次幂呢
结论:如果每个⻚⾯⼤⼩为2^K B，⽤⼆进制数表示逻辑地址，则末尾
K位即为⻚内偏移量，其余部分就是⻚号
基本地址变换机构【⻅P7】
基本分段存储管理
段⻚式存储管理
内存空间的扩充
地址转换
存储保护
07 基本地址变换机构
⻚表寄存器的作⽤
存放⻚表起始地址
存放⻚表⻓度
⚡地址变换过程&lt;/li>
&lt;li>根据逻辑地址算出⻚号、⻚内偏移量&lt;/li>
&lt;li>⻚号的合法性检查(与⻚表⻓度对⽐)&lt;/li>
&lt;li>若⻚号合法，再根据⻚表起始地址、⻚号找到对应⻚表项&lt;/li>
&lt;li>根据⻚表项中记录的内存块号、⻚内偏移量得到最终的物理地址&lt;/li>
&lt;li>访问物理内存对应的内存单元
其他⼩细节
⻚内偏移量位数与⻚⾯⼤⼩之间的关系(要能⽤其中⼀个条件推出另⼀个条件)
⻚式管理中地址是⼀维的
实际应⽤中，通常使-个⻚框恰好能放⼊整数个⻚表项
为了⽅便找到⻚表项，⻚表- -般是放在连续的内存块中的
08 具有快表的地址变换机构
什么是快表（TLB）
快表，⼜称联想寄存器(TLB， translation lookaside buffer)，是⼀种访问速度⽐内存快
很多的⾼速缓存(TLB不是内存! )，⽤来存放最近访问的⻚表项的副本，可以加速地址
变换的速度。与此对应，内存中的⻚表常称为慢表。
引⼊快表后，地址的变换过程
①CPU给出逻辑地址，由某个硬件算得⻚号、⻚内偏移量，将⻚号与快表中的所有⻚
号进⾏⽐较。
②如果找到匹配的⻚号，说明要访问的⻚表项在快表中有副本，则直接从中取出该⻚
对应的内存块号，再将内存块号与⻚内偏移量拼接形成物理地址，最后，访问该物理
地址对应的内存单元。因此，若快表命中，则访问某个逻辑地址仅需⼀次访存即可。
③如果没有找到匹配的⻚号，则需要访问内存中的⻚表，找到对应⻚表项，得到⻚⾯
存放的内存块号，再将内存块号与⻚内偏移量拼接形成物理地址，最后，访问该物理
地址对应的内存单元。因此，若快表未命中，则访问某个逻辑地址需要两次访存(注
意:在找到⻚表项后，应同时将其存⼊快表，以便后⾯可能的再次访问。但若快表已
满，则必须按照⼀-定 的算法对旧的⻚表项进⾏替换)
局部性原理
时间局部性
如果执⾏了程序中的某条指令，那么不久后这条指令很有可能再次执⾏;如果某个
数据被访问过，不久之后该数据很可能再次被访问。( 因为程序中存在⼤量的循
环)
空间局部性
⼀旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访
问。(因为很 多数据在内存中都是连续存放的)
对⽐图
09 两级⻚表
单级⻚表存在什么问题?如何解决?
所有⻚表项必须连续存放，⻚表过⼤时需要很⼤的连续空间
在⼀段时间内并⾮所有⻚⾯都⽤得到，因此没必要让整个⻚表常驻内存
两级⻚表
将⻓⻓的⻚表再分⻚
逻辑地址结构: 【⼀级⻚号，⼆级⻚号，⻚内偏移量】
注意⼏个术语:⻚⽬录表/外层⻚表/顶级⻚表
如何实现地址变换?
①按照地址结构将逻辑地址拆分成三部分
②从PCB中读出⻚⽬录表始址，根据⼀级⻚号查⻚⽬录表，找到下⼀级⻚表在内存中
的存放位置
③根据⼆级⻚号查表，找到最终想访问的内存块号
④结合⻚内偏移量得到物理地址
两级⻚表问题需要注意的⼏个细节
多级⻚表中，各级⻚表的⼤⼩不能超过⼀个⻚⾯。若两级⻚表不够，可以分更多级
多级⻚表的访存次数(假设没有快表机构) ——N 级⻚表访问⼀个逻辑地址需要N+ 1次访
存
10 基本分段存储管理⽅式
什么是分段(类似于分⻚管理中的&amp;quot;分⻚&amp;rdquo;)
将地址空间按照程序⾃身的逻辑关系划分为若⼲个段，每段从0开始编址
每个段在内存中占据连续空间，但各段之间可以不相邻
逻辑地址结构：【段号， 段内地址】
什么是段表(类似于分⻚管理中的&amp;quot;⻚表&amp;quot;)
记录逻辑段到实际存储地址的映射关系
每个段对应-个段表项。各段表项⻓度相同，由段号(隐含)段⻓、基址组成
如何实现地址变换&lt;/li>
&lt;li>由逻辑地址得到段号、段内地址&lt;/li>
&lt;li>段号与段表寄存器中的段⻓度⽐较，检查是否越界&lt;/li>
&lt;li>由段表始址、段号找到对应段表项&lt;/li>
&lt;li>根据段表中记录的段⻓，检查段内地址是否越界&lt;/li>
&lt;li>由段表中的“基址+段内地址”得到最终的物理地址&lt;/li>
&lt;li>访问⽬标单元
分段、分⻚管理的对⽐
分⻚对⽤户不可⻅，分段对⽤户可⻅
分⻚的地址空间是⼀维的，分段的地址空间是⼆维的
分段更容易实现信息的共享和保护(纯代码可重⼊代码可以共享)
分⻚(单级⻚表)、 分段访问⼀个逻辑地址都需要两次访存，分段存储中也可以引⼊快
表机构
11 段⻚式管理⽅式
分⻚、分段管理⽅式中最⼤的优缺点
将地址空间按照程序⾃身的逻辑关系划分为若⼲个段，在将各段分为⼤⼩相等的⻚⾯
将内存空间分为与⻚⾯⼤⼩相等的⼀个个内存块，系统以块为单位为进程分配内存
逻辑地址结构:【段号，⻚号，⻚内偏移量】
分段 + 分⻚的结合——段⻚式管理⽅式
每个段对应⼀个段表项。各段表项⻓度相同，由段号(隐含)、⻚表⻓度、⻚表存放地
址组成
每个⻚对应⼀个⻚表项。各⻚表项⻓度相同，由⻚号(隐含)、⻚⾯存放的内存块号组
成
段表、⻚表&lt;/li>
&lt;li>由逻辑地址得到段号、⻚号、⻚内偏移量&lt;/li>
&lt;li>段号与段表寄存器中的段⻓度⽐较，检查是否越界&lt;/li>
&lt;li>由段表始址、段号找到对应段表项&lt;/li>
&lt;li>根据段表中记录的⻚表⻓度，检查⻚号是否越界&lt;/li>
&lt;li>由段表中的⻚表地址、⻚号得到查询⻚表，找到相应⻚表项&lt;/li>
&lt;li>由⻚⾯存放的内存块号、⻚内偏移量得到最终的物理地址&lt;/li>
&lt;li>访问⽬标单元
如何实现地址变换
第⼀次——查段表、第⼆次——查⻚表、第三次——访问⽬标单元
可引⼊快表机构，以段号和⻚号为关键字查询快表，即可直接找到
最终的⽬标⻚⾯存放位置。引⼊快表后仅需-次访存
12 虚拟内存的基本概念
传统存储管理⽅式的特征、缺点
⼀次性
作业必须⼀次性全部装⼊内存后才能开始运⾏。这会造成两个问题：
①作业很⼤时，不能全部装⼊内存，导致⼤作业⽆法运⾏；
②当⼤量作业要求运⾏时，由于内存⽆法容纳所有作业，因此只有少量作业能运
⾏，导致多道程序并发度下降。
驻留性
⼀旦作业被装⼊内存，就会⼀直驻留在内存中，直⾄作业运⾏结束。事实上，在
⼀个时间段内，只需要访问作业的⼀⼩部分数据即可正常运⾏，这就导致了内存
中会驻留⼤量的、暂时⽤不到的数据，浪费了宝贵的内存资源。
局部性原理
时间局部性
现在访问的指令、数据在不久后很可能会被再次访问
空间局部性
现在访问的内存单元周围的内存空间，很可能在不久后会被访问
⾼速缓存技术
使⽤频繁的数据放到更⾼速的存储器中
虚拟内存的定义和特征
定义
程序不需全部装⼊即可运⾏，运⾏时根据需要动态调⼊数据，若内存不够，还需
换出⼀些数据。
多次性：⽆需在作业运⾏时⼀次性全部装⼊内存，⽽是允许被分成多次调⼊内存。
对换性：在作业运⾏时⽆需⼀直常驻内存，⽽是允许在作业运⾏过程中，将作业换
⼊、换出。
虚拟性：从逻辑上扩充了内存的容量，使⽤户看到的内存容量，远⼤于实际的容量。
如何实现虚拟内存技术
借助离散分配的内存管理⽅式（基本分⻚存储管理、基本分段、基本段⻚式）
访问的信息不在内存时，由操作系统负责将所需信息从外存调⼊内存(请求调⻚功能)
内存空间不够时，将内存中暂时⽤不到的信息换出到外存(⻚⾯置换功能)
虚拟内存的实现
请求分⻚存储管理
请求调⻚
⻚⾯置换
请求分段存储管理
请求调段
段置换
请求段⻚式存储管理
13 请求分⻚管理⽅式
⻚表机制
在基本分⻚的基础上增加了⼏个表项
状态位：表示⻚⾯是否已在内存中
访问字段：记录最近被访问过⼏次，或记录上次访问的时间，供置换算法选择换出⻚
⾯时参考
修改位：表示⻚⾯调⼊内存后是否被修改过，只有修改过的⻚⾯才需在置换时写回外
存
外存地址：⻚⾯在外存中存放的位置
缺⻚中断机构
找到⻚表项后检查⻚⾯是否已在内存，若没在内存,产⽣缺⻚中断
缺⻚中断处理中，需要将⽬标⻚⾯调⼊内存，有必要时还要换出⻚⾯
缺⻚中断属于内中断，属于内中断中的“故障&amp;quot;，即可能被系统修复的异常
⼀条指令在执⾏过程中可能产⽣多次缺⻚中断
地址变换机构
找到⻚表项是需要检查⻚⾯是否在内存中
若⻚⾯不再内存中，需要请求调⻚
若内存空间不够，还需换出⻚⾯
⻚⾯调⼊内存后，需要修改相应⻚表项
14 ⻚⾯置换算法
最佳置换算法(OPT)
最佳置换算法(OPT, Optimal) :每次选择淘汰的⻚⾯将是以后永不使⽤，或者在最⻓时
间内不再被访问的⻚⾯，这样可以保证最低的缺⻚率。
最佳置换算法可以保证最低的缺⻚率，但实际上，只有在进程执⾏的过程中才能知道
接下来会访问到的是哪个⻚⾯。操作系统⽆法提前预判⻚⾯访问序列。因此，最佳置
换算法是⽆法实现的。
先进先出置换算法(FIFO)
先进先出置换算法(FIFO) ：每次选择淘汰的⻚⾯是最早进⼊内存的⻚⾯
实现⽅法:把调⼊内存的⻚⾯根据调⼊的先后顺序排成⼀⼀个队列， 需要换出⻚⾯时
选择队头⻚⾯即可。队列的最⼤⻓度取决于系统为进程分配了多少个内存块。
Belady异常——当为进 程分配的物理块数增⼤时，缺⻚次数不减反增的异常现象。
只有FIFO算法会产⽣Belady异常。另外，FIFO算法 虽然实现简单，但是该算法与进程
实际运⾏时的规律不适应，因为先进⼊的⻚⾯也有可能最经常被访问。因此，算法性
能差
最近最久未使⽤置换算法(LRU)
最近最久未使⽤置换算法(LRU， least recently used)：每次淘汰的⻚⾯是最近最久未
使⽤的⻚⾯
实现⽅法:赋予每个⻚⾯对应的⻚表项中，⽤访问字段记录该⻚⾯⾃上次被访问以来
所经历的时间t。
当需要淘汰：⼀个⻚⾯时，选择现有⻚⾯中t值最⼤的，即最近最久未使⽤的⻚⾯。
时钟置换算法(CLOCK)
时钟置换算法是⼀种性能和开销较均衡的算法，⼜称CLOCK算法，或最近未⽤算法
(NRU，Not Recently Used)
简单的CLOCK算法实现⽅法：为每个⻚⾯设置⼀个访问位，再将内存中的⻚⾯都通过
链接指针链接成⼀个循环队列。
当某⻚被访问时，其访问位置为1。
当需要淘汰⼀个⻚⾯时，只需检查⻚的访问位。
如果是0，就选择该⻚换出；
如果是1，则将它置为0，暂不换出，继续检查下⼀个⻚⾯，若第⼀轮扫描中
所有⻚⾯都是1，则将这些⻚⾯的访问位依次置为0后，再进⾏第⼆轮扫描(第
⼆轮扫描中⼀定会有访问位为0的⻚⾯，因此简单的CLOCK算法选择⼀个淘汰
⻚⾯最多会经过两轮扫描)
改进型的时钟置换算法
简单的时钟置换算法仅考虑到⼀个⻚⾯最近是否被访问过。事实上，如果被淘汰的⻚
⾯没有被修改过，就不需要执⾏I/0操作写回外存。只有被淘汰的⻚⾯被修改过时，才
需要写回外存。
因此，除了考虑⼀个⻚⾯最近有没有被访问过之外，操作系统还应考虑⻚⾯有没有被
修改过。在其他条件都相同时，应优先淘汰没有修改过的⻚⾯，避免I/O操作。这就
是改进型的时钟置换算法的思想。修改位=0，表示⻚⾯没有被修改过;修改位=1， 表
示⻚⾯被修改过。
为⽅便讨论，⽤(访问位，修改位)的形式表示各⻚⾯状态。如(1，1)表示⼀个⻚⾯近
期被访问过,且被修改过。
算法规则
⼏种置换算法的⽐较
15 ⻚⾯分配策略
驻留集
驻留集
指请求分⻚存储管理中给进程分配的物理块的集合。
在采⽤了虚拟存储技术的系统中，驻留集⼤⼩⼀般⼩于进程的总⼤⼩。
若驻留集太⼩，会导致缺⻚频繁，系统要花⼤量的时间来处理缺⻚，实际⽤于进
程推进的时间很少；
驻留集太⼤，⼜会导致多道程序并发度下降，资源利⽤率降低。所以应该选择⼀
个合适的驻留集⼤⼩。
固定分配：操作系统为每个进程分配- -组固定数⽬的物理块，在进程运⾏期间不再改
变。即，驻留集⼤⼩不变
可变分配：先为每个进程分配&amp;ndash;定数⽬的物理块，在进程运⾏期间，可根据情况做适
当的增加或减少。即，驻留集⼤⼩可变
局部置换：发⽣缺⻚时只能选进程⾃⼰的物理块进⾏置换。
全局置换：可以将操作系统保留的空闲物理块分配给缺⻚进程，也可以将别的进程持
有的物理块置换到外存，再分配给缺⻚进程。
⻚⾯分配、置换策略
固定分配局部置换
固定分配局部置换:系统为每个进程分配-⼀ 定数量的物理英,”在整个运⾏期向都不改
变。若进程在运外⾏中发⽣缺⻚，则只能从该进程在内存中的⻚⾯中选出⼀- ⻚换
出，然后再调⼊需要的⻚⾯。这种策略的缺点是:很难在刚开始就确定应为每个进程
分配多少个物理块才算合理。(采⽤这种策略的 系统可以根据进程⼤⼩、优先级、或
是根据程序员给出的参数来确定为- - 个进程分配的内存块数)
可变分配全局置换
刚开始会为每个进程分配⼀定数量的物理块。操作系统会保持- - 个空闲物理块队
列。当某进程发⽣缺⻚时，从空闲物理块中取出⼀块分配给该进程;若已⽆空闲物
理块，则可选择⼀个未锁定的⻚⾯换出外存，再将该物理块分配给缺⻚的进程。
采⽤这种策略时，只要某进程发⽣缺⻚，.都将获得新的物理块，仅当空闲物理块
⽤完时，系统才选择⼀个未锁定的⻚⾯调出。被选择调出的⻚可能是系统中任何
⼀个进程中的⻚，因此这个被选中的进程拥有的物理块会减少，缺⻚率会增加。
可变分配局部置换
刚开始会为每个进程分配⼀定数量的物理块。当某进程发⽣缺⻚时，只允许从该
进程⾃⼰的物理块中选出⼀个进⾏换出外存。如果进程在运⾏中频繁地缺⻚，系
统会为该进程多分配⼏个物理块，直⾄该进程缺⻚率趋势适当程度；反之，如果
进程在运⾏中缺⻚率特别低，则可适当减少分配给该进程的物理块。
区别
可变分配全局置换：只要缺⻚就给分配新物理块
可变分配局部置换：要根据发⽣缺⻚的频率来动态地增加或减少进程的物理块
调⼊⻚⾯的时机
预调⻚策略：⼀般⽤于进程运⾏前
请求调⻚策略：进程运⾏时，发现缺⻚再调⻚
从何处调⻚
对换区——采⽤连续存储⽅式，速度更快；⽂件区——采⽤离散存储⽅式，速度更
慢。
对换区⾜够⼤：运⾏将数据从⽂件区复制到对换区，之后所有的⻚⾯调⼊、调出都是
在内存与对换区之间进⾏
对换区不够⼤：不会修改的数据每次都从⽂件区调⼊；会修改的数据调出到对换区，
需要时再从对换区调⼊
抖动(颠簸)现象
⻚⾯频繁换⼊换出的现象。主要原因是分配给进程的物理块不够
⼯作集
在某段时间间隔⾥，进程实际访问⻚⾯的集合。驻留集⼤⼩⼀般不能⼩于⼯作集⼤
⼩。
第四章 ⽂件管理
01 初识⽂件管理
⽂件定义：⼀组有意义的信息的集合
⽂件的属性
⽂件名：由创建⽂件的⽤户决定⽂件名，主要是为了⽅便⽤户找到⽂件，同⼀⽬录下
不允许有重名⽂件。
标识符：⼀个系统内的各⽂件标识符唯-⼀，对⽤户来说毫⽆可读性,因此标识符只是
操作系统⽤于区分各个⽂件的⼀种内部名称。
类型：指明⽂件的类型.
位置：⽂件存放的路径(让⽤户使⽤)、在外存中的地址(操作系统使⽤，对⽤户不可
⻅)
⼤⼩：指明⽂件⼤⼩
创建时间、上次修改时间、⽂件所有者信息
保护信息：对⽂件进⾏保护的访问控制信息
操作系统向上提供哪些功能
创建⽂件(create系统调⽤)
删除⽂件(delete 系统调⽤)
读⽂件(read系统调⽤)
写⽂件(write系统调⽤)
打开⽂件(open系统调⽤)
关闭⽂件(close 系统调⽤)
⽂件内部应该如何被组织起来(⽂件的逻辑结构)
⽂件之间应该如何被组织起来(⽬录结构)
⽂件应如何存放在外存中(⽂件的物理结构)
操作系统如何管理外存中的空闲块(存储空间的管理)
操作系统需要提供的其他⽂件管理功能
⽂件共享
⽂件保护
02 ⽂件的逻辑结构
⽆结构⽂件
有结构⽂件
顺序⽂件
串结构：记录顺序与关键字⽆关
顺序结构：记录按关键字顺序排列
可变⻓记录的顺序⽂件⽆法实现随机存取，定⻓记录可以
定⻓记录、顺序结构的顺序⽂件可以快速检索(根据关键字快速找到记录)
最⼤缺点：不⽅便增加/删除记录
索引⽂件
建⽴⼀张索引表，每个记录对应-个表项。各记录不⽤保持顺序,⽅便增加删除记
录
索引表本身就是定⻓记录的顺序⽂件，⼀个索引表项就是⼀条定⻓记录， 因此索
引⽂件可⽀持随机存取
若索引表按关键字顺序排列，则可⽀持快速检索
解决了顺序⽂件不⽅便增/删记录的问题，同时让不定⻓记录的⽂件实现了随机存
取。但索引表可能占⽤很多空间
索引顺序⽂件
将记录分组，每组对应-⼀个索引表项
检索记录时先顺序查索引表，找到分组，再顺序查找分组
当记录过多时，可建⽴多级索引表
03 ⽂件⽬录
⽂件控制块(实现⽂件⽬录的关键数据结构)
⼀个⽂件对应⼀个FCB，个FCB就是⼀个⽬录项，多个FCB组成⽂件⽬录
对⽬录的操作:搜索、创建⽂件、删除⽂件、显示⽂件、修改⽂件
⽬录结构
单级⽬录结构
⼀个系统只有⼀张⽬录表，不允许⽂件重名
两级⽬录结构
不同⽤户的⽂件可以重名，但不能对⽂件进⾏分类
多级⽬录结构(树形⽬录结构)
不同⽬录下的⽂件可以重名，可以对⽂件进⾏分类，不⽅便⽂件共享
系统根据“⽂件路径&amp;quot;找到⽬标⽂件
从根⽬录出发的路径是“绝对路径&amp;quot; (&amp;quot;/照⽚/2015-08/⾃ 拍jipg&amp;quot;)
从&amp;quot;当前⽬录”出发的路径是&amp;quot;相对路径”(&amp;quot;/照⽚/201 5-08/⾃拍jpg&amp;quot;)
⽆环图⽬录结构
在树形⽬录结构的基础上，增加⼀些指向同⼀节点的有向边，使整个⽬录成为⼀
个有向⽆环图
为共享结点设置⼀个共享计数器，计数器为0时才真正删除该结点
索引结点(对⽂件控制块的优化)
除了⽂件名之外的所有信息都放到索引结点中，每个⽂件对应⼀个索引结点
⽬录项中只包含⽂件名、索引结点指针，因此每个⽬录项的⻓度⼤幅减⼩
由于⽬录项⻓度减⼩，因此每个磁盘块可以存放更多个⽬录项，因此检索⽂件时磁盘
I/0的次数就少了很多
04 ⽂件的物理结构（⽂件分配⽅式）
对⾮空闲磁盘块的管理（存放了⽂件数据的磁盘块）
连续分配
链接分配
链接分配采取离散分配的⽅式，可以为⽂件分配离散的磁盘块。分为隐式链接和
显式链接两种。
隐式链接
隐式链接——除⽂件的最后⼀个盘块之外，每个盘块中都存有指向下⼀个盘块
的指针。⽂件⽬录包括⽂件第⼀块的指针和最后⼀块的指针。
优点：很⽅便⽂件拓展，不会有碎⽚问题，外存利⽤率⾼。
缺点：只⽀持顺序访问，不⽀持随机访问，查找效率低，指向下⼀个盘块的
指针也需要耗费少量的存储空间。
题⽬中没有要求，默认是隐式链接的链接分配
显式链接
把⽤于链接⽂件各物理块的指针显式地存放在⼀张表中，即⽂件分配表
(FAT， File Allocation Table)。⼀个磁盘只会建⽴⼀张⽂件分配表。开机时⽂
件分配表放⼊内存，并常驻内存。
优点：很⽅便⽂件拓展，不会有碎⽚问题，外存利⽤率⾼，并且⽀持随机访
问。相⽐于隐式链接来说，地址转换时不需要访问磁盘，因此⽂件的访问效
率更⾼。
缺点：⽂件分配表的需要占⽤⼀定的存储空间。
索引分配
①链接⽅案：如果索引表太⼤，⼀个索引块装不下，那么可以将多个索引块链接
起来存放。缺点:若⽂件很⼤，索引表很⻓，就需要将很多个索引块链接起来。想
要找到i号索引块，必须先依次读⼊0~i-1号索引块，这就导致磁盘I/O次数过多，
查找效率低下。
②多层索引：建⽴多层索引(原理类似于多级⻚表)。使第⼀层索引块指向第⼆层
的索引块。还可根据⽂件⼤⼩的要求再建⽴第三层、第四层索引块。采⽤K层索
引结构，且顶级索引表未调⼊内存，则访问⼀个数据块只需要K+ 1次读磁盘操
作。
缺点：即使是⼩⽂件，访问⼀个数据块依然需要K+1次读磁盘。
③混合索引：多种索引分配⽅式的结合。例如，⼀个⽂件的顶级索引表中，既包
含直接地址索引(直接指向数据块)，⼜包含⼀级间接索引(指向单层索引表)、还包
含两级间接索引(指向两层索引表)。
优点：对于⼩⽂件来说，访问⼀个数据块所需的读磁盘次数更少。
超级超级超级重要考点:
①要会根据多层索引、混合索引的结构计算出⽂件的最⼤⻓度(Key：各级索
引表最⼤不能超过⼀个块) ；
②要能⾃⼰分析访问某个数据块所需要的读磁盘次数(Key：FCB中 会存有。
指向顶级索 引块的指针，因此可以根据FCB读⼊顶级索引块。每次读⼊下⼀
级的索引块都需要⼀次读磁盘操作。另外，要注意题⽬条件——顶级索引块是
否已调⼊内存)
各种⽂件分配⽅式的区别
对空闲磁盘块的管理
06 逻辑结构vs物理结构
逻辑结构
⽤户(⽂件创建者)的视⻆看到的亚⼦
在⽤户看来，整个⽂件占⽤连续的逻辑地址空间
⽂件内部的信息组织完全由⽤户⾃⼰决定，操作系统并不关⼼
物理结构
由操作系统决定⽂件采⽤什么物理结构存储
操作系统负责将逻辑地址转变为(逻辑块号， 块内偏移量)的形式，并负责实现逻辑块
号到物理块号的映射
07 ⽂件存储空间管理
存储空间的划分与初始化
⽂件卷(逻辑卷)的概念
为磁盘分区（C/D/E盘），分为逻辑磁盘
⽬录区与⽂件区
⽬录区，主要存放⽂件⽬录信息（FCB）、⽤与磁盘存储空间管理的信息
⽂件区，⽤于存放⽂件数据
多个物理磁盘也可以组成⼀个⽂件卷
初始化
将各个⽂件卷划分为⽬录区、⽂件去
⼏种管理⽅法
注意：
⽤什么⽅式记录、组织空闲块？
如何分配磁盘块
如何回收磁盘块
空闲表法
绿⾊为空闲块、橙⾊为⾮空闲块，适⽤于“连续分配⽅式”
如何分配磁盘块：与内存管理中的动态分区分配很类似，为⼀个⽂件分配连续的
存储空间。同样可采⽤⾸次适应、最佳适应、最坏适应等算法来决定要为⽂件分
配哪个区间。
如何回收磁盘块:与内存管理中的动态分区分配很类似，当回收某个存储区时需要
有四种情况
①回收区的前后都没有相邻空闲区;
②回收区的前后都是空闲区;
③回收区前⾯是空闲区;
④回收区后⾯是空闲区。
总之，回收时需要注意表项的合并问题。
空闲链表法
空闲盘块链
以盘块为单位组成⼀条空闲链
图示
空闲盘区链
以盘区为单位组成⼀条空闲链
图示
如何分配：如何分配:若某⽂件申请K个盘块，则可以采⽤⾸次适应、最佳适
应等算法，从链头开始检索，按照算法规则找到⼀个⼤⼩符合要求的空闲盘
区，分配给⽂件。若没有合适的连续空闲块，也可以将不同盘区的盘块同时
分配给⼀个⽂件，注意分配后可能要修改相应的链指针、盘区⼤⼩等数据。
如何回收：若回收区和某个空闲盘区相邻，则需要将回收区合并到空闲盘区
中。若回收区没有和任何空闲区相邻，将回收区作为单独的⼀个空闲盘区挂
到链尾。
离散分配、连续分配都适⽤。为⼀个⽂件分配多个盘块时效率更⾼。
两种分配⽅式的图示
位示图法
位示图：每个⼆进制位对应⼀⼀个盘块。在本例中，“0” 代表盘块空闲，“1”代表
盘块已分配。位示图⼀般⽤连续的“字”来表示，如本例中⼀个字的字⻓是16位，
字中的每- -位对应⼀⼀个盘块。因此可以⽤(字号，位号)对应⼀个盘块号。当然
有的题⽬中也描述为(⾏号，列号)
计算：
通过（字号，位号）=（i， j）定位得到盘块号b
b号盘块对应的字号i = b/n，位号j = b%n
区分从0开始还是从1开始
如何分配：若⽂件需要K个块，
①顺序扫描位示图，找到K个相邻或不相邻的“0”;
②根据字号、位号算出对应的盘块号，将相应盘块分配给⽂件;
③将相应位设置为“1”
如何回收：
①根据回收的盘块号计算出对应的字号、位号;
②将相应⼆进制位设为“0”
适⽤：连续分配和离散分配都适⽤
成组链接法
Unix系统中采⽤了成组链接法对磁盘空闲块进⾏管理
⽂件卷的⽬录区中专⻔⽤⼀个磁盘块作为“超级块”，当系统启动时需要将超级块
读⼊内存，并且要保证内存与外存的“超级块”数据⼀致
超级块
还有点&amp;hellip;笔者理解起来有点困难，先不写了&amp;hellip;
08 ⽂件的基本操作
向上提供的⼏个最基本的功能
创建⽂件 create系统调⽤
点击“新建”后，图形化交互进程在背后调⽤“create系统调⽤”
提供的参数
所需的外存空间⼤⼩：1KB
⽂件存放路径&amp;quot;D:/Demo&amp;quot;
⽂件名 test.txt
操作系统需要做的：
在外存找到⽂件所需的空间（⽤空闲链表法、位示图、成组链接法等管
理策略，找到空闲空间）
根据⽂件存放路径的信息找到该⽬录对应的⽬录⽂件(此处就是D:/Demo
⽬录)，在⽬录中创建该⽂件对应的⽬录项。⽬录项中包含了⽂件名、⽂
件在外存中的存放位置等信息。
删除⽂件 delete系统调⽤
读⽂件 read系统调⽤
写⽂件 write系统调⽤
打开⽂件open系统调⽤
关闭⽂件 close系统调⽤
0x&amp;hellip;
第五章 输⼊/输出(I/O)管理
后续会更新&amp;hellip;
稍安勿躁。&lt;/li>
&lt;/ol></description></item><item><title/><link>https://ysyyhhh.github.io/docs/knowledge/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/docs/knowledge/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</guid><description>&lt;h1 id="操作系统基础">操作系统基础&lt;/h1>
&lt;h2 id="计算机系统概述">⼀、计算机系统概述&lt;/h2>
&lt;h3 id="11-基本概念">1.1 基本概念&lt;/h3>
&lt;p>OS指控制和管理整个计算机系统的硬件与软件资源，合理组织、调度计算机的⼯作与资源分配，进⽽为⽤户和其他软件提供⽅便接⼝与环境的程序集合；&lt;/p>
&lt;p>基本特征：&lt;/p>
&lt;ul>
&lt;li>并发: 两个或多个事件在同⼀时间间隔内发⽣；&lt;/li>
&lt;li>共享: 系统中的资源可供多个并发进程共同使⽤；&lt;/li>
&lt;li>虚拟: 通过某种技术将⼀个物理实体变为多个逻辑实体；&lt;/li>
&lt;li>异步: 事件以不可知的速度推进；&lt;/li>
&lt;/ul>
&lt;p>功能根据目标的划分:&lt;/p>
&lt;ul>
&lt;li>对硬件资源抽象（OS作为 扩充机器 ）
&lt;ul>
&lt;li>将裸机改造为功能更强、使⽤更⽅便的机器，因此把覆盖了软件的机器叫做 虚拟机 和 扩充机器；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>资源管理
&lt;ul>
&lt;li>处理机管理&lt;/li>
&lt;li>存储器管理&lt;/li>
&lt;li>⽂件管理&lt;/li>
&lt;li>设备管理&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>提供用户与硬件之间的接⼝
&lt;ul>
&lt;li>命令接⼝
&lt;ul>
&lt;li>联机命令接⼝（交互式命令接⼝）&lt;/li>
&lt;li>脱机命令接⼝（批处理命令接⼝）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>程序接⼝
&lt;ul>
&lt;li>由⼀组 作业控制命令 组成；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>功能从应用角度划分:&lt;/p>
&lt;ul>
&lt;li>进程管理&lt;/li>
&lt;li>存储管理(内/外存管理)&lt;/li>
&lt;li>⽂件管理&lt;/li>
&lt;li>设备管理(IO管理)&lt;/li>
&lt;/ul>
&lt;h3 id="12-发展与分类">1.2 发展与分类*&lt;/h3>
&lt;ul>
&lt;li>⼿⼯操作阶段：没有操作系统出现，每个操作都由⼈来控制；&lt;/li>
&lt;li>批处理阶段
&lt;ul>
&lt;li>将多个操作打包成作业使计算机进程批处理；&lt;/li>
&lt;li>单道批处理：操作是成批进⾏的（⼀份作业包含很多操作），内存只有⼀道作业；&lt;/li>
&lt;li>多道批处理：内存包含多道作业（等待事件发⽣时可以⾃动切换作业）；宏观并⾏，微观串⾏（ 并发执行 ）；&lt;/li>
&lt;li>ENIAC、GM-NAA I／O&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>分时操作系统：多⽤户通过终端同时共享⼀台主机（⼀般采⽤分时技术），提⾼ 交
互性 ；
&lt;ul>
&lt;li>Multics、UNIX、Linux&lt;/li>
&lt;li>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e5%9f%ba%e7%a1%80/2024-03-07-10-06-07.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>实时操作系统：提⾼ 及时性 和 可靠性 ；&lt;/li>
&lt;li>⽹络操作系统和分布式计算机系统&lt;/li>
&lt;li>个⼈计算机操作系统
&lt;ul>
&lt;li>macOS、Windows&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="13-硬件结构">1.3 硬件结构*&lt;/h3>
&lt;p>冯诺依曼结构&lt;/p>
&lt;ul>
&lt;li>中央处理器（CPU）：根据程序指令对数据进⾏处理；主要负责运算和逻辑控制；&lt;/li>
&lt;li>存储器：存放程序和数据。&lt;/li>
&lt;li>输入输出设备&lt;/li>
&lt;/ul>
&lt;p>CPU的指令集架构（Instruction Set Architecture，ISA）包含了CPU的指令集、特叹级、寄存器、执行模式｀安全扩展。&lt;/p>
&lt;p>指令集：&lt;/p>
&lt;ul>
&lt;li>精简指令集（RISC）
&lt;ul>
&lt;li>AArch64体系结构（ARMv8）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>复杂指令集（CISC）
&lt;ul>
&lt;li>x86体系结构&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>CPU运⾏状态&lt;/strong>
不同架构下CPU的特权级划分不一致&lt;/p>
&lt;p>如AArch64按如下划分：&lt;/p>
&lt;ul>
&lt;li>EL0: 最低的特权级，应用程序通常运行在该特权级，也称为&lt;strong>用户态&lt;/strong>。&lt;/li>
&lt;li>EL1:操作系统通常运行在该特权级，也称为&lt;strong>内核态&lt;/strong>。&lt;/li>
&lt;li>EL2:在虚拟化场景下需要，虚拟机监控器(VirtualMachine Monitor，VMM，也称为 Hypervisor)通常运行在该特权级。&lt;/li>
&lt;li>EL3:和安全特性 TrustZone相关，负责普通世界(normal world)和安全世界secure world)之间的切换。&lt;/li>
&lt;/ul>
&lt;p>x86按如下划分：&lt;/p>
&lt;ul>
&lt;li>Ring 0: 内核态&lt;/li>
&lt;li>Ring 1-3: 用户态&lt;/li>
&lt;li>Ring 0是最高特权级，Ring 3是最低特权级。&lt;/li>
&lt;/ul>
&lt;p>通常只需要区分内核态和用户态即可&lt;/p>
&lt;ul>
&lt;li>内核态（ 管态 ）
&lt;ul>
&lt;li>可以使⽤ &lt;strong>特权指令&lt;/strong> ；&lt;/li>
&lt;li>OS的 内核程序 运⾏在管态；&lt;/li>
&lt;li>内核态特权指令对应的实体为 内核 ；
&lt;blockquote>
&lt;p>系统调⽤相关位于⾼层，硬件相关位于底层；
内核是计算机上配置的 底层软件 ，是计算机功能的延伸；&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>系统调⽤相关；
&lt;blockquote>
&lt;p>引发⼴义中断⾥⾯的系统异常（⽤户执⾏陷⼊指令⽽触发的操作系统的系统调⽤引起的中断）；&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>进程管理&lt;/li>
&lt;li>存储器管理&lt;/li>
&lt;li>设备管理&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>硬件模块相关；
&lt;ul>
&lt;li>时钟管理&lt;/li>
&lt;li>中断机制
&lt;ul>
&lt;li>只有⼀⼩部分在内核（保护和恢复中断现场的信息，转移控制权到相关的处理程序）；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>原语&lt;/li>
&lt;li>设备驱动&lt;/li>
&lt;li>CPU切换&lt;/li>
&lt;li>进程通信&lt;/li>
&lt;li>…&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>⽤户态（ 目态 ）
&lt;ul>
&lt;li>&lt;strong>不可以使⽤特权指令&lt;/strong>；&lt;/li>
&lt;li>⽤户的⾃编程序（ 应用程序 ）运⾏在⽬态；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>用户态切换到内核态的三种方式&lt;/p>
&lt;ul>
&lt;li>系统调用(Trap)&lt;/li>
&lt;li>中断(Interrupt)&lt;/li>
&lt;li>异常(Exception)&lt;/li>
&lt;/ul>
&lt;p>中断和异常
异常（硬件故障：访管指令）&amp;gt; 中断（外部中断，程序性中断）&amp;gt;系统异常（重启）&lt;/p>
&lt;ul>
&lt;li>异常（不可屏蔽,缺⻚中断为内中断）
&lt;ul>
&lt;li>⾃愿中断（系统异常）
&lt;ul>
&lt;li>时钟中断&lt;/li>
&lt;li>特权指令&lt;/li>
&lt;li>切换核⼼态&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>强迫中断（狭义异常）
&lt;ul>
&lt;li>&lt;strong>CPU内部&lt;/strong> 硬件故障&lt;/li>
&lt;li>软中断&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>中断（分为可屏蔽中断和不可屏蔽中断）
&lt;ul>
&lt;li>硬中断（外设导致的中断）&lt;/li>
&lt;li>与程序运⾏⽆关的中断（⼈的⼲预）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>系统调⽤: ⽤户在程序中调⽤操作系统所提供的⼀些⼦功能；&lt;/p>
&lt;ol>
&lt;li>需先执⾏ &lt;strong>陷入指令Trap&lt;/strong> （⾮特权指令）切换为内核态。此时发生了&lt;/li>
&lt;li>再处理OS的系统调⽤，&lt;/li>
&lt;li>处理完成后,执⾏ 返回指令 （特权指令，⼀般为中断返回指令），切换为⽤户态；&lt;/li>
&lt;/ol>
&lt;h3 id="14-体系结构">1.4 体系结构&lt;/h3>
&lt;p>⼤内核（单内核）：将OS的主要功能模块作为⼀个紧密整体运⾏在核⼼态；&lt;/p>
&lt;p>微内核&lt;/p>
&lt;ul>
&lt;li>保留基本功能，其它服务移动到⽤户态；&lt;/li>
&lt;li>有效分离了内核与服务、服务与服务；&lt;/li>
&lt;/ul>
&lt;h2 id="进程管理">⼆、进程管理&lt;/h2>
&lt;h3 id="21-进程与线程">2.1 进程与线程*&lt;/h3>
&lt;h4 id="211-进程的概念和特征">2.1.1 进程的概念和特征&lt;/h4>
&lt;p>1）概念&lt;/p>
&lt;ul>
&lt;li>进程实体：程序段、数据段、进程控制块 PCB 组成 ；
&lt;ul>
&lt;li>PCB是进程存在的唯⼀标志；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>进程&lt;/strong>是&lt;strong>进程实体&lt;/strong>的运⾏过程，是系统进⾏ &lt;strong>资源分配&lt;/strong> 的独⽴单位；&lt;/li>
&lt;li>进程是 动态 的，进程实体是 静态 的；&lt;/li>
&lt;li>引⼊进程是为了&lt;strong>描述程序的动态执⾏过程&lt;/strong>，更好的⽀持和管理多道程序的并发执⾏（进程的异步性与进程同步机制）；&lt;/li>
&lt;/ul>
&lt;p>PCB包含：&lt;/p>
&lt;ul>
&lt;li>进程描述信息（PID，UID）&lt;/li>
&lt;li>进程控制和管理信息&lt;/li>
&lt;li>资源分配清单&lt;/li>
&lt;li>处理机相关信息&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e5%9f%ba%e7%a1%80/2024-03-07-16-41-37.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;blockquote>
&lt;p>c语⾔程序对内存分为正⽂段（代码和常量）、数据堆段（动态分配到存储区）、数据栈段（临时变量）；&lt;/p>
&lt;/blockquote>
&lt;p>对于有线程系统：&lt;/p>
&lt;ul>
&lt;li>进程是&lt;strong>资源分配&lt;/strong>的独立单位&lt;/li>
&lt;li>线程是&lt;strong>资源调度&lt;/strong>的独立单位
对于无线程系统：&lt;/li>
&lt;li>进程是资源调度、分配的独立单位&lt;/li>
&lt;/ul>
&lt;p>2）特点
动态性：具有⽣命周期，是动态变化的（进程最基本的特征）；
并发性: 多个进程并发执⾏.
独⽴性: 进程是系统资源分配的基本单位，是独⽴的实体；
异步性：进程以不可知速度推进，需要配置相应的 进程同步 机制；
结构性: 每个进程都配置一个PCB进行描述。&lt;/p>
&lt;h4 id="212-进程的状态和转换">2.1.2 进程的状态和转换&lt;/h4>
&lt;p>五种状态&lt;/p>
&lt;ul>
&lt;li>创建态：正在被创建，尚未到就绪状态。&lt;/li>
&lt;li>运⾏态：进程正在处理器上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)。&lt;/li>
&lt;li>就绪态：即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。&lt;/li>
&lt;li>阻塞态（等待态）：正在等待某一事件而暂停运行如&lt;strong>等待某资源为可用或等待 IO 操作&lt;/strong>完成。（即使处理器空闲，该进程也不能运行）&lt;/li>
&lt;li>结束态：进程正常结束或其他原因中断退出运行。&lt;/li>
&lt;/ul>
&lt;p>状态转换&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e5%9f%ba%e7%a1%80/%e8%bd%ac%e6%8d%a2%e5%9b%be.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;ul>
&lt;li>⼀个进程从运⾏态变成阻塞态是 主动 的⾏为&lt;/li>
&lt;li>从阻塞态变成就绪态是 被动 的⾏为，需要其他相关进程的协助。&lt;/li>
&lt;/ul>
&lt;h4 id="213-进程控制-">2.1.3 进程控制-&lt;/h4>
&lt;p>进程控制通过 原语 操作，在核⼼态运⾏；&lt;/p>
&lt;p>进程创建（ 创建原语 ）&lt;/p>
&lt;ol>
&lt;li>申请空⽩的PCB，申请失败（PCB有限）则创建失败；&lt;/li>
&lt;li>为进程分配资源，申请失败进⼊等待态；&lt;/li>
&lt;li>初始化PCB；&lt;/li>
&lt;li>等待被调度；&lt;/li>
&lt;/ol>
&lt;p>进程终⽌（ 撤销原语 ）&lt;/p>
&lt;ul>
&lt;li>由 正常结束 、 异常结束 、 外界干预 三种终⽌事件；&lt;/li>
&lt;li>根据被终⽌进程的 标识符 ，检索PCB，读取进程状态；&lt;/li>
&lt;li>处于执⾏状态则终⽌，归还 处理机资源 给其他进程；&lt;/li>
&lt;li>若该进程有⼦进程，则终⽌⼦进程；&lt;/li>
&lt;li>由进程创建的进程为该⽗进程的⼦进程；&lt;/li>
&lt;li>归还 其它资源 给⽗进程或OS；&lt;/li>
&lt;/ul>
&lt;p>进程阻塞&lt;/p>
&lt;ul>
&lt;li>系统⾃动执⾏ 阻塞原语 （主动）；&lt;/li>
&lt;li>找到被阻塞进程标识号对应的PCB；&lt;/li>
&lt;li>若为运⾏态，则保护现场，将其状态转为等待态；&lt;/li>
&lt;li>将该PCB插⼊ 等待队列 ，将处理机调度给其它就绪进程；&lt;/li>
&lt;/ul>
&lt;p>进程唤醒&lt;/p>
&lt;ul>
&lt;li>由有关进程调⽤ 唤醒原语 （被动）；&lt;/li>
&lt;li>与阻塞原语成对出现；&lt;/li>
&lt;li>在该事件的等待队列找到相应的PCB；&lt;/li>
&lt;li>从等待队列移除，置其状态转为就绪态；&lt;/li>
&lt;li>PCB插⼊ 就绪队列 ，等待调度；&lt;/li>
&lt;/ul>
&lt;p>进程切换&lt;/p>
&lt;blockquote>
&lt;p>进程切换和处理机模式切换不同，模式切换时，处理机逻辑上还在执⾏同⼀进程，所以进程环境不变，只需要 恢复CPU现场 ；但进程切换时，进程改变， 进程环境改变 （处理机上下⽂改变）；
调度和切换：调度决定资源分配的进程，是⼀种决策⾏为；切换是实际分配⾏为，是⼀种执⾏⾏为； 先有调度再有切换 ；&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>保存处理机上下⽂（PC和其它寄存器）；&lt;/li>
&lt;li>更新PCB信息；&lt;/li>
&lt;li>将PCB移⼊相应队列；&lt;/li>
&lt;li>选择另⼀进程执⾏，并更新其PCB；&lt;/li>
&lt;li>更新内存管理的数据结构；&lt;/li>
&lt;li>恢复处理机上下⽂；&lt;/li>
&lt;/ul>
&lt;h4 id="214-进程的组织-">2.1.4 进程的组织-&lt;/h4>
&lt;p>进程控制块&lt;/p>
&lt;blockquote>
&lt;p>通常采⽤ 链接方式 和 索引方式 来组织不同状态的PCB；&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>PCB结构&lt;/li>
&lt;li>程序段
&lt;ul>
&lt;li>程序段就是能被进程调度程序调度到CPU执⾏的程序代码段。注意，程序可被多个进程共享，即,多个进程可以运⾏同⼀个程序；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>数据段
&lt;ul>
&lt;li>⼀个进程的数据段，可以是进程对应的程序加⼯处理的原始数据，也可以是程序执⾏时产⽣的中间或最终结果。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="215-进程的通信">2.1.5 进程的通信&lt;/h4>
&lt;p>进程通信就是进程之间的数据交换。&lt;/p>
&lt;p>PV操作时低级通信方式，高级通信方式是指以较高的效率传输大量数据的通信方式。高级通信方法可分为共享存储、消息传递和管道通信三大类。&lt;/p>
&lt;p>&lt;a href="https://www.jianshu.com/p/c1015f5ffa74" target="_blank" rel="noopener">详细&lt;/a>&lt;/p>
&lt;p>管道（PIPE）&lt;/p>
&lt;ul>
&lt;li>无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统&lt;/li>
&lt;li>有名管道：一种半双工的通信方式，它允许无亲缘关系进程间的通信
&lt;ul>
&lt;li>优点：可以实现任意关系的进程间的通信&lt;/li>
&lt;li>缺点：
&lt;ul>
&lt;li>&lt;strong>名字以文件的形式&lt;/strong>长期存于系统中，使用不当容易出错&lt;/li>
&lt;li>缓冲区有限&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>无名管道：一种半双工的通信方式，只能在具有亲缘关系的进程间使用（父子进程/兄弟进程）
&lt;ul>
&lt;li>优点：简单方便&lt;/li>
&lt;li>缺点：
&lt;ul>
&lt;li>局限于&lt;strong>单向通信&lt;/strong>&lt;/li>
&lt;li>只能创建在它的进程以及其有亲缘关系的进程之间&lt;/li>
&lt;li>缓冲区有限&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>信号量（Semaphore）：一个计数器，可以用来控制多个线程对共享资源的访问，信号量的意图在于进程间同步。&lt;/p>
&lt;ul>
&lt;li>优点：可以同步进程&lt;/li>
&lt;li>缺点：信号量有限&lt;/li>
&lt;/ul>
&lt;p>信号（Signal）：一种比较复杂的通信方式，用于通知接收进程某个事件已经发生. 如SIGKILL：用户终止进程执行信号。shell下执行kill -9发送该信号。&lt;/p>
&lt;p>消息队列（Message Queue）：是消息的链表，存放在内核中并由消息队列标识符标识。&lt;/p>
&lt;ul>
&lt;li>与管道不同
&lt;ul>
&lt;li>消息队列&lt;strong>存放在内核中&lt;/strong>，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。&lt;/li>
&lt;li>消息队列在某个进程往一个队列写入消息之前，并不需要另外某个进程在该队列上等待消息的到达。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>优点：可以实现任意进程间的通信，并通过系统调用函数来实现消息发送和接收之间的同步，无需考虑同步问题，方便&lt;/li>
&lt;li>缺点：信息的复制需要额外消耗 CPU 的时间，不适宜于信息量大或操作频繁的场合&lt;/li>
&lt;/ul>
&lt;p>共享内存（Shared Memory）：映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问&lt;/p>
&lt;ul>
&lt;li>优点：无须复制，快捷，信息量大&lt;/li>
&lt;li>缺点：
&lt;ul>
&lt;li>通信是通过将共享空间缓冲区直接附加到进程的虚拟地址空间中来实现的，因此进程间的读写操作的同步问题&lt;/li>
&lt;li>利用内存缓冲区直接交换信息，内存的实体存在于计算机中，只能同一个计算机系统中的诸多进程共享，不方便网络通信&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>套接字（Socket）：可用于&lt;strong>不同计算机间&lt;/strong>的进程通信&lt;/p>
&lt;ul>
&lt;li>优点：
&lt;ul>
&lt;li>传输数据为字节级，传输数据可自定义，数据量小效率高传输数据时间短，性能高&lt;/li>
&lt;li>适合于客户端和服务器端之间信息实时交互&lt;/li>
&lt;li>可以加密,数据安全性强&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>缺点：需对传输的数据进行解析，转化成应用级的数据。&lt;/li>
&lt;/ul>
&lt;h4 id="216-线程的概念和多线程模型">2.1.6 线程的概念和多线程模型&lt;/h4>
&lt;p>1）线程和进程⽐较&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e5%9f%ba%e7%a1%80/2024-03-07-15-52-01.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>一个进程中可以有多个线程，多个线程共享进程的堆和方法区 (JDK1.8 之后的元空间)资源，但是每个线程有自己的程序计数器、虚拟机栈 和 本地方法栈。&lt;/p>
&lt;p>调度：线程是 处理机独立调度 的基本单位，进程是 资源分配 （除CPU外）的基本单位；&lt;/p>
&lt;p>资源：线程不拥有系统资源（有⼀点），但可以访问所属进程的资源；&lt;/p>
&lt;p>并发：线程也可以并发执⾏；&lt;/p>
&lt;p>通信：线程可以直接读写进程数据段（全局变量）来通信，进程需要使⽤同步互斥⼿段；&lt;/p>
&lt;p>系统开销：线程不拥有资源，因此切换的开销⼩；&lt;/p>
&lt;p>&lt;strong>线程的通信&lt;/strong>
线程间的通信目的&lt;strong>主要是用于线程同步&lt;/strong>，所以线程没有像进程通信中的用于数据交换的通信机制&lt;/p>
&lt;ul>
&lt;li>锁机制：包括互斥锁/量（mutex）、读写锁（reader-writer lock）、自旋锁（spin lock）、条件变量（condition）
&lt;ul>
&lt;li>互斥锁/量（mutex）：提供了以排他方式防止数据结构被并发修改的方法。&lt;/li>
&lt;li>读写锁（reader-writer lock）：允许多个线程同时读共享数据，而对写操作是互斥的。&lt;/li>
&lt;li>自旋锁（spin lock）与互斥锁类似，都是为了保护共享资源。互斥锁是当资源被占用，申请者进入睡眠状态；而自旋锁则循环检测保持者是否已经释放锁。&lt;/li>
&lt;li>条件变量（condition）：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>信号量机制(Semaphore)
&lt;ul>
&lt;li>无名线程信号量&lt;/li>
&lt;li>命名线程信号量&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>信号机制(Signal)：类似进程间的信号处理&lt;/li>
&lt;li>屏障（barrier）：屏障允许每个线程等待，直到所有的合作线程都达到某一点，然后从该点继续执行。&lt;/li>
&lt;/ul>
&lt;p>2）线程的实现
用户级线程和内核级线程&lt;/p>
&lt;p>⽤户级线程 ULT ；&lt;/p>
&lt;ul>
&lt;li>管理由应⽤程序通过 线程库 （最简单可以由的if语句构建）来完成，操作系统意识不到线程，在 用户态 下就可以完成；&lt;/li>
&lt;li>内核调度的还是进程，因此并发度低（⽆法利⽤多核处理机）；&lt;/li>
&lt;li>⼀个线程阻塞，进程就⽆法继续执⾏；&lt;/li>
&lt;/ul>
&lt;p>内核级线程 KLT ；&lt;/p>
&lt;ul>
&lt;li>管理由OS完成，需要切换为 内核态 （切换CPU态需要开销）；&lt;/li>
&lt;li>内核调度的是线程，并发度⾼（可以利⽤多核处理机）；
即使某⼀线程阻塞，其它线程也可以执⾏（内核线程都阻塞时才阻塞）；&lt;/li>
&lt;/ul>
&lt;p>多线程模型 （组合⽅式）；
多对⼀：等价于ULT；
⼀对⼀：等价于KLT；
多对多（ 内核级线程数少于用户级线程 ）：相⽐ULT提⾼了并发度；相⽐KLT节省了管理开销；&lt;/p>
&lt;h3 id="22-处理机调度">2.2 处理机调度*&lt;/h3>
&lt;p>为合理的处理计算机软硬件资源⽽进⾏调度；&lt;/p>
&lt;h4 id="221-三级调度">2.2.1 三级调度&lt;/h4>
&lt;p>⾼级调度（作业调度）&lt;/p>
&lt;ul>
&lt;li>内存与辅存之间的调度。创建态的调度；&lt;/li>
&lt;li>每个作业只调⼊⼀次；
中级调度（内存调度）&lt;/li>
&lt;li>将暂时不能运⾏的进程&lt;strong>调⾄外存&lt;/strong>等待， 挂起态的调度；&lt;/li>
&lt;li>为提⾼内存利⽤率和系统吞吐量；
低级调度（进程调度）&lt;/li>
&lt;li>就绪队列到 运行态的调度；&lt;/li>
&lt;/ul>
&lt;h4 id="222-调度和切换的时机-">2.2.2 调度和切换的时机-&lt;/h4>
&lt;p>进程切换在进程调度之后⽴刻发⽣；&lt;/p>
&lt;p>不调度的情况&lt;/p>
&lt;ul>
&lt;li>处理 中断 的过程中；&lt;/li>
&lt;li>进程在OS内核程序 临界区 中；&lt;/li>
&lt;li>原⼦操作（ 原语 ）过程中；&lt;/li>
&lt;/ul>
&lt;p>调度的情况&lt;/p>
&lt;ul>
&lt;li>非剥夺调度 （⾮抢占⽅式）：调度条件发送后，等进程运⾏结束或⽆法继续运⾏时，才进⾏调度与切换；&lt;/li>
&lt;li>剥夺调度 （抢占⽅式）：调度条件发送后，除遇到不能调度情况需等待结束后再调度外，其它情况⽴刻调度；&lt;/li>
&lt;/ul>
&lt;h4 id="223-调度的评价标准-">2.2.3 调度的评价标准-&lt;/h4>
&lt;ul>
&lt;li>CPU利⽤率&lt;/li>
&lt;li>系统吞吐量：单位时间完成作业的数量；&lt;/li>
&lt;li>周转时间：⽤户提交作业到作业完成经历的时间；包含所有调度的时间；&lt;/li>
&lt;li>响应时间：⽤户提交作业到⾸次响应的时间；包含作业调度和⼀部分中低级调度；&lt;/li>
&lt;li>等待时间：进程等待分配处理机的等待时间和进⼊内存却未被分配处理机的时间；&lt;/li>
&lt;/ul>
&lt;h4 id="224-调度算法">2.2.4 调度算法&lt;/h4>
&lt;p>优先级调度适⽤于 实时系统 ；&lt;/p>
&lt;p>⾼响应⽐调度、时间⽚轮转调度、多级反馈队列调度适⽤于 分时系统 ；&lt;/p>
&lt;p>1）先来先服务 FCFS 调度算法；
适⽤于进程调度和作业调度；&lt;/p>
&lt;p>2）优先级调度算法；
适⽤于进程调度和作业调度；
优先级：&lt;/p>
&lt;ul>
&lt;li>系统进程 &amp;gt; ⽤户进程&lt;/li>
&lt;li>交互型进程 &amp;gt; ⾮交互型进⾏&lt;/li>
&lt;li>I/O型进程 &amp;gt; 计算型进程
分类：&lt;/li>
&lt;li>静态优先级、动态优先级；&lt;/li>
&lt;li>剥夺式优先级、⾮剥夺式优先级；&lt;/li>
&lt;/ul>
&lt;p>3）短作业优先 SJF 调度算法；
适⽤于进程调度和作业调度；
SJF调度 的平均等待时间、平均周转时间最少；&lt;/p>
&lt;p>4）⾼响应比调度算法；
主要⽤于作业调度；
响应⽐⾼的先调度（取决于 已等待时间 与 需要服务时间 ）；
已等待时间越⻓响应⽐越⾼；
需要服务时间越⼩响应⽐越⾼；&lt;/p>
&lt;p>5）时间⽚轮转调度算法；
⽤于进程调度；&lt;/p>
&lt;p>6）多级反馈队列调度算法；
⽤于进程调度；
设置多个不同优先级的队列，优先级越⾼的队列对应的可执⾏时间⽚越⼩；
初始进程放⼊第⼀级队列队尾，按FCFS排队，在第⼀级未执⾏完后放⼊第⼆级；
知道前⼀级队列为空时，才执⾏下⼀级队列；&lt;/p>
&lt;h4 id="225-僵尸进程和孤儿进程">2.2.5 僵尸进程和孤儿进程&lt;/h4>
&lt;p>当一个进程调用 exit()系统调用结束自己的生命时，内核会释放该进程的所有资源，包括打开的文件、占用的内存等，但是该进程对应的 &lt;strong>PCB 依然存在于系统中&lt;/strong>。这些信息只有在父进程调用 wait()或 waitpid()系统调用时才会被释放，&lt;strong>以便让父进程得到子进程的状态信息&lt;/strong>&lt;/p>
&lt;p>僵尸进程：&lt;/p>
&lt;ul>
&lt;li>子进程已经终止，但是其父进程仍在运行，且父进程没有调用 wait()或 waitpid()等系统调用来获取子进程的状态信息，释放子进程占用的资源，导致子进程的 PCB 依然存在于系统中，但无法被进一步使用。&lt;/li>
&lt;li>这种情况下，子进程被称为“僵尸进程”。避免僵尸进程的产生，父进程需要及时调用 wait()或 waitpid()系统调用来回收子进程。&lt;/li>
&lt;/ul>
&lt;p>Linux 下可以使用 Top 命令查找，zombie 值表示僵尸进程的数量，为 0 则代表没有僵尸进程。
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e5%9f%ba%e7%a1%80/2024-03-08-08-43-12.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>定位僵尸进程以及该僵尸进程的父进程:
&lt;code>ps -A -ostat,ppid,pid,cmd |grep -e '^[Zz]'&lt;/code>&lt;/p>
&lt;p>孤儿进程：&lt;/p>
&lt;ul>
&lt;li>一个进程的父进程已经终止或者不存在，但是该进程仍在运行。这种情况下，该进程就是孤儿进程。&lt;/li>
&lt;li>孤儿进程通常是由于父进程意外终止或未及时调用 wait()或 waitpid()等系统调用来回收子进程导致的。&lt;/li>
&lt;li>为了避免孤儿进程占用系统资源，操作系统会&lt;strong>将孤儿进程的父进程设置为 init 进程（进程号为 1）&lt;/strong>，由 init 进程来回收孤儿进程的资源。&lt;/li>
&lt;/ul>
&lt;h3 id="23-进程同步">2.3 进程同步*&lt;/h3>
&lt;p>为了协调进程之间的相互制约关系；&lt;/p>
&lt;h4 id="231-基本概念-">2.3.1 基本概念-&lt;/h4>
&lt;p>临界资源: ⼀次仅允许⼀个进程使⽤；
临界区 （临界段）: 进程中访问临界资源的代码&lt;/p>
&lt;p>同步 （直接制约关系）：为完成某个任务，针对多个进程的⼯作次序⽽产⽣的制约；&lt;/p>
&lt;p>互斥 （间接制约关系）：当⼀个进程访问临界资源时，另⼀个进程必须等待；&lt;/p>
&lt;ul>
&lt;li>空闲让进：临界区空闲，则可以使⼀个进程进⼊；&lt;/li>
&lt;li>忙则等待：已有进程进⼊临界区则等待；&lt;/li>
&lt;li>有限等待：等待时间为有限时间；&lt;/li>
&lt;li>让权等待：等待时让出处理器（防⽌ 忙等待 ）；&lt;/li>
&lt;/ul>
&lt;h4 id="232-互斥实现法-">2.3.2 互斥实现⽅法-&lt;/h4>
&lt;p>1）软件⽅法&lt;/p>
&lt;ul>
&lt;li>单标志法&lt;/li>
&lt;li>双标志法先检查&lt;/li>
&lt;li>双标志法后检查&lt;/li>
&lt;li>Peterson&amp;rsquo;s Algorithm&lt;/li>
&lt;li>创建管程&lt;/li>
&lt;/ul>
&lt;p>2）硬件⽅法&lt;/p>
&lt;ul>
&lt;li>中断屏蔽⽅法&lt;/li>
&lt;li>硬件指令⽅法&lt;/li>
&lt;li>指令由硬件逻辑直接实现；&lt;/li>
&lt;li>指令均为原⼦操作；&lt;/li>
&lt;li>TestAndSet指令&lt;/li>
&lt;li>Swap指令&lt;/li>
&lt;li>PV指令&lt;/li>
&lt;/ul>
&lt;h4 id="233-同步实现法">2.3.3 同步实现⽅法&lt;/h4>
&lt;p>1）信号量&lt;/p>
&lt;ul>
&lt;li>整型信号量
&lt;ul>
&lt;li>P操作不遵从 让权等待 ，进程⼀直占⽤处理器查询是否可以进⼊临界区；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>记录型信号量
&lt;ul>
&lt;li>P操作：信号量减⼀，信号量 小于 0时，⾃动阻塞进程；&lt;/li>
&lt;li>V操作：信号量加⼀，信号量 小于等于 0时，唤醒⼀个等待进程；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>信号量实现互斥
&lt;ul>
&lt;li>信号 初值为1 ，在临界区前加上P操作，后加上V操作；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>信号量实现同步
&lt;ul>
&lt;li>信号量 初值为0 ，在前⼀进程后加上V操作，后⼀进程前加上P操作；&lt;/li>
&lt;li>每有⼀个前后关系设置⼀个信号量；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>2）管程&lt;/p>
&lt;ul>
&lt;li>管程把对共享资源的操作封装起来；&lt;/li>
&lt;li>只能通过管程的操作访问共享资源；&lt;/li>
&lt;li>每次只允许⼀个进程进⼊管程；&lt;/li>
&lt;li>管程的 条件变量 为没有值的信号量，仅实现 等待排队 功能；&lt;/li>
&lt;/ul>
&lt;h4 id="234-经典同步问题">2.3.4 经典同步问题&lt;/h4>
&lt;p>同步问题:&lt;/p>
&lt;ul>
&lt;li>⽣产者-消费者问题&lt;/li>
&lt;li>吸烟者问题：相当于⽣产者⽣成多种产品的⽣产者-消费者问题；&lt;/li>
&lt;/ul>
&lt;p>互斥问题:&lt;/p>
&lt;ul>
&lt;li>读者-写者问题：设置计数器；&lt;/li>
&lt;li>哲学家进餐问题：使⽤信号量数组；&lt;/li>
&lt;/ul>
&lt;h3 id="24-死锁">2.4 死锁*&lt;/h3>
&lt;h4 id="241-死锁的必要条件">2.4.1 死锁的必要条件&lt;/h4>
&lt;p>互斥条件 ：某资源⼀段时间内只允许⼀个进程进⾏访问；
不可剥夺条件 ：进程所获得的资源只能由进程⾃⼰释放；
请求并保持 ：已占有资源，并继续请求其他资源；
循环等待条件 ：存在⼀种进程资源的循环等待链；&lt;/p>
&lt;p>产生原因:&lt;/p>
&lt;ul>
&lt;li>系统资源不⾜；&lt;/li>
&lt;li>资源分配不当；&lt;/li>
&lt;li>进程推进顺序不当；&lt;/li>
&lt;/ul>
&lt;h4 id="242-死锁的处理策略">2.4.2 死锁的处理策略&lt;/h4>
&lt;p>1） 死锁预防 ；&lt;/p>
&lt;p>破坏死锁的必要条件；&lt;/p>
&lt;ul>
&lt;li>破环互斥条件：某些场合（打印机）应保持互斥性；&lt;/li>
&lt;li>破坏⾮剥夺条件：请求新资源得不到满⾜时， 释放已申请 的所有资源重新申请；(仅适用于 主存资源 和 处理器资源 的分配),会导致资源利用率下降&lt;/li>
&lt;li>破环请求并保持条件：使⽤ &lt;strong>静态分配 （运⾏前⼀次申请完毕）&lt;/strong>；&lt;/li>
&lt;li>破坏循环等待条件：采⽤ &lt;strong>顺序资源分配 （按资源编号申请资源）&lt;/strong>；&lt;/li>
&lt;/ul>
&lt;p>2） 死锁避免 ；&lt;/p>
&lt;p>资源动态分配过程中，防⽌系统进⼊不安全状态；&lt;/p>
&lt;p>每次分配都预先验证是否会使系统保持 安全状态 ；
并⾮所有不安全状态都是死锁状态；&lt;/p>
&lt;p>银⾏家算法：&lt;/p>
&lt;ul>
&lt;li>进程后续申请资源数和已占⽤资源数之和 与 最⼤需求量⽐较，超过则拒绝分配；&lt;/li>
&lt;li>系统将现存资源数量 与 进程请求量进⾏⽐较，如果超过则拒绝分配；&lt;/li>
&lt;li>执⾏安全性算法，检测此次分配后是否满⾜安全状态，满⾜则正式分配；&lt;/li>
&lt;/ul>
&lt;p>3） 死锁的检测和解除 ；&lt;/p>
&lt;p>系统采取措施检测死锁并解除；&lt;/p>
&lt;p>死锁检测： 死锁条件 是 &lt;strong>资源分配图 不可完全简化&lt;/strong>；&lt;/p>
&lt;ul>
&lt;li>既 不独立也不阻塞 （有有向边连接且申请资源数⼩于系统资源数）的进程点即可释放所有资源；
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e5%9f%ba%e7%a1%80/2024-03-08-08-50-34.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/li>
&lt;/ul>
&lt;p>死锁解除：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>撤销进程法：撤销进程；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>进程回退法：回退进程；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>立即结束所有进程的执行，重新启动操作系统：这种方法简单，但以前所在的工作全部作废，损失很大。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>撤销涉及死锁的所有进程，解除死锁后继续运行：这种方法能彻底打破死锁的循环等待条件，但将付出很大代价，例如有些进程可能已经计算了很长时间，由于被撤销而使产生的部分结果也被消除了，再重新执行时还要再次进行计算。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>逐个撤销涉及死锁的进程，回收其资源直至死锁解除。抢占资源：从涉及死锁的一个或几个进程中&lt;/p>
&lt;/li>
&lt;li>
&lt;p>抢占资源，把夺得的资源再分配给涉及死锁的进程直至死锁解除。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="25-作业程序进程的关系-">2.5 作业、程序、进程的关系-&lt;/h3>
&lt;p>⼀份作业包含多段程序；&lt;/p>
&lt;p>进程是程序的动态运⾏过程；&lt;/p>
&lt;blockquote>
&lt;p>⼀个程序可以形成⼏个进程，⼀个进程也可以执⾏多个程序（程序有⼤有⼩）；&lt;/p>
&lt;/blockquote>
&lt;p>每个作业动态转换为⼀个进程族；&lt;/p>
&lt;ul>
&lt;li>批处理系统 ，每个作业有⼀个 根进程 ，该进程执⾏作业控制命令解释程序，解释改作业说明书，根进程在运⾏过程中可以动态的创建多个⼦进程；&lt;/li>
&lt;li>分时系统 的作业为⽤户的⼀次 上机交互过程 ，根进程为 终端进程 ，执⾏命令解释程序；&lt;/li>
&lt;li>交互提交批作业 的操作系统中，可以交互式的提交批作业，动态转化为⼀个进程族；&lt;/li>
&lt;/ul>
&lt;h2 id="三内存管理">三、内存管理&lt;/h2>
&lt;h3 id="31-内存管理概念">3.1 内存管理概念&lt;/h3>
&lt;h4 id="311-内存管理功能">3.1.1 内存管理功能*&lt;/h4>
&lt;ul>
&lt;li>内存空间的分配和回收: 对进程所需的内存进行分配和释放，malloc 函数：申请内存，free 函数：释放内存。&lt;/li>
&lt;li>地址转换: 将程序中的虚拟地址转换成内存中的物理地址。&lt;/li>
&lt;li>空间扩充: 当系统没有足够的内存时，利用&lt;strong>虚拟内存技术或自动覆盖技术&lt;/strong>，从逻辑上扩充内存。&lt;/li>
&lt;li>内存保护: 保证进程之间使用内存互不干扰，避免一些恶意程序通过修改内存来破坏系统的安全性。&lt;/li>
&lt;/ul>
&lt;h4 id="312-程序执步骤">3.1.2 程序执⾏步骤&lt;/h4>
&lt;p>1）编译：由编译程序将源代码编译成各**⽬标模块的机器语⾔代码**；
2）链接：由链接程序按 各模块代码 与 库函数 的相对地址链接成从0开始编制的 &lt;strong>统一逻辑地址空间&lt;/strong> ，形成 装入模块 ；&lt;/p>
&lt;ul>
&lt;li>静态链接：装⼊之前就链接；&lt;/li>
&lt;li>装⼊时动态链接：装⼊时链接；&lt;/li>
&lt;li>运⾏时动态链接：程序执⾏时需要⽤到⽬标模块再链接；
3）装⼊：由装⼊程序将装⼊模块 分配地址 装⼊内存；&lt;/li>
&lt;li>绝对装⼊：由 程序员 直接赋予或由 编译程序 给出 绝对/物理地址 ；&lt;/li>
&lt;li>静态重定位： 装入前 为从0开始的 逻辑地址 ，装⼊后重定位为 绝对/物理地址 ；&lt;/li>
&lt;li>动态重定位： 运行时 将逻辑地址转为绝对/物理地址（需 重定位寄存器/基址寄存器 ）；&lt;/li>
&lt;/ul>
&lt;h4 id="313-逻辑地址和物理地址">3.1.3 逻辑地址和物理地址&lt;/h4>
&lt;p>每个⽬标模块都&lt;strong>从0开始编制，为其相对地址（逻辑地址）&lt;/strong>，
链接程序将 各模块和库函数 链接为同⼀的从0编制的逻辑地址空间，对程序员不透明；&lt;/p>
&lt;p>物理地址为内存的实际地址，对程序员时 透明 的；&lt;/p>
&lt;h3 id="32-地址分配和回收">3.2 地址分配和回收*&lt;/h3>
&lt;p>内部内存碎片(Internal Memory Fragmentation，简称为内存碎片)：已经&lt;strong>分配给进程使用但未被使用的内存&lt;/strong>。&lt;/p>
&lt;p>外部内存碎片(External Memory Fragmentation，简称为外部碎片)：由于未分配的连续内存区域太小，以至于&lt;strong>不能满足任意进程所需要的内存分配请求&lt;/strong>，这些小片段且不连续的内存空间被称为外部碎片。&lt;/p>
&lt;h4 id="321-连续分配-管理式">3.2.1 连续分配 管理⽅式&lt;/h4>
&lt;p>1）单⼀连续分配
仅分为低位的 系统区 和⾼位的 用户区 ；
内存只有⼀道程序， 无需系统保护 ；&lt;/p>
&lt;p>2）固定分区分配
每个分区装⼊⼀道作业；&lt;/p>
&lt;ul>
&lt;li>分为 分区⼤⼩相等、分区⼤⼩不等 两种划分⽅式；&lt;/li>
&lt;li>使⽤ 覆盖技术 扩⼤分区可容纳的程序⼤⼩；&lt;/li>
&lt;li>⽆外部碎⽚，易产⽣ 内部碎片 ；&lt;/li>
&lt;/ul>
&lt;p>3）动态分区分配（可变分区分配）&lt;/p>
&lt;ul>
&lt;li>根据装⼊进程的⼤⼩ 动态的 建⽴分区；&lt;/li>
&lt;li>易产⽣ 外部碎片 ，可采⽤ 紧凑技术 解决，需要动态重定位寄存器（ 基址寄存器 ）的⽀持；&lt;/li>
&lt;li>分区 分配策略 ：
&lt;ul>
&lt;li>⾸次适应算法
&lt;ul>
&lt;li>⽐其它三种都好；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>最佳适应算法
&lt;ul>
&lt;li>⽐最⼤适应好；&lt;/li>
&lt;li>最容易产⽣内部碎⽚；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>最坏/⼤适应算法&lt;/li>
&lt;li>临近适应算法（循环⾸次适应算法）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>块式管理 是早期计算机操作系统的一种连续内存管理方式，存在严重的内存碎片问题。&lt;/p>
&lt;p>在 Linux 系统中，连续内存管理采用了 伙伴系统（Buddy System）算法.一种经典的连续内存分配算法，可以有效解决外部内存碎片的问题。伙伴系统的主要思想是将内存按 2 的幂次划分（每一块内存大小都是 2 的幂次比如 2^6=64 KB），并将相邻的内存块组合成一对伙伴（注意：必须是相邻的才是伙伴）。&lt;/p>
&lt;ul>
&lt;li>当进行内存分配时，伙伴系统会尝试找到大小最合适的内存块。如果找到的内存块过大，就将其一分为二，分成两个大小相等的伙伴块。如果还是大的话，就继续切分，直到到达合适的大小为止。&lt;/li>
&lt;li>假设两块相邻的内存块都被释放，系统会将这两个内存块合并，进而形成一个更大的内存块，以便后续的内存分配。这样就可以减少内存碎片的问题，提高内存利用率。&lt;/li>
&lt;/ul>
&lt;p>对于内部内碎片问题, Linux采用SLAB解决.&lt;/p>
&lt;h4 id="322-非连续分配-管理式">3.2.2 非连续分配 管理⽅式&lt;/h4>
&lt;h5 id="1-基本-页式-存储管理">1 基本 页式 存储管理&lt;/h5>
&lt;p>分⻚是 &lt;strong>系统行为&lt;/strong> ，对程序员是 透明的 ；&lt;/p>
&lt;p>A）基本概念&lt;/p>
&lt;p>⻚⾯&lt;/p>
&lt;ul>
&lt;li>将进程的块称为 页/页面 ，内存中块称为 页框/页架 ，两者 一一对应 ；&lt;/li>
&lt;li>⻚⾯⼤⼩是2的整数次幂；&lt;/li>
&lt;li>每个进程有多个逻辑模块，⻚式存储每个⻚表对应进程的⼀个逻辑模块，因此 &lt;strong>页表内所有页为统一的逻辑地址空间&lt;/strong> ；&lt;/li>
&lt;/ul>
&lt;p>⻚表和⻚表项&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e5%9f%ba%e7%a1%80/%e2%bb%9a%e8%a1%a8%e5%9b%be.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;ul>
&lt;li>⻚表记录了对应进程每个⻚⾯在内存中所对应的 物理页号 ；&lt;/li>
&lt;li>⻚表由⻚表项构成；&lt;/li>
&lt;li>⻚表项分为 页号 （ 隐含 ，&lt;strong>因为定⻓且顺序存储&lt;/strong>）和 块号 ；&lt;/li>
&lt;/ul>
&lt;p>⻚式逻辑地址
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e5%9f%ba%e7%a1%80/%e2%bb%9a%e5%bc%8f%e9%80%bb%e8%be%91%e5%9c%b0%e5%9d%80%e5%9b%be.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;ul>
&lt;li>⾼位为 页号 ，低位为 页内偏移量 ；&lt;/li>
&lt;li>⻚内偏移量的位数决定了 页面大小 ；&lt;/li>
&lt;li>⻚式管理中地址空间是 &lt;strong>一维&lt;/strong> 的（只要知道逻辑地址,根据页面大小可以确定页号和偏移量）；&lt;/li>
&lt;/ul>
&lt;p>B）⻚式地址转换&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e5%9f%ba%e7%a1%80/%e2%bb%9a%e5%bc%8f%e8%bd%ac%e6%8d%a2%e6%b5%81%e7%a8%8b%e5%9b%be.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;ul>
&lt;li>根据进程号找到 页表基址寄存器PTR 内的⻚表基址；&lt;/li>
&lt;li>计算 页号和偏移量 ：⽤逻辑地址⼤⼩除以⻚⾯⼤⼩，整数部分为⻚号，余数部分为⻚内偏移量；&lt;/li>
&lt;li>当⻚号⼤于⻚表⻓度（表项个数）时，产⽣ 越界中断 ；&lt;/li>
&lt;li>取出⻚表内对应的物理⻚号，与偏移量组成物理地址；&lt;/li>
&lt;/ul>
&lt;p>C）快表（ &lt;strong>相联存储器TLB&lt;/strong> ）
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e5%9f%ba%e7%a1%80/%e5%bf%ab%e8%a1%a8%e5%9c%b0%e5%9d%80%e8%bd%ac%e6%8d%a2%e6%b5%81%e7%a8%8b%e5%9b%be.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;ul>
&lt;li>将常⽤的⻚表项存储到⾼速存储器；&lt;/li>
&lt;li>CPU给出逻辑地址后同时查找快表和内存⻚表（或先查快表再查⻚表）；&lt;/li>
&lt;li>快表的有效性取决于 &lt;strong>局部性原理&lt;/strong> （空间局部性、时间局部性）
&lt;ul>
&lt;li>空间局部性：活跃部分集中在临近空间；&lt;/li>
&lt;li>时间局部性：某部分在单位时间内多次使⽤；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>D）两级⻚表
地址转换过程和段⻚式存储相似；
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e5%9f%ba%e7%a1%80/%e4%b8%a4%e7%ba%a7%e2%bb%9a%e8%a1%a8%e5%9b%be.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;ul>
&lt;li>
&lt;p>由于进程⻚表过⼤占⽤多个⻚⾯，且不需要所有保存⻚表项的⻚⾯都调⼊内存，因此采⽤⼆级⻚表；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>⼀级⻚表（⻚⽬录表/顶级⻚表）负责 ⼆级⻚表逻辑地址和物理地址的映射关系；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>最底层⻚表负责 进程逻辑地址到物理地址的映射关系；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h5 id="2-基本-段式-存储管理">2 基本 段式 存储管理&lt;/h5>
&lt;p>分段是 &lt;strong>按用户进程&lt;/strong> 的⾃然段划分的逻辑空间；&lt;/p>
&lt;p>A）基本概念&lt;/p>
&lt;p>分段是 按用户进程 的⾃然段划分的逻辑空间；
分段的⻓度 不固定 ；
每个进程对应⼀个段表，每个逻辑模块对应⼀个段表项，因此 &lt;strong>段内逻辑地址连续，段间不连续&lt;/strong>；&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e5%9f%ba%e7%a1%80/%e6%ae%b5%e8%a1%a8.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>段式逻辑地址：段式逻辑地址空间是 二维 的，&lt;strong>因为段⻓不固定&lt;/strong>，因此需要段号和偏移量才能知道物理地址；&lt;/p>
&lt;p>B）段式地址转换
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e5%9f%ba%e7%a1%80/%e6%ae%b5%e5%bc%8f%e5%9c%b0%e5%9d%80%e8%bd%ac%e6%8d%a2%e6%b5%81%e7%a8%8b%e5%9b%be.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;ul>
&lt;li>根据进程号找到 段表基址寄存器 的基址；&lt;/li>
&lt;li>段号⼤于段表⻓则产⽣ 越界中断 ；&lt;/li>
&lt;li>根据段号找到段表项，如果取出的段⻓⼩于段内偏移量产⽣ 越界中断 ；&lt;/li>
&lt;li>最后取出物理段号，和偏移量组合成物理地址；&lt;/li>
&lt;/ul>
&lt;p>C）段的共享和保护&lt;/p>
&lt;ul>
&lt;li>段共享通过将两个作业的段表中相应表项指向同⼀个物理地址来实现；&lt;/li>
&lt;li>段保护为 存取控制保护 和 地址越界保护;
&lt;ul>
&lt;li>存取控制保护设置共享段的存取权限，地址越界保护和⻚保护相似（多了⼀个偏移量越界中断）；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>只有 纯代码/可重入代码 （不能修改的代码，因此 不属于临界资源 ）才可以共享；&lt;/li>
&lt;/ul>
&lt;h5 id="3-基本-段页式-管理式">3 基本 段页式 管理⽅式&lt;/h5>
&lt;p>A）基本概念
段⻚式逻辑地址结构
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e5%9f%ba%e7%a1%80/%e6%ae%b5%e8%a1%a8%e5%92%8c%e2%bb%9a%e8%a1%a8.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>段表和⻚表，⻚表和⻚式存储相同，段表与段式存储相⽐段始址换位 页表基址 ；&lt;/p>
&lt;p>每个进程有**⼀个段表，多个⻚表**；&lt;/p>
&lt;p>B）段⻚式地址转换
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e5%9f%ba%e7%a1%80/%e8%bd%ac%e6%8d%a2%e6%b5%81%e7%a8%8b%e5%9b%be.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
分别检测 段表越界 和 页表越界 （相当于段式存储中断偏移量越界）；&lt;/p>
&lt;h3 id="33-地址转换和内存保护">3.3 地址转换和内存保护&lt;/h3>
&lt;h4 id="331-地址转换-装入-">3.3.1 地址转换（ 装入 ）&lt;/h4>
&lt;p>连续分配管理&lt;/p>
&lt;ul>
&lt;li>单⼀连续分配：绝对装⼊、静态重定位、动态重定位；&lt;/li>
&lt;li>固定分区分配：绝对装⼊、静态重定位、动态重定位；&lt;/li>
&lt;li>可变分区分配：绝对装⼊、静态重定位、动态重定位；&lt;/li>
&lt;/ul>
&lt;p>⾮连续分配管理：动态重定位；&lt;/p>
&lt;h4 id="332-地址保护">3.3.2 地址保护&lt;/h4>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="img/%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e5%9f%ba%e7%a1%80/2024-03-08-09-36-18.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="34-内存空间扩充">3.4 内存空间扩充*&lt;/h3>
&lt;h4 id="341-覆盖-和-交换">3.4.1 覆盖 和 交换&lt;/h4>
&lt;p>覆盖⽤于同⼀进程，⽽交换⽤于多个不同进程；&lt;/p>
&lt;p>1）覆盖&lt;/p>
&lt;ul>
&lt;li>不需要装⼊进程的全部信息；⽤于单⼀分配和固定分区；&lt;/li>
&lt;li>把⽤户空间分为⼀个&lt;strong>固定区和若⼲覆盖区&lt;/strong>；&lt;/li>
&lt;li>固定区存放进程中活跃的部分；&lt;/li>
&lt;li>覆盖区存放即将要访问的段(将不活跃的部分划分为永&lt;strong>远不会同时运⾏的段&lt;/strong>)；&lt;/li>
&lt;/ul>
&lt;p>2）交换&lt;/p>
&lt;ul>
&lt;li>就是 进程挂起 ；&lt;/li>
&lt;li>进程完全空闲时，将进程交换到辅存内独⽴于⽂件系统的 对换区 （采⽤连续分配⽅式因此读写速度更快）；&lt;/li>
&lt;/ul>
&lt;h4 id="342-虚拟内存-技术以-请求页式存储管理-为例">3.4.2 虚拟内存 技术（以 请求页式存储管理 为例）&lt;/h4>
&lt;p>虚拟内存(Virtual Memory) 是计算机系统内存管理非常重要的一个技术，本质上来说它&lt;strong>只是逻辑存在的，是一个假想出来的内存空间，主要作用是作为进程访问主存（物理内存）的桥梁并简化内存管理&lt;/strong>。&lt;/p>
&lt;p>虚拟内存的作用:&lt;/p>
&lt;ul>
&lt;li>隔离进程：物理内存通过虚拟地址空间访问，虚拟地址空间与进程一一对应。进程之间彼此隔离，一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。&lt;/li>
&lt;li>提升物理内存利用率：有了虚拟地址空间后，操作系统只需要将进程当前正在使用的部分数据或指令加载入物理内存。&lt;/li>
&lt;li>简化内存管理：进程都有一个一致且私有的虚拟地址空间，程序员不用和真正的物理内存打交道，而是借助虚拟地址空间访问物理内存，从而简化了内存管理。&lt;/li>
&lt;li>多个进程共享物理内存：进程在运行过程中，会加载许多操作系统的动态库。这些库对于每个进程而言都是公用的，它们在内存中实际只会加载一份，这部分称为共享内存。&lt;/li>
&lt;li>提高内存使用安全性：控制进程对物理内存的访问，隔离不同进程的访问权限，提高系统的安全性。&lt;/li>
&lt;li>提供更大的可使用内存空间：可以让程序拥有超过系统物理内存大小的可用内存空间。这是因为当物理内存不够用时，可以利用磁盘充当，将物理内存页（通常大小为 4 KB）保存到磁盘文件（会影响读写速度），数据或代码页会根据需要在物理内存与磁盘之间移动。&lt;/li>
&lt;/ul>
&lt;p>没有虚拟内存有什么问题？&lt;/p>
&lt;ul>
&lt;li>系统不安全: 用户程序可以访问任意物理内存，可能会不小心操作到系统运行必需的内存，进而造成操作系统崩溃，严重影响系统的安全。&lt;/li>
&lt;li>进程不稳定: 同时运行多个程序容易崩溃。比如你想同时运行一个微信和一个 QQ 音乐，微信在运行的时候给内存地址 1xxx 赋值后，QQ 音乐也同样给内存地址 1xxx 赋值，那么 QQ 音乐对内存的赋值就会覆盖微信之前所赋的值，这就可能会造成微信这个程序会崩溃。&lt;/li>
&lt;li>浪费内存: 程序运行过程中使用的所有数据或指令都要载入物理内存，根据局部性原理，其中很大一部分可能都不会用到，白白占用了宝贵的物理内存资源。&lt;/li>
&lt;/ul>
&lt;p>1）请求⻚式存储管理
2）请求段式存储管理
3）请求段⻚式存储管理&lt;/p>
&lt;p>A）⻚表项&lt;/p>
&lt;ul>
&lt;li>状态位/有效位：是否调⼊内存；&lt;/li>
&lt;li>访问字段/置换位：⼀段时间内被访问次数，配合⻚⾯置换算法使&lt;/li>
&lt;li>修改位/脏位：是否被修改&lt;/li>
&lt;li>外存地址：该⻚在外存的地址；&lt;/li>
&lt;/ul>
&lt;p>B）缺⻚中断&lt;/p>
&lt;ul>
&lt;li>缺⻚中断为 内中断 ；&lt;/li>
&lt;/ul>
&lt;p>C）⻚⾯置换策略/算法&lt;/p>
&lt;ul>
&lt;li>最佳置换 OPT 算法
&lt;ul>
&lt;li>无法实现, 用于评价其他算法&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>先进先出 FIFO 置换算法
&lt;ul>
&lt;li>会产⽣belady异常, 分配的页面数增多，但缺页率反而提高&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>最近不经常使⽤ LRU 算法&lt;/li>
&lt;li>时钟置换 CLOCK 算法（最近未使⽤ NRU 算法）
&lt;ul>
&lt;li>因LRU实现困难，开销⼤⽽设计；增加访问位和修改位；&lt;/li>
&lt;li>最近未被访问，也未被修改(u=0, m= 0)；&lt;/li>
&lt;li>最近未被访问，但被修改(u=0,m=1)；&lt;/li>
&lt;li>最近被访问，但未被修改(u= 1,m=0)；&lt;/li>
&lt;li>最近被访问，被修改(u=1,m= 1)；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>D）⻚⾯分配
反复的调⼊调出叫 抖动/颠簸 ；
驻留集: 是内存为进程分配的空间⼤⼩；
工作集: 为某段时间间隔内（⼯作集窗⼝），进程访问的⻚⾯集合（ 驻留集需要大于工作集 ）；&lt;/p>
&lt;p>分配策略/算法&lt;/p>
&lt;ul>
&lt;li>固定分配
&lt;ul>
&lt;li>驻留集⼤⼩不变；&lt;/li>
&lt;li>固定分配局部置换：驻留集⼤⼩不变，且只在分配的驻留集内进程⻚⾯置换；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>可变分配
&lt;ul>
&lt;li>驻留集⼤⼩可变；&lt;/li>
&lt;li>可变分配全局置换：驻留集⼤⼩可变，且将欲调⼊的⻚置换到OS的空闲块队列；&lt;/li>
&lt;li>可变分配局部置换：驻留集⼤⼩可变，将欲调⼊的⻚置换到驻留集，根据缺⻚率动态调整驻留集⼤⼩；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>⻚⾯调⼊时机&lt;/p>
&lt;ul>
&lt;li>预调页 策略/算法：运⾏前预测需要调⼊的⻚⾯，⼀次调⼊内存；&lt;/li>
&lt;li>请求调页 策略/算法：运⾏时根据请求来逐⻚的调⼊内存；
调⼊调出的位置&lt;/li>
&lt;li>当系统拥有⾜够对换区空间时，调⼊调出都使⽤对换区；&lt;/li>
&lt;li>当系统没有⾜够对换区空间时，从⽂件区调⼊，从对换区调出修改过的内容（未修改的不⽤调出，直接下次再从⽂件区调⼊）；&lt;/li>
&lt;li>UNIX方式 ：从⽂件区调⼊，从对换区调出（只要是从内存调出都放⼊对换区）；&lt;/li>
&lt;/ul>
&lt;h2 id="四件管理">四、⽂件管理&lt;/h2>
&lt;h3 id="41-件系统基础">4.1 ⽂件系统基础*&lt;/h3>
&lt;p>Windows：FCB 表 + FAT + 位图
Unix：inode + 混合索引 + 成组链接&lt;/p>
&lt;p>文件系统主要负责管理和组织计算机存储设备上的文件和目录，其功能包括以下几个方面：&lt;/p>
&lt;ul>
&lt;li>存储管理：将文件数据存储到物理存储介质中，并且管理空间分配，以确保每个文件都有足够的空间存储，并避免文件之间发生冲突。&lt;/li>
&lt;li>文件管理：文件的创建、删除、移动、重命名、压缩、加密、共享等等。&lt;/li>
&lt;li>目录管理：目录的创建、删除、移动、重命名等等。&lt;/li>
&lt;li>文件访问控制：管理不同用户或进程对文件的访问权限，以确保用户只能访问其被授权访问的文件，以保证文件的安全性和保密性&lt;/li>
&lt;/ul>
&lt;h4 id="411-录结构">4.1.1 ⽬录结构&lt;/h4>
&lt;p>1）⽂件控制块和索引结点&lt;/p>
&lt;p>A）⽂件控制块 FCB&lt;/p>
&lt;ul>
&lt;li>为实现 按名存取 ⽽设计，FCB的有序集合位⽬录，⼀个FCB为⼀个⽂件⽬录项；&lt;/li>
&lt;li>基本信息 （⽂件名、物理位置、逻辑结构、物理结构等）、 存取控制信息（存取权限等）、 使用信息 （建⽴时间、修改时间等）；&lt;/li>
&lt;/ul>
&lt;p>B） 索引结点&lt;/p>
&lt;ul>
&lt;li>将FCB的⽂件名和⽂件描述信息分离（使得磁盘块可以存储更多的FCB）；&lt;/li>
&lt;li>索引结点为 文件描述信息 ，FCB只包含⽂件名和索引结点指针；&lt;/li>
&lt;/ul>
&lt;p>2）⽬录结构&lt;/p>
&lt;ul>
&lt;li>单级⽬录结构：整个系统就⼀个⽬录；&lt;/li>
&lt;li>两级⽬录结构：每个⽤户有⼀个⽬录；&lt;/li>
&lt;li>多级⽬录结构（树形⽬录结构）：有多级⽬录，出现 绝对路径 和 相对路径 ；&lt;/li>
&lt;li>⽆环图⽬录结构：多个⽗结点指向同⼀个结点（实现 文件共享 ）；
&lt;ul>
&lt;li>某个⽗结点删除共享结点后不⼀定删除，需要所有指向共享结点的结点都断开才删除；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="412-件共享与保护">4.1.2 ⽂件共享与保护*&lt;/h4>
&lt;p>1）⽂件共享&lt;/p>
&lt;ul>
&lt;li>基于索引结点共享（ 硬链接 ）：直接使**⽬录项指向该⽂件的索引结点**；
&lt;ul>
&lt;li>只有删除了源文件和所有对应的硬链接文件，该文件才会被真正删除&lt;/li>
&lt;li>&lt;code>ln&lt;/code> 命令用于创建硬链接。&lt;/li>
&lt;li>限制
&lt;ul>
&lt;li>不能对目录以及不存在的文件创建硬链接&lt;/li>
&lt;li>硬链接不能跨越文件系统。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>基于符号链共享（ 软链接 ）：建⽴ &lt;strong>LINK文件&lt;/strong> 保存共享⽂件的绝对路径；
&lt;ul>
&lt;li>使⽤时根据绝对路径⼀级⼀级查找；&lt;/li>
&lt;li>&lt;code>ln -s&lt;/code> 命令用于创建软链接&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>2）⽂件保护&lt;/p>
&lt;p>A）访问控制：每个⽂件增加⼀个 访问控制列表ACL ，规定不同⽤户/⽤户组的访问权限；&lt;/p>
&lt;p>B）其它
⼝令：输⼊FCB上的⼝令来访问⽂件；
密码：保存的⽂件是加密过的不能正常读写，需要输⼊密码修改为正常⽂件&lt;/p>
&lt;h4 id="413-件的逻辑结构">4.1.3 ⽂件的逻辑结构&lt;/h4>
&lt;p>1）⽆结构⽂件（流式⽂件）
2）有结构⽂件（记录式⽂件）&lt;/p>
&lt;ul>
&lt;li>为实现 顺序查找 、 索引查找 、 索引顺序查找 、 哈希查找 ⽽设计；&lt;/li>
&lt;/ul>
&lt;p>A）顺序⽂件: 顺序存储&lt;/p>
&lt;ul>
&lt;li>定⻓顺序存储：可实现 随机存取 ；
&lt;ul>
&lt;li>定⻓串结构
&lt;ul>
&lt;li>记录⻓度相等，记录之间顺序与关键字⽆关（由时间决定）；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>定⻓顺序结构：可实现 随机存取 与 快速检索 ；
&lt;ul>
&lt;li>记录⻓度相等，记录之间按关键字排列；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>变⻓顺序存储
&lt;ul>
&lt;li>变⻓串结构&lt;/li>
&lt;li>变⻓顺序结构&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>B）索引⽂件：建⽴的索引表可以实现 随机存取 ；&lt;/p>
&lt;p>C）索引顺序⽂件：顺序⽂件分组，建⽴索引表，索引表每个表项指向其中⼀组；&lt;/p>
&lt;p>D）直接⽂件（散列⽂件）：根据散列函数存取；&lt;/p>
&lt;h3 id="42-件系统实现">4.2 ⽂件系统实现&lt;/h3>
&lt;p>⽂件区和⽬录区是分开的；&lt;/p>
&lt;h4 id="421-录实现">4.2.1 ⽬录实现&lt;/h4>
&lt;p>线性表: 顺序和链式均可；
哈希表&lt;/p>
&lt;h4 id="422-件的物理结构">4.2.2 ⽂件的物理结构&lt;/h4>
&lt;p>1）⽂件分配⽅式（⾮空闲磁盘块的管理）&lt;/p>
&lt;ul>
&lt;li>A）连续分配&lt;/li>
&lt;li>B）链接分配
&lt;ul>
&lt;li>显式链接：建⽴⽂件分配表 FAT ，使每个物理块号有指定的下⼀块指针；⽂件分配表FAT可以 随机访问 ；&lt;/li>
&lt;li>隐式链接：直接在块上⾯存放指针；
C）索引分配：每个⽂件建⽴ 索引表 ，使得⽂件的每个逻辑块号都有对应的物理块号；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>和⻚表相似；&lt;/li>
&lt;li>链接⽅案：为解决索引表⼤于磁盘块的问题，使⽤指针将多个索引块链接；&lt;/li>
&lt;li>多层索引：类⽐内存管理的多级⻚表；&lt;/li>
&lt;li>混合索引：建⽴包含直接地址、间接索引表地址的 &lt;strong>顶级索引表&lt;/strong> ；&lt;/li>
&lt;/ul>
&lt;p>2）⽂件存储空间管理（空闲磁盘块的管理）&lt;/p>
&lt;p>A）空闲表法&lt;/p>
&lt;p>B）空闲链表法&lt;/p>
&lt;ul>
&lt;li>空闲 盘块 链&lt;/li>
&lt;li>空闲 盘区 链：有下⼀盘区的指针与本盘区的⼤⼩；
C）位示图法
D）成组链表 法&lt;/li>
&lt;li>适⽤于⼤型⽂件系统；&lt;/li>
&lt;li>把空闲块依次填⼊其余空闲块的地址，从第⼀个块开始读取地址分配空间；&lt;/li>
&lt;li>第⼀个填⼊地址的空闲块叫做 超级块 ，需要预先读⼊主存；&lt;/li>
&lt;/ul>
&lt;h4 id="423-件系统的层次结构">4.2.3 ⽂件系统的层次结构&lt;/h4>
&lt;p>1）⽤户调⽤接⼝
2）⽂件⽬录系统: 管理⽂件⽬录；
3）存取控制验证模块: 通过⽂件⽬录的FCB实现 文件保护 ；
4）逻辑⽂件系统与⽂件信息缓冲区: 根据⽂件的逻辑结构将⽤户的要读写的逻辑记录转换成⽂件逻辑结构内的相应块号；
5）物理⽂件系统: 将逻辑记录所在的相应块号转换为实际的物理地址；
6）辅助分配模块: 管理辅存空间；
7）设备管理程序模块: 硬件相关 ；&lt;/p>
&lt;h4 id="424-提高文件系统性能的方式有哪些">4.2.4 提高文件系统性能的方式有哪些？*&lt;/h4>
&lt;ul>
&lt;li>优化硬件：使用高速硬件设备（如 SSD、NVMe）替代传统的机械硬盘，使用 RAID（Redundant Array of Inexpensive Disks）等技术提高磁盘性能。&lt;/li>
&lt;li>选择合适的文件系统选型：不同的文件系统具有不同的特性，对于不同的应用场景选择合适的文件系统可以提高系统性能。&lt;/li>
&lt;li>运用缓存：访问磁盘的效率比较低，可以运用缓存来减少磁盘的访问次数。不过，需要注意缓存命中率，缓存命中率过低的话，效果太差。&lt;/li>
&lt;li>避免磁盘过度使用：注意磁盘的使用率，避免将磁盘用满，尽量留一些剩余空间，以免对文件系统的性能产生负面影响。&lt;/li>
&lt;li>对磁盘进行合理的分区：合理的磁盘分区方案，能够使文件系统在不同的区域存储文件，从而减少文件碎片，提高文件读写性能。&lt;/li>
&lt;/ul>
&lt;h3 id="43-磁盘组织与管理">4.3 磁盘组织与管理&lt;/h3>
&lt;h4 id="431-磁盘的结构">4.3.1 磁盘的结构&lt;/h4>
&lt;p>组成:&lt;/p>
&lt;ul>
&lt;li>柱⾯&lt;/li>
&lt;li>磁头&lt;/li>
&lt;li>扇区&lt;/li>
&lt;/ul>
&lt;p>分类&lt;/p>
&lt;ul>
&lt;li>活动头磁盘、固定头磁盘&lt;/li>
&lt;li>固定盘磁盘、可换盘磁盘&lt;/li>
&lt;/ul>
&lt;h4 id="432-磁盘调度算法">4.3.2 磁盘调度算法*&lt;/h4>
&lt;p>标准：寻找时间（找磁道时间）、延迟时间（找扇区时间）、传输时间；&lt;/p>
&lt;ul>
&lt;li>先来先服务 FCFS 算法
&lt;ul>
&lt;li>按照请求到达磁盘调度器的顺序进行处理，先到达的请求的先被服务。FCFS 算法实现起来比较简单，不存在算法开销。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>最短寻找时间 SSTF 算法
&lt;ul>
&lt;li>也被称为最佳服务优先（Shortest Service Time First，SSTF）算法，优先选择距离当前磁头位置最近的请求进行服务。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>扫描 SCAN 算法：双向扫描；
&lt;ul>
&lt;li>可默认为LOOK算法，双向扫描到此⽅向最后⼀个柱⾯就转向；⼜称电梯调度算法；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>循环扫描 C-CSAN 算法：单向扫描；
&lt;ul>
&lt;li>可默认为C-LOOK算法，单向扫描到最后⼀个柱⾯就返回；&lt;/li>
&lt;li>只在磁盘的一侧进行扫描，并且只按照一个方向扫描，直到到达磁盘边界，然后回到磁盘起点，重新开始循环。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="433-磁盘的管理">4.3.3 磁盘的管理&lt;/h4>
&lt;p>1）磁盘初始化&lt;/p>
&lt;p>低级格式化 （物理分区）&lt;/p>
&lt;ul>
&lt;li>每个扇区分为头、尾和数据部分（头尾包含磁盘控制所⽤的信息）
逻辑格式化 （创建⽂件系统）&lt;/li>
&lt;/ul>
&lt;p>2）引导块&lt;/p>
&lt;p>磁盘上的引导块装⼊ 自举程序 （计算机启动时运⾏的初始化程序），在ROM硬件上只保留很⼩的 自居装入程序 （为了⽅便更改）；&lt;/p>
&lt;p>3）坏块&lt;/p>
&lt;p>简单磁盘会将坏扇区在FAT表中表明；&lt;/p>
&lt;p>复杂磁盘会使⽤控制器维护⼀个磁盘坏块链表，使⽤低级格式化时保留的备⽤块进⾏替换，这种⽅式对OS 透明 ；（ 扇区备用 ）&lt;/p>
&lt;h2 id="五输输出管理">五、输⼊/输出管理&lt;/h2>
&lt;h3 id="51-io管理概述">5.1 I/O管理概述&lt;/h3>
&lt;h4 id="511-io控制式">5.1.1 I/O控制⽅式&lt;/h4>
&lt;p>程序查询⽅式&lt;/p>
&lt;ul>
&lt;li>全程需要CPU参与；&lt;/li>
&lt;li>按字读写；&lt;/li>
&lt;/ul>
&lt;p>中断⽅式&lt;/p>
&lt;ul>
&lt;li>设备运⾏完成，准备就绪后发⽣中断使CPU参与；&lt;/li>
&lt;li>按字读写；&lt;/li>
&lt;/ul>
&lt;p>DMA⽅式&lt;/p>
&lt;ul>
&lt;li>DMA控制器为⼀种 块设备 的I/O控制器，且每个DMA仅对应⼀台设备；块设备可寻址；&lt;/li>
&lt;li>DMA控制器：命令/状态寄存器CR、数据寄存器DR、主存地址寄存器MAR、数据计数器DC；&lt;/li>
&lt;li>数据交换过程不需要经过CPU寄存器，CPU需最后读取DMA状态（还包括DMA启动时的预处理）；&lt;/li>
&lt;li>DMA⽅式下每条I/O指令，只能读写连续的数据块；&lt;/li>
&lt;li>按块读写；&lt;/li>
&lt;/ul>
&lt;p>通道控制⽅式&lt;/p>
&lt;ul>
&lt;li>CPU发送的I/O指令负责启动通道程序，最后CPU读取状态；&lt;/li>
&lt;li>通道执⾏内存中的通道程序（不必只操作连续数据块）；对⼀组块进程操作；&lt;/li>
&lt;/ul>
&lt;h4 id="512-io系统的层次结构">5.1.2 I/O⼦系统的层次结构&lt;/h4>
&lt;p>1）⽤户层I/O软件：实现与⽤户交互的接⼝；&lt;/p>
&lt;p>2）设备独⽴性软件&lt;/p>
&lt;p>A）执⾏所有设备的公有操作；&lt;/p>
&lt;ul>
&lt;li>I/O调度&lt;/li>
&lt;li>缓冲管理&lt;/li>
&lt;li>设备分配与回收&lt;/li>
&lt;li>设备保护&lt;/li>
&lt;li>SPOOLing技术
B）⾯向⽤户层提供接⼝；&lt;/li>
&lt;/ul>
&lt;p>3）设备驱动程序：与硬件相关；
4）中断处理程序：与硬件相关；
5）硬件设备&lt;/p>
&lt;h3 id="52-io核系统">5.2 I/O核⼼⼦系统&lt;/h3>
&lt;h4 id="521-io调度如磁盘调度">5.2.1 I/O调度：如磁盘调度；&lt;/h4>
&lt;h4 id="522-缓冲区">5.2.2 缓冲区&lt;/h4>
&lt;blockquote>
&lt;p>磁盘高速缓存 的缓冲区⼀般为内存，逻辑上属于磁盘，实际为内存；&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>单缓冲：
&lt;ul>
&lt;li>两次相同状态间的时间为：【CPU处理时间】与【I/O输⼊到缓存区的时间】取最⼤值，加上【缓存区传输到CPU的时间】；&lt;/li>
&lt;li>因为单缓冲区时，CPU和I/O设备都不能和缓存区冲突，因此最后【缓存区传输到CPU的时间】与其它相加；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>双缓冲：
&lt;ul>
&lt;li>【CPU处理时间】加上【缓存区传输到CPU的时间】，与【I/O输⼊到缓存区的时间】取最⼤值；&lt;/li>
&lt;li>因为双缓存时，缓存交替使⽤，所以I/O设备的传输可以和其它操作并⾏，所以【I/O输⼊到缓存区的时间】与其它操作时间取最⼤值；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>循环缓存&lt;/li>
&lt;li>缓冲池&lt;/li>
&lt;/ul>
&lt;h4 id="523-设备分配与回收">5.2.3 设备分配与回收&lt;/h4>
&lt;p>1）设备类型
独占式设备
分时共享设备
共享设备（SPOOLing技术）&lt;/p>
&lt;p>2）设备分配的数据结构&lt;/p>
&lt;p>从物理设备名依次按照SDT → DCT → COCT → CHCT的顺序查找并分配设备，所有部件都分配成功则设备分配完成；
⽤逻辑设备名查找时第⼀次使⽤SDT查找，并在LUT建⽴表项，以后基础使⽤LUT进程查找；&lt;/p>
&lt;p>通道控制表 CHCT ：描述通道状态，有 指向控制器 的指针；
控制器控制表 COCT ：描述控制器状态，有 指向通道 的指针；
设备控制表 DCT ：描述设备状态，有 指向控制器 的指针；
系统设备表 SDT ：⼀个系统只有⼀个，每个表项都有⼀个 DCT ；
逻辑设备表 LUT ：负责保存逻辑设备名（设备类型）到物理设备名的映射关系；
将常⽤设备名映射关系从⼤表SDT转移到⼩表LUT；&lt;/p>
&lt;p>3）分配策略
分配⽅式&lt;/p>
&lt;ul>
&lt;li>静态分配：⼀次性分配所有要求的设备；&lt;/li>
&lt;li>动态分配&lt;/li>
&lt;/ul>
&lt;p>分配算法：FCFS、优先级等
类似进程调度算法；&lt;/p>
&lt;p>4）分配安全性（设备保护？）&lt;/p>
&lt;ul>
&lt;li>安全分配⽅式：发出I/O请求后就阻塞进程，直到I/O操作完成；&lt;/li>
&lt;li>不安全分配⽅式：发出I/O请求后也不阻塞，可以继续申请；&lt;/li>
&lt;/ul>
&lt;h4 id="524-spooling技术-假脱机技术">5.2.4 SPOOLing技术 （假脱机技术）&lt;/h4>
&lt;p>1）组成&lt;/p>
&lt;ul>
&lt;li>输⼊井和输出井&lt;/li>
&lt;li>输⼊缓冲区和输⼊缓冲区&lt;/li>
&lt;li>输⼊进程和输出进程&lt;/li>
&lt;/ul>
&lt;p>2）特点（空间换时间）&lt;/p>
&lt;ul>
&lt;li>提⾼I/O速度；&lt;/li>
&lt;li>将独占设备改为共享设备；&lt;/li>
&lt;li>实现了虚拟设备功能；&lt;/li>
&lt;/ul></description></item></channel></rss>