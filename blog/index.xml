<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Blog | Ysyy's</title><link>https://ysyyhhh.github.io/blog/</link><atom:link href="https://ysyyhhh.github.io/blog/index.xml" rel="self" type="application/rss+xml"/><description>Blog</description><generator>Hugo Blox Builder (https://hugoblox.com)</generator><language>en-us</language><lastBuildDate>Fri, 01 Mar 2024 00:00:00 +0000</lastBuildDate><image><url>https://ysyyhhh.github.io/media/logo.svg</url><title>Blog</title><link>https://ysyyhhh.github.io/blog/</link></image><item><title>Abstraction vs implementation</title><link>https://ysyyhhh.github.io/blog/abstraction-vs-implementation/</link><pubDate>Fri, 01 Mar 2024 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/blog/abstraction-vs-implementation/</guid><description>&lt;h2 id="ispc-language">ISPC language&lt;/h2>
&lt;p>SPMD: Single Program Multiple Data
一种花哨的方式来说，就是一种并行编程的范式，它的特点是：在编程时，我们只需要写一个程序，然后在运行时，这个程序会被复制多份，每一份都会被分配到不同的处理器上去执行，这样就实现了并行。&lt;/p>
&lt;p>用ISPC实现sinx&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="n">export&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">sinx&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">uniform&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">uniform&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">terms&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">uniform&lt;/span> &lt;span class="kt">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">uniform&lt;/span> &lt;span class="kt">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//assume N % programCount == 0
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">uniform&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">programCount&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">idx&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">programIndex&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">float&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">idx&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">float&lt;/span> &lt;span class="n">number&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">uniform&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">denom&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">6&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">uniform&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">sign&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">uniform&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">terms&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">j&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">value&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">sign&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">number&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="n">denom&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">number&lt;/span> &lt;span class="o">*=&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">denom&lt;/span> &lt;span class="o">*=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">sign&lt;/span> &lt;span class="o">*=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">result&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">idx&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用C++来调用
调用ISPC的东西是个程序实例的集合, gang.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c++" data-lang="c++">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;#34;sinx.ispc.h&amp;#34;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="n">N&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1000000&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="n">terms&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="kt">float&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">N&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="kt">float&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">N&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//init x
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//execute
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">ispc&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">sinx&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">N&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">terms&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">result&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/abstraction-vs-implementation/img/2023-10-07-21-12-02_huf0efc3661c3a8dbb19222d4c78427dcd_64558_6645a5b3ae3ddd05822a97581964c7a1.webp 400w,
/blog/abstraction-vs-implementation/img/2023-10-07-21-12-02_huf0efc3661c3a8dbb19222d4c78427dcd_64558_a5fc4d7e11a6077f1c92e8e21cf17691.webp 760w,
/blog/abstraction-vs-implementation/img/2023-10-07-21-12-02_huf0efc3661c3a8dbb19222d4c78427dcd_64558_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/abstraction-vs-implementation/img/2023-10-07-21-12-02_huf0efc3661c3a8dbb19222d4c78427dcd_64558_6645a5b3ae3ddd05822a97581964c7a1.webp"
width="377"
height="390"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>ispc中不需要手动设置programCount,programIndex&lt;/p>
&lt;p>programCount: &lt;strong>number of simultaneous program&lt;/strong> instances in the gang (uniform value)&lt;/p>
&lt;p>programIndex: &lt;strong>id of the current program&lt;/strong> instance in the gang(a non-uniform value)&lt;/p>
&lt;p>uniform value: 一个值在gang中的所有实例中都是一样的&lt;/p>
&lt;p>如果在ispc中直接使用sinx 并不会更快.&lt;/p>
&lt;p>因为有一些相同的工作会被重复做很多次.
通过分离他们,可以减少重复计算的次数,从而提高效率.&lt;/p>
&lt;p>一个设想的实现方法如下:
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/abstraction-vs-implementation/img/2023-10-07-21-20-55_hu8ffcb6cb31f8f6bbebe6700f4e47b705_244038_6c839c2c7db48b5c09baf72171af45ca.webp 400w,
/blog/abstraction-vs-implementation/img/2023-10-07-21-20-55_hu8ffcb6cb31f8f6bbebe6700f4e47b705_244038_c5c93d956e779e277324ce9a6f829f09.webp 760w,
/blog/abstraction-vs-implementation/img/2023-10-07-21-20-55_hu8ffcb6cb31f8f6bbebe6700f4e47b705_244038_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/abstraction-vs-implementation/img/2023-10-07-21-20-55_hu8ffcb6cb31f8f6bbebe6700f4e47b705_244038_6c839c2c7db48b5c09baf72171af45ca.webp"
width="728"
height="526"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>ISPC是为了更容易编写SIMD代码而设计的, 只需要通过特殊的宏或编译指示就可以使用SIMD指令.&lt;/p>
&lt;p>programCount 就是 向量宽度&lt;/p>
&lt;p>SPMD programming &lt;strong>abstraction&lt;/strong>&lt;/p>
&lt;p>ISPC compiler generates SIMD &lt;strong>implementation&lt;/strong>&lt;/p>
&lt;p>version2版本的代码,这是分块进行而不是交错的.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="n">export&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">sinx&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">uniform&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">uniform&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">terms&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">uniform&lt;/span> &lt;span class="kt">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">uniform&lt;/span> &lt;span class="kt">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">uniform&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">count&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">N&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="n">programCount&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">start&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">programIndex&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">count&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//assume N % programCount == 0
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">uniform&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">count&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">idx&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">start&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">float&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">idx&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">float&lt;/span> &lt;span class="n">number&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">uniform&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">denom&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">6&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">uniform&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">sign&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">uniform&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">terms&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">j&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">value&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">sign&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">number&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="n">denom&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">number&lt;/span> &lt;span class="o">*=&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">denom&lt;/span> &lt;span class="o">*=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">sign&lt;/span> &lt;span class="o">*=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">result&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">idx&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/abstraction-vs-implementation/img/2023-10-07-21-26-19_hu7938bd2c1271d40663fbfcd32562e0ce_196751_489fcd0f2eb24701e06c213cf432a3a7.webp 400w,
/blog/abstraction-vs-implementation/img/2023-10-07-21-26-19_hu7938bd2c1271d40663fbfcd32562e0ce_196751_58e4e2bf0e53ad2ba318e1a2ae95c491.webp 760w,
/blog/abstraction-vs-implementation/img/2023-10-07-21-26-19_hu7938bd2c1271d40663fbfcd32562e0ce_196751_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/abstraction-vs-implementation/img/2023-10-07-21-26-19_hu7938bd2c1271d40663fbfcd32562e0ce_196751_489fcd0f2eb24701e06c213cf432a3a7.webp"
width="723"
height="530"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>交错通常比分块更好,因为分块会导致数据的访问不连续. 当计算量不均匀时,分块会导致一些处理器的负载过重,而另一些处理器的负载过轻.&lt;/p>
&lt;p>并且因为是同时进行的, 交错可以访问邻近的数据,这样可以增加cache的命中率.&lt;/p>
&lt;p>根本原因:
矢量加载指令(寄存器)是一次加载多个数据,如果在很短的时间内,要加载的数据是连续的,那么就可以一次加载多个数据,如果数据是不连续的,那么就需要多次加载,这样就会降低效率.
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/abstraction-vs-implementation/img/2023-10-07-21-30-56_hu772df7a64f68035bf40a24f2e3f74143_347068_3384da9ebeed146a97cfc55595a67d0b.webp 400w,
/blog/abstraction-vs-implementation/img/2023-10-07-21-30-56_hu772df7a64f68035bf40a24f2e3f74143_347068_1575106681211a7a5c741cec621dd52d.webp 760w,
/blog/abstraction-vs-implementation/img/2023-10-07-21-30-56_hu772df7a64f68035bf40a24f2e3f74143_347068_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/abstraction-vs-implementation/img/2023-10-07-21-30-56_hu772df7a64f68035bf40a24f2e3f74143_347068_3384da9ebeed146a97cfc55595a67d0b.webp"
width="760"
height="562"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>如果有个聪明的编译器,它可以自动将分块的代码转换为交错的代码,这样就可以兼顾两者的优点.&lt;/p>
&lt;p>foreach就可以实现这个功能,让程序员不需要关心这些细节.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="n">export&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">sinx&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">uniform&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">uniform&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">terms&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">uniform&lt;/span> &lt;span class="kt">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">uniform&lt;/span> &lt;span class="kt">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">foreach&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="p">...&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">float&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">float&lt;/span> &lt;span class="n">number&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">uniform&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">denom&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">6&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">uniform&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">sign&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">uniform&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">terms&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">j&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">value&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">sign&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">number&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="n">denom&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">number&lt;/span> &lt;span class="o">*=&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">denom&lt;/span> &lt;span class="o">*=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">sign&lt;/span> &lt;span class="o">*=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">result&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ISPC的错误例子:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="n">export&lt;/span> &lt;span class="n">uniform&lt;/span> &lt;span class="kt">float&lt;/span> &lt;span class="nf">sumall&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">uniform&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">uniform&lt;/span> &lt;span class="kt">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">uniform&lt;/span> &lt;span class="kt">float&lt;/span> &lt;span class="n">sum&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">foreach&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="p">...&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">sum&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">sum&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>错误:编译器会报错,因为sum是一个uniform value,它在所有的实例中都是一样的,但是在foreach中,每个实例都会对sum进行修改,这样就会导致错误.&lt;/p>
&lt;p>修正这个错误:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="n">export&lt;/span> &lt;span class="n">uniform&lt;/span> &lt;span class="kt">float&lt;/span> &lt;span class="nf">sumall&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">uniform&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">uniform&lt;/span> &lt;span class="kt">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">uniform&lt;/span> &lt;span class="kt">float&lt;/span> &lt;span class="n">sum&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">float&lt;/span> &lt;span class="n">partial_sum&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">foreach&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="p">...&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">partial_sum&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">sum&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nf">reduce_add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">partial_sum&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">sum&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>reduce_add原语: 允许将一组不同的值合并为一个值,这个值在所有的实例中都是一样的.&lt;/p>
&lt;p>编译后的细节
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/abstraction-vs-implementation/img/2023-10-07-21-41-11_hu30d7f4b1ac4472348ddd5783aa0a2e21_362539_c0b3c7b02a87cd0eafa04c9f4beee5c6.webp 400w,
/blog/abstraction-vs-implementation/img/2023-10-07-21-41-11_hu30d7f4b1ac4472348ddd5783aa0a2e21_362539_55edfb833370beeedb04607514558ee7.webp 760w,
/blog/abstraction-vs-implementation/img/2023-10-07-21-41-11_hu30d7f4b1ac4472348ddd5783aa0a2e21_362539_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/abstraction-vs-implementation/img/2023-10-07-21-41-11_hu30d7f4b1ac4472348ddd5783aa0a2e21_362539_c0b3c7b02a87cd0eafa04c9f4beee5c6.webp"
width="741"
height="536"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>ISPC tasks: 基本上就是一个线程,但是它可以被分配到不同的处理器上去执行.&lt;/p>
&lt;h2 id="三种并行编程范式-和-三种-machine-architecture">三种并行编程范式 和 三种 machine architecture&lt;/h2>
&lt;p>聚焦于 communication 和 cooperation&lt;/p>
&lt;p>使用pthread时要call operate system
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/abstraction-vs-implementation/img/2023-10-07-21-46-12_hu424ec0e5f725e78cd54c25ee6a2805b4_197701_83380472fb20f875d83bf8891c0f6c14.webp 400w,
/blog/abstraction-vs-implementation/img/2023-10-07-21-46-12_hu424ec0e5f725e78cd54c25ee6a2805b4_197701_ed04f98ce04c7e8e1fd1bf25ece5ef46.webp 760w,
/blog/abstraction-vs-implementation/img/2023-10-07-21-46-12_hu424ec0e5f725e78cd54c25ee6a2805b4_197701_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/abstraction-vs-implementation/img/2023-10-07-21-46-12_hu424ec0e5f725e78cd54c25ee6a2805b4_197701_83380472fb20f875d83bf8891c0f6c14.webp"
width="737"
height="539"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>而在ISPC中,只需要call compiler&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/abstraction-vs-implementation/img/2023-10-07-21-46-25_hu743500d3f46eda111182bb13825ddd61_215881_52792a10df8d3bb4c80ec3a9d0e8c19a.webp 400w,
/blog/abstraction-vs-implementation/img/2023-10-07-21-46-25_hu743500d3f46eda111182bb13825ddd61_215881_030e1987c8ce29fd60d9d581425c576f.webp 760w,
/blog/abstraction-vs-implementation/img/2023-10-07-21-46-25_hu743500d3f46eda111182bb13825ddd61_215881_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/abstraction-vs-implementation/img/2023-10-07-21-46-25_hu743500d3f46eda111182bb13825ddd61_215881_52792a10df8d3bb4c80ec3a9d0e8c19a.webp"
width="727"
height="516"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="three-models-of-communicationabstraction">Three models of communication(abstraction)&lt;/h3>
&lt;h4 id="1shared-address-space">1.Shared address space&lt;/h4>
&lt;p>asst3中会用到&lt;/p>
&lt;p>多个线程之间通过互斥锁来进行通信&lt;/p>
&lt;p>在硬件中, Dance-hall model
所有处理器在同一侧.&lt;/p>
&lt;p>Symmetric Multiprocessor(SMP) system 就是如此&lt;/p>
&lt;p>最简单的方式是总线, 但这样无法扩展,因为总线的带宽是有限的.
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/abstraction-vs-implementation/img/2023-10-07-21-53-08_hub47389cf4f6ee62c3a24da3ed64647bd_284773_83f92147b67d52d347c9e764be414a7b.webp 400w,
/blog/abstraction-vs-implementation/img/2023-10-07-21-53-08_hub47389cf4f6ee62c3a24da3ed64647bd_284773_cc407f2eb03a52fbae43d3cfe589a807.webp 760w,
/blog/abstraction-vs-implementation/img/2023-10-07-21-53-08_hub47389cf4f6ee62c3a24da3ed64647bd_284773_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/abstraction-vs-implementation/img/2023-10-07-21-53-08_hub47389cf4f6ee62c3a24da3ed64647bd_284773_83f92147b67d52d347c9e764be414a7b.webp"
width="719"
height="515"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
但实际中:
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/abstraction-vs-implementation/img/2023-10-07-21-55-16_huf5246cd0b880f843a34d54e8a9ceaf60_364206_72f74a1364f215b213f08c01860aa3b0.webp 400w,
/blog/abstraction-vs-implementation/img/2023-10-07-21-55-16_huf5246cd0b880f843a34d54e8a9ceaf60_364206_edb55a08e1aefae545f268c2c8d26a2d.webp 760w,
/blog/abstraction-vs-implementation/img/2023-10-07-21-55-16_huf5246cd0b880f843a34d54e8a9ceaf60_364206_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/abstraction-vs-implementation/img/2023-10-07-21-55-16_huf5246cd0b880f843a34d54e8a9ceaf60_364206_72f74a1364f215b213f08c01860aa3b0.webp"
width="700"
height="525"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/abstraction-vs-implementation/img/2023-10-07-21-55-34_hua87b13fdf1ea4f4894dd6309e2108996_336002_c2b29e4255b71be3da91f5e5bf6035ad.webp 400w,
/blog/abstraction-vs-implementation/img/2023-10-07-21-55-34_hua87b13fdf1ea4f4894dd6309e2108996_336002_62a5aae783f2810b1b06c98e682c54c6.webp 760w,
/blog/abstraction-vs-implementation/img/2023-10-07-21-55-34_hua87b13fdf1ea4f4894dd6309e2108996_336002_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/abstraction-vs-implementation/img/2023-10-07-21-55-34_hua87b13fdf1ea4f4894dd6309e2108996_336002_c2b29e4255b71be3da91f5e5bf6035ad.webp"
width="713"
height="527"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>还有一种访问本地内存的方式,就是通过cache,这样就可以减少对总线的访问,从而提高效率.
Non-Uniform Memory Access(NUMA) system
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/abstraction-vs-implementation/img/2023-10-14-14-14-34_hud613f70bd8ccce87e35300c481917997_435369_f41680dad25a8c31bbd97860f05c5172.webp 400w,
/blog/abstraction-vs-implementation/img/2023-10-14-14-14-34_hud613f70bd8ccce87e35300c481917997_435369_fb2fbd3e109a81339371b7401c85f29f.webp 760w,
/blog/abstraction-vs-implementation/img/2023-10-14-14-14-34_hud613f70bd8ccce87e35300c481917997_435369_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/abstraction-vs-implementation/img/2023-10-14-14-14-34_hud613f70bd8ccce87e35300c481917997_435369_f41680dad25a8c31bbd97860f05c5172.webp"
width="760"
height="410"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>但它为程序员引入的复杂性是很大的,因为程序员需要手动的将数据放到本地内存中,这样才能提高效率.&lt;/p>
&lt;p>shared address space的优点:&lt;/p>
&lt;ol>
&lt;li>程序员不需要关心数据的传输&lt;/li>
&lt;li>程序员不需要关心数据的分布&lt;/li>
&lt;/ol>
&lt;h4 id="2message-passing">2.Message passing&lt;/h4>
&lt;p>aasst4中会用到&lt;/p>
&lt;p>由于实现缓存一致性需要额外的成本，因此在大型系统中，共享内存的实现是不可行的。在这种情况下，消息传递是一种更好的选择。&lt;/p>
&lt;p>在消息传递中，每个处理器都有自己的私有内存，而且没有共享内存。要在处理器之间传递数据，必须使用显式的消息传递原语。&lt;/p>
&lt;p>不需要任何硬件支持，因此可以在任何系统上实现。只需要网络。&lt;/p>
&lt;p>可以构建大型系统，因为没有共享内存的限制。&lt;/p>
&lt;p>这些原语允许程序员在处理器之间传递数据，但是程序员必须显式地指定数据的传输。这种方式的缺点是，程序员需要关心数据的传输，这样就会增加程序员的负担。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/abstraction-vs-implementation/img/2023-10-14-14-18-37_hu42065f6b748829e4ad2ed8749e657be7_703756_ddc00b5301d4dc84d1e271fe7930a3e9.webp 400w,
/blog/abstraction-vs-implementation/img/2023-10-14-14-18-37_hu42065f6b748829e4ad2ed8749e657be7_703756_d491feaa04b414c21f714294089e1a0f.webp 760w,
/blog/abstraction-vs-implementation/img/2023-10-14-14-18-37_hu42065f6b748829e4ad2ed8749e657be7_703756_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/abstraction-vs-implementation/img/2023-10-14-14-18-37_hu42065f6b748829e4ad2ed8749e657be7_703756_ddc00b5301d4dc84d1e271fe7930a3e9.webp"
width="760"
height="513"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h4 id="3data-parallel">3.Data parallel&lt;/h4>
&lt;p>asst2中会用到&lt;/p>
&lt;p>上面两种方式可以在任何硬件上实现。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/abstraction-vs-implementation/img/2023-10-14-14-22-41_hu29009ffeff66b4988989ee35eddf94af_620179_c09df96c7d1eb7e807d4e08bd88b7d7a.webp 400w,
/blog/abstraction-vs-implementation/img/2023-10-14-14-22-41_hu29009ffeff66b4988989ee35eddf94af_620179_45b583dd334a3ef06cb1eba15c98eb10.webp 760w,
/blog/abstraction-vs-implementation/img/2023-10-14-14-22-41_hu29009ffeff66b4988989ee35eddf94af_620179_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/abstraction-vs-implementation/img/2023-10-14-14-22-41_hu29009ffeff66b4988989ee35eddf94af_620179_c09df96c7d1eb7e807d4e08bd88b7d7a.webp"
width="760"
height="440"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>Data parallel对程序员来说是最简单的，因为程序员不需要关心数据的传输，也不需要关心数据的分布。但是，它只能在特定的硬件上实现，因为它需要硬件支持。&lt;/p>
&lt;p>过去我们使用SIMD，现在使用SPMD。&lt;/p>
&lt;p>并行程序的问题&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/abstraction-vs-implementation/img/2023-10-14-14-28-16_hu69dfe58954025daef8c252774f7a0fae_426166_3f56fdd1ed92ca29942ada1ecd451f8a.webp 400w,
/blog/abstraction-vs-implementation/img/2023-10-14-14-28-16_hu69dfe58954025daef8c252774f7a0fae_426166_35f3911aeb8171c6b3bb3b1641022573.webp 760w,
/blog/abstraction-vs-implementation/img/2023-10-14-14-28-16_hu69dfe58954025daef8c252774f7a0fae_426166_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/abstraction-vs-implementation/img/2023-10-14-14-28-16_hu69dfe58954025daef8c252774f7a0fae_426166_3f56fdd1ed92ca29942ada1ecd451f8a.webp"
width="760"
height="562"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>这样的并行会得到不确定的结果。&lt;/p>
&lt;p>那么如何有原则性地使用并行呢？&lt;/p>
&lt;p>有一个抽象概念是stream，可以避免并行竞争问题。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/abstraction-vs-implementation/img/2023-10-14-14-30-44_hu3d9b4b708f4c384b1f7b7d012771095e_675645_3c7739822199ef3aa5013f2a499cb65b.webp 400w,
/blog/abstraction-vs-implementation/img/2023-10-14-14-30-44_hu3d9b4b708f4c384b1f7b7d012771095e_675645_2e3d9be1885abeb0b8a5ba073e2faa56.webp 760w,
/blog/abstraction-vs-implementation/img/2023-10-14-14-30-44_hu3d9b4b708f4c384b1f7b7d012771095e_675645_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/abstraction-vs-implementation/img/2023-10-14-14-30-44_hu3d9b4b708f4c384b1f7b7d012771095e_675645_3c7739822199ef3aa5013f2a499cb65b.webp"
width="760"
height="519"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>两个函数间的用法：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/abstraction-vs-implementation/img/2023-10-14-14-31-24_hu7ad04064968c85894cc57d0d9c48a049_715623_64ef6cbf5a00d5a6bf1599d935d086d9.webp 400w,
/blog/abstraction-vs-implementation/img/2023-10-14-14-31-24_hu7ad04064968c85894cc57d0d9c48a049_715623_48da98c2f403b1682277c9fc2c8145bc.webp 760w,
/blog/abstraction-vs-implementation/img/2023-10-14-14-31-24_hu7ad04064968c85894cc57d0d9c48a049_715623_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/abstraction-vs-implementation/img/2023-10-14-14-31-24_hu7ad04064968c85894cc57d0d9c48a049_715623_64ef6cbf5a00d5a6bf1599d935d086d9.webp"
width="760"
height="559"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>当如果使用stream，就必须创建tmp。不得不把临时数据写入浪费的带宽中。&lt;/p>
&lt;p>所以我们希望也许有一些新的运算符可以做更加高级的操作。&lt;/p>
&lt;p>gather: 将数据从不同的stream中收集到一个stream中。
scatter: 将数据从一个stream中分散到不同的stream中。&lt;/p>
&lt;p>intel包括了gather，但不包括scatter。
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/abstraction-vs-implementation/img/2023-10-14-14-39-33_huac084b4facbe1a325680980b61a6f2eb_748223_5e0630b9c73daaa7936463d125ffd07c.webp 400w,
/blog/abstraction-vs-implementation/img/2023-10-14-14-39-33_huac084b4facbe1a325680980b61a6f2eb_748223_88196d1ffbb5e688aa133fefcc71da82.webp 760w,
/blog/abstraction-vs-implementation/img/2023-10-14-14-39-33_huac084b4facbe1a325680980b61a6f2eb_748223_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/abstraction-vs-implementation/img/2023-10-14-14-39-33_huac084b4facbe1a325680980b61a6f2eb_748223_5e0630b9c73daaa7936463d125ffd07c.webp"
width="760"
height="568"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/abstraction-vs-implementation/img/2023-10-14-14-42-00_hu1e128ac41b625201ee01db386b0f9bf6_668641_08b839ae4cc614773c96da758214b653.webp 400w,
/blog/abstraction-vs-implementation/img/2023-10-14-14-42-00_hu1e128ac41b625201ee01db386b0f9bf6_668641_fd727307d9b3eec91fb5789f8d13a106.webp 760w,
/blog/abstraction-vs-implementation/img/2023-10-14-14-42-00_hu1e128ac41b625201ee01db386b0f9bf6_668641_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/abstraction-vs-implementation/img/2023-10-14-14-42-00_hu1e128ac41b625201ee01db386b0f9bf6_668641_08b839ae4cc614773c96da758214b653.webp"
width="760"
height="557"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h4 id="总结">总结&lt;/h4>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/abstraction-vs-implementation/img/2023-10-14-14-44-11_hu191eb3d20f4c2a32765dba803ce24f69_671529_e7cdb83e3678f5e26c23091fd4def508.webp 400w,
/blog/abstraction-vs-implementation/img/2023-10-14-14-44-11_hu191eb3d20f4c2a32765dba803ce24f69_671529_7c9a647964f71be563c9183aefe4e725.webp 760w,
/blog/abstraction-vs-implementation/img/2023-10-14-14-44-11_hu191eb3d20f4c2a32765dba803ce24f69_671529_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/abstraction-vs-implementation/img/2023-10-14-14-44-11_hu191eb3d20f4c2a32765dba803ce24f69_671529_e7cdb83e3678f5e26c23091fd4def508.webp"
width="760"
height="512"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>这些并不是完全独立的，而是可以组合使用的。&lt;/p>
&lt;p>通常在实践中为了得到最好的性能，会使用以上所有的方式。&lt;/p>
&lt;p>多核芯片内部通常是shared address space，但小规模情况下使用message passing。&lt;/p></description></item><item><title>asst1</title><link>https://ysyyhhh.github.io/blog/asst1/</link><pubDate>Fri, 01 Mar 2024 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/blog/asst1/</guid><description>&lt;p>&lt;a href="https://www.cnblogs.com/kalicener/p/16824312.html" target="_blank" rel="noopener">参考&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://github.com/stanford-cs149/asst1" target="_blank" rel="noopener">任务&lt;/a>&lt;/p>
&lt;h2 id="program-1-parallel-fractal-generation-using-threads-20-pointshttpsgithubcomstanford-cs149asst1program-1-parallel-fractal-generation-using-threads-20-points">&lt;a href="https://github.com/stanford-cs149/asst1#program-1-parallel-fractal-generation-using-threads-20-points" target="_blank" rel="noopener">Program 1: Parallel Fractal Generation Using Threads (20 points)&lt;/a>&lt;/h2>
&lt;p>提示:
需要先看CMU15-418/CS149的L2再完成Pro1&lt;/p>
&lt;p>任务描述:
用多线程画mandelbrot fractal.&lt;/p>
&lt;p>代码中给出了串行的实现, 你需要实现多线程的版本.&lt;/p>
&lt;p>多线程版本中只需要修改 &lt;code>workerThreadStart&lt;/code>函数.
不需要手动创建线程, 也不需要手动join线程.
直接调用mandelbrotThread().&lt;/p>
&lt;h3 id="11--12-计算在23456781632个线程下的加速比">1.1 &amp;amp; 1.2, 计算在2,3,4,5,6,7,8,16,32个线程下的加速比&lt;/h3>
&lt;h4 id="编写并观察">编写并观察&lt;/h4>
&lt;p>workerThreadStart函数的实现:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="mi">345&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">workerThreadStart&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">WorkerArgs&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// TODO FOR CS149 STUDENTS: Implement the body of the worker
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// thread here. Each thread should make a call to mandelbrotSerial()
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// to compute a part of the output image. For example, in a
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// program that uses two threads, thread 0 could compute the top
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// half of the image and thread 1 could compute the bottom half.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// printf(&amp;#34;Hello world from thread %d\n&amp;#34;, args-&amp;gt;threadId);
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">double&lt;/span> &lt;span class="n">startTime&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">CycleTimer&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">currentSeconds&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 每个线程负责的行数(除不尽的部分由最后一个线程负责)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">height&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">height&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">numThreads&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">startRow&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">threadId&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">height&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">numRows&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">height&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">threadId&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">numThreads&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 如果是最后一个线程，那么就要把除不尽的部分也算上
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">numRows&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">height&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">height&lt;/span> &lt;span class="o">%&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">numThreads&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Thread %d startRow: %d, numRows: %d&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">threadId&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">startRow&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">numRows&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">mandelbrotSerial&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">x0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">y0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">x1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">y1&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">width&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">height&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">startRow&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">numRows&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">maxIterations&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">output&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">double&lt;/span> &lt;span class="n">endTime&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">CycleTimer&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">currentSeconds&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Thread %d time: %.3f ms&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">threadId&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">endTime&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">startTime&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="mi">1000&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>结果:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>线程数&lt;/th>
&lt;th>加速比&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>2&lt;/td>
&lt;td>1.97&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>3&lt;/td>
&lt;td>1.63&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>4&lt;/td>
&lt;td>2.31&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>5&lt;/td>
&lt;td>2.37&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>6&lt;/td>
&lt;td>3.08&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>7&lt;/td>
&lt;td>3.15&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>8&lt;/td>
&lt;td>3.74&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>16&lt;/td>
&lt;td>5.14&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>可以观察到，加速比和线程数并不是线性相关.&lt;/p>
&lt;h4 id="猜测原因">猜测原因&lt;/h4>
&lt;p>猜测可能的原因有:&lt;/p>
&lt;ul>
&lt;li>线程通信的开销&lt;/li>
&lt;li>每个线程分配的任务不均匀&lt;/li>
&lt;/ul>
&lt;h3 id="13-查看每个线程的执行时间验证猜想">1.3 查看每个线程的执行时间,验证猜想&lt;/h3>
&lt;p>当线程数为4时, 每个线程的执行时间如下:
Thread 0 time: 63.974 ms
Thread 3 time: 65.563 ms
Thread 2 time: 259.972 ms
Thread 1 time: 260.669 ms&lt;/p>
&lt;p>当线程数为8时, 每个线程的执行时间如下:
Thread 0 time: 13.702 ms
Thread 7 time: 16.831 ms
Thread 1 time: 57.324 ms
Thread 6 time: 61.069 ms
Thread 5 time: 113.431 ms
Thread 2 time: 115.753 ms
Thread 4 time: 164.736 ms
Thread 3 time: 166.306 ms&lt;/p>
&lt;p>可以看到,中间线程分配的任务更多,执行时间更长.
因此在增加线程数时,加速比并不是线性增加的.&lt;/p>
&lt;h3 id="14">1.4&lt;/h3>
&lt;p>任务描述:&lt;/p>
&lt;ul>
&lt;li>解决上面的问题,使得加速比更接近线性.
&lt;ul>
&lt;li>如: 8线程时的加速比需要在7~8之间.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>解决方法需要具有适用性, 适用所有的线程数.&lt;/li>
&lt;/ul>
&lt;p>tips:
有一个非常简单的静态赋值可以实现这个目标，并且线程之间不需要通信/同步.&lt;/p>
&lt;h4 id="解决方案">解决方案&lt;/h4>
&lt;p>思路:
根据代码可知, 每行的计算是独立的, 因此可以将每行分配给不同的线程.
但由上面的实验可知,中间行的计算量比较大.&lt;/p>
&lt;p>因此我们不应该直接平均切分行, 而是以线程数量为步长,线程交叉依次分配行.
即 第i个线程分配k*n+i行.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">workerThreadStart&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">WorkerArgs&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// TODO FOR CS149 STUDENTS: Implement the body of the worker
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// thread here. Each thread should make a call to mandelbrotSerial()
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// to compute a part of the output image. For example, in a
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// program that uses two threads, thread 0 could compute the top
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// half of the image and thread 1 could compute the bottom half.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// printf(&amp;#34;Hello world from thread %d\n&amp;#34;, args-&amp;gt;threadId);
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">double&lt;/span> &lt;span class="n">startTime&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">CycleTimer&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">currentSeconds&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cm">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> 方案1
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> // 每个线程负责的行数(除不尽的部分由最后一个线程负责)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> int baseHeight = args-&amp;gt;height / args-&amp;gt;numThreads;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> int startRow = args-&amp;gt;threadId * baseHeight;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> int numRows = baseHeight;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> int yu = args-&amp;gt;height % args-&amp;gt;numThreads;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> // 均匀分配剩余行
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> if (args-&amp;gt;threadId &amp;lt; yu)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> {
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> numRows++;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> }
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> startRow += std::min(args-&amp;gt;threadId, yu);
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> printf(&amp;#34;Thread %d startRow: %d, numRows: %d\n&amp;#34;, args-&amp;gt;threadId, startRow, numRows);
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> mandelbrotSerial(args-&amp;gt;x0, args-&amp;gt;y0, args-&amp;gt;x1, args-&amp;gt;y1,
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> args-&amp;gt;width, args-&amp;gt;height,
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> startRow, numRows,
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> args-&amp;gt;maxIterations, args-&amp;gt;output);
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 方案2, 依次分配行
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">height&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">height&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">threadId&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">height&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">numThreads&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">mandelbrotSerial&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">x0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">y0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">x1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">y1&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">width&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">height&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">maxIterations&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">output&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">double&lt;/span> &lt;span class="n">endTime&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">CycleTimer&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">currentSeconds&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Thread %d time: %.3f ms&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">threadId&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">endTime&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">startTime&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="mi">1000&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>输出结果:&lt;/p>
&lt;p>Thread 3 time: 88.842 ms
Thread 1 time: 89.680 ms
Thread 0 time: 89.717 ms
Thread 7 time: 90.280 ms
Thread 5 time: 90.715 ms
Thread 6 time: 90.743 ms
Thread 2 time: 91.049 ms
Thread 4 time: 92.982 ms
[mandelbrot thread]: [93.318] ms
Wrote image file mandelbrot-thread.ppm
(7.10x speedup from 8 threads)&lt;/p>
&lt;p>上面的解决方案使得每个线程的执行时间基本相同,因此加速比接近线性.
在8线程时,加速比为7.1.&lt;/p>
&lt;h3 id="15-16线程和8线程的加速比">1.5 16线程和8线程的加速比&lt;/h3>
&lt;p>现在16线程是否明显优于8线程? 给出是或否的原因.
(6.45x speedup from 16 threads)
16线程并没有明显由于8线程,反而还更慢.
原因:&lt;/p>
&lt;ul>
&lt;li>电脑本身是4核, 超线程后是8线程.&lt;/li>
&lt;li>16线程时线程切换反而导致开销增加.&lt;/li>
&lt;/ul>
&lt;h3 id="总结">总结&lt;/h3>
&lt;p>pro1的目的是为了认识到并行计算的overhead, 以及多线程在计算上也应该是依次交替分配的. 不能简单的平均分配.&lt;/p>
&lt;p>pro1是通过垂直分割来实现并行计算.
而向量化是通过水平分割来实现并行计算.&lt;/p>
&lt;h2 id="program-2-vectorizing-code-using-simd-intrinsics">program-2-vectorizing-code-using-simd-intrinsics&lt;/h2>
&lt;p>前提: L2
任务描述：
使用SIMD指令(CS149intrin.h提供的),来实现clampedExpVector函数.&lt;/p>
&lt;p>示例函数:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">absVector&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">values&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">output&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">__cs149_vec_float&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">__cs149_vec_float&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">__cs149_vec_float&lt;/span> &lt;span class="n">zero&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">_cs149_vset_float&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mf">0.f&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">__cs149_mask&lt;/span> &lt;span class="n">maskAll&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">maskIsNegative&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">maskIsNotNegative&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// Note: Take a careful look at this loop indexing. This example
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// code is not guaranteed to work when (N % VECTOR_WIDTH) != 0.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// Why is that the case?
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">N&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">+=&lt;/span>&lt;span class="n">VECTOR_WIDTH&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// All ones
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">maskAll&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">_cs149_init_ones&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// All zeros
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">maskIsNegative&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">_cs149_init_ones&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Load vector of values from contiguous memory addresses
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">_cs149_vload_float&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">values&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">maskAll&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// x = values[i];
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Set mask according to predicate
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">_cs149_vlt_float&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">maskIsNegative&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">zero&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">maskAll&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// if (x &amp;lt; 0) {
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Execute instruction using mask (&amp;#34;if&amp;#34; clause)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">_cs149_vsub_float&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">result&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">zero&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">maskIsNegative&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// output[i] = -x;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Inverse maskIsNegative to generate &amp;#34;else&amp;#34; mask
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">maskIsNotNegative&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">_cs149_mask_not&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">maskIsNegative&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// } else {
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Execute instruction (&amp;#34;else&amp;#34; clause)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">_cs149_vload_float&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">result&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">values&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">maskIsNotNegative&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// output[i] = x; }
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Write results back to memory
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">_cs149_vstore_float&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">output&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">maskAll&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>示例函数absVector并不能适用于所有情况,原因如下:
当n%VECTOR_WIDTH != 0时, 会越界.&lt;/p>
&lt;h3 id="12-实现clampedexpvector函数">1&amp;amp;2 实现clampedExpVector函数&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">clampedExpVector&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">float&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">values&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">exponents&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">float&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">output&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// CS149 STUDENTS TODO: Implement your vectorized version of
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// clampedExpSerial() here.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// Your solution should work for any value of
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// N and VECTOR_WIDTH, not just when VECTOR_WIDTH divides N
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">__cs149_vec_float&lt;/span> &lt;span class="n">one&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">nine&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">__cs149_vec_int&lt;/span> &lt;span class="n">zeroInt&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">oneInt&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">oneInt&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">_cs149_vset_int&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">zeroInt&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">_cs149_vset_int&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">one&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">_cs149_vset_float&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mf">1.f&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">nine&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">_cs149_vset_float&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mf">9.999999f&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">VECTOR_WIDTH&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">__cs149_mask&lt;/span> &lt;span class="n">maskAll&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">maskIsZero&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">maskIsNotZero&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">__cs149_vec_float&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">__cs149_vec_int&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// All ones
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">maskAll&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">_cs149_init_ones&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// All zeros
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">maskIsZero&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">_cs149_init_ones&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 防止在最后一次循环时，i+VECTOR_WIDTH超出N
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">VECTOR_WIDTH&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">maskAll&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">_cs149_init_ones&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">N&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// float x = values[i];
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">_cs149_vload_float&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">values&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">maskAll&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// int y = exponents[i];
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">_cs149_vload_int&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">exponents&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">maskAll&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// if (y == 0)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">_cs149_veq_int&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">maskIsZero&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">zeroInt&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">maskAll&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// {
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// output[i] = 1.f;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// }
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">_cs149_vstore_float&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">output&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">one&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">maskIsZero&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// else
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">maskIsNotZero&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">_cs149_mask_not&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">maskIsZero&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 消除最后一次循环时，i+VECTOR_WIDTH超出N的情况
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">maskIsNotZero&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">_cs149_mask_and&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">maskIsNotZero&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">maskAll&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// float result = x;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">__cs149_vec_float&lt;/span> &lt;span class="n">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// int count = y - 1;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">__cs149_vec_int&lt;/span> &lt;span class="n">count&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">_cs149_vsub_int&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">count&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">oneInt&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">maskIsNotZero&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 哪些count&amp;gt;0
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">__cs149_mask&lt;/span> &lt;span class="n">countMark&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">_cs149_vgt_int&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">countMark&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">count&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">zeroInt&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">maskIsNotZero&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// while (count &amp;gt; 0)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">_cs149_cntbits&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">countMark&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// result *= x;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">_cs149_vmult_float&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">result&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">countMark&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// count--;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">_cs149_vsub_int&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">count&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">count&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">oneInt&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">countMark&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 哪些count&amp;gt;0
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">_cs149_vgt_int&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">countMark&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">count&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">zeroInt&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">countMark&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// if (result &amp;gt; 9.999999f)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">__cs149_mask&lt;/span> &lt;span class="n">gtNineMask&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">_cs149_vgt_float&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">gtNineMask&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">nine&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">maskIsNotZero&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// { reult = 9.999999f;}
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">_cs149_vmove_float&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">result&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">nine&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">gtNineMask&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// output[i] = result;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">_cs149_vstore_float&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">output&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">maskIsNotZero&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>通过init_ones来防止在有n%vectorWith!=0时 越界.&lt;/p>
&lt;ul>
&lt;li>在最开始的maskAll时设置&lt;/li>
&lt;li>在取反码后也要设置一次&lt;/li>
&lt;/ul>
&lt;p>count循环:
通过设置一个mask来标记哪些count&amp;gt;0, 从而实现循环.&lt;/p>
&lt;p>修改vectorWidth为2, 4, 8, to 16来回答:
Does the vector utilization increase, decrease or stay the same as VECTOR_WIDTH changes? Why?&lt;/p>
&lt;p>vectorWidth为2时, 结果如下:
****************** Printing Vector Unit Statistics *******************
Vector Width: 2
Total Vector Instructions: 162728
Vector Utilization: 77.0%
Utilized Vector Lanes: 250653
Total Vector Lanes: 325456&lt;/p>
&lt;p>vectorWidth为4时, 结果如下:
****************** Printing Vector Unit Statistics *******************
Vector Width: 3
Total Vector Instructions: 119440
Vector Utilization: 72.2%
Utilized Vector Lanes: 258879
Total Vector Lanes: 358320&lt;/p>
&lt;p>vectorWidth为8时, 结果如下:
****************** Printing Vector Unit Statistics *******************
Vector Width: 8
Total Vector Instructions: 51628
Vector Utilization: 66.0%
Utilized Vector Lanes: 272539
Total Vector Lanes: 413024&lt;/p>
&lt;p>vectorWidth为16时, 结果如下:
****************** Printing Vector Unit Statistics *******************
Vector Width: 16
Total Vector Instructions: 26968
Vector Utilization: 64.2%
Utilized Vector Lanes: 277188
Total Vector Lanes: 431488&lt;/p>
&lt;p>可以发现, 随着vectorWidth的增加, vectorUtilization也在减少.&lt;/p>
&lt;p>原因:
有多个条件语句,当vectorWidth增加时, 每次在某个条件中不执行的指令也会增加.&lt;/p>
&lt;h3 id="3-实现arraysumvector">3 实现arraySumVector&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">float&lt;/span> &lt;span class="nf">arraySumVector&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">float&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">values&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// CS149 STUDENTS TODO: Implement your vectorized version of arraySumSerial here
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">__cs149_vec_float&lt;/span> &lt;span class="n">sum&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">_cs149_vset_float&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mf">0.f&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">VECTOR_WIDTH&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">__cs149_mask&lt;/span> &lt;span class="n">maskAll&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">__cs149_vec_float&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// All ones
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">maskAll&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">_cs149_init_ones&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 防止在最后一次循环时，i+VECTOR_WIDTH超出N
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">VECTOR_WIDTH&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">maskAll&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">_cs149_init_ones&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">N&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// float x = values[i];
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">_cs149_vload_float&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">values&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">maskAll&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// sum += x;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">_cs149_vadd_float&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">sum&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">sum&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">maskAll&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">float&lt;/span> &lt;span class="n">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mf">0.f&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// log2(VECTOR_WIDTH)内解决
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">log2&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">VECTOR_WIDTH&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 使用_cs149_hadd_float函数，将sum中的每两个元素相加
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 再使用_cs149_interleave_float函数，将sum中的每两个元素交叉放置
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 重复log2(VECTOR_WIDTH)次
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">_cs149_hadd_float&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">sum&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">sum&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">_cs149_interleave_float&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">sum&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">sum&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 将sum中的第一个元素赋值给result
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">sum&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>假设VECTOR_WIDTHs始终是N的因子.&lt;/p>
&lt;p>可以实现在O(N/VECTOR_WIDTH + log2(VECTOR_WIDTH))的时间内完成计算.&lt;/p>
&lt;p>最后的log2实现方式.
提示中给了两个函数
hadd: 将每两个元素相加
interleave: 将每两个元素交叉放置&lt;/p>
&lt;p>因此我们可以类似与归并排序的方式,将sum中的每两个元素相加,再将每两个元素交叉放置.
重复log2(VECTOR_WIDTH)次后,第一个元素就是结果.&lt;/p>
&lt;h2 id="program-3-ispc">program-3 ISPC&lt;/h2>
&lt;p>前提: L3&lt;/p>
&lt;h3 id="part1-ispc-basic">part1 ISPC basic&lt;/h3>
&lt;p>任务:学习ISPC基本概念和编写.&lt;/p>
&lt;p>ISPC是一种编译器,可以将C代码编译为SIMD指令.&lt;/p>
&lt;h3 id="part2-ispc-task">part2 ISPC task&lt;/h3>
&lt;p>任务描述:
观察ISPCtask执行的结果&lt;/p>
&lt;h4 id="1">1&lt;/h4>
&lt;p>启动mandelbrot_ispc &amp;ndash;tasks&lt;/p>
&lt;p>结果:
[mandelbrot serial]: [424.881] ms
Wrote image file mandelbrot-serial.ppm
[mandelbrot ispc]: [97.180] ms
Wrote image file mandelbrot-ispc.ppm
[mandelbrot multicore ispc]: [48.986] ms
Wrote image file mandelbrot-task-ispc.ppm
(4.37x speedup from ISPC)
(8.67x speedup from task ISPC)&lt;/p>
&lt;p>因为设置了两个task所以大约是两倍的加速比 对于 ISPC&lt;/p>
&lt;h4 id="2">2&lt;/h4>
&lt;p>修改mandelbrot_ispc_withtasks()中的task数量,
you should be able to achieve performance that exceeds the sequential version of the code by over 32 times!
How did you determine how many tasks to create?
Why does the number you chose work best?&lt;/p>
&lt;p>根据机器的最大超线程数量设置
我设置了16个task, 因为我的机器是4核8线程, 16个task可以使得每个线程都有两个task.&lt;/p>
&lt;h4 id="3">3&lt;/h4>
&lt;p>what happens when you launch 10,000 ISPC tasks? What happens when you launch 10,000 threads?&lt;/p>
&lt;p>向量加速&lt;/p>
&lt;p>思考题:
Q: Why are there two different mechanisms (foreach and launch) for expressing independent, parallelizable work to the ISPC system?
A:foreach是将一个任务分配给多个线程,而launch是将多个任务分配给多个线程.&lt;/p>
&lt;p>Q: Couldn&amp;rsquo;t the system just partition the many iterations of foreach across all cores and also emit the appropriate SIMD code for the cores?
A:&lt;/p>
&lt;h2 id="program-4-iterative-sqrt-15-points">program-4 Iterative sqrt (15 points)&lt;/h2>
&lt;p>用sqrt复习ISPC的基本概念&lt;/p>
&lt;h3 id="1-1">1&lt;/h3>
&lt;p>运行结果:
[sqrt serial]: [1316.793] ms
[sqrt ispc]: [301.134] ms
[sqrt task ispc]: [52.439] ms
(4.37x speedup from ISPC)
(25.11x speedup from task ISPC)
4.37x speedup due to SIMD
25.11 / 4.37 = 5.74x speedup due to multi-core&lt;/p>
&lt;h3 id="2-1">2&lt;/h3>
&lt;p>构造数组使得加速比最大.&lt;/p>
&lt;p>全部数为2.998.
思路:
因为每个元素相同可以让计算更均匀,2.998可以充分调动cpu
结构:
(5.60x speedup from ISPC)
(30.39x speedup from task ISPC)&lt;/p>
&lt;h3 id="3-1">3&lt;/h3>
&lt;p>构造数组使得加速比最小.&lt;/p>
&lt;p>全部数为1
思路:
1的sqrt计算迭代最少.&lt;/p>
&lt;p>结果:
(2.50x speedup from ISPC)
(3.08x speedup from task ISPC)&lt;/p>
&lt;h2 id="program-5-blas-saxpy-10-points">program-5 BLAS saxpy (10 points)&lt;/h2>
&lt;h3 id="1-2">1&lt;/h3>
&lt;p>运行观察加速比
[saxpy ispc]: [25.098] ms [11.874] GB/s [1.594] GFLOPS
[saxpy task ispc]: [18.438] ms [16.164] GB/s [2.169] GFLOPS
(1.36x speedup from use of tasks)&lt;/p>
&lt;p>因为需要访问内存所以加速比不高.&lt;/p>
&lt;h3 id="2-2">2&lt;/h3>
&lt;p>Even though saxpy loads one element from X, one element from Y, and writes one element to result the multiplier by 4 is correct. Why is this the case? (Hint, think about how CPU caches work.)&lt;/p>
&lt;p>当程序写入结果的一个元素时，它首先将包含这个元素的缓存行提取到缓存中。这需要一个内存操作。然后，当不需要这个缓存行时，它将从缓存中闪现出来，这需要另一个内存操作。&lt;/p></description></item><item><title>asst2</title><link>https://ysyyhhh.github.io/blog/asst2/</link><pubDate>Fri, 01 Mar 2024 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/blog/asst2/</guid><description>&lt;h2 id="c-sync">C++ Sync&lt;/h2>
&lt;h3 id="thread的使用">thread的使用&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;thread&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">my_func&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">thread_id&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">num_threads&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Hello from spawned thread %d of %d&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">thread_id&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">num_threads&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">argc&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">char&lt;/span>&lt;span class="o">**&lt;/span> &lt;span class="n">argv&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="kr">thread&lt;/span> &lt;span class="n">t0&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="kr">thread&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">my_func&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="kr">thread&lt;/span> &lt;span class="n">t1&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="kr">thread&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">my_func&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;The main thread is running concurrently with spawned threads.&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">t0&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">t1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Spawned threads have terminated at this point.&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="mutex">mutex&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;chrono&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;map&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;mutex&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;string&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;thread&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">map&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">string&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">g_pages&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">mutex&lt;/span> &lt;span class="n">g_pages_mutex&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">save_page&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">string&lt;/span>&lt;span class="o">&amp;amp;&lt;/span> &lt;span class="n">url&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// simulate a long page fetch
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">this_thread&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">sleep_for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">chrono&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">seconds&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">string&lt;/span> &lt;span class="n">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#34;fake content&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">lock_guard&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">mutex&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">guard&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">g_pages_mutex&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">g_pages&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">url&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="kr">thread&lt;/span> &lt;span class="n">t1&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">save_page&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;http://foo&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="kr">thread&lt;/span> &lt;span class="n">t2&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">save_page&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;http://bar&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">t1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">t2&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// safe to access g_pages without lock now, as the threads are joined
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="k">auto&lt;/span>&lt;span class="o">&amp;amp;&lt;/span> &lt;span class="nl">pair&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="n">g_pages&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">pair&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">first&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34; =&amp;gt; &amp;#34;&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">pair&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">second&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="sc">&amp;#39;\n&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Output&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">http://bar &lt;span class="o">=&lt;/span>&amp;gt; fake content
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">http://foo &lt;span class="o">=&lt;/span>&amp;gt; fake content
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="condition_variable">condition_variable&lt;/h3>
&lt;p>线程调用 wait (lock)来指示它希望等待来自另一个线程的通知。&lt;/p>
&lt;p>注意，互斥对象(包装在 std: : only _ lock 中)被传递给 wait ()调用。当通知线程时，条件变量将获得锁。&lt;/p>
&lt;p>这意味着当调用 wait ()返回时，调用线程是锁的当前持有者。锁通常用于保护线程现在需要检查的共享变量，以确保它正在等待的条件为真。&lt;/p>
&lt;p>创建 N 个线程。N-1个线程等待来自线程0的通知，然后在接到通知后，自动递增一个受共享互斥锁保护的计数器。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="cm">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * Wrapper class around a counter, a condition variable, and a mutex.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">ThreadState&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">public&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">condition_variable&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">condition_variable_&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">mutex&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">mutex_&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">counter_&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">num_waiting_threads_&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ThreadState&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">num_waiting_threads&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">condition_variable_&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">condition_variable&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">mutex_&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">mutex&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">counter_&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">num_waiting_threads_&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">num_waiting_threads&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">~&lt;/span>&lt;span class="n">ThreadState&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">delete&lt;/span> &lt;span class="n">condition_variable_&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">delete&lt;/span> &lt;span class="n">mutex_&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">signal_fn&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ThreadState&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">thread_state&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Acquire mutex to make sure the shared counter is read in a
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// consistent state.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">thread_state&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">mutex_&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">lock&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">thread_state&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">counter_&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">thread_state&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">num_waiting_threads_&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">thread_state&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">mutex_&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">unlock&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Release the mutex before calling `notify_all()` to make sure
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// waiting threads have a chance to make progress.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">thread_state&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">condition_variable_&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">notify_all&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Re-acquire the mutex to read the shared counter again.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">thread_state&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">mutex_&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">lock&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">thread_state&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">mutex_&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">unlock&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">wait_fn&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ThreadState&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">thread_state&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// A lock must be held in order to wait on a condition variable.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// This lock is atomically released before the thread goes to sleep
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// when `wait()` is called. The lock is atomically re-acquired when
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// the thread is woken up using `notify_all()`.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">unique_lock&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">mutex&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">lk&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">thread_state&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">mutex_&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">thread_state&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">condition_variable_&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">wait&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">lk&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Increment the shared counter with the lock re-acquired to inform the
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// signaling thread that this waiting thread has successfully been
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// woken up.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">thread_state&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">counter_&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Lock re-acquired after wait()...&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">lk&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">unlock&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * Signaling thread spins until each waiting thread increments a shared
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * counter after being woken up from the `wait()` method.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">condition_variable_example&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">num_threads&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;==============================================================&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Starting %d threads for signal-and-waiting...&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">num_threads&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="kr">thread&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">threads&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="kr">thread&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">num_threads&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ThreadState&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">thread_state&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">ThreadState&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">num_threads&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">threads&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="kr">thread&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">signal_fn&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">thread_state&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">num_threads&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">threads&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="kr">thread&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">wait_fn&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">thread_state&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">num_threads&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">threads&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;==============================================================&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">delete&lt;/span> &lt;span class="n">thread_state&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">delete&lt;/span>&lt;span class="p">[]&lt;/span> &lt;span class="n">threads&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="part_a">part_a&lt;/h2>
&lt;h3 id="step-1-实现tasksystemparallelspawn">step 1 实现TaskSystemParallelSpawn&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c++" data-lang="c++">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="n">TaskSystemParallelSpawn&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">run&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">IRunnable&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">runnable&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">num_total_tasks&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// TODO: CS149 students will modify the implementation of this
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// method in Part A. The implementation provided below runs all
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// tasks sequentially on the calling thread.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">atomic&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">taskId&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">num_threads&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">num_threads&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="kr">thread&lt;/span> &lt;span class="n">threads&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">num_threads&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 交叉分配任务
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">num_threads&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">threads&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="kr">thread&lt;/span>&lt;span class="p">([&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">]()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">task_id&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">taskId&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">fetch_add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">task_id&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">num_total_tasks&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">runnable&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">runTask&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">task_id&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">num_total_tasks&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">task_id&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">taskId&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">fetch_add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">num_threads&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">threads&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// printf(&amp;#34;done\n&amp;#34;);
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Q:How will you assign tasks to your worker threads? Should you consider static or dynamic assignment of tasks to threads?
A:交叉分配任务，动态分配任务&lt;/p>
&lt;p>Q:How will you ensure that all tasks are executed exactly once?
A:使用原子变量taskId&lt;/p>
&lt;h3 id="step-2-实现--tasksystemparallelthreadpoolspinning">step 2 实现 TaskSystemParallelThreadPoolSpinning&lt;/h3>
&lt;p>step1 的overhead主要是创建线程的开销(尤其是计算量低的任务上)，因此使用线程池可以减少开销&lt;/p>
&lt;p>要求: 在TestSystem 创建时,或者在run时创建线程池&lt;/p>
&lt;p>Q1: 作为一个开始的实现，我们建议您将worker threads设计为连续循环，始终检查它们是否有更多的工作要执行。(进入 while 循环直到条件为真的线程通常称为“spinning”)
那么worker thread 如何确定有work要执行呢？&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c++" data-lang="c++">&lt;span class="line">&lt;span class="cl">&lt;span class="n">TaskSystemParallelThreadPoolSpinning&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">TaskSystemParallelThreadPoolSpinning&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">num_threads&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">ITaskSystem&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">num_threads&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// TODO: CS149 student implementations may decide to perform setup
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// operations (such as thread pool construction) here.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// Implementations are free to add new class member variables
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// (requiring changes to tasksys.h).
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">exit_flag_&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">false&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">num_threads&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">threads&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">emplace_back&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">TaskSystemParallelThreadPoolSpinning&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">func&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">TaskSystemParallelThreadPoolSpinning&lt;/span>&lt;span class="o">::~&lt;/span>&lt;span class="n">TaskSystemParallelThreadPoolSpinning&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">exit_flag_&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">true&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">auto&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="kr">thread&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">threads&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">thread&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="n">TaskSystemParallelThreadPoolSpinning&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">run&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">IRunnable&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">runnable&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">num_total_tasks&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// TODO: CS149 students will modify the implementation of this
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// method in Part A. The implementation provided below runs all
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// tasks sequentially on the calling thread.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// printf(&amp;#34;run\n&amp;#34;);
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">runnable_&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">runnable&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">num_tasks_&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">num_total_tasks&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">num_tasks_done_&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">num_total_tasks&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">num_total_tasks&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">tasks_mutex_&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">lock&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">tasks_&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">push&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">tasks_mutex_&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">unlock&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">num_tasks_done_&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">num_total_tasks&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">this_thread&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">yield&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Q:为什么要使用yield
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// A:因为如果不使用yield，那么线程会一直占用CPU，导致其他线程无法运行
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// Q:那我直接死循环呢
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// A:死循环会导致CPU占用率100%，导致其他线程无法运行
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Q2:确保 run ()实现所需的同步行为是非常重要的。如何更改 run ()的实现以确定批量任务启动中的所有任务都已完成？
A:使用原子变量num_tasks_done_，每个任务完成时，num_tasks_done_加一，当num_tasks_done_等于num_total_tasks时，所有任务完成&lt;/p>
&lt;h3 id="step-3-实现-tasksystemparallelthreadpoolsleeping">step 3 实现 TaskSystemParallelThreadPoolSleeping&lt;/h3>
&lt;p>Step2的缺点：
当线程“spin”等待某些操作时，它们会利用 CPU 核心的执行资源。&lt;/p>
&lt;ul>
&lt;li>例如，工作线程可能会循环等待新任务到达。&lt;/li>
&lt;li>另一个例子是，主线程可能会循环等待辅助线程完成所有任务，这样它就可以从 run ()调用返回。&lt;/li>
&lt;/ul>
&lt;p>这可能会影响性能，因为即使这些线程没有做有用的工作，也会使用 CPU 资源来运行这些线程。&lt;/p>
&lt;p>在任务的这一部分中，我们希望您通过让线程处于休眠状态来提高任务系统的效率，直到它们所等待的条件得到满足。&lt;/p>
&lt;p>您的实现可以选择使用条件变量来实现此行为。条件变量是一个同步原语，它允许线程在等待条件存在时休眠(不占用 CPU 处理资源)。其他线程向等待唤醒的线程发出“信号”，以查看它们所等待的条件是否已经满足。例如，如果没有工作要做，您的工作线程可能会处于休眠状态(这样它们就不会从尝试执行有用工作的线程那里占用 CPU 资源)。另一个例子是，调用 run ()的主应用程序线程可能希望在等待批量任务启动中的所有任务由工作线程完成时休眠。(否则，一个旋转的主线程将从工作线程那里夺走 CPU 资源!)有关 C + + 中条件变量的更多信息，请参见我们的 C + + 同步教程。&lt;/p>
&lt;p>您在这部分作业中的实现可能需要考虑棘手的race conditions 。您需要考虑许多可能的线程行为交错&lt;/p>
&lt;p>您可能需要考虑编写额外的测试用例来测试您的系统。赋值入门代码包括评分脚本用于评分代码性能的工作负载，但是我们也将使用一组更广泛的工作负载来测试您的实现的正确性，而我们在入门代码中并没有提供这些工作负载！&lt;/p>
&lt;p>The assignment starter code includes the workloads that the grading script will use to grade the performance of your code, but we will also test the correctness of your implementation using a wider set of workloads that we are not providing in the starter code!&lt;/p>
&lt;p>tasksys.h&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="cm">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * TaskSystemParallelThreadPoolSleeping: This class is the student&amp;#39;s
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * optimized implementation of a parallel task execution engine that uses
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * a thread pool. See definition of ITaskSystem in
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * itasksys.h for documentation of the ITaskSystem interface.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">TaskSystemParallelThreadPoolSleeping&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="k">public&lt;/span> &lt;span class="n">ITaskSystem&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">public&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">TaskSystemParallelThreadPoolSleeping&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">num_threads&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">~&lt;/span>&lt;span class="n">TaskSystemParallelThreadPoolSleeping&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">const&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nf">name&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">void&lt;/span> &lt;span class="nf">run&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">IRunnable&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">runnable&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">num_total_tasks&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">TaskID&lt;/span> &lt;span class="nf">runAsyncWithDeps&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">IRunnable&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">runnable&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">num_total_tasks&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">const&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">vector&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">TaskID&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">deps&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">void&lt;/span> &lt;span class="nf">sync&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">private&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">vector&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="kr">thread&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">threads&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">num_tasks_&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">bool&lt;/span> &lt;span class="n">exit_flag_&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">atomic&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">num_tasks_done_&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">queue&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">tasks_&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">mutex&lt;/span> &lt;span class="n">tasks_mutex_&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">IRunnable&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">runnable_&lt;/span>&lt;span class="p">{};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">void&lt;/span> &lt;span class="nf">func&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">condition_variable&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">queue_condition_&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">condition_variable&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">condition_variable&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">all_done_condition_&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">condition_variable&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">num_waiting_threads_&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">atomic&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">num_tasks_remaining_&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">mutex&lt;/span> &lt;span class="n">all_done_mutex_&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>tasksys.cpp&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="cm">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * ================================================================
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * Parallel Thread Pool Sleeping Task System Implementation
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * ================================================================
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">const&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">TaskSystemParallelThreadPoolSleeping&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="s">&amp;#34;Parallel + Thread Pool + Sleep&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="n">TaskSystemParallelThreadPoolSleeping&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">func&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">task_id&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">exit_flag_&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">task_id&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">task_id&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">unique_lock&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">mutex&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">lk&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">tasks_mutex_&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 等待任务
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">queue_condition_&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">wait&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">lk&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">[]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">exit_flag_&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">tasks_&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">empty&lt;/span>&lt;span class="p">())&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">task_id&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">tasks_&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">front&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">tasks_&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">pop&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">runnable_&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">runTask&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">task_id&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">num_tasks_&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">num_tasks_remaining_&lt;/span>&lt;span class="o">--&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">num_tasks_remaining_&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 通知主线程
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// printf(&amp;#34;notify_all_done\n&amp;#34;);
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">all_done_condition_&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">notify_one&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 通知其他线程
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// printf(&amp;#34;notify_all\n&amp;#34;);
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">queue_condition_&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">notify_one&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">TaskSystemParallelThreadPoolSleeping&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">TaskSystemParallelThreadPoolSleeping&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">num_threads&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">ITaskSystem&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">num_threads&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// TODO: CS149 student implementations may decide to perform setup
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// operations (such as thread pool construction) here.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// Implementations are free to add new class member variables
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// (requiring changes to tasksys.h).
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">exit_flag_&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">false&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">num_threads&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">threads&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">emplace_back&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">TaskSystemParallelThreadPoolSleeping&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">func&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">TaskSystemParallelThreadPoolSleeping&lt;/span>&lt;span class="o">::~&lt;/span>&lt;span class="n">TaskSystemParallelThreadPoolSleeping&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// TODO: CS149 student implementations may decide to perform cleanup
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// operations (such as thread pool shutdown construction) here.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// Implementations are free to add new class member variables
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// (requiring changes to tasksys.h).
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">exit_flag_&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">true&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">queue_condition_&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">notify_all&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">auto&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="kr">thread&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">threads&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">thread&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="n">TaskSystemParallelThreadPoolSleeping&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">run&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">IRunnable&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">runnable&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">num_total_tasks&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// TODO: CS149 students will modify the implementation of this
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// method in Parts A and B. The implementation provided below runs all
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// tasks sequentially on the calling thread.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">runnable_&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">runnable&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">num_tasks_&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">num_total_tasks&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">num_tasks_remaining_&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">num_total_tasks&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">tasks_mutex_&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">lock&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">num_total_tasks&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">tasks_&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">push&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">tasks_mutex_&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">unlock&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 通知其他线程
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">queue_condition_&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">notify_all&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// printf(&amp;#34;run\n&amp;#34;);
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">num_tasks_remaining_&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">unique_lock&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">mutex&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">lk2&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">all_done_mutex_&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">all_done_condition_&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">wait&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">lk2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">[]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// printf(&amp;#34;all done\n&amp;#34;);
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// printf(&amp;#34;all done\n&amp;#34;);
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>结果分析:&lt;/p>
&lt;p>sleep对spin的提升效果不明显，可能是因为任务太少，线程切换的开销比较大.&lt;/p>
&lt;p>运行结果:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">&lt;span class="o">================================================================================&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Running task system grading harness... &lt;span class="o">(&lt;/span>&lt;span class="m">11&lt;/span> total tests&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> - Detected CPU with &lt;span class="m">16&lt;/span> execution contexts
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> - Task system configured to use at most &lt;span class="m">8&lt;/span> &lt;span class="nv">threads&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">================================================================================&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">================================================================================&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Executing test: super_super_light...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Reference binary: ./runtasks_ref_linux
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Results &lt;span class="k">for&lt;/span>: super_super_light
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> STUDENT REFERENCE PERF?
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Serial&lt;span class="o">]&lt;/span> 5.281 5.788 0.91 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Always Spawn&lt;span class="o">]&lt;/span> 95.221 92.995 1.02 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Spin&lt;span class="o">]&lt;/span> 10.877 10.446 1.04 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Sleep&lt;span class="o">]&lt;/span> 6.943 42.705 0.16 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">================================================================================&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Executing test: super_light...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Reference binary: ./runtasks_ref_linux
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Results &lt;span class="k">for&lt;/span>: super_light
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> STUDENT REFERENCE PERF?
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Serial&lt;span class="o">]&lt;/span> 37.497 37.844 0.99 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Always Spawn&lt;span class="o">]&lt;/span> 108.136 108.805 0.99 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Spin&lt;span class="o">]&lt;/span> 10.777 13.615 0.79 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Sleep&lt;span class="o">]&lt;/span> 10.274 44.686 0.23 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">================================================================================&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Executing test: ping_pong_equal...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Reference binary: ./runtasks_ref_linux
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Results &lt;span class="k">for&lt;/span>: ping_pong_equal
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> STUDENT REFERENCE PERF?
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Serial&lt;span class="o">]&lt;/span> 603.419 606.739 0.99 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Always Spawn&lt;span class="o">]&lt;/span> 167.412 178.638 0.94 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Spin&lt;span class="o">]&lt;/span> 105.983 123.525 0.86 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Sleep&lt;span class="o">]&lt;/span> 108.243 148.316 0.73 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">================================================================================&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Executing test: ping_pong_unequal...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Reference binary: ./runtasks_ref_linux
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Results &lt;span class="k">for&lt;/span>: ping_pong_unequal
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> STUDENT REFERENCE PERF?
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Serial&lt;span class="o">]&lt;/span> 1126.19 1109.329 1.02 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Always Spawn&lt;span class="o">]&lt;/span> 259.271 260.822 0.99 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Spin&lt;span class="o">]&lt;/span> 199.088 198.013 1.01 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Sleep&lt;span class="o">]&lt;/span> 198.777 214.293 0.93 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">================================================================================&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Executing test: recursive_fibonacci...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Reference binary: ./runtasks_ref_linux
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Results &lt;span class="k">for&lt;/span>: recursive_fibonacci
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> STUDENT REFERENCE PERF?
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Serial&lt;span class="o">]&lt;/span> 1052.273 1128.069 0.93 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Always Spawn&lt;span class="o">]&lt;/span> 156.014 172.113 0.91 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Spin&lt;span class="o">]&lt;/span> 156.31 171.337 0.91 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Sleep&lt;span class="o">]&lt;/span> 156.462 166.476 0.94 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">================================================================================&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Executing test: math_operations_in_tight_for_loop...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Reference binary: ./runtasks_ref_linux
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Results &lt;span class="k">for&lt;/span>: math_operations_in_tight_for_loop
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> STUDENT REFERENCE PERF?
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Serial&lt;span class="o">]&lt;/span> 411.426 423.96 0.97 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Always Spawn&lt;span class="o">]&lt;/span> 537.747 532.353 1.01 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Spin&lt;span class="o">]&lt;/span> 99.286 104.844 0.95 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Sleep&lt;span class="o">]&lt;/span> 95.817 239.76 0.40 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">================================================================================&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Executing test: math_operations_in_tight_for_loop_fewer_tasks...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Reference binary: ./runtasks_ref_linux
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Results &lt;span class="k">for&lt;/span>: math_operations_in_tight_for_loop_fewer_tasks
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> STUDENT REFERENCE PERF?
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Serial&lt;span class="o">]&lt;/span> 413.681 415.961 0.99 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Always Spawn&lt;span class="o">]&lt;/span> 514.021 505.234 1.02 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Spin&lt;span class="o">]&lt;/span> 108.644 117.702 0.92 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Sleep&lt;span class="o">]&lt;/span> 106.84 260.724 0.41 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">================================================================================&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Executing test: math_operations_in_tight_for_loop_fan_in...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Reference binary: ./runtasks_ref_linux
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Results &lt;span class="k">for&lt;/span>: math_operations_in_tight_for_loop_fan_in
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> STUDENT REFERENCE PERF?
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Serial&lt;span class="o">]&lt;/span> 212.534 211.52 1.00 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Always Spawn&lt;span class="o">]&lt;/span> 76.402 76.09 1.00 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Spin&lt;span class="o">]&lt;/span> 37.203 39.662 0.94 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Sleep&lt;span class="o">]&lt;/span> 36.523 57.039 0.64 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">================================================================================&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Executing test: math_operations_in_tight_for_loop_reduction_tree...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Reference binary: ./runtasks_ref_linux
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Results &lt;span class="k">for&lt;/span>: math_operations_in_tight_for_loop_reduction_tree
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> STUDENT REFERENCE PERF?
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Serial&lt;span class="o">]&lt;/span> 208.076 207.488 1.00 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Always Spawn&lt;span class="o">]&lt;/span> 45.054 45.227 1.00 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Spin&lt;span class="o">]&lt;/span> 33.079 33.9 0.98 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Sleep&lt;span class="o">]&lt;/span> 34.502 38.389 0.90 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">================================================================================&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Executing test: spin_between_run_calls...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Reference binary: ./runtasks_ref_linux
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Results &lt;span class="k">for&lt;/span>: spin_between_run_calls
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> STUDENT REFERENCE PERF?
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Serial&lt;span class="o">]&lt;/span> 353.553 382.373 0.92 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Always Spawn&lt;span class="o">]&lt;/span> 180.401 197.119 0.92 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Spin&lt;span class="o">]&lt;/span> 205.374 222.315 0.92 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Sleep&lt;span class="o">]&lt;/span> 214.819 197.579 1.09 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">================================================================================&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Executing test: mandelbrot_chunked...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Reference binary: ./runtasks_ref_linux
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Results &lt;span class="k">for&lt;/span>: mandelbrot_chunked
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> STUDENT REFERENCE PERF?
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Serial&lt;span class="o">]&lt;/span> 257.289 256.815 1.00 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Always Spawn&lt;span class="o">]&lt;/span> 34.395 34.058 1.01 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Spin&lt;span class="o">]&lt;/span> 34.241 34.922 0.98 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Sleep&lt;span class="o">]&lt;/span> 35.191 35.273 1.00 &lt;span class="o">(&lt;/span>OK&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">================================================================================&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Overall performance results
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Serial&lt;span class="o">]&lt;/span> : All passed Perf
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Always Spawn&lt;span class="o">]&lt;/span> : All passed Perf
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Spin&lt;span class="o">]&lt;/span> : All passed Perf
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Parallel + Thread Pool + Sleep&lt;span class="o">]&lt;/span> : All passed Perf
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="part_b">part_b&lt;/h2>
&lt;p>在任务的 B 部分中，您将扩展您的 A 部分任务系统实现，以支持可能依赖于以前任务的任务的异步启动。这些任务间依赖关系创建了任务执行库必须遵守的调度约束。&lt;/p>
&lt;p>ITaskSystem 接口还有一个方法:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="k">virtual&lt;/span> &lt;span class="n">TaskID&lt;/span> &lt;span class="nf">runAsyncWithDeps&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">IRunnable&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">runnable&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">num_total_tasks&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">const&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">vector&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">TaskID&lt;/span>&lt;span class="o">&amp;gt;&amp;amp;&lt;/span> &lt;span class="n">deps&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>RunAsyncWithDeps ()类似于 run () ，因为它也用于执行 num &lt;em>total&lt;/em> asks 任务的批量启动。但是，它与 run ()在许多方面有所不同&amp;hellip;&lt;/p>
&lt;h3 id="asynchronous-task-launch">Asynchronous Task Launch&lt;/h3>
&lt;p>首先，使用 runAsyncWithDeps ()创建的任务由任务系统与调用线程异步执行。&lt;/p>
&lt;p>这意味着 runAsyncWithDeps ()应该立即返回给调用方，即使任务尚未完成执行。&lt;/p>
&lt;p>该方法返回与此批量任务启动关联的唯一标识符。&lt;/p>
&lt;p>调用线程可以通过调用 sync ()来确定大容量任务启动的实际完成时间。&lt;/p>
&lt;p>&lt;code>virtual void sync() = 0;&lt;/code>&lt;/p>
&lt;p>只有当与之前所有批量任务启动关联的任务完成时，sync ()才返回给调用方。例如，考虑以下代码:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// assume taskA and taskB are valid instances of IRunnable...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">vector&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">TaskID&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">noDeps&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// empty vector
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">ITaskSystem&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">t&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">TaskSystem&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">num_threads&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// bulk launch of 4 tasks
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">TaskID&lt;/span> &lt;span class="n">launchA&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">t&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">runAsyncWithDeps&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">taskA&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">noDeps&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// bulk launch of 8 tasks
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">TaskID&lt;/span> &lt;span class="n">launchB&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">t&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">runAsyncWithDeps&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">taskB&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">8&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">noDeps&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// at this point tasks associated with launchA and launchB
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// may still be running
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">t&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">sync&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// at this point all 12 tasks associated with launchA and launchB
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// are guaranteed to have terminated
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如上面的注释中所述，在线程调用sync() runAsyncWithDeps() ) 的任务已完成。 准确地说， runAsyncWithDeps()告诉您的任务系统执行新的批量任务启动，但您的实现可以灵活地在下次调用sync()之前随时执行这些任务。 请注意，此规范意味着无法保证您的实现在从 launchB 启动任务之前先执行 launchA 中的任务！&lt;/p>
&lt;h3 id="support-for-explicit-dependencies">Support for Explicit Dependencies&lt;/h3>
&lt;p>runAsyncWithDeps()的第二个关键细节是它的第三个参数：TaskID 标识符向量，必须引用之前使用runAsyncWithDeps()启动的批量任务。 该向量指定当前批量任务启动中的任务所依赖的先前任务。 因此，在依赖向量中给出的启动中的所有任务完成之前，您的任务运行时无法开始执行当前批量任务启动中的任何任务！ 例如，考虑以下示例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">vector&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">TaskID&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">noDeps&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// empty vector
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">vector&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">TaskID&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">depOnA&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">vector&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">TaskID&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">depOnBC&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">ITaskSystem&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">t&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">TaskSystem&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">num_threads&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">TaskID&lt;/span> &lt;span class="n">launchA&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">t&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">runAsyncWithDeps&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">taskA&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">128&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">noDeps&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">depOnA&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">push_back&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">launchA&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">TaskID&lt;/span> &lt;span class="n">launchB&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">t&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">runAsyncWithDeps&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">taskB&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">depOnA&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">TaskID&lt;/span> &lt;span class="n">launchC&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">t&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">runAsyncWithDeps&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">taskC&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">6&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">depOnA&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">depOnBC&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">push_back&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">launchB&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">depOnBC&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">push_back&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">launchC&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">TaskID&lt;/span> &lt;span class="n">launchD&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">t&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">runAsyncWithDeps&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">taskD&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">32&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">depOnBC&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">t&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">sync&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面的代码有四个批量任务启动（taskA：128 个任务，taskB：2 个任务，taskC：6 个任务，taskD：32 个任务）。 请注意，任务 B 和任务 C 的启动取决于任务 A。 taskD 的批量启动 ( launchD ) 取决于launchB和launchC的结果。 因此，虽然您的任务运行时可以按任意顺序（包括并行）处理与launchB和launchC关联的任务，但这些启动中的所有任务必须在launchA的任务完成后开始执行，并且它们必须在运行时开始之前完成从launchD执行任何任务。&lt;/p>
&lt;p>我们可以通过任务图直观地说明这些依赖关系。 任务图是有向无环图 (DAG)，其中图中的节点对应于批量任务启动，从节点 X 到节点 Y 的边表示 Y 对 X 输出的依赖关系。上述代码的任务图是：
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img src="https://github.com/jeremyephron/asst2/raw/master/figs/task_graph.png" alt="Alt text" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>请注意，如果您在具有八个执行上下文的 Myth 计算机上运行上面的示例，则并行调度launchB和launchC中的任务的能力可能非常有用，因为单独的批量任务启动都不足以使用所有执行机器的资源。&lt;/p>
&lt;h3 id="task">Task&lt;/h3>
&lt;p>您必须从 A 部分扩展任务系统实现，才能正确实现TaskSystem::runAsyncWithDeps()和TaskSystem::sync() 。 与 A 部分一样，我们为您提供以下入门提示：&lt;/p>
&lt;ul>
&lt;li>It may be helpful to think about the behavior of runAsyncWithDeps() as pushing a record corresponding to the bulk task launch, or perhaps records corresponding to each of the tasks in the bulk task launch onto a &amp;ldquo;work queue&amp;rdquo;. Once the record to work to do is in the queue, runAsyncWithDeps() can return to the caller.&lt;/li>
&lt;li>The trick in this part of the assignment is performing the appropriate bookkeeping to track dependencies. What must be done when all the tasks in a bulk task launch complete? (This is the point when new tasks may become available to run.)&lt;/li>
&lt;li>It can be helpful to have two data structures in your implementation: (1) a structure representing tasks that have been added to the system via a call to runAsyncWithDeps(), but are not yet ready to execute because they depend on tasks that are still running (these tasks are &amp;ldquo;waiting&amp;rdquo; for others to finish) and (2) a &amp;ldquo;ready queue&amp;rdquo; of tasks that are not waiting on any prior tasks to finish and can safely be run as soon as a worker thread is available to process them.&lt;/li>
&lt;li>You need not worry about integer wrap around when generating unique task launch ids. We will not hit your task system with over 2^31 bulk task launches.&lt;/li>
&lt;li>You can assume all programs will either call only run() or only runAsyncWithDeps(); that is, you do not need to handle the case where a run() call needs to wait for all proceeding calls to runAsyncWithDeps() to finish.&lt;/li>
&lt;/ul>
&lt;p>在part_b/子目录中实现B部分实现，以与正确的参考实现（ part_b/runtasks_ref_* ）进行比较。&lt;/p></description></item><item><title>L2</title><link>https://ysyyhhh.github.io/blog/l2/</link><pubDate>Fri, 01 Mar 2024 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/blog/l2/</guid><description>&lt;h2 id="并行程序">并行程序&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c++" data-lang="c++">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">sinx&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">terms&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">float&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">float&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">float&lt;/span> &lt;span class="n">number&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">sign&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">denom&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">6&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">terms&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">j&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">value&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">sign&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">number&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="n">denom&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">sign&lt;/span> &lt;span class="o">*=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">denom&lt;/span> &lt;span class="o">*=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">number&lt;/span> &lt;span class="o">*=&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">result&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>转换成汇编后大致如下:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-asm" data-lang="asm">&lt;span class="line">&lt;span class="cl">&lt;span class="nf">ld&lt;/span> &lt;span class="no">r0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">addr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="no">r1&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">mul&lt;/span> &lt;span class="no">ri&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">r0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">r0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">mul&lt;/span> &lt;span class="no">r1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">r1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">r0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">可以看到每次循环都是独立的。&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">对于最简单的是顺序执行。&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">通过超线程(超标量处理器具有从单个指令流中提取多个指令的能力)可以提高性能。有时称指令级并行性。(&lt;/span>&lt;span class="nf">ILP&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">Instruction&lt;/span> &lt;span class="no">Level&lt;/span> &lt;span class="no">Parallelism&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">但在这些汇编指令中必须顺序执行。&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">因此实现指令级并行性是一个挑战。&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">但即使是纯顺序执行的代码,也有很多方式使其运行更快(基于写代码的方式和编译器的智能程度).&lt;/span> &lt;span class="nf">Pentium&lt;/span> &lt;span class="mi">4&lt;/span> &lt;span class="err">比如先取多条指令等&lt;/span>&lt;span class="p">.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">(有个黑匣子会预测分支,预测错误的话就会清空流水线,浪费时间)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">解决方法:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">1.&lt;/span> &lt;span class="err">通过&lt;/span>&lt;span class="nf">pthread编写并行性的程序&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">2.&lt;/span> &lt;span class="err">假设有一种语言可以表示并行性,编译器可以自动并行化程序&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">如:&lt;/span> &lt;span class="nf">forall&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">int&lt;/span> &lt;span class="no">i&lt;/span> &lt;span class="no">from&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="no">to&lt;/span> &lt;span class="no">n-1&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="err">{}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">自动并行化可能的解决方法:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">1.&lt;/span> &lt;span class="err">直接分为&lt;/span>&lt;span class="nf">k个线程&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="err">每个线程处理&lt;/span>&lt;span class="no">n&lt;/span>&lt;span class="err">/&lt;/span>&lt;span class="no">k个循环.&lt;/span> &lt;span class="err">然后将结果合并&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">2.&lt;/span> &lt;span class="err">在硬件上执行.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">有一堆性能较低但具有并行性的处理器时,&lt;/span> &lt;span class="err">也需要更多电力/时间来驱动很多信号从一端到另一端.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">## CPU &amp;amp;&amp;amp; GPU
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nf">GPU将核心的概念带到了极致&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="err">抛弃了所有的分支预测&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="err">只是控制逻辑而不完成计算&lt;/span>&lt;span class="p">.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">对于上面的程序有垂直和水平两种分割方式:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">-&lt;/span> &lt;span class="err">垂直:&lt;/span> &lt;span class="err">每个线程处理一个循环&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">-&lt;/span> &lt;span class="err">水平:&lt;/span> &lt;span class="err">同时处理多个循环,&lt;/span> &lt;span class="err">如先同时进行所有的第一个乘法&lt;/span>&lt;span class="na">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">## SIMD Single Instruction Multiple Data
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="err">假设我正在执行的多次操作之间没有依赖关系,都能够并行运行.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">a&lt;/span> &lt;span class="no">single&lt;/span> &lt;span class="no">instruction&lt;/span> &lt;span class="no">is&lt;/span> &lt;span class="no">applied&lt;/span> &lt;span class="no">to&lt;/span> &lt;span class="no">multiple&lt;/span> &lt;span class="no">data&lt;/span> &lt;span class="no">elements&lt;/span> &lt;span class="no">simultaneously.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">即:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">同时对8个数值和另一个地方的8个数值取出并进行加法.&lt;/span> &lt;span class="err">有时这些数值可以被称作向量.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">使用&lt;/span>&lt;span class="nf">AVX&lt;/span> &lt;span class="no">intrinsics的向量化程序&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">```&lt;/span>&lt;span class="nf">c&lt;/span>&lt;span class="err">++&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">void&lt;/span> &lt;span class="no">sinx&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">int&lt;/span> &lt;span class="no">N&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">int&lt;/span> &lt;span class="no">terms&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">float&lt;/span>&lt;span class="p">*&lt;/span> &lt;span class="no">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">float&lt;/span>&lt;span class="p">*&lt;/span> &lt;span class="no">result&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="err">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="no">int&lt;/span> &lt;span class="no">i&lt;/span> &lt;span class="err">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="c1">; i &amp;lt; N; i+=8) {
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">__m256&lt;/span> &lt;span class="no">origx&lt;/span> &lt;span class="err">=&lt;/span> &lt;span class="no">_mm256_load_ps&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="err">&amp;amp;&lt;/span>&lt;span class="no">x&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="no">i&lt;/span>&lt;span class="p">])&lt;/span>&lt;span class="c1">;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">__m256&lt;/span> &lt;span class="no">value&lt;/span> &lt;span class="err">=&lt;/span> &lt;span class="no">origx&lt;/span>&lt;span class="c1">;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">__m256&lt;/span> &lt;span class="no">number&lt;/span> &lt;span class="err">=&lt;/span> &lt;span class="no">_mm256_mul_ps&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">origx&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">_mm256_mul_ps&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">origx&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">origx&lt;/span>&lt;span class="p">))&lt;/span>&lt;span class="c1">;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">float&lt;/span> &lt;span class="no">sign&lt;/span> &lt;span class="err">=&lt;/span> &lt;span class="p">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="c1">;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">__m256&lt;/span> &lt;span class="no">denom&lt;/span> &lt;span class="err">=&lt;/span> &lt;span class="no">_mm256_set1_ps&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">6&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="c1">;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="no">int&lt;/span> &lt;span class="no">j&lt;/span> &lt;span class="err">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="c1">; j &amp;lt; terms; j++) {
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//value += sign * number / denom;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">__m256&lt;/span> &lt;span class="no">tmp&lt;/span> &lt;span class="err">=&lt;/span> &lt;span class="no">_mm256_div_ps&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">number&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">denom&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="c1">;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">tmp&lt;/span> &lt;span class="err">=&lt;/span> &lt;span class="no">_mm256_mul_ps&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">tmp&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">_mm256_set1_ps&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">sign&lt;/span>&lt;span class="p">))&lt;/span>&lt;span class="c1">;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">value&lt;/span> &lt;span class="err">=&lt;/span> &lt;span class="no">_mm256_add_ps&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">value&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">tmp&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="c1">;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">sign&lt;/span> &lt;span class="p">*&lt;/span>&lt;span class="err">=&lt;/span> &lt;span class="p">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="c1">;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//denom *= (2*j+3)*(2*j+2);
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">denom&lt;/span> &lt;span class="err">=&lt;/span> &lt;span class="no">_mm256_mul_ps&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">denom&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">_mm256_set1_ps&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">*&lt;/span>&lt;span class="no">j&lt;/span>&lt;span class="err">+&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">)*(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">*&lt;/span>&lt;span class="no">j&lt;/span>&lt;span class="err">+&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">)))&lt;/span>&lt;span class="c1">;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//number *= x[i] * x[i];
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">number&lt;/span> &lt;span class="err">=&lt;/span> &lt;span class="no">_mm256_mul_ps&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">number&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">_mm256_mul_ps&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">origx&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">origx&lt;/span>&lt;span class="p">))&lt;/span>&lt;span class="c1">;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="err">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">_mm256_store_ps&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="err">&amp;amp;&lt;/span>&lt;span class="no">result&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="no">i&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="no">value&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="c1">;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//result[i] = value;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="err">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>编译成汇编后大致如下:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-asm" data-lang="asm">&lt;span class="line">&lt;span class="cl">&lt;span class="nf">vloadps&lt;/span> &lt;span class="no">xmm0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">addr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="no">r1&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">vmulps&lt;/span> &lt;span class="no">xmm1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">xmm0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">xmm0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">vmulps&lt;/span> &lt;span class="no">xmm2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">xmm1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">xmm0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="no">vstoreps&lt;/span> &lt;span class="no">addr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="no">xmm2&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="no">xmm0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>AVX代表高级矢量扩展, 256代表每次可以处理256位的数据, 也就是8个float.
有多个版本:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-md" data-lang="md">&lt;span class="line">&lt;span class="cl">AVX: 128位 = 4 &lt;span class="ge">* 4 *&lt;/span> 8 = 32字节
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">AVX2: 256位 = 8 &lt;span class="ge">* 4 *&lt;/span> 8 = 32字节
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">AVX512: 512位 = 16 &lt;span class="ge">* 4 *&lt;/span> 8 = 64字节
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>XMM寄存器是特殊的32字节 256位寄存器, 有16个, 从xmm0到xmm15. 用于支持vectorized SIMD指令.&lt;/p>
&lt;p>那么有没有办法让编译器自动将代码向量化呢?&lt;/p>
&lt;ul>
&lt;li>有,GCC的-O3选项可以自动向量化代码.&lt;/li>
&lt;/ul>
&lt;p>但只有非常结构化,精心编写的代码才能被自动向量化.&lt;/p>
&lt;h3 id="条件">条件&lt;/h3>
&lt;p>如果加入条件判断,如何向量化?&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c++" data-lang="c++">&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;span class="k">else&lt;/span>&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>SIMD可能的做法:
设置一个掩码, 用于标记哪些元素需要执行哪些不需要执行.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-md" data-lang="md">&lt;span class="line">&lt;span class="cl">x &lt;span class="p">&amp;lt;&lt;/span> &lt;span class="nt">0:&lt;/span> &lt;span class="na">1&lt;/span> &lt;span class="na">1&lt;/span> &lt;span class="na">0&lt;/span> &lt;span class="na">0&lt;/span> &lt;span class="na">1&lt;/span> &lt;span class="na">0&lt;/span> &lt;span class="na">0&lt;/span> &lt;span class="na">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">x &lt;/span>&lt;span class="o">=&lt;/span> &lt;span class="s">-x:&lt;/span> &lt;span class="na">1&lt;/span> &lt;span class="na">1&lt;/span> &lt;span class="na">0&lt;/span> &lt;span class="na">0&lt;/span> &lt;span class="na">1&lt;/span> &lt;span class="na">0&lt;/span> &lt;span class="na">0&lt;/span> &lt;span class="na">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">翻转:&lt;/span> &lt;span class="na">0&lt;/span> &lt;span class="na">0&lt;/span> &lt;span class="na">1&lt;/span> &lt;span class="na">1&lt;/span> &lt;span class="na">0&lt;/span> &lt;span class="na">1&lt;/span> &lt;span class="na">1&lt;/span> &lt;span class="na">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">x &lt;/span>&lt;span class="o">=&lt;/span> &lt;span class="s">x:&lt;/span> &lt;span class="na">0&lt;/span> &lt;span class="na">0&lt;/span> &lt;span class="na">1&lt;/span> &lt;span class="na">1&lt;/span> &lt;span class="na">0&lt;/span> &lt;span class="na">1&lt;/span> &lt;span class="na">1&lt;/span> &lt;span class="na">1&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>但大多时候只保留了一半的效率,因为每次有可能只有一半的数据需要执行.
不过这很好的保证了一致性,因为分支结束后又回到了同一个执行路径.
即保持一致性,远离分歧.&lt;/p>
&lt;p>coherent execution: 所有的线程都执行相同的指令.&lt;/p>
&lt;p>divergent: a lack of instruction stream coherence.&lt;/p>
&lt;p>对于生成这些矢量操作,要么有聪明的编译器,要么就是有耐心的程序员.&lt;/p>
&lt;h3 id="simd-execution-on-many-modern-gpus">SIMD execution on many modern GPUs&lt;/h3>
&lt;p>SPMD: Single Program Multiple Data&lt;/p>
&lt;p>GPU给的不是SIMD,而是SPMD. 单个程序,多个数据. 意味着程序的不同部分可以执行不同的指令.&lt;/p>
&lt;p>在这之下,还是用SIMD来实现大部分逻辑,采用异构的方式来实现并行.&lt;/p>
&lt;p>但有n个加法, 即两个包含n个值的向量相加.
实际上不是所有单位都在等待计算.而是会先计算出如何分配到块中,底层块的实际大小是32, 32values而不是32byte. 这个被称作SIMD宽度,一般是8-32.&lt;/p>
&lt;h3 id="gpu和cpu的差别">GPU和CPU的差别&lt;/h3>
&lt;p>CPU i7:&lt;/p>
&lt;ul>
&lt;li>4核&lt;/li>
&lt;li>8 SIMD ALUs per core&lt;/li>
&lt;li>每秒大概几千次浮点运算&lt;/li>
&lt;/ul>
&lt;p>GPU: RTX 1080&lt;/p>
&lt;ul>
&lt;li>20 cores&lt;/li>
&lt;li>32 SIMD ALUs per core&lt;/li>
&lt;li>每秒大概8m次浮点运算&lt;/li>
&lt;/ul>
&lt;p>GPU的核心摒弃了分支预测等只用做control,因此可以有更多的ALU.填充进来.&lt;/p>
&lt;p>大概是80:1的原始计算能力差异.&lt;/p>
&lt;h3 id="总结">总结&lt;/h3>
&lt;p>三种方法实现并行计算&lt;/p>
&lt;p>多核CPU:&lt;/p>
&lt;ul>
&lt;li>线程级实现并行&lt;/li>
&lt;/ul>
&lt;p>SIMD:&lt;/p>
&lt;ul>
&lt;li>指令级并行&lt;/li>
&lt;li>通过向量化指令实现&lt;/li>
&lt;li>但依赖于事先知道执行的指令优先级顺序&lt;/li>
&lt;/ul>
&lt;p>Superscaler:
exploit ILP within an instruction stream&lt;/p>
&lt;h2 id="paart2-accessing-memory">paart2 accessing memory&lt;/h2>
&lt;p>Memory latency: 从CPU到内存的时间&lt;/p>
&lt;ul>
&lt;li>example: DRAM访问时间 100 cycles, 100ns&lt;/li>
&lt;/ul>
&lt;p>Memory bandwidth: 从内存到CPU的时间&lt;/p>
&lt;ul>
&lt;li>example: 20GB/s 其实不是很快&lt;/li>
&lt;/ul>
&lt;p>Stall: CPU等待内存的时间
当cpu试图进行读取而内存不可用时，就会停等知道内存可用.&lt;/p>
&lt;p>缓存就是为了解决Stall的问题.&lt;/p>
&lt;p>在多级缓存中,靠近核心的缓存是私有的.
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l2/img/2023-10-05-16-43-06_hu18c235196594db696f84796cb1ead687_215427_6a724ed12fad9a3240b03da2a1c0ff6b.webp 400w,
/blog/l2/img/2023-10-05-16-43-06_hu18c235196594db696f84796cb1ead687_215427_9ceee60bd8fdd3eb63114e89b322d0b0.webp 760w,
/blog/l2/img/2023-10-05-16-43-06_hu18c235196594db696f84796cb1ead687_215427_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l2/img/2023-10-05-16-43-06_hu18c235196594db696f84796cb1ead687_215427_6a724ed12fad9a3240b03da2a1c0ff6b.webp"
width="760"
height="424"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
这样可以通过写入读出L2缓存的数据来实现通讯,而不需要经过DRAM.&lt;/p>
&lt;p>缓存对延迟和带宽都有帮助.&lt;/p>
&lt;h3 id="prefecthing-reduces-stalls">Prefecthing reduces stalls&lt;/h3>
&lt;p>硬件通常通过预取来&lt;strong>减少延迟&lt;/strong>.
即预测下一次可能会访问的数据,并将其提前读取到缓存中.
不过可能会造成信息泄露&lt;/p>
&lt;p>使用预取的效果:
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l2/img/2023-10-05-16-47-27_hu9e755d86af4542e2c891b6ef523b2239_504134_f5783346b6eafcc279c7b7eadc75a246.webp 400w,
/blog/l2/img/2023-10-05-16-47-27_hu9e755d86af4542e2c891b6ef523b2239_504134_e1a197eee3ba4938657b7931766d1231.webp 760w,
/blog/l2/img/2023-10-05-16-47-27_hu9e755d86af4542e2c891b6ef523b2239_504134_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l2/img/2023-10-05-16-47-27_hu9e755d86af4542e2c891b6ef523b2239_504134_f5783346b6eafcc279c7b7eadc75a246.webp"
width="760"
height="556"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="multi-threading-reduces-stalls">Multi-threading reduces stalls&lt;/h3>
&lt;p>让多个线程交替进行, 如asst1/prog2的实现&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l2/img/2023-10-05-16-53-05_hu018724600a89671805482e5e14021481_143403_2c3960edeb7b7146e69b7397f368eed9.webp 400w,
/blog/l2/img/2023-10-05-16-53-05_hu018724600a89671805482e5e14021481_143403_ae5cc04b79da4d5c206e7798358b5dff.webp 760w,
/blog/l2/img/2023-10-05-16-53-05_hu018724600a89671805482e5e14021481_143403_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l2/img/2023-10-05-16-53-05_hu018724600a89671805482e5e14021481_143403_2c3960edeb7b7146e69b7397f368eed9.webp"
width="760"
height="284"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
这也是超线程的实现,在一个核心中多路复用多个指令流.
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l2/img/2023-10-05-16-52-35_hu6c2acc8845dfbfbe4383d0d236adfe16_560224_3bc248fc2800b46d51b509a0fd52a08a.webp 400w,
/blog/l2/img/2023-10-05-16-52-35_hu6c2acc8845dfbfbe4383d0d236adfe16_560224_f27aeda0e160298c73ea9b46e9eef185.webp 760w,
/blog/l2/img/2023-10-05-16-52-35_hu6c2acc8845dfbfbe4383d0d236adfe16_560224_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l2/img/2023-10-05-16-52-35_hu6c2acc8845dfbfbe4383d0d236adfe16_560224_3bc248fc2800b46d51b509a0fd52a08a.webp"
width="760"
height="563"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>对于CPU&amp;amp;GPU, 谁来组织线程是不同的做法.(操作系统 or 硬件)&lt;/p>
&lt;p>通常情况下内存要比其他因素更加限制速度&lt;/p></description></item><item><title>L4 Parallel Programing basics</title><link>https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/</link><pubDate>Fri, 01 Mar 2024 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/</guid><description>&lt;p>主要用三种方式实现并行程序(没有进行真正的优化)&lt;/p>
&lt;p>例子 n-body simulation&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-19-08-15_hue48a4921cc49cf57e882ed55cfa33ec8_653223_300d6e55ae7158eb7f77967a00820153.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-19-08-15_hue48a4921cc49cf57e882ed55cfa33ec8_653223_6c1a606d891b45c87635608e28e74a79.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-19-08-15_hue48a4921cc49cf57e882ed55cfa33ec8_653223_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-19-08-15_hue48a4921cc49cf57e882ed55cfa33ec8_653223_300d6e55ae7158eb7f77967a00820153.webp"
width="760"
height="566"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>创建并行程序的过程&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-19-12-34_hu8ca133d8fdd22bace72d28bc0e9f928f_717995_d7d48a19c6b8d98d4bb025be7407106a.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-19-12-34_hu8ca133d8fdd22bace72d28bc0e9f928f_717995_becf2ea517713a91c8190995e7cc73a3.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-19-12-34_hu8ca133d8fdd22bace72d28bc0e9f928f_717995_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-19-12-34_hu8ca133d8fdd22bace72d28bc0e9f928f_717995_d7d48a19c6b8d98d4bb025be7407106a.webp"
width="760"
height="569"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="1-decomposition">1. Decomposition&lt;/h3>
&lt;p>主要思想: 创造至少足够的任务让所有的处理单元都有事情做&lt;/p>
&lt;p>Amdahl&amp;rsquo;s Law: 串行部分的比例越大, 并行程序的加速比就越小,因为增加处理单元的数量并不能减少串行部分的时间&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-19-17-14_hu6b8d57c08ba6ce2d6ea30fe8baefa3d4_659251_0e9ae484b47d7b98ce1bcb4d1368d085.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-19-17-14_hu6b8d57c08ba6ce2d6ea30fe8baefa3d4_659251_f894a7fc4c613f87e7daa182688bfbb2.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-19-17-14_hu6b8d57c08ba6ce2d6ea30fe8baefa3d4_659251_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-19-17-14_hu6b8d57c08ba6ce2d6ea30fe8baefa3d4_659251_0e9ae484b47d7b98ce1bcb4d1368d085.webp"
width="760"
height="570"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-19-25-06_hu46e8e5fd6fd42d95218680164502ccdb_474311_26ca6d976940fa163bdb00a72d487ab2.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-19-25-06_hu46e8e5fd6fd42d95218680164502ccdb_474311_7d794c4862846294ba020113fcbd3a99.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-19-25-06_hu46e8e5fd6fd42d95218680164502ccdb_474311_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-19-25-06_hu46e8e5fd6fd42d95218680164502ccdb_474311_26ca6d976940fa163bdb00a72d487ab2.webp"
width="760"
height="562"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>分解的任务更多是程序员的工作, 编译器还无法很好的帮助我们&lt;/p>
&lt;h3 id="2assignment">2.Assignment&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-19-27-56_huac3192b45d26432b1fbf3a13b42c3714_518393_f4b6891d6e8836e5b078c7b6aec5aadd.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-19-27-56_huac3192b45d26432b1fbf3a13b42c3714_518393_65d2c13a7bb828fa5c068bca90139c7a.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-19-27-56_huac3192b45d26432b1fbf3a13b42c3714_518393_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-19-27-56_huac3192b45d26432b1fbf3a13b42c3714_518393_f4b6891d6e8836e5b078c7b6aec5aadd.webp"
width="760"
height="568"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>需要考虑让每个处理单元尽可能减少沟通.&lt;/p>
&lt;p>有一种方法是随机分配,但会最大化沟通
还有一个极端是全部由一个处理单元完成,但是这样就没有并行了&lt;/p>
&lt;p>这是另一个挑战&lt;/p>
&lt;p>分配可以静态也可以动态发生&lt;/p>
&lt;p>静态: 在程序开始时就确定好.
动态: 在程序运行时分配
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-19-32-26_hue221ecbb5d082188d974279744465ae6_739363_469ecdbd4a9b8454fd47173ba40269f8.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-19-32-26_hue221ecbb5d082188d974279744465ae6_739363_b3390ceebc8efeab9b8139e9845c32b3.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-19-32-26_hue221ecbb5d082188d974279744465ae6_739363_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-19-32-26_hue221ecbb5d082188d974279744465ae6_739363_469ecdbd4a9b8454fd47173ba40269f8.webp"
width="760"
height="562"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>静态分配的问题:&lt;/p>
&lt;ul>
&lt;li>无法适应不同的输入(如:工作量不均匀)&lt;/li>
&lt;li>无法适应不同的处理单元数量&lt;/li>
&lt;/ul>
&lt;p>动态分配: 通过消息传递来实现, 每个处理单元都有一个队列, 用来存放需要处理的任务(tasks). 当一个处理单元完成了一个任务, 就从队列中取出一个任务来处理
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-19-41-07_hu6c85e4ef3ddfa256fd5b280b3f1947d5_610384_1ec3e9269d1b9769ff7549ca3e7ff991.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-19-41-07_hu6c85e4ef3ddfa256fd5b280b3f1947d5_610384_435b8b910d0cf444fe612cbec0958114.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-19-41-07_hu6c85e4ef3ddfa256fd5b280b3f1947d5_610384_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-19-41-07_hu6c85e4ef3ddfa256fd5b280b3f1947d5_610384_1ec3e9269d1b9769ff7549ca3e7ff991.webp"
width="760"
height="526"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>缺点:
队列需要同步, 会有额外的开销&lt;/p>
&lt;h3 id="3-orchestration-编排阶段">3. Orchestration 编排阶段&lt;/h3>
&lt;p>编排的目标是:
减少沟通和同步的成本, preserve &lt;strong>locality&lt;/strong> of data reference, reduce overhead.&lt;/p>
&lt;h3 id="4mapping">4.mapping&lt;/h3>
&lt;p>这是程序员最不需要关心的, 交给编译器就好了
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-19-48-55_hu7d458683065d371a53e4f3bbced0dc5b_674886_dd70cb98c5d235d4af085a8b85d717eb.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-19-48-55_hu7d458683065d371a53e4f3bbced0dc5b_674886_d0427d53091c240e55a9032cbafa5c74.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-19-48-55_hu7d458683065d371a53e4f3bbced0dc5b_674886_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-19-48-55_hu7d458683065d371a53e4f3bbced0dc5b_674886_dd70cb98c5d235d4af085a8b85d717eb.webp"
width="760"
height="574"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h2 id="example">example&lt;/h2>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-20-28-08_hu4bc1ad631611432311f7608937c4d974_532911_378f26ab2469867248ef1ea890a944f5.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-28-08_hu4bc1ad631611432311f7608937c4d974_532911_2b961a92c582af81689691d4ee62333d.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-28-08_hu4bc1ad631611432311f7608937c4d974_532911_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-20-28-08_hu4bc1ad631611432311f7608937c4d974_532911_378f26ab2469867248ef1ea890a944f5.webp"
width="760"
height="568"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>顺序程序:
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-20-29-38_huef0e497a0a3be02bd46e8912ca469521_552238_b0a20d7e5de93d8bfdaa4a330e9fd80e.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-29-38_huef0e497a0a3be02bd46e8912ca469521_552238_eb0f8d018192eebde00a35c3f9fa78f1.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-29-38_huef0e497a0a3be02bd46e8912ca469521_552238_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-20-29-38_huef0e497a0a3be02bd46e8912ca469521_552238_b0a20d7e5de93d8bfdaa4a330e9fd80e.webp"
width="760"
height="579"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>那么如何并行执行呢?&lt;/p>
&lt;h3 id="step1-identify-dependenciesproblem-decomposition">Step1: identify dependencies(problem decomposition)&lt;/h3>
&lt;p>因为会迭代很多次,所以会引起不同迭代次数的数据竞争.&lt;/p>
&lt;p>有一种划分方法是沿着对角线:
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-20-32-11_hua770f7c3378cf5e52779686442875f74_850357_eac19ef97378e0332e37b6120c1b7460.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-32-11_hua770f7c3378cf5e52779686442875f74_850357_11f821c7ea9de7edb4def82251e9efdf.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-32-11_hua770f7c3378cf5e52779686442875f74_850357_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-20-32-11_hua770f7c3378cf5e52779686442875f74_850357_eac19ef97378e0332e37b6120c1b7460.webp"
width="760"
height="617"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>不足之处是:&lt;/p>
&lt;ul>
&lt;li>有些对角线很短, 负载不均衡&lt;/li>
&lt;li>需要额外的计算(对角线下标)&lt;/li>
&lt;/ul>
&lt;p>另一种方法是滚动数组:
用两个数组, 一个用来存放当前迭代的结果, 一个用来存放上一次迭代的结果&lt;/p>
&lt;p>这样计算时不会有数据竞争.&lt;/p>
&lt;p>但很多人不希望有额外的内存开销.&lt;/p>
&lt;p>事实上使用的是红黑排序.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-20-37-00_hub6902c6359b72f71195b1f839828355e_586963_5d8ef9fd25d94e005487943ac9894f81.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-37-00_hub6902c6359b72f71195b1f839828355e_586963_34f7f339aea72b213c8a668102485760.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-37-00_hub6902c6359b72f71195b1f839828355e_586963_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-20-37-00_hub6902c6359b72f71195b1f839828355e_586963_5d8ef9fd25d94e005487943ac9894f81.webp"
width="760"
height="566"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>每次迭代只更新红色的部分, 然后再翻转.
这样就不需要复制数组了.&lt;/p>
&lt;h3 id="step2-assign-tasks">Step2: assign tasks&lt;/h3>
&lt;p>我们不把每一个元素作为一个任务,而是把每一行作为一个任务.&lt;/p>
&lt;p>同时:
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-20-41-36_hubdceb7f300441a8766ba1431277c7cc4_755276_711347c7e817fe638550eebcc34b2faf.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-41-36_hubdceb7f300441a8766ba1431277c7cc4_755276_accd9f6717d58f6ab57f5c5748534b83.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-41-36_hubdceb7f300441a8766ba1431277c7cc4_755276_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-20-41-36_hubdceb7f300441a8766ba1431277c7cc4_755276_711347c7e817fe638550eebcc34b2faf.webp"
width="760"
height="569"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>红黑排序有一个同步的步骤: 必须等待所有的红色部分都计算完毕, 才能开始计算黑色部分.&lt;/p>
&lt;p>为了最小化沟通, 相邻行作为捆包是更好的选择, 这样只在更新边界时需要沟通.&lt;/p>
&lt;h3 id="三种实现方法">三种实现方法&lt;/h3>
&lt;h4 id="data-parallel-expression-of-solver">Data-parallel expression of solver&lt;/h4>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-20-45-17_hu05b94560b10f4189a08c6cb5f48bfd71_676413_6071d1eabf8eb456c38c7ab568c29c85.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-45-17_hu05b94560b10f4189a08c6cb5f48bfd71_676413_bd6ad13f2f63aba99999c5aa7836e481.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-45-17_hu05b94560b10f4189a08c6cb5f48bfd71_676413_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-20-45-17_hu05b94560b10f4189a08c6cb5f48bfd71_676413_6071d1eabf8eb456c38c7ab568c29c85.webp"
width="760"
height="568"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>这个的特点是系统做了很多工作, 程序只需要指定哪里需要并行.&lt;/p>
&lt;h4 id="shared-address-space-code">shared-address-space code&lt;/h4>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-20-49-07_hud4acc75f44d57621c38bcef37ecf69ad_501385_5ac6b61cbfefc82f7f4c733828aa1374.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-49-07_hud4acc75f44d57621c38bcef37ecf69ad_501385_4fee6b612cf87991254c9c57b904ce52.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-49-07_hud4acc75f44d57621c38bcef37ecf69ad_501385_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-20-49-07_hud4acc75f44d57621c38bcef37ecf69ad_501385_5ac6b61cbfefc82f7f4c733828aa1374.webp"
width="760"
height="576"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>version1 :
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-20-49-41_hu397a5c725eab7f2ec6ba703b751c7761_745157_533e533992488749606b9438d64b007c.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-49-41_hu397a5c725eab7f2ec6ba703b751c7761_745157_0b75e1a598b6dc90f1d0988f46b9c18f.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-49-41_hu397a5c725eab7f2ec6ba703b751c7761_745157_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-20-49-41_hu397a5c725eab7f2ec6ba703b751c7761_745157_533e533992488749606b9438d64b007c.webp"
width="760"
height="577"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>但是有个锁会使得程序变慢
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-20-51-52_hue0bce16ea2bc879cd28793bae80b6fdb_858650_008576a8562e19a9b68a706920f134f5.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-51-52_hue0bce16ea2bc879cd28793bae80b6fdb_858650_162d8768bd53d226b92aa1e3c8b841ae.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-51-52_hue0bce16ea2bc879cd28793bae80b6fdb_858650_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-20-51-52_hue0bce16ea2bc879cd28793bae80b6fdb_858650_008576a8562e19a9b68a706920f134f5.webp"
width="760"
height="564"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>version2:
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-20-53-12_hu36b9d35db431827e24b4b081d064641f_693240_d83b71c546167384983d9a1ef9afcab6.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-53-12_hu36b9d35db431827e24b4b081d064641f_693240_0b8c610136d7c28529574edd2eba5bbd.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-53-12_hu36b9d35db431827e24b4b081d064641f_693240_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-20-53-12_hu36b9d35db431827e24b4b081d064641f_693240_d83b71c546167384983d9a1ef9afcab6.webp"
width="760"
height="574"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>有三个barrier来保证红黑顺序
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-20-54-07_hudaa8f328867329c6ba35530421eebfde_512012_66c627513b8313419cea65ed7635bd4f.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-54-07_hudaa8f328867329c6ba35530421eebfde_512012_b8e8413bb73b3bc460895c08c728e194.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-54-07_hudaa8f328867329c6ba35530421eebfde_512012_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-20-54-07_hudaa8f328867329c6ba35530421eebfde_512012_66c627513b8313419cea65ed7635bd4f.webp"
width="760"
height="545"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
为什么是三个呢?&lt;/p>
&lt;p>每一部分都要被分割&lt;/p>
&lt;p>最后一个是为了diff的分割
第一个是为了myDiff的分割
第二个是为了diff的分割&lt;/p>
&lt;p>所以可以使用diff数组&lt;/p>
&lt;p>version3:
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-20-57-40_hu0d1996844693b134151c8d82ee5425bd_617614_38e643162361d034d8e8ed437c443f84.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-57-40_hu0d1996844693b134151c8d82ee5425bd_617614_5ce102c5ce45f0dbc1dac41b6096bf7b.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-57-40_hu0d1996844693b134151c8d82ee5425bd_617614_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-20-57-40_hu0d1996844693b134151c8d82ee5425bd_617614_38e643162361d034d8e8ed437c443f84.webp"
width="760"
height="566"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>barrier的问题:
barrier还是有点笨重, 这会强制所有线程到一个起跑线
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-20-59-07_huaecac9eeb7b6b74f7510d557e9b6e26a_572209_41fd0f188cd297c382afe2bc81211c7e.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-59-07_huaecac9eeb7b6b74f7510d557e9b6e26a_572209_8f25e59fa55106ba0b7456f62971f92b.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-20-59-07_huaecac9eeb7b6b74f7510d557e9b6e26a_572209_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-20-59-07_huaecac9eeb7b6b74f7510d557e9b6e26a_572209_41fd0f188cd297c382afe2bc81211c7e.webp"
width="760"
height="584"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>但如果有更精确的信息, 只需要等待依赖的线程就好了&lt;/p>
&lt;h4 id="message-passing-code">message-passing code&lt;/h4>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-21-00-57_hue70b1faf829cca87f081e5bc424c7628_594886_3dcdaa90f3dc0b6edb968742fde6788b.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-21-00-57_hue70b1faf829cca87f081e5bc424c7628_594886_5f9edad42ee570536dbb24cbbf0e2313.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-21-00-57_hue70b1faf829cca87f081e5bc424c7628_594886_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-21-00-57_hue70b1faf829cca87f081e5bc424c7628_594886_3dcdaa90f3dc0b6edb968742fde6788b.webp"
width="760"
height="574"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>需要有额外的划分,来存储相邻处理器的数据&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-21-02-04_hu4c6d7b1bda54071ab3467deea4424d30_799693_194c426e9f4bd30f2c0f56092d87ed1d.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-21-02-04_hu4c6d7b1bda54071ab3467deea4424d30_799693_201679da15e21745058c91d98624422d.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-21-02-04_hu4c6d7b1bda54071ab3467deea4424d30_799693_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-21-02-04_hu4c6d7b1bda54071ab3467deea4424d30_799693_194c426e9f4bd30f2c0f56092d87ed1d.webp"
width="760"
height="579"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>同时,在最后计算diff时,需要等待所有的处理器都计算完毕.
这里选中了一个processor zero来计算diff, 其他的处理器都发送自己的diff给它.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-21-04-12_hu40d62451cdfd210f1a8f99acfc52e78e_920652_34bd425bc4ebe88a31f4957864cd7fe4.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-21-04-12_hu40d62451cdfd210f1a8f99acfc52e78e_920652_a4c392a2099e53a7ae0b5f3bc237eb21.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-21-04-12_hu40d62451cdfd210f1a8f99acfc52e78e_920652_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-21-04-12_hu40d62451cdfd210f1a8f99acfc52e78e_920652_34bd425bc4ebe88a31f4957864cd7fe4.webp"
width="760"
height="562"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>但沟通时有可能发生死锁. 因为每个处理器都在等待其他处理器的消息, 但是自己的消息又没有发送出去.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-21-06-02_huc087edeeaded9dcd70e781a8caf24d42_565877_7664ca781070f75ef349661a85c63958.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-21-06-02_huc087edeeaded9dcd70e781a8caf24d42_565877_68b90074dc227e55c1a49326a35e5e23.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-21-06-02_huc087edeeaded9dcd70e781a8caf24d42_565877_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-21-06-02_huc087edeeaded9dcd70e781a8caf24d42_565877_7664ca781070f75ef349661a85c63958.webp"
width="760"
height="574"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>所以需要分奇偶来发送&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l4-parallel-programing-basics/img/2023-10-14-21-07-24_hu36e0868a51b260305696d6733ba21ec5_677923_a6befff3da24916d55d41b8bb71c4d75.webp 400w,
/blog/l4-parallel-programing-basics/img/2023-10-14-21-07-24_hu36e0868a51b260305696d6733ba21ec5_677923_1053a357a9c5aa6773e8e220d458f49a.webp 760w,
/blog/l4-parallel-programing-basics/img/2023-10-14-21-07-24_hu36e0868a51b260305696d6733ba21ec5_677923_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l4-parallel-programing-basics/img/2023-10-14-21-07-24_hu36e0868a51b260305696d6733ba21ec5_677923_a6befff3da24916d55d41b8bb71c4d75.webp"
width="760"
height="590"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p></description></item><item><title>L5 Work distribution and scheduling</title><link>https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/</link><pubDate>Fri, 01 Mar 2024 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/</guid><description>&lt;h2 id="三种分配策略的总结">三种分配策略的总结&lt;/h2>
&lt;h3 id="静态分配">静态分配&lt;/h3>
&lt;p>优点:&lt;/p>
&lt;ul>
&lt;li>几乎没有运行时的开销(关于分配)&lt;/li>
&lt;/ul>
&lt;p>缺点:&lt;/p>
&lt;ul>
&lt;li>不总是均匀的分配任务&lt;/li>
&lt;/ul>
&lt;p>什么时候使用:&lt;/p>
&lt;ul>
&lt;li>(最简单的例子) 当知道每个任务的工作量相当的时候&lt;/li>
&lt;li>当每个任务的工作量是可预测的,但不一定相等的时候&lt;/li>
&lt;/ul>
&lt;p>半静态分配&lt;/p>
&lt;ul>
&lt;li>场景: 当工作量会随时间发生改变,当变化比较慢时.(任务量不可预测)&lt;/li>
&lt;li>做法: 定期的重新分配任务
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-15-17-17-21_huc4d2be410d647016a3206e85b20b8291_1107621_5880584d2300544cd55841de43263248.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-15-17-17-21_huc4d2be410d647016a3206e85b20b8291_1107621_68fb3d31df2ca327d35ff36a5b6491e8.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-15-17-17-21_huc4d2be410d647016a3206e85b20b8291_1107621_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-15-17-17-21_huc4d2be410d647016a3206e85b20b8291_1107621_5880584d2300544cd55841de43263248.webp"
width="760"
height="574"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/li>
&lt;/ul>
&lt;h3 id="动态分配">动态分配&lt;/h3>
&lt;p>场景: 当每个任务的工作量或者任务的数量是不可预测的时候&lt;/p>
&lt;p>每个计算单元都要去获取任务&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-15-17-25-21_hua6a3c077cced5abdb9b7bbaa576a7ec8_874748_13253e7a7b20fe3aefc71947e01ae37c.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-15-17-25-21_hua6a3c077cced5abdb9b7bbaa576a7ec8_874748_7546cdc1ebd3007df3f8be6534e94e4f.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-15-17-25-21_hua6a3c077cced5abdb9b7bbaa576a7ec8_874748_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-15-17-25-21_hua6a3c077cced5abdb9b7bbaa576a7ec8_874748_13253e7a7b20fe3aefc71947e01ae37c.webp"
width="760"
height="552"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>但这样的实现, 每次的任务可能会很少,
会使得更多的开销在争夺锁(获取任务的锁)上面.&lt;/p>
&lt;p>有一个办法是一次性计算更多的任务.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-15-17-26-57_huf835b5eac9d37b49ce3c30a88aace822_752046_764dee7c21fd261f1ea42dd03deaac94.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-15-17-26-57_huf835b5eac9d37b49ce3c30a88aace822_752046_d2c2f29cd40410d16e80729d86a1a85a.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-15-17-26-57_huf835b5eac9d37b49ce3c30a88aace822_752046_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-15-17-26-57_huf835b5eac9d37b49ce3c30a88aace822_752046_764dee7c21fd261f1ea42dd03deaac94.webp"
width="760"
height="535"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>但分配更多的任务可能会导致负载不平衡.&lt;/p>
&lt;p>因此需要在分配任务数量上要找一个平衡, 不花费过多的时间在争夺锁上, 也不会导致负载不平衡.&lt;/p>
&lt;p>&lt;strong>Schedule long tasks first&lt;/strong>
但如果有一个大任务在最后，将出现如下情况：
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-08-53-07_hu91d4bd1fcd6b2d3a4a21166e27be8ac1_532596_a319b7fbc769ba12a45b529df1c65503.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-08-53-07_hu91d4bd1fcd6b2d3a4a21166e27be8ac1_532596_dbd94cdf2d21f71697636c8d4408b78a.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-08-53-07_hu91d4bd1fcd6b2d3a4a21166e27be8ac1_532596_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-16-08-53-07_hu91d4bd1fcd6b2d3a4a21166e27be8ac1_532596_a319b7fbc769ba12a45b529df1c65503.webp"
width="760"
height="567"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>因此，如果知道有一个大任务，可以提前处理，而不是放到最后一个.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-08-56-01_hubaef0c3f89c826d5b1d5dd6890516517_550046_ac355852c6e4b1b13a70e8840c1e0592.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-08-56-01_hubaef0c3f89c826d5b1d5dd6890516517_550046_ec03d531275ed3b43bc45e5ddf89fe21.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-08-56-01_hubaef0c3f89c826d5b1d5dd6890516517_550046_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-16-08-56-01_hubaef0c3f89c826d5b1d5dd6890516517_550046_ac355852c6e4b1b13a70e8840c1e0592.webp"
width="760"
height="566"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h4 id="work-stealing">Work stealing&lt;/h4>
&lt;p>当一个计算单元没有任务的时候, 从其他计算单元那里偷取任务.&lt;/p>
&lt;p>实现的一些问题:&lt;/p>
&lt;p>1.从哪个线程开始偷取任务呢?
有随机的, 也有从最后一个开始偷取的.&lt;/p>
&lt;p>2.应该偷取多少任务呢?
应该偷取尽可能多一些,这样可以减少偷取任务的次数.&lt;/p>
&lt;p>3.怎样检测一个计算单元是否有任务呢?
可能会循环遍历,&lt;/p>
&lt;p>4.使用本地队列(分布式队列)会更快(在有互斥锁的情况下)&lt;/p>
&lt;p>还有一种方式是使用特殊的数据结构来存储任务间的依赖关系, 从而可以在任务完成的时候, 自动的调度下一个任务.
缺点是额外开销
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-32-31_hu882ba279ae3cd004bfdf46a1a891da1b_594941_ef134a9b1bd58c72a760187990732c21.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-32-31_hu882ba279ae3cd004bfdf46a1a891da1b_594941_c2a7dd664f517f7aea7b9a0f8edb78b1.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-32-31_hu882ba279ae3cd004bfdf46a1a891da1b_594941_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-32-31_hu882ba279ae3cd004bfdf46a1a891da1b_594941_ef134a9b1bd58c72a760187990732c21.webp"
width="760"
height="564"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h2 id="常见的并行编程模式">常见的并行编程模式&lt;/h2>
&lt;p>循环
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-42-32_hua668693ef93510a897eb16b96202656c_595050_512dd4ec637d5bdea75de7f988ef7ae6.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-42-32_hua668693ef93510a897eb16b96202656c_595050_d23d15f8a4c93c3c3ca1dbe1f069c539.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-42-32_hua668693ef93510a897eb16b96202656c_595050_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-42-32_hua668693ef93510a897eb16b96202656c_595050_512dd4ec637d5bdea75de7f988ef7ae6.webp"
width="760"
height="571"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>创建显示线程
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-43-32_hu787070f973929fd30cb38c336bbde5e3_506261_1bd6943adefdb492091091335d4f6790.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-43-32_hu787070f973929fd30cb38c336bbde5e3_506261_fd4d25059248640d13177979d28dfbe2.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-43-32_hu787070f973929fd30cb38c336bbde5e3_506261_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-43-32_hu787070f973929fd30cb38c336bbde5e3_506261_1bd6943adefdb492091091335d4f6790.webp"
width="760"
height="575"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>递归时的并行&lt;/p>
&lt;p>递归可以编写出简单的代码, 但是递归的并行化是比较困难的.&lt;/p>
&lt;p>因为递归的并行化需要在递归的每一层都要进行并行化, 并且需要在每一层都要进行同步.&lt;/p>
&lt;p>但只要有独立的子问题, 就可以创造很多潜在的并行性.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-45-15_hue5ded81e796c68dee0b0618a6e0920dd_758799_83e684b20ad601fbffd05f681e98b070.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-45-15_hue5ded81e796c68dee0b0618a6e0920dd_758799_f656576fbd7c80b31534d8c55418bd72.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-45-15_hue5ded81e796c68dee0b0618a6e0920dd_758799_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-45-15_hue5ded81e796c68dee0b0618a6e0920dd_758799_83e684b20ad601fbffd05f681e98b070.webp"
width="760"
height="576"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h2 id="fork-join-pattern">Fork-Join pattern&lt;/h2>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-47-18_hu0f4ed4729d5da33b2852ec7891c96ad1_815835_a69bafaace4900b4f73d3c5cf6d9df30.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-47-18_hu0f4ed4729d5da33b2852ec7891c96ad1_815835_56c44942eb8197b75e566cfc48810c8c.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-47-18_hu0f4ed4729d5da33b2852ec7891c96ad1_815835_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-47-18_hu0f4ed4729d5da33b2852ec7891c96ad1_815835_a69bafaace4900b4f73d3c5cf6d9df30.webp"
width="760"
height="567"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>cilk_spawn: 会创建一个新的线程, 并且在新的线程中执行函数, 并且不会阻塞当前的线程.&lt;/p>
&lt;p>cilk_sync: 会等待所有的子线程执行完毕, 并且会阻塞当前的线程.&lt;/p>
&lt;p>每个函数的结尾隐式的调用了cilk_sync.&lt;/p>
&lt;p>example:
有一个主线程+fork的线程.
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-49-40_hu6b2a13e8c61edb007acb8c68ac6cc24d_722419_3330ee920e588071cd2cc18ca84067e5.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-49-40_hu6b2a13e8c61edb007acb8c68ac6cc24d_722419_9e9c62ec66af9b2387fa7b6c712555a7.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-49-40_hu6b2a13e8c61edb007acb8c68ac6cc24d_722419_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-49-40_hu6b2a13e8c61edb007acb8c68ac6cc24d_722419_3330ee920e588071cd2cc18ca84067e5.webp"
width="760"
height="573"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>快排的例子:
在规模较小的时候, 使用串行的快排. 这样可以减少线程的创建和销毁的开销.
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-53-13_hub5a36810580b89ed0b40df5af3f5878e_872565_77c644f2c45c972574415e31fe8b84ab.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-53-13_hub5a36810580b89ed0b40df5af3f5878e_872565_9e81ba5d6c1f18ad17e02f7b2e7199ab.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-53-13_hub5a36810580b89ed0b40df5af3f5878e_872565_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-16-09-53-13_hub5a36810580b89ed0b40df5af3f5878e_872565_77c644f2c45c972574415e31fe8b84ab.webp"
width="760"
height="560"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>&lt;strong>不要忽略了抽象和实现的区别.&lt;/strong>
spawn不是生成一个具体的线程, 而是声明这里有一个可以并行的任务.&lt;/p>
&lt;p>任务的数量至少需要比硬件线程多,但也不能大于100倍.
8倍是一个比较好的选择.
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-01-49_huac690f525b910e3151d41f9e83b20825_725705_68336c190f129e2e078badf9a4caf4bc.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-01-49_huac690f525b910e3151d41f9e83b20825_725705_3b3a6a1947f775d0efca7c18769e335e.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-01-49_huac690f525b910e3151d41f9e83b20825_725705_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-01-49_huac690f525b910e3151d41f9e83b20825_725705_68336c190f129e2e078badf9a4caf4bc.webp"
width="760"
height="500"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h2 id="cilk的实现">Cilk的实现&lt;/h2>
&lt;p>假设我们要去实现clik_spawn 和 cilk_sync
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-04-28_huef2c8d13f3726a6bfffc8a2b7080cdd9_608019_2241e98cd40fefed3853c0a484c7dd60.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-04-28_huef2c8d13f3726a6bfffc8a2b7080cdd9_608019_cf4047faa49cace03c1989649aefba72.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-04-28_huef2c8d13f3726a6bfffc8a2b7080cdd9_608019_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-04-28_huef2c8d13f3726a6bfffc8a2b7080cdd9_608019_2241e98cd40fefed3853c0a484c7dd60.webp"
width="760"
height="566"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>线程池的实现(CILB):&lt;/p>
&lt;p>thread1 需要找到一种方法来发现有新的任务可以执行.
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-15-52_hu6062ae083bda93fd6d07b13dc77a746e_457683_347386d8c0afd36698d48e122a0c1825.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-15-52_hu6062ae083bda93fd6d07b13dc77a746e_457683_b919d83502c83d6232a5d7d03bf95db5.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-15-52_hu6062ae083bda93fd6d07b13dc77a746e_457683_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-15-52_hu6062ae083bda93fd6d07b13dc77a746e_457683_347386d8c0afd36698d48e122a0c1825.webp"
width="760"
height="593"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>所以thread 0不能简单的调用foo, 它的作用是执行foo.&lt;/p>
&lt;p>但需要在执行foo前,把特殊的东西放入工作队列中.&lt;/p>
&lt;p>此时如果另一个线程突然变得空闲, 它就可以从工作队列中获取任务.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-26-10_hu0eab66eeb24e199a2ed3f547cb3fdbbd_614646_2713f0abd710a06c367e46d38effce5b.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-26-10_hu0eab66eeb24e199a2ed3f547cb3fdbbd_614646_df1c7581b35efeb6316a776aaa66ab1c.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-26-10_hu0eab66eeb24e199a2ed3f547cb3fdbbd_614646_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-26-10_hu0eab66eeb24e199a2ed3f547cb3fdbbd_614646_2713f0abd710a06c367e46d38effce5b.webp"
width="760"
height="564"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>为什么不把foo放入队列, 直接执行bar呢?(上面是执行foo bar放入队列)&lt;/p>
&lt;p>这涉及到 continuation first(child stealing) 和 child first(continuation stealing) 的问题.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-34-20_hufa1a658f74f9b4a90809f48194848857_696273_fe7736de0427a88b81b2c7d0be7754ad.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-34-20_hufa1a658f74f9b4a90809f48194848857_696273_cb1ddf6b4689a69077e0506ca9f22a9f.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-34-20_hufa1a658f74f9b4a90809f48194848857_696273_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-34-20_hufa1a658f74f9b4a90809f48194848857_696273_fe7736de0427a88b81b2c7d0be7754ad.webp"
width="760"
height="567"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-36-22_huf67bed5371ecbc7f84d380e6087a42a4_776363_40fcf8e5060f66ffb6e517fa52d3f196.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-36-22_huf67bed5371ecbc7f84d380e6087a42a4_776363_ecff36fcf2da6712dd8f81729708df45.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-36-22_huf67bed5371ecbc7f84d380e6087a42a4_776363_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-36-22_huf67bed5371ecbc7f84d380e6087a42a4_776363_40fcf8e5060f66ffb6e517fa52d3f196.webp"
width="760"
height="570"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>continuation first会导致线程0的大量工作排队.(广度优先队列)
child first会导致其他线程把下一个任务偷走时, 会导致线程0的工作队列为空.(深度优先队列)&lt;/p>
&lt;p>实际上child first是合理的.(在递归中是最合适的)&lt;/p>
&lt;p>在递归程序中,会先将所有深度的任务放入队列中.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-48-23_hu66dd5b38ec1cb04147fc744f7a6b03af_704850_1c76cdef873f64be703a63df2b13a2f4.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-48-23_hu66dd5b38ec1cb04147fc744f7a6b03af_704850_46b3b02be3b190b15285021529e61fd4.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-48-23_hu66dd5b38ec1cb04147fc744f7a6b03af_704850_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-48-23_hu66dd5b38ec1cb04147fc744f7a6b03af_704850_1c76cdef873f64be703a63df2b13a2f4.webp"
width="760"
height="567"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>按照之前优先执行大任务的策略, 其他线程会优先从队列顶部(先入的)中偷取任务.
因为在分而治之的算法中, 大任务会被分解成小任务, 因此大任务会先被放入队列中.&lt;/p>
&lt;p>实际中使用了双端队列:&lt;/p>
&lt;ul>
&lt;li>从队列头部获取任务&lt;/li>
&lt;li>从队列尾部放入任务&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-52-42_hu052208d2ad01dc27d0149b8c74cf57ec_616787_49c97faec0e975c38ed21774d1caec1a.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-52-42_hu052208d2ad01dc27d0149b8c74cf57ec_616787_7bf3fcf44cbc5d63c27fb37d53c448c5.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-52-42_hu052208d2ad01dc27d0149b8c74cf57ec_616787_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-52-42_hu052208d2ad01dc27d0149b8c74cf57ec_616787_49c97faec0e975c38ed21774d1caec1a.webp"
width="760"
height="571"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>但之前有一个问题: 很多队列,该从哪个队列中获取任务呢?
也许是随机的. 偷取任务的时候, 不随机的更可能会引起负载不均衡.&lt;/p>
&lt;p>本地线程访问的是本地队列的尾部, 偷取时也是放入尾部.(偷其他队列的头部)
这样也有利于空间局部性.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-58-04_huef94ca176ae555045fd9f51c7aa174d2_800473_b158461eeda1557071d3b4c63c8e3fe8.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-58-04_huef94ca176ae555045fd9f51c7aa174d2_800473_9d3eab37557ed64ca33376a218896efe.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-58-04_huef94ca176ae555045fd9f51c7aa174d2_800473_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-16-10-58-04_huef94ca176ae555045fd9f51c7aa174d2_800473_b158461eeda1557071d3b4c63c8e3fe8.webp"
width="760"
height="567"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>那么如何实现同步呢?&lt;/p>
&lt;p>Example1: stalling join policy
拖延政策: 所有我创建的任务都必须完成后, 我才能继续执行.
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-11-01-00_hu7eda749a9f38115f90e5a19b6e792dce_643232_b716a896fce22ab605c4290cace396e0.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-11-01-00_hu7eda749a9f38115f90e5a19b6e792dce_643232_5b91177fc136336170132f872072d0ec.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-11-01-00_hu7eda749a9f38115f90e5a19b6e792dce_643232_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-16-11-01-00_hu7eda749a9f38115f90e5a19b6e792dce_643232_b716a896fce22ab605c4290cace396e0.webp"
width="760"
height="572"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>Example2: greedy join policy(cilk的实现方法)&lt;/p>
&lt;p>有一个跟踪数据结构,但那个东西可以四处移动.&lt;/p>
&lt;p>最后一个完成的线程会偷走这个数据结构&lt;/p>
&lt;p>所以一旦最后一个任务完成, 就可以继续执行了.&lt;/p>
&lt;p>这样不会浪费时间等待同步.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-11-04-26_hu803153c610f9240dc37b9df9cd593271_620138_b52217a08b08c5bd606846c2329641a3.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-11-04-26_hu803153c610f9240dc37b9df9cd593271_620138_140ed442354f7ce867bd06440a9c0b7d.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-11-04-26_hu803153c610f9240dc37b9df9cd593271_620138_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-16-11-04-26_hu803153c610f9240dc37b9df9cd593271_620138_b52217a08b08c5bd606846c2329641a3.webp"
width="760"
height="570"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>第一个方法实现起来更简单,但速度更慢.
因为它总是首线程只等待其他线程完成.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-11-09-58_hu4b706f34d698b4c5ca13bee75ebcc6f0_719518_a9b876038607b0430400742d4c1f6534.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-11-09-58_hu4b706f34d698b4c5ca13bee75ebcc6f0_719518_9d10c292ac70375ca23c48a9647fc5ab.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-11-09-58_hu4b706f34d698b4c5ca13bee75ebcc6f0_719518_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-16-11-09-58_hu4b706f34d698b4c5ca13bee75ebcc6f0_719518_a9b876038607b0430400742d4c1f6534.webp"
width="760"
height="570"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-11-10-26_hu503fb65c817ae1cedfa6301188230a3a_411373_6fa573df606795d8a26e44006a6d0209.webp 400w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-11-10-26_hu503fb65c817ae1cedfa6301188230a3a_411373_1efd01f734283ebc6881240856c4c447.webp 760w,
/blog/l5-work-distribution-and-scheduling/img/2023-10-16-11-10-26_hu503fb65c817ae1cedfa6301188230a3a_411373_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l5-work-distribution-and-scheduling/img/2023-10-16-11-10-26_hu503fb65c817ae1cedfa6301188230a3a_411373_6fa573df606795d8a26e44006a6d0209.webp"
width="760"
height="421"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p></description></item><item><title>L6</title><link>https://ysyyhhh.github.io/blog/l6/</link><pubDate>Fri, 01 Mar 2024 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/blog/l6/</guid><description>&lt;p>虚拟文件系统&lt;/p>
&lt;p>/proc/cpuinfo&lt;/p>
&lt;ul>
&lt;li>model name&lt;/li>
&lt;li>cpu MHz - 频率&lt;/li>
&lt;li>cache size - 缓存大小&lt;/li>
&lt;li>siblings - 逻辑cpu数量&lt;/li>
&lt;li>processor - 逻辑cpu编号&lt;/li>
&lt;li>cpu cores - 物理cpu数量&lt;/li>
&lt;li>core id - 物理cpu编号&lt;/li>
&lt;li>&lt;/li>
&lt;/ul>
&lt;p>这样查看的cpu数量很多&lt;/p>
&lt;p>siblings是逻辑cpu的数量&lt;/p>
&lt;p>cpu cores是物理cpu的数量&lt;/p>
&lt;p>为什么报告的processor数量是40而siblings是20呢?
因为报告的processor包括超线程的逻辑cpu. 这样操作系统就可以直接根据逻辑cpu的数量来分配任务.&lt;/p>
&lt;p>Memory bandwidth - 内存带宽
Power consumption - 功耗
能源消耗实际上是一个很大的问题.
Intel code name - 代号
Functional units&lt;/p>
&lt;ul>
&lt;li>latency - 延迟&lt;/li>
&lt;li>issue time - 发射时间&lt;/li>
&lt;li>capacity - 容量&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="http://www.agner.org/optimize/microarchitecture.pdf" target="_blank" rel="noopener">微处理架构&lt;/a>&lt;/p>
&lt;h2 id="function-units">function units&lt;/h2>
&lt;ul>
&lt;li>latency - 延迟，执行一个指令所需要的时钟周期数(不包括等待)&lt;/li>
&lt;li>issue time - 发射时间，指令发射到执行所需要的时钟周期数(包括等待)&lt;/li>
&lt;li>capacity - 容量&lt;/li>
&lt;/ul>
&lt;p>优化的地方:&lt;/p>
&lt;ul>
&lt;li>搞清楚到底哪些代码是执行次数最多的(内部循环)(对实际使用情况来说)&lt;/li>
&lt;li>基本运算消耗时间: 除法 &amp;gt; 乘法 &amp;gt; 加法 &amp;gt; 位移&lt;/li>
&lt;/ul>
&lt;p>基本的程序:
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l6/img/2023-10-17-20-22-45_hu85293fdaa222549af0ddcf65b2bf7284_658635_5ab47a1042335e55b8938e5994f8e82a.webp 400w,
/blog/l6/img/2023-10-17-20-22-45_hu85293fdaa222549af0ddcf65b2bf7284_658635_e757e717e52c37dae010bd08781bf275.webp 760w,
/blog/l6/img/2023-10-17-20-22-45_hu85293fdaa222549af0ddcf65b2bf7284_658635_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l6/img/2023-10-17-20-22-45_hu85293fdaa222549af0ddcf65b2bf7284_658635_5ab47a1042335e55b8938e5994f8e82a.webp"
width="760"
height="362"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>合并重复计算的简单的提升:
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l6/img/2023-10-17-20-23-02_hudb10c716aa5853d9906cab8e836be839_490764_e61947fe8d466c3906248b8957252142.webp 400w,
/blog/l6/img/2023-10-17-20-23-02_hudb10c716aa5853d9906cab8e836be839_490764_139df3e7b8e363317855fbed39089e3f.webp 760w,
/blog/l6/img/2023-10-17-20-23-02_hudb10c716aa5853d9906cab8e836be839_490764_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l6/img/2023-10-17-20-23-02_hudb10c716aa5853d9906cab8e836be839_490764_e61947fe8d466c3906248b8957252142.webp"
width="760"
height="363"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l6/img/2023-10-17-20-24-13_hud8148b776d8e4bb3b0215a9ad8cf6f95_349342_738cfac8407fe76b9bd88d182792930c.webp 400w,
/blog/l6/img/2023-10-17-20-24-13_hud8148b776d8e4bb3b0215a9ad8cf6f95_349342_63cfbdb2168372034d159f8ad1ec2a56.webp 760w,
/blog/l6/img/2023-10-17-20-24-13_hud8148b776d8e4bb3b0215a9ad8cf6f95_349342_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l6/img/2023-10-17-20-24-13_hud8148b776d8e4bb3b0215a9ad8cf6f95_349342_738cfac8407fe76b9bd88d182792930c.webp"
width="760"
height="389"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>将除法次数减少,(不依赖于内层循环的变量的计算拿出来)&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l6/img/2023-10-17-20-24-42_hu3b7220bf0b4c94aedaa80f1185888619_507170_9095d26daddab8794efd73a5792f17c3.webp 400w,
/blog/l6/img/2023-10-17-20-24-42_hu3b7220bf0b4c94aedaa80f1185888619_507170_5ff7d026f194e0d2cd56e0d7a8225adb.webp 760w,
/blog/l6/img/2023-10-17-20-24-42_hu3b7220bf0b4c94aedaa80f1185888619_507170_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l6/img/2023-10-17-20-24-42_hu3b7220bf0b4c94aedaa80f1185888619_507170_9095d26daddab8794efd73a5792f17c3.webp"
width="760"
height="383"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>循环展开 loop unrolling&lt;/p>
&lt;p>如果每一次循环都要进行一次是否终止的测试,开销会很大.(尤其是一次循环的计算 相比于 循环次数来说很小 时)&lt;/p>
&lt;p>所以处理器从简单的策略开始,如预测循环的次数. 大部分都是基于统计预测的.&lt;/p>
&lt;p>如果可以预测循环的次数,就可以将循环展开. 每次循环多执行4 或 8 或&amp;hellip;次原来循环做的事情.&lt;/p>
&lt;p>但展开时不一定均匀,&lt;/p>
&lt;p>uniform可以使得循环展开的更好.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l6/img/2023-10-17-20-35-48_huf0320ca0eb40e0cc3f8446f56f4bb928_788707_4a9e00eea4a0274ea68f3d4c2a674fbf.webp 400w,
/blog/l6/img/2023-10-17-20-35-48_huf0320ca0eb40e0cc3f8446f56f4bb928_788707_2f730b863ed7aa2fc673db2504200996.webp 760w,
/blog/l6/img/2023-10-17-20-35-48_huf0320ca0eb40e0cc3f8446f56f4bb928_788707_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l6/img/2023-10-17-20-35-48_huf0320ca0eb40e0cc3f8446f56f4bb928_788707_4a9e00eea4a0274ea68f3d4c2a674fbf.webp"
width="760"
height="459"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l6/img/2023-10-17-20-39-50_hu45d93cab90138384d4beff72db4bc99e_596600_e755b84003b152ad93396cb9cfcd83e7.webp 400w,
/blog/l6/img/2023-10-17-20-39-50_hu45d93cab90138384d4beff72db4bc99e_596600_800800c4cbdaf41f00d08bd8121bf03d.webp 760w,
/blog/l6/img/2023-10-17-20-39-50_hu45d93cab90138384d4beff72db4bc99e_596600_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l6/img/2023-10-17-20-39-50_hu45d93cab90138384d4beff72db4bc99e_596600_e755b84003b152ad93396cb9cfcd83e7.webp"
width="760"
height="452"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>为什么8维向量获得了超过8倍的加速呢?
因为uniform, 原本要做8次的判断,现在只需要做一次.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l6/img/2023-10-17-20-42-45_hudc3741a959af0eae57271f90b977df00_280278_baf35b7a782eb349a2031ec1a434ece4.webp 400w,
/blog/l6/img/2023-10-17-20-42-45_hudc3741a959af0eae57271f90b977df00_280278_93cfbec29770590a36c25754a7afcd12.webp 760w,
/blog/l6/img/2023-10-17-20-42-45_hudc3741a959af0eae57271f90b977df00_280278_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l6/img/2023-10-17-20-42-45_hudc3741a959af0eae57271f90b977df00_280278_baf35b7a782eb349a2031ec1a434ece4.webp"
width="760"
height="306"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>常规优化提升了15倍
向量优化提升了5.4倍
总计提升了82倍&lt;/p>
&lt;p>向量化很好且是free的,但不能忽略了传统的优化&lt;/p>
&lt;p>传统的优化(213 program)使得速度提升了三倍&lt;/p>
&lt;p>要做到极致的优化,就比如要花3个星期的时间在编码风格上, 最后30分钟花在向量化上.&lt;/p>
&lt;p>但要看情况来决定编码风格的优化.
因为如果我们编写的代码不是执行次数最多(如内核,场景仿真,高频), 那么可能更需要的是可读性.&lt;/p>
&lt;p>可读性变差 可能会导致bug很容易被引入, 并且非常不容易被发现和维护.&lt;/p></description></item><item><title>L7</title><link>https://ysyyhhh.github.io/blog/l7/</link><pubDate>Fri, 01 Mar 2024 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/blog/l7/</guid><description>&lt;p>GPU&lt;/p>
&lt;h2 id="图形渲染">图形渲染&lt;/h2>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/l7/img/2023-10-18-22-45-21_huf26ab9cd16631e333ae7f2c3af77eb19_132208_4715ef0685f9d6c48ae4ca6038102849.webp 400w,
/blog/l7/img/2023-10-18-22-45-21_huf26ab9cd16631e333ae7f2c3af77eb19_132208_d0293c4adf5cdc95de68440138589056.webp 760w,
/blog/l7/img/2023-10-18-22-45-21_huf26ab9cd16631e333ae7f2c3af77eb19_132208_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/l7/img/2023-10-18-22-45-21_huf26ab9cd16631e333ae7f2c3af77eb19_132208_4715ef0685f9d6c48ae4ca6038102849.webp"
width="686"
height="519"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>图像中的每个对象都有很自然的并行性。&lt;/p></description></item><item><title>NoRBERT：使用迁移学习改进需求分类任务</title><link>https://ysyyhhh.github.io/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/</link><pubDate>Fri, 01 Mar 2024 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/</guid><description>&lt;p>NoRBERT: Transfer Learning for Requirements Classification
Tobias Hey， Jan Keim， Anne Koziolek， Walter F. Tichy
Karlsruhe Institute of Technology (KIT)&lt;/p>
&lt;h2 id="引用">引用&lt;/h2>
&lt;p>T. Hey, J. Keim, A. Koziolek and W. F. Tichy, &amp;ldquo;NoRBERT: Transfer Learning for Requirements Classification,&amp;rdquo; 2020 IEEE 28th International Requirements Engineering Conference (RE), Zurich, Switzerland, 2020, pp. 169-179, doi: 10.1109/RE48521.2020.00028.&lt;/p>
&lt;p>论文：https://sdq.kastel.kit.edu/publications/pdfs/hey2020.pdf
仓库：https://github.com/tobhey/NoRBERT&lt;/p>
&lt;h2 id="摘要">摘要&lt;/h2>
&lt;p>本文提出了NoRBERT，它使用了BERT模型进行微调，在需求工程领域进行迁移学习。他在PROMISE NFR数据集上，对功能性和非功能性需求的分类任务F1分数高达94％。对于分类非功能性需求的子类，超越了最近的方法，最常见的类别平均F1分数达到87%。在一个未见过的项目设置下，它比最近的方法高出15个百分点。此外，我们根据所包含的关注点，即功能、数据和行为，来分类功能性要求，标记了PROMISE NFR数据集中的功能性需求，并应用于测试NoRBERT，最终取得了高达92%的F1分数。NoRBERT提高了需求分类的准确性，并且可以很好地应用于未见过的项目。&lt;/p>
&lt;h2 id="1-引言">1 引言&lt;/h2>
&lt;p>需求的主要来源仍然是自然语言文档。对需求进行分类对于在项目早期识别出特定需求（如与安全相关的需求）非常重要。尽管已有的自动分类方法在多样化数据集上表现不错，但它们在未见过的项目上的性能会下降，因为需求的表述和结构依赖于项目和作者，而现有方法缺乏泛化能力。为了解决这个问题，我们探索了迁移学习方法，这种方法在NLP领域广泛应用，通过在大型数据集上训练来捕捉文本的深层含义，并能针对特定任务进行微调，从而在少量数据下实现更好的性能和泛化。
我们提出了NoRBERT方法，它基于BERT模型。BERT是一种预训练在大型文本语料库上的语言模型。BERT可以通过提供少量数据在特定任务上进行微调。我们使用NoRBERT在PROMISE NFR数据集上进行需求分类，并测试了其在重新标记的NFR数据集上的泛化能力。此外，我们还使用NoRBERT根据Glinz提出的关注点对功能性需求进行分类。这种方法在需求工程中特别有用，因为它可以在有限的标记数据情况下提供有效的分类。
本文的贡献包括以下三方面：
我们研究了通过迁移学习对已知和未知项目的需求进行分类的改进程度。
我们提供了一个新的数据集，根据功能、数据和行为的关注点进一步对功能性需求进行分类。
我们评估了基于迁移学习的方法在新数据集和任务上的表现。&lt;/p>
&lt;h2 id="2-技术介绍">2 技术介绍&lt;/h2>
&lt;h3 id="21相关工作">2.1相关工作&lt;/h3>
&lt;p>在需求工程领域，功能性需求与非功能性需求的区分是一个广泛研究的主题。功能性需求指的是系统必须执行的具体任务，而非功能性需求则涉及系统的质量标准，如性能、可靠性等，它们没有明确的执行标准。一些研究者将非功能性需求视为质量目标，而另一些则将其归类为系统属性或约束。
自动从文档中提取和分类需求是研究者关注的重点，已经发展出多种方法。例如，Cleland-Huang等人利用信息检索技术，通过识别指示词来分类需求，但这种方法在精确度上有所欠缺。Hussain等人通过使用特定词汇和决策树分类器改进了需求分类。Kurtanović和Maleej则采用自动化特征选择来预测需求类别。还有研究者使用深度学习技术，如卷积神经网络（CNN），来分类需求。
尽管这些方法展示了不同技术的潜力，但它们在实际应用中可能存在局限性，如过度依赖特定数据集、对措辞和句子结构敏感，或需要手动预处理。此外，这些方法在泛化到新项目上的能力上也存在不足。为了解决这些问题，我们尝试迁移学习方法，以期望在较少的训练数据下实现更好的性能和泛化能力。&lt;/p>
&lt;h3 id="22-bert介绍">2.2 BERT介绍&lt;/h3>
&lt;p>BERT（Bidirectional Encoder Representations from Transformers）是一种语言模型（LM）。用于预测词序列中词的概率，具有迁移学习的能力，即能在微调后适应不同任务。它起源于词嵌入技术，如word2vec，但通过使用ELMo的双向LSTM解决了word2vec忽略词义歧义的问题。BERT采用预训练和微调的方法进一步发展了语言模型，。
BERT的核心是Transformer架构，它用自注意力编码器-解码器结构替代了LSTM。自注意力层让模型能够识别并赋予相关词更高的权重，而忽略不相关的词。Transformer的多头注意力机制使模型能同时关注不同位置的词，提高了对词义的理解。
BERT的训练结合了双向预训练和掩码语言建模。在训练中，一部分输入词被掩码，模型需要预测这些词，同时学习判断句子是否可能连续。这种训练方法使BERT在多个NLP任务上取得了优异的表现。
BERT有两个版本：基础模型和大模型，分别具有不同数量的编码器层、隐藏单元和注意力头，参数数量也有所不同。基础模型有1.1亿参数，而大模型有3.4亿参数。BERT最初是在英文维基百科和BooksCorpus上训练的。BERT和类似的方法目前正在取代传统的自然语言处理系统。Tenney等人对BERT的不同层次和底层学习结构的分析表明，BERT重塑了类似于NLP流水线的相似结构。
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-06-42_huc8b64004ae082380fceeb6a9cfbbeb07_31345_3c1781b45a3d97aba38f4017c3469efb.webp 400w,
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-06-42_huc8b64004ae082380fceeb6a9cfbbeb07_31345_132fca3f76a341537ef1ec54a8e7014b.webp 760w,
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-06-42_huc8b64004ae082380fceeb6a9cfbbeb07_31345_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-06-42_huc8b64004ae082380fceeb6a9cfbbeb07_31345_3c1781b45a3d97aba38f4017c3469efb.webp"
width="522"
height="293"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
图1：用于微调 BERT 进行分类的架构。
图1展示了如何使用BERT进行分类。输入被分词。BERT的第一个输入标记始终是特殊标记[CLS]。标记[SEP]是一个特殊的分隔符标记，例如用于分隔句子，而标记[PAD]用于填充。对于分类和类似的下游任务，BERT产生的唯一输出是BERT为第一个标记([CLS])产生的输出，这是所有标记的聚合输出。这个聚合输出可以输入到一个单层前馈神经网络中，该网络使用softmax为不同类别分配概率。&lt;/p>
&lt;h2 id="3-实验评估">3 实验评估&lt;/h2>
&lt;h3 id="31-实验设置">3.1 实验设置&lt;/h3>
&lt;p>研究问题。在本文中，我们研究以下研究问题：
RQ1：迁移学习在需求分类中的表现如何？
RQ2：迁移学习是否提高了在未见项目上对需求进行分类的性能？
RQ3：迁移学习方法能够多大程度上检测到功能性需求的子类？
评估数据集。为了回答RQ1和RQ2，我们利用了两个现有的数据集。一个是广泛使用的PROMISE NFR数据集，该数据集在RE'17数据挑战中进行了处理，另一个是由Dalpiaz等人提供了一个重新标记的版本。前者来自15个项目的625个需求。这625个需求包括255个功能性需求和370个非功能性需求。表I显示了数据集中类别的分布以及每个类别需求的平均长度。每个需求只被标记为一个类别（F或11个NFR子类之一）。这些类别的分布不均匀。该数据集中F类要比NFR类少115个，且NFR子类的数量差异很大，从可用性的67个到可移植性的1个不等。可用性、安全性、操作性和性能是超过50个示例的类别，而容错性、法律性、可维护性和可移植性的类别则低于20个。
表I：原始 NFR 数据集的分布
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-06-59_hu388e9616551c1f5bdec730c883c65300_84423_70eead7a812275fb0c16047b4993e02c.webp 400w,
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-06-59_hu388e9616551c1f5bdec730c883c65300_84423_2f89f33ca0f4dcb3b1a90ef60ee5cdcd.webp 760w,
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-06-59_hu388e9616551c1f5bdec730c883c65300_84423_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-06-59_hu388e9616551c1f5bdec730c883c65300_84423_70eead7a812275fb0c16047b4993e02c.webp"
width="554"
height="377"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
由于数据集中F和NFR之间的区分有争议，并且数据集包含重复和错误标记的需求，Dalpiaz等人提供了一个重新标记的数据集。表II展示了数据集的概述。它仅由原始625个需求中的612个组成，并且仅使用了两个类别。一个需求可以具有功能性（F）或质量方面（Q）或两者都有。80个需求两者都有。230个需求仅具有功能性方面（OnlyF），而302个需求仅包含质量方面（OnlyQ）。
表II：重新标记的 NFR 数据集的分布
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-07-15_hu02e0e06c76d63d35764eae008a391e88_45107_c74c6d3c38e54489cfb77b0ebc0d1c64.webp 400w,
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-07-15_hu02e0e06c76d63d35764eae008a391e88_45107_47fb1dd26c8aa895635ef42f0c40500a.webp 760w,
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-07-15_hu02e0e06c76d63d35764eae008a391e88_45107_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-07-15_hu02e0e06c76d63d35764eae008a391e88_45107_c74c6d3c38e54489cfb77b0ebc0d1c64.webp"
width="554"
height="195"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
对比方法。基于数据集，我们将我们的方法应用于以下任务：
任务1：在原始NFR数据集上对F/NFR进行二元分类。
任务2：在原始NFR数据集上对四个最常见的NFR子类（US，SE，O，PE）进行二元和多类分类。
任务3：在原始NFR数据集中对所有NFR子类进行多类分类。
任务4：使用Dalpiaz等人提供的重新标记的NFR数据集，根据功能和质量方面对需求进行二元分类。
评估指标。对于所有任务，使用精确率（P）、召回率（R）和F1分数（F1）。对于多类分类，还报告了预测类别的加权平均F1分数（A）。
采用不同的设置来评估这些任务，包括使用.75-split描述了一个单次分成75%训练和25%测试集分割的数据集，以及使用了分层的10折交叉验证，即将数据集分割为10次，其中90%为训练集，10%为测试集，并对结果进行平均。分层分割确保数据集中类别的分布在训练集和测试集中保持一致。
为了进一步研究方法的可迁移性，使用了两种特定于项目的折叠策略。使用p-fold描述了Dalpiaz等人使用的项目级交叉验证，将数据集分割为10次，其中3个项目作为测试集，12个项目作为训练集，确保功能和质量方面的均匀分布。此外，还使用了一种留一项目交叉验证（loPo），即在n-1个项目上进行n次训练，并在留出的项目上进行测试。对于像NFR子类这样高度不平衡的二元任务，我们尝试了欠采样和过采样策略。我们还尝试了早期停止（ES）和不同的训练周期数。早期停止是一种常用的正则化技术，用于避免迭代学习器过拟合。&lt;/p>
&lt;h3 id="32norbert-使用bert进行非功能性和功能性需求分类">3.2NORBERT: 使用BERT进行非功能性和功能性需求分类&lt;/h3>
&lt;p>我们使用BERT的微调版本来研究迁移学习对需求分类任务的影响。
我们使用了两种不同的预训练BERT模型，基础和大型模型，都是带词性的版本。我们还尝试了不带词性的模型，但带词性的模型表现更好。这可能是因为需求中使用的命名实体被误认为是普通名词。我们使用BERT分词器，不对需求进行预处理。在预训练模型的基础上，我们定义了输出层，即分类头。我们使用BERT的序列中的第一个标记[CLS]的输出。这个输出被输入到由一个单层的线性神经元组成的前馈神经网络的分类头。输出直接计算自加权输入的总和（再加上一些偏差）。我们使用softmax函数为不同的标签获得概率分布。在训练过程中，我们使用交叉熵损失函数，并使用以下公式量化预测分布与真实分布的接近程度。：&lt;/p>
&lt;p>H(p，q)=-∑_x▒〖p(x) log⁡〖q(x)〗 〗&lt;/p>
&lt;p>p(x)表示目标概率，q(x)表示实际概率，x代表不同的标签。对于正确标签，p(x)设为1，其他错误标签设为0。损失函数旨在惩罚不准确或不确定的预测，同时奖励那些准确的自信预测。
我们使用AdamW优化器而非传统的随机梯度下降来更新网络权重。AdamW引入了权重衰减校正，但不补偿偏差。我们设置权重衰减为0.01，最大学习率为2e-05，与BERT原始论文中的设置相同。实验表明，批量大小16在所有测试中表现最佳。我们根据模型大小设定最大序列长度，以优化性能并避免内存问题。
在微调NoRBERT的超参数时，我们认为增加训练周期可以提高模型对训练数据的拟合度，但也可能增加过拟合的风险。实验显示，对于二元分类，10到32个训练周期，对于多类分类，10到64个训练周期效果最佳。&lt;/p>
&lt;h3 id="33任务1分类功能性和非功能性需求">3.3任务1分类功能性和非功能性需求&lt;/h3>
&lt;p>对于第一个任务，我们想要衡量NoRBERT在原始PROMISE NFR数据库上将需求分类为功能性（F）或非功能性（NFR）的性能。
我们使用分层10折交叉验证设置来回答关于迁移学习在需求分类性能方面的RQ1。我们训练了二元分类模型，即预测一个需求是F还是NFR，并与其他最新方法进行比较。
表III：在 PROMISE NFR 数据集上的 F/NFR 分类。粗体数值显示每个类别的每个指标的最高得分。
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-07-28_hu2335320fabdcdd914c3c2750d176ede8_133308_e10aa20ebe9e75babaeb2be06f5cba26.webp 400w,
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-07-28_hu2335320fabdcdd914c3c2750d176ede8_133308_ba29e752a0afb1564f99fce882834466.webp 760w,
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-07-28_hu2335320fabdcdd914c3c2750d176ede8_133308_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-07-28_hu2335320fabdcdd914c3c2750d176ede8_133308_e10aa20ebe9e75babaeb2be06f5cba26.webp"
width="507"
height="360"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
表III显示了我们的结果与其它方法报告的结果的比较。NoRBERT 在功能性需求和非功能性需求的 F1 分数上分别为 90% 和 93%。在NFR上，除了依赖手动提供的字典和规则进行数据预处理的Abad等人的方法外，NoRBERT超过了所有其他方法。NoRBERT与之相比不需要手动预处理，因此可以轻松地迁移到任何其他数据集。
我们的10折交叉验证结果显示，模型性能不受BERT模型选择或训练周期数的显著影响。Kurtanovi ´c和Maleej在功能性需求上取得了更高的F1分数，但他们的方法可能存在过拟合问题。
表III中的结果也有助于回答关于我们方法泛化能力的RQ2。10折没有考虑到数据集包含不同项目、不同领域和措辞。为了评估在未见过的项目上的性能，我们使用了特定于项目的设置（loPo和p-fold）。结果与10折评估相似或更好。这表明NoRBERT能够从训练期间看到的措辞中泛化出来。在不同项目和领域的数据集上，NoRBERT也能保持稳定性能。这与需要针对每个项目调整的手动字典和规则定义方法形成鲜明对比。&lt;/p>
&lt;h3 id="34-非功能性需求子类的分类">3.4 非功能性需求子类的分类&lt;/h3>
&lt;p>为了解决PROMISE NFR数据库中定义的非功能性需求（NFR）子类的分类任务。首先研究了数据库中四个最频繁的NFR子类的分类（任务2）。接着还研究了所有NFR子类的分类（任务3）。&lt;/p>
&lt;h4 id="a-任务2-最常见nfr子类的分类">A. 任务2: 最常见NFR子类的分类&lt;/h4>
&lt;p>我们使用NoRBERT对四种最常见的NFR进行了二元和多类分类。结果显示，NoRBERT在二元分类中取得了高达83%的加权平均F1分数，在多类分类中达到了87%。NoRBERT在大多数类别上的表现都超过了Kurtanovi´c和Maleej的模型。此外，NoRBERT在不同设置下的表现也有所不同，最佳二元分类结果是在16个周期、过采样和早停的情况下获得的。
表V: NFR 数据集上所有 NFR 子类的多类别分类。16、32 和 50 表示使用的时代数，bin 表示二元分类，mult 表示多类分类，B 和 L 分别表示使用的 BERT 模型（基础/大型）。bin16 还额外使用了 OS，multiL32 使用了 ES。LDA 和 NB（朴素贝叶斯）是指 Abad 等人的方法，其中有（P）或没有（UP）预处理过的数据。
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-07-38_huba703d7661994bccd6dab0abad0e6024_137406_528dccf1c61689f97642321c7a35c991.webp 400w,
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-07-38_huba703d7661994bccd6dab0abad0e6024_137406_ff72545e5cc5db6610093f4866007b5e.webp 760w,
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-07-38_huba703d7661994bccd6dab0abad0e6024_137406_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-07-38_huba703d7661994bccd6dab0abad0e6024_137406_528dccf1c61689f97642321c7a35c991.webp"
width="554"
height="179"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h4 id="b-任务3-所有nfr子类的多类分类">B. 任务3: 所有NFR子类的多类分类&lt;/h4>
&lt;p>我们使用NoRBERT对所有NFR子类别进行了多类分类。多类分类器尤其是在代表数量较少的类别上表现良好。所有多类模型在平均性能上都优于相应的二元分类器。基于BERT-large的模型在这项任务上表现最佳，这可能是因为它们具有更大的参数空间，能够更好地处理语言的微妙差异。NoRBERT在这项任务上的表现超过了Navarro-Almanza等人的方法，这表明迁移学习在这项任务上优于基于词嵌入的深度学习。
我们还探讨了NoRBERT在未见过的项目上的性能（RQ2）。在p折和loPo设置中，NoRBERT的性能略有下降，但多类分类器仍然优于二元分类器。尽管在loPo设置中NoRBERT的表现略逊于p折，但多类分类器和大型模型在所有设置中都优于二元分类器。
NoRBERT在分类NFR子类别方面表现出色，即使在训练数据有限的情况下也能识别出代表性不足的子类别。NoRBERT提供了一种可行的方法来替代手动数据预处理。&lt;/p>
&lt;h3 id="35-任务4-功能性和质量方面的分类">3.5 任务4: 功能性和质量方面的分类&lt;/h3>
&lt;p>功能性（F）和非功能性需求（NFR）之间的区别并不总是清晰的，一些需求包含了两者的方面。因此，我们在Dalpiaz等人提供的重新标记的PROMISE NFR数据库上衡量NoRBERT的性能[9]，并将NoRBERT与Kurtanovi´c和Maleej[8]的方法进行比较。
表 VI：重新标记的 PROMISE NFR 数据集中类的二元分类。粗体数值代表每个类别每个指标的最高分。星号标记的 F1 分数与其他出版物报道的精度和召回率不匹配。
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-07-44_hu451a5970b1399f4901b17b67f458adc0_110807_f9c826fb2c531078bb010cbbd3b32e88.webp 400w,
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-07-44_hu451a5970b1399f4901b17b67f458adc0_110807_400b1161088cb767f7f83b529a74a4c9.webp 760w,
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-07-44_hu451a5970b1399f4901b17b67f458adc0_110807_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-07-44_hu451a5970b1399f4901b17b67f458adc0_110807_f9c826fb2c531078bb010cbbd3b32e88.webp"
width="554"
height="213"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
表VI显示了在重新标记集上训练的二元分类器的结果。我们使用与Dalpiaz等人相同的设置，即.75-split、10-fold、p-fold和随机种子（42），此外还评估了loPo设置。NoRBERT在所有这些设置中都优于其他方法。因此，迁移学习方法明显提高了分类需求的性能（RQ1）。
在.75分割中，NoRBERT的基础模型在纯功能或质量类别上表现更佳，而大型模型在其他类别上表现更好。在10折交叉验证中，NoRBERT的最佳模型平均优于Dalpiaz等人的最佳模型10个百分点，尤其在仅含功能方面的需求上（F1得分91% vs 73%）。p折和loPo的结果显示NoRBERT在未见项目上的迁移能力强。与Kurtanovi´c和Maleej的方法相比，NoRBERT在处理未见项目上表现更好，平均F1得分高出15个百分点。
这表明NoRBERT具有良好的泛化能力，无需重新训练即可在实际项目中使用。我们认为，在评估需求分类方法时，应更重视其在未见项目上的表现。&lt;/p>
&lt;h3 id="36功能性需求的分类">3.6功能性需求的分类&lt;/h3>
&lt;p>NoRBERT在分类非功能性需求上表现出了良好的效果。现在研究它在分类功能性需求方面的表现。功能性需求通常根据它们所属的产品部分（例如用户界面或业务逻辑）来分类。有些模型则采用基于关注点的方法，包括功能性和行为性需求以及数据。如果我们想要开发能够自动理解功能性需求的系统，比如自动化追踪或建模系统，那么了解功能性需求的子类别就很重要，因为它们定义了需求可能的实现方式。
我们采用了Glinz提出的基于关注点的模型，它帮助我们理解功能性需求是描述系统的功能、系统展示的行为，还是仅仅是数据和数据结构。我们使用以下子类别：
功能：系统应执行的功能。 例子：系统应允许房地产经纪人查询MLS信息。
数据：应成为系统状态一部分的数据项或数据结构。 例子：审计报告应包括估计中使用的回收部件总数。
行为：系统展示的行为或由一个或多个刺激触发的反应。 例子：如果射门被标记为命中，产品应允许进攻球员定义射门。
需求可能包含多个关注点，这些类别可能会重叠，例如，“只有注册客户可以购买流媒体电影”。它既包含功能也包含行为。
为了回答RQ3，即迁移学习方法是否能够识别功能性需求中的关注点，由两位作者独立手动标记了PROMISE NFR数据集中的310个功能性需求。我们使用了Krippendorff的α（Kα）来衡量标注者间的一致性，发现功能和数据类别的一致性超过了0.8，而行为类别的一致性为0.752，虽然略低，但仍然是可接受的。
表VII: 功能性需求数据集概述
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-07-53_huc2ad73bdeda65935e5b408996e7bffdf_39679_375dd2a87193dc3e3b5df6204b31e3da.webp 400w,
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-07-53_huc2ad73bdeda65935e5b408996e7bffdf_39679_44287f837bac2078888284819104f442.webp 760w,
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-07-53_huc2ad73bdeda65935e5b408996e7bffdf_39679_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-07-53_huc2ad73bdeda65935e5b408996e7bffdf_39679_375dd2a87193dc3e3b5df6204b31e3da.webp"
width="554"
height="127"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
表VII显示了项目中类别的分布。需求的数量少于每个项目中类别代表的数量，因为每个需求可能包含多个关注点。项目11到14包含的需求数量较少，因为它们主要由非功能性需求组成。
A. 在功能性需求数据集上评估NoRBERT
我们使用标记好的数据集来评估NoRBERT在分类功能性需求上的表现。我们训练了二元分类模型，并在10折交叉验证和loPo（低代表性项目）设置下进行了评估。
表 VIII：使用 NoRBERT 在新数据集上对功能性需求子类进行二元分类，采用 10 折交叉验证和 loPo 设置。粗体数值代表每个类别每个指标的最高分。b 和 l 分别代表基础模型和大型模型
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="" srcset="
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-08-03_hu40c15b79533008f61d7df5aa86d8eea3_116653_6b3b08e00faba501d946fd636ee5c031.webp 400w,
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-08-03_hu40c15b79533008f61d7df5aa86d8eea3_116653_9a8c617c4e0be7eaae5dbeb72d0bf711.webp 760w,
/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-08-03_hu40c15b79533008f61d7df5aa86d8eea3_116653_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/norbert%E4%BD%BF%E7%94%A8%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%94%B9%E8%BF%9B%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/img/2024-03-01-10-08-03_hu40c15b79533008f61d7df5aa86d8eea3_116653_6b3b08e00faba501d946fd636ee5c031.webp"
width="554"
height="338"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
表VIII结果显示，NoRBERT在功能和行为类别上表现良好，但在数据类别上的召回率较低。这可以归因于这个类别缺乏训练数据和数据集的不平衡。我们发现欠采样和过采样对不同类别的影响不同。
在loPo设置中，NoRBERT的表现与10折交叉验证相似，功能类别的F1分数甚至略有提高，但数据类别的性能下降到了56%。尽管如此，与10折交叉验证相比，这个结果仍然是好的。我们还发现，在loPo设置中，大型模型在所有类别上的表现优于基础模型，这可能是因为loPo设置要求更好的泛化能力。
为了回答RQ3，我们可以得出结论，对于这些数据量，NoRBERT在处理功能性需求方面表现不错，尤其是在功能和行为类别上。虽然数据类别的表现有待提高，但通过更多的训练数据，NoRBERT的性能有望进一步提升。这可能有助于能够改进诸如追踪链接恢复或自动化建模等方法。&lt;/p></description></item><item><title>P0 [C++ Primer](https://15445.courses.cs.cmu.edu/fall2022/project0/)</title><link>https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/</link><pubDate>Fri, 01 Mar 2024 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/</guid><description>&lt;h1 id="l1-relational-model--relational-algebra">L1 Relational Model &amp;amp; Relational Algebra&lt;/h1>
&lt;h2 id="11-databases">1.1 Databases&lt;/h2>
&lt;p>数据库：an organized collection of inter-related data that models some aspect of the real-world&lt;/p>
&lt;p>数据库管理系统 DBMS：the software that manages a database&lt;/p>
&lt;h2 id="12-flat-file-strawman">1.2 Flat File Strawman&lt;/h2>
&lt;p>数据库常常以CSV(comma-separated value)文件的形式存储，由DBMS进行管理。每次应用程序要读取或者更新记录时，都必须解析文件(parse files)。&lt;/p>
&lt;h2 id="13-database-management-system">1.3 Database Management System&lt;/h2>
&lt;ul>
&lt;li>A general-purpose(通用) &lt;strong>DBMS&lt;/strong> is designed to allow the definition, creation, querying, update, and administration of databases in accordance with some &lt;strong>data model&lt;/strong>.&lt;/li>
&lt;li>A &lt;strong>data model&lt;/strong> is a collection of concepts for describing the data in database
&lt;ul>
&lt;li>Examples: &lt;strong>relational&lt;/strong> (most common), NoSQL (&lt;strong>key/value&lt;/strong>, graph), array/matrix/vectors&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>A &lt;strong>schema&lt;/strong>(模式) is a description of a particular collection of data based on a &lt;strong>data model&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>早期，数据库应用很难建立和维护，因为逻辑层和物理层之间存在着紧密的耦合。&lt;/p>
&lt;ul>
&lt;li>逻辑层： 描述了数据库有哪些实体和属性。&lt;/li>
&lt;li>物理层： 是这些实体和属性的存储方式。&lt;/li>
&lt;/ul>
&lt;p>所以早期的数据库，一旦改变了物理层，逻辑层也得跟着变。&lt;/p>
&lt;h2 id="14-relational-model">1.4 Relational Model&lt;/h2>
&lt;p>人们每次改变物理层都要重新写数据管理系统，故Ted Codd注意到后提出了关系模型。&lt;/p>
&lt;p>The relational model defines a database abstraction based on relations to avoid &lt;strong>maintenance overhead&lt;/strong>(维护开销).&lt;/p>
&lt;p>三要点:&lt;/p>
&lt;ul>
&lt;li>Store database in simple data structures (relations).&lt;/li>
&lt;li>Access data through high-level language, DBMS &lt;strong>figures out&lt;/strong>(找出) best execution strategy.&lt;/li>
&lt;li>Physical storage &lt;strong>left up to&lt;/strong>(取决于) the DBMS implementation.&lt;/li>
&lt;/ul>
&lt;p>三概念&lt;/p>
&lt;p>The relational data model defines three concepts:&lt;/p>
&lt;ul>
&lt;li>Structure: The definition of relations and their contents. This is the attributes the relations have and the values that those attributes can hold.&lt;/li>
&lt;li>&lt;strong>Integrity&lt;/strong>(完整性): Ensure the database’s contents satisfy constraints.
&lt;ul>
&lt;li>实体完整性 entity integrity:主属性不能为空&lt;/li>
&lt;li>参照完整性 referential integrity: 外键的值必须存在&lt;/li>
&lt;li>用户定义的完整性
&lt;ul>
&lt;li>An example constraint would be that any value for the year attribute has to be a number.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Manipulation: How to access and modify a database’s contents.&lt;/li>
&lt;/ul>
&lt;p>关系:&lt;/p>
&lt;p>&lt;strong>A relation&lt;/strong> is an &lt;strong>unordered&lt;/strong> set that contains the relationship of attributes that represent entities. So the DBMS can store them in any way it wants, allowing for &lt;strong>optimization&lt;/strong>(允许优化).&lt;/p>
&lt;p>元组:&lt;/p>
&lt;p>&lt;strong>A tuple&lt;/strong> is a set of &lt;strong>attribute values&lt;/strong> (also known as its &lt;strong>domain&lt;/strong> 域 一组相同数据类型的值的集合) in the relation. &lt;strong>Originally&lt;/strong>, values had to be atomic or scalar(标量), but &lt;strong>now&lt;/strong> values can also be lists or &lt;strong>nested&lt;/strong>(嵌套) data structures. Every attribute can be a special value, &lt;strong>NULL&lt;/strong>, which means for a given tuple the attribute is &lt;strong>undefined&lt;/strong>.&lt;/p>
&lt;p>关系:&lt;/p>
&lt;p>&lt;strong>A relation&lt;/strong> with n attributes is called &lt;strong>an n-ary relation&lt;/strong>.&lt;/p>
&lt;p>键&lt;/p>
&lt;p>&lt;strong>A relation’s primary key&lt;/strong> uniquely identifies a single tuple.&lt;/p>
&lt;ul>
&lt;li>Some DBMSs automatically create an internal primary key if you do not define one.&lt;/li>
&lt;li>A lot of DBMSs have support for autogenerated keys so an application does not have to &lt;strong>manually increment&lt;/strong>(手动增加) the keys, but a primary key is still required for some DBMSs.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>A foreign key&lt;/strong> specifies that an attribute from one relation has to map to a tuple in another relation.&lt;/p>
&lt;h2 id="15-data-manipulation-languages-dmls">1.5 Data Manipulation Languages (DMLs)&lt;/h2>
&lt;p>Methods to store and retrieve information from a database.&lt;/p>
&lt;p>There are two classes of languages for this:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Procedural&lt;/strong>(程序上的): The query &lt;strong>specifies the (high-level) strategy&lt;/strong> the DBMS should use to find &lt;strong>the desired result based on sets / bags.&lt;/strong> (relational &lt;strong>algebra&lt;/strong> 代数)&lt;/li>
&lt;li>Non-Procedural (&lt;strong>Declarative&lt;/strong> 声明): The query specifies only what data is wanted and not how to find it. (relational &lt;strong>calculus&lt;/strong> 微积分/关系演算)&lt;/li>
&lt;/ul>
&lt;p>一般现在都是用第二种的，我不管DBMS用什么&lt;strong>策略&lt;/strong>，我只需要你给我我想要的数据。&lt;/p>
&lt;h2 id="16-relational-algebra-关系代数">1.6 Relational Algebra 关系代数&lt;/h2>
&lt;p>&lt;strong>Relational Algebra&lt;/strong> is a set of fundamental operations to &lt;strong>retrieve&lt;/strong>(检索) and manipulate tuples in a relation.&lt;/p>
&lt;p>Each operator &lt;strong>takes in&lt;/strong>(需要) one or more relations as inputs, and outputs a new relation. To write queries we can “&lt;strong>chain&lt;/strong>(链)” these operators together to create more complex operations.&lt;/p>
&lt;p>5种基本&lt;strong>关系操作&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>选择,投影,并,差,笛卡儿积&lt;/li>
&lt;/ul>
&lt;p>传统&lt;strong>集合运算&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>二目运算: 并,差,交,笛卡尔积&lt;/li>
&lt;/ul>
&lt;p>专门的&lt;strong>关系运算&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>选择selection ,投影projection,连接 join,除 dividen&lt;/li>
&lt;/ul>
&lt;p>选择:在&lt;strong>关系R&lt;/strong>中,选择符合条件的&lt;strong>元组&lt;/strong>,是从行的角度进行运算.&lt;/p>
&lt;p>投影:在&lt;strong>关系R&lt;/strong>中,选择出&lt;strong>若干属性列&lt;/strong>组成新的关系,从列的角度&lt;/p>
&lt;p>连接:两个关系的&lt;strong>笛卡尔积&lt;/strong>中,选取属性中满足一定条件的元组&lt;/p>
&lt;ul>
&lt;li>自然连接 内连接: 不保留悬浮元组.&lt;/li>
&lt;li>外连接 outer join : 保留&lt;strong>悬浮元组&lt;/strong>(填NULL)的连接&lt;/li>
&lt;li>左连接 left outer join: 只保留&lt;strong>左边关系R&lt;/strong>中的悬浮空组.&lt;/li>
&lt;li>右连接 right outer join: 只保留&lt;strong>右边关系R&lt;/strong>中的悬浮空组.&lt;/li>
&lt;/ul>
&lt;p>除: R除以S得到T, 则T包含所有&lt;strong>在R而不在S&lt;/strong>的&lt;strong>属性及其值&lt;/strong>. 且T和S的所有组合都在R中.&lt;/p>
&lt;h1 id="l2-modern-sql">L2 Modern SQL&lt;/h1>
&lt;h2 id="21-relation-languages">2.1 Relation Languages&lt;/h2>
&lt;p>用户只需要使用声明性语言（即SQL）来指定他们想要的结果。DBMS 负责确定产生该答案的最有效计划。&lt;/p>
&lt;p>关系代数基于 sets (unordered, no duplicates)。 SQL基于 bags (unordered, allows duplicates)&lt;/p>
&lt;h2 id="22-sql-history">2.2 SQL History&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>SEQUEL Structured English Query Language&lt;/p>
&lt;p>SQL Structured Query Language&lt;/p>
&lt;/li>
&lt;li>
&lt;p>该语言由不同类别的命令组成：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>DML&lt;/strong> Data Manipulation Language &lt;code>SELECT, INSERT, UPDATE, DELETE&lt;/code>&lt;/li>
&lt;li>&lt;strong>DDL&lt;/strong> Data Definition Language Schema definitions for tables, indexes, views, and other objects.&lt;/li>
&lt;li>&lt;strong>DCL&lt;/strong> Data Control Language Security, access controls.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>SQL仍在不断发展的&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="23-join">2.3 Join&lt;/h2>
&lt;p>结合一个或多个表的列，产生一个新的表。用来表达涉及跨越多个表的数据的查询&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">CREATE TABLE student (
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> sid INT PRIMARY KEY,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> name VARCHAR(16),
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> login VARCHAR(32) UNIQUE,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> age SMALLINT,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> gpa FLOAT
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">CREATE TABLE course (
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> cid VARCHAR(32) PRIMARY KEY,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> name VARCHAR(32) NOT NULL
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">CREATE TABLE enrolled (
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> sid INT REFERENCES student (sid),
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> cid VARCHAR(32) REFERENCES course (cid),
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> grade CHAR(1)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">找出在15-721拿到A的学术
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">SELECT s.name
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">FROM enrolled AS e, student AS s
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">WHERE e.grade = &amp;#39;A&amp;#39; AND e.cid = &amp;#39;15-721&amp;#39;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">AND e.sid = s.sid;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="24-aggregates-聚合函数">2.4 Aggregates 聚合函数&lt;/h2>
&lt;p>聚合函数接受一组列表，然后产生一个单一的标量值作为其输出。基本上只能在SELECT输出列表中使用！&lt;/p>
&lt;p>函数：&lt;/p>
&lt;ul>
&lt;li>&lt;code>AVG&lt;/code>&lt;/li>
&lt;li>&lt;code>MIN&lt;/code>&lt;/li>
&lt;li>&lt;code>MAX&lt;/code>&lt;/li>
&lt;li>&lt;code>COUNT&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>当使用goup时,聚合函数输出为每个组的输出.&lt;/p>
&lt;p>having 在聚合计算的基础过滤输出结果.而不是where&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SELECT AVG(s.gpa) AS avg_gpa, e.cid
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">FROM enrolled AS e, student AS s
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">WHERE e.sid = s.sid
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">GROUP BY e.cid
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">HAVING avg_gpa &amp;gt; 3.9;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="25-sting-operation">2.5 Sting Operation&lt;/h2>
&lt;p>&lt;strong>SQL标准&lt;/strong>是&lt;strong>区分大小写&lt;/strong>的，而且只能是&lt;strong>单引号&lt;/strong>！有一些函数可以处理字符串，可以在查询的任何部分使用。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>Pattern Matching&lt;/strong>:&lt;/p>
&lt;p>Like 关键字&lt;/p>
&lt;ul>
&lt;li>&lt;code>%&lt;/code> : matches any substrings (including empty).&lt;/li>
&lt;li>&lt;code>_&lt;/code> : matches any one character&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>String Function:&lt;/strong> &lt;code>SUBSTRING(S, B, E)&lt;/code> &lt;code>UPPER(S)&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Concatenation&lt;/strong>(连接) : &lt;code>||&lt;/code> concatenate two or more strings together into a single string&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="26-date-and-time">2.6 Date and Time&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>时间函数&lt;/p>
&lt;ul>
&lt;li>当前日期时间 &lt;code>NOW()&lt;/code>, &lt;code>CURRENT_TIMESTAMP()&lt;/code>&lt;/li>
&lt;li>当前UNIX时间戳 &lt;code>UNIX_TIMESTAMP()&lt;/code>&lt;/li>
&lt;li>当前日期 &lt;code>CURRENT_DATE()&lt;/code>&lt;/li>
&lt;li>当前时间 &lt;code>CURRENT_TIME()&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>日期时间转换函数&lt;/p>
&lt;ul>
&lt;li>当前时间戳转换为北京时间 &lt;code>FROM_UNIXTIME()&lt;/code>&lt;/li>
&lt;li>北京时间转换为时间戳 &lt;code>UNIX_TIMESTAMP()&lt;/code>&lt;/li>
&lt;li>时间中解析年月日时间 &lt;code>DATE_FORMAT(date, format)&lt;/code>&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">select DATE_FORMAT(&amp;#39;2021-01-01 08:30:50&amp;#39;,&amp;#39;%Y-%m-%d&amp;#39;)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>日期时间运算函数&lt;/p>
&lt;ol>
&lt;li>
&lt;p>在某个时间的基础上加上或者减去某个时间 &lt;code>DATE_ADD(date,INTERVAL expr unit)&lt;/code> &lt;code>DATE_SUB(date,INTERVAL expr unit)&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>返回两个日期值之间的天数 &lt;code>DATEDIFF(expr1,expr2))&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">select DATEDIFF(&amp;#39;2021-01-02&amp;#39;,&amp;#39;2021-01-01&amp;#39;)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>时间差函数 &lt;code>TIMESTAMPDIFF(unit,datetime_expr1,datetime_expr2)&lt;/code>&lt;/p>
&lt;p>unit：天(DAY)、小时(HOUR），分钟(MINUTE)和秒(SECOND)，TIMESTAMPDIFF函数比DATEDIFF函数用起来更加灵活&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;h2 id="27-output-redirection">2.7 Output Redirection&lt;/h2>
&lt;p>你可以告诉DBMS将查询结果存储到另一个表中，而不是将查询结果返回给客户端（例如，终端）。结果存储到另一个表中。然后你可以在随后的查询中访问这些数据&lt;/p>
&lt;ul>
&lt;li>
&lt;p>New Table: 将查询的输出存储到一个新的（永久）表中。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SELECT DISTINCT cid INTO CourseIds FROM enrolled;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>Exustubg Table:&lt;/p>
&lt;p>将&lt;strong>查询的输出存储到数据库中已经存在的表&lt;/strong>中。该表 目标表必须有与目标表相同数量和相同类型的列，但输出查询中的列名不需要匹配。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">INSERT INTO CourseIds (SELECT DISTINCT cid FROM enrolled)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;h2 id="28-output-control">2.8 Output Control&lt;/h2>
&lt;p>可以用ORDER BY来对输出进行排序,后面可以加&lt;code>DESC&lt;/code>, &lt;code>ASC&lt;/code>来指定排序策略&lt;/p>
&lt;p>输出的数量可以用&lt;code>LIMIT n&lt;/code> 进行指定,当然也可以用&lt;code>OFFSET&lt;/code> 来提供一个bias。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">ELECT sid, grade FROM enrolled WHERE cid = &amp;#39;15-721&amp;#39;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ORDER BY grade;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">SELECT sid, name FROM student WHERE login LIKE &amp;#39;%@cs&amp;#39;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">LIMIT 20 OFFSET 10;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="29-nested-queries">2.9 Nested Queries&lt;/h2>
&lt;p>在其他查询中调用查询，在单个查询中执行更复杂的逻辑。嵌套查询往往难以优化。&lt;/p>
&lt;p>外部查询的范围包括在内部查询中（即&lt;strong>内部查询可以访问来自外部查询&lt;/strong>），反之不行。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>内部查询几乎可以出现在一个查询的任何部分。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;code>SELECT&lt;/code> Output Targets&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SELECT (SELECT 1) AS one FROM student;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;code>FROM&lt;/code> &lt;strong>Clause&lt;/strong>(条件):&lt;/p>
&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SELECT name
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> FROM student AS s, (SELECT sid FROM enrolled) AS e
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> WHERE s.sid = e.sid;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="3">
&lt;li>&lt;code>WHERE&lt;/code> Clause&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SELECT name FROM student
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> WHERE sid IN ( SELECT sid FROM enrolled );
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>例子： 获取在15-445中注册的学生名字&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SELECT name FROM student
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> WHERE sid IN (
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> SELECT sid FROM enrolled
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> WHERE cid = &amp;#39;15-445&amp;#39;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>请注意，根据它在查询中出现的位置，sid有不同的范围。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>例子： 找到注册了至少一门课的最大的学生id&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SELECT student.sid, name
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> FROM student
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> JOIN (SELECT MAX(sid) AS sid
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> FROM enrolled) AS max_e
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ON student.sid = max_e.sid;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;h3 id="nested-query-results-expressions">Nested Query Results Expressions:&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>关键字：&lt;/p>
&lt;ul>
&lt;li>&lt;code>ALL&lt;/code> Must satisfy expression for all rows in sub-query&lt;/li>
&lt;li>&lt;code>ANY&lt;/code> Must satisfy expression for at least one row in sub-query.&lt;/li>
&lt;li>&lt;code>IN&lt;/code> Equivalent to =ANY().&lt;/li>
&lt;li>&lt;code>EXISTS&lt;/code> At least one row is returned.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>例子： 找到所有没有学生注册的课&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SELECT * FROM course
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> WHERE NOT EXISTS(
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> SELECT * FROM enrolled
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> WHERE course.cid = enrolled.cid
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;h2 id="210-window-functions">2.10 Window Functions&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>函数： 窗口函数可以是我们上面讨论的任何一个聚合函数。也有一些特殊的窗口函数。&lt;/p>
&lt;ol>
&lt;li>&lt;code>ROW_NUMBER&lt;/code>: 当前列的数字&lt;/li>
&lt;li>&lt;code>RANK&lt;/code>: 当前列的顺序&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>Grouping: &lt;strong>OVER子句指定了在计算窗口函数时如何对图元进行分组&lt;/strong>。使用&lt;strong>PARTITION BY&lt;/strong>来指定分组&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SELECT cid, sid, ROW_NUMBER() OVER (PARTITION BY cid)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> FROM enrolled ORDER BY cid;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们也可以在OVER中放入ORDER BY，以确保结果的确定性排序，即使数据库内部发生变化。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SELECT *, ROW_NUMBER() OVER (ORDER BY cid)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> FROM enrolled ORDER BY cid;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;strong>重要提示：&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>DBMS在窗函数排序后计算&lt;code>RANK&lt;/code>，而在排序前计算&lt;code>ROW_NUMBER&lt;/code>。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>找到每门课程中成绩第二高的学生&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SELECT * FROM (
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> SELECT *, RANK() OVER (PARTITION BY cid
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ORDER BY grade ASC) AS rank
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> FROM enrolled) AS ranking
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">WHERE ranking.rank = 2;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="211-commom-table-expressions">2.11. Commom Table Expressions&lt;/h2>
&lt;p>在编写更复杂的查询时，通用表表达式（CTE）是窗口或嵌套查询的一种替代方法。复杂的查询时，可以替代窗口或嵌套查询。它们提供了一种方法来为用户在一个更大的查询中编写辅助语句.&lt;/p>
&lt;p>可以理解为一个辅助表。&lt;/p>
&lt;p>&lt;code>WITH&lt;/code>子句将内部查询的输出与一个具有该名称的临时结果绑定。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>例子： 生成一个名为cteName的CTE，其中包含一个单一属性设置为 &amp;ldquo;1 &amp;ldquo;的元组。从这个CTE中选择所有属性。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">WITH cteName AS (
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> SELECT 1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">SELECT * FROM cteName;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们可以在AS之前将输出列绑定到名称上&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">WITH cteName (col1, col2) AS (
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> SELECT 1, 2
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">SELECT col1 + col2 FROM cteName;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>一个查询可能包含多个CTE声明&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">WITH cte1 (col1) AS (SELECT 1), cte2 (col2) AS (SELECT 2)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">SELECT * FROM cte1, cte2;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>递归能力 在WITH后面&lt;strong>添加RECURSIVE关键字&lt;/strong>允许CTE引用自己。这使得在SQL查询中可以实现递归。有了递归的CTE，SQL被证明是图灵完备的，这意味着它在计算上的表现力不亚于更多的通用编程语言&lt;/p>
&lt;/li>
&lt;li>
&lt;p>例子：打印从1到10的数字&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">WITH RECURSIVE cteSource (counter) AS (
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ( SELECT 1 )
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> UNION
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ( SELECT counter + 1 FROM cteSource
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> WHERE counter &amp;lt; 10 )
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">SELECT * FROM cteSource;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;h1 id="homework-1---sql">Homework #1 - SQL&lt;/h1>
&lt;p>CASE 语句&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SELECT name,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> CASE
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> when died is not null
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> then died-born
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> else &amp;#39;2022&amp;#39; - born
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> END as age
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">FROM people
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">where born &amp;gt;= &amp;#39;1900&amp;#39;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ORDER by age DESC,name
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">LIMIT 20;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>CAST AS TEXT 转换成字符串，字符串连接用 ||&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">select
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">CAST(titles.premiered/10*10 AS TEXT) || &amp;#39;s&amp;#39; as decade,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">round(avg(rating),2) as avg,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">max(rating) as top,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">min(rating) as min,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">count(*) as NUM_RELEASES
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">from ratings
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">join titles on titles.title_id = ratings.title_id
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">where decade is not null
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">GROUP by decade
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">order by avg DESC,decade
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">limit 20;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>第一个with后，用,隔开&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">with person_title as (
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> select people.name,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> people.person_id,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> crew.title_id
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> from people
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> join crew on crew.person_id = people.person_id
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> join titles on titles.title_id = crew.title_id
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> where born = 1955 and titles.type = &amp;#34;movie&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">),
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">person_avg as (
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> select person_title.name,round(avg(rating),2) as avg
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> from RATINGS
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> join person_title on person_title.title_id = ratings.title_id
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> group by person_title.person_id
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">),
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">quantiles as (
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> select * ,NTILE(10) OVER (ORDER BY avg ASC) as QuantileRating from person_avg
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">select
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">name,avg
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">from quantiles
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">where QuantileRating = 9
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">order by avg DESC,name;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>把表格数据压缩成一行，用，隔开&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">with p as(
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> select akas.title as dubbed
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> from titles
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> join akas on akas.title_id = titles.title_id
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> where primary_title = &amp;#34;House of the Dragon&amp;#34; and type = &amp;#34;tvSeries&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> group by primary_title,dubbed
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> order by dubbed
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">select GROUP_CONCAT(dubbed,&amp;#39;, &amp;#39;) from p;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="l3--4database-storage">L3 -4Database Storage&lt;/h1>
&lt;h2 id="31-storage">3.1 Storage&lt;/h2>
&lt;p>The DBMS assumes that the primary storage location of the database is on non-volatile disk.&lt;/p>
&lt;p>The DBMS&amp;rsquo;s components manage the movement of data between non-volatile and volatile storage.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222153223421" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222153223421_hud22ed9fb7e05b813d6f8ec53aae116f9_88815_5cb0075bf1c94b9519597682f898623e.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222153223421_hud22ed9fb7e05b813d6f8ec53aae116f9_88815_25d36e1da19b804aeaf0d87a056222ff.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222153223421_hud22ed9fb7e05b813d6f8ec53aae116f9_88815_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222153223421_hud22ed9fb7e05b813d6f8ec53aae116f9_88815_5cb0075bf1c94b9519597682f898623e.webp"
width="760"
height="456"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>Volatile Devices:&lt;/p>
&lt;ul>
&lt;li>Volatile means that if you pull the power from the machine, then the data is lost.&lt;/li>
&lt;li>Volatile storage supports fast &lt;strong>random access&lt;/strong> with byte-addressable locations. This means that the program can jump to any byte address and get the data that is there.&lt;/li>
&lt;li>For our purposes, we will always refer to this storage class as “memory.”&lt;/li>
&lt;/ul>
&lt;p>Non-Volatile Devices:&lt;/p>
&lt;ul>
&lt;li>Non-volatile means that the storage device does not require continuous power in order for the device to retain the bits that it is storing.&lt;/li>
&lt;li>It is also block/page addressable. This means that &lt;strong>in order to read a value at a particular offset&lt;/strong>, the program &lt;strong>first has to load the 4 KB page into memory&lt;/strong> that holds the value the program wants to read.&lt;/li>
&lt;li>Non-volatile storage is &lt;strong>traditionally better at sequential access&lt;/strong> (reading multiple contiguous chunks of data at the same time).&lt;/li>
&lt;li>We will refer to this as “disk.” We will not make a (major) distinction between solid-state storage (SSD) and spinning hard drives (HDD).&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222153508116" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222153508116_hu2bfa840c291ed983668d96ded6216345_109474_09dd1725ed7f8adc8264af1eee03297d.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222153508116_hu2bfa840c291ed983668d96ded6216345_109474_86de3de50577edcb256e34e8562b58cb.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222153508116_hu2bfa840c291ed983668d96ded6216345_109474_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222153508116_hu2bfa840c291ed983668d96ded6216345_109474_09dd1725ed7f8adc8264af1eee03297d.webp"
width="746"
height="467"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h2 id="32-disk-oriented-dbms-overview">3.2 Disk-Oriented DBMS Overview&lt;/h2>
&lt;p>The database is &lt;strong>all on disk&lt;/strong>, and the data in database files is organized into pages, with the first page being the directory page.&lt;/p>
&lt;p>To operate on the data, the DBMS needs to bring the data into memory. It does this by &lt;strong>having a buffer pool&lt;/strong> that &lt;strong>manages the data movement back and forth&lt;/strong> between disk and memory&lt;/p>
&lt;p>The DBMS also has an &lt;strong>execution engine&lt;/strong> that will execute queries. The execution engine will &lt;strong>ask the buffer pool for a specific page&lt;/strong>, and the buffer pool will take care of bringing that page into memory and &lt;strong>giving the execution engine a pointer&lt;/strong> to that page in memory.&lt;/p>
&lt;p>The buffer pool manager will &lt;strong>ensure&lt;/strong> that &lt;strong>the page is there while the execution engine operates on that part of memory&lt;/strong>.&lt;/p>
&lt;h2 id="33-dbms-vs-os">3.3 DBMS vs OS&lt;/h2>
&lt;ul>
&lt;li>DBMS的一个&lt;strong>高级设计目标是支持超过可用内存量&lt;/strong>的数据库。因为访问disk的代价很大，所以使用disk应该要小心。我们不希望从磁盘上访问数据时停顿太久，从而拖慢其他一切。我们希望DBMS能够处理在等待从磁盘获取数据时，能够处理其他查询。&lt;/li>
&lt;li>这个高层次的设计目标就像虚拟内存一样，有一个大的地址空间和一个供操作系统从磁盘引入页面的地方。&lt;/li>
&lt;li>实现这种虚拟内存的方法之一是使用mmap来映射进程地址空间中的文件内容，这使得操作系统负责在磁盘和内存之间来回移动页面。 但不幸的是，如果&lt;strong>mmap遇到页面故障，进程将会被阻塞&lt;/strong>。
&lt;ul>
&lt;li>如果你需要写入，你永远不想在你的DBMS中使用mmap。&lt;/li>
&lt;li>DBMS（几乎）总是想自己控制事情，而且可以做得更好，因为它知道更多关于被访问的数据和被处理的查询。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>可以通过使用操作系统：
&lt;ul>
&lt;li>&lt;code>madvise&lt;/code>: 告诉操作系统你打算何时读某些页面。&lt;/li>
&lt;li>&lt;code>mlock&lt;/code>: 告诉操作系统不要把内存范围换到磁盘上。&lt;/li>
&lt;li>&lt;code>msync&lt;/code>: 告诉操作系统将内存范围刷新到磁盘。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>出于正确性和性能的考虑，我们不建议在DBMS中使用&lt;/strong>&lt;code>mmap&lt;/code>。&lt;/p>
&lt;h2 id="34-file-storage">3.4 File Storage&lt;/h2>
&lt;ul>
&lt;li>在其最基本的形式中，DBMS将&lt;strong>数据库存储为磁盘上的文件&lt;/strong>。有些可能使用文件层次结构，有些则可能使用单个文件&lt;/li>
&lt;li>操作系统对这些文件的内容一无所知。&lt;strong>只有DBMS知道如何解读它们的内容&lt;/strong>，因为它是以DBMS特有的方式编码的。&lt;/li>
&lt;li>DBMS的存储管理器负责管理数据库的文件。它将文件表示为一个 页的集合。它还跟踪哪些数据被读和写到了页面上，以及这些页面有多少可用空间。这些页面中还有多少可用空间。&lt;/li>
&lt;/ul>
&lt;h2 id="35-database-pages">3.5 Database Pages&lt;/h2>
&lt;ul>
&lt;li>DBMS将数据库组织在&lt;strong>一个或多个文件中的固定大小的数据块&lt;/strong>，称为页。页面可以包含不同种类的数据（tuple、indexes等）。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;ul>
&lt;li>大多数系统不会将这些类型混合在一页中。 有些系统会要求页面是自成一体（self-contained）的，也就是说，阅读每个页面所需的所有信息都在页面本身。读取每一页的所有信息都在页面本身&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;ul>
&lt;li>Each page is given a unique identifier.
&lt;ul>
&lt;li>The DBMS uses an indirection layer to map page IDs to physical locations.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>There are three different &lt;strong>notions&lt;/strong> of &amp;ldquo;pages&amp;rdquo; in a DBMS:&lt;/p>
&lt;ul>
&lt;li>Hardware Page (usually 4KB)&lt;/li>
&lt;li>OS Page (usually 4KB)&lt;/li>
&lt;li>Database Page (512B-16KB)&lt;/li>
&lt;/ul>
&lt;p>存储设备保证写的操作是atomic 原子的。 这意味着，如果我们的数据库页面比我们的硬件页面大，DBMS将不得不采取额外的措施 以确保数据被安全地写出来。 因为当系统崩溃时，程序可能已经完成了将数据库页面写入磁盘的一部分&lt;/p>
&lt;p>Different DBMSs manage pages in files on disk in different ways.&lt;/p>
&lt;ul>
&lt;li>Heap File Organization&lt;/li>
&lt;li>Tree File Organization&lt;/li>
&lt;li>Sequential / Sorted File Organization (ISAM)&lt;/li>
&lt;li>Hashing File Organization&lt;/li>
&lt;/ul>
&lt;p>At this point in the &lt;strong>hierarchy&lt;/strong>(层次结构) we don&amp;rsquo;t need to know anything about what is inside of the pages.&lt;/p>
&lt;h2 id="36-database-heap">3.6 Database Heap&lt;/h2>
&lt;p>A &lt;strong>heap file&lt;/strong> is an &lt;strong>unordered&lt;/strong> collection of pages with tuples that are stored in random order.&lt;/p>
&lt;ul>
&lt;li>Create / Get / Write / Delete Page&lt;/li>
&lt;li>Must also support iterating over all pages.&lt;/li>
&lt;/ul>
&lt;p>DBMS可以通过使用页面的链接列表或页面目录在磁盘上找到一个给定的页面ID&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Linked List: Header page持有指向自由页列表和数据页列表的指针。然而，如果 DBMS正在寻找一个特定的页面，它必须在数据页列表上进行顺序扫描，直到它找到它要找的页面。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Page Directory:&lt;/p>
&lt;p>DBMS维护特殊的页面，跟踪数据页的位置以及每页的可用空间。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222155657027" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222155657027_hue6ceeb2c876f7e8bb9567dc43df03885_128348_19e1f258c1eaffbced6c82db8733249f.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222155657027_hue6ceeb2c876f7e8bb9567dc43df03885_128348_c485bf2a46a3ac3c1a373535423f72ae.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222155657027_hue6ceeb2c876f7e8bb9567dc43df03885_128348_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222155657027_hue6ceeb2c876f7e8bb9567dc43df03885_128348_19e1f258c1eaffbced6c82db8733249f.webp"
width="760"
height="413"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222155526907" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222155526907_hu2514056af22ca82486386cbb9fdb114c_40697_179a9702190fbffc038bb147ea6b13d3.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222155526907_hu2514056af22ca82486386cbb9fdb114c_40697_3a0493d5dbdbc9057477b0943ccd7e23.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222155526907_hu2514056af22ca82486386cbb9fdb114c_40697_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222155526907_hu2514056af22ca82486386cbb9fdb114c_40697_179a9702190fbffc038bb147ea6b13d3.webp"
width="760"
height="214"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>Need &lt;strong>meta-data&lt;/strong> to keep track of what pages exist in multiple files and which ones have free space.&lt;/p>
&lt;h2 id="37-page-layout">3.7 Page Layout&lt;/h2>
&lt;ul>
&lt;li>每个页面都包括一个header，记录关于页面内容的元数据。
&lt;ul>
&lt;li>Page size&lt;/li>
&lt;li>Checksum&lt;/li>
&lt;li>DBMS version&lt;/li>
&lt;li>Transaction visibility&lt;/li>
&lt;li>Self-containment(自成一体) (Some systems like Oracle require this.)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>For any page storage architecture, we now need to decide &lt;strong>how to organize the data inside of the page.&lt;/strong>&lt;/p>
&lt;p>We are still assuming that we are only storing &lt;strong>tuples&lt;/strong>.&lt;/p>
&lt;p>Two approaches:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Tuple&lt;/strong>-oriented (其实是 &lt;strong>slotted-page&lt;/strong>)
&lt;ul>
&lt;li>页面将slots映射到offsets,slot array 记录对应tuple的便宜量&lt;/li>
&lt;li>Header keeps track of the number of used slots, the offset of the starting location of the last used slot, and a slot array, which keeps track of the location of the start of each tuple.&lt;/li>
&lt;li>To add a tuple, the slot array will grow from the beginning to the end, and the data of the tuples will grow from end to the beginning. The page is considered full when the slot array and the tuple data meet&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Log-structured&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222161048229" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161048229_hub44ae70f4f7c00c2718018a74f4c1d06_119403_a6fd6f2414dd48c987770212b2738c6c.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161048229_hub44ae70f4f7c00c2718018a74f4c1d06_119403_8f4f905424d552352ad3eae80f9367af.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161048229_hub44ae70f4f7c00c2718018a74f4c1d06_119403_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161048229_hub44ae70f4f7c00c2718018a74f4c1d06_119403_a6fd6f2414dd48c987770212b2738c6c.webp"
width="760"
height="412"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h2 id="38-tuple-layout">3.8 Tuple Layout&lt;/h2>
&lt;p>tuple 内部的结构&lt;/p>
&lt;p>tuples本质上是一个字节序列。DBMS的工作是将这些字节解释为属性类型和值。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Tuple Header：包含了tuple的元数据&lt;/p>
&lt;ul>
&lt;li>DBMS的并发控制协议的可见性信息。关于哪个事务创建/修改了该元组&lt;/li>
&lt;li>NULL值的位图。&lt;/li>
&lt;li>注意，DBMS不需要在这里存储关于数据库模式的元数据。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Tuple Data：数据的实际属性&lt;/p>
&lt;ul>
&lt;li>属性通常按照你创建表时指定的顺序存储&lt;/li>
&lt;li>大多数DBMS不允许一个tuple超过一个页面的大小。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Unique Identifier&lt;/p>
&lt;ul>
&lt;li>数据库中的每个tuple都被分配一个唯一的标识符&lt;/li>
&lt;li>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222161450033" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161450033_hu3bd19195469812a461a7fa0e1b7190f8_46490_e95fc6290195b3eb2c3331929231fd6e.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161450033_hu3bd19195469812a461a7fa0e1b7190f8_46490_e384fcb96492f2d64c31cba4265d83d8.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161450033_hu3bd19195469812a461a7fa0e1b7190f8_46490_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161450033_hu3bd19195469812a461a7fa0e1b7190f8_46490_e95fc6290195b3eb2c3331929231fd6e.webp"
width="315"
height="415"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/li>
&lt;li>一般是：&lt;code>page_id + (offset or slow)&lt;/code>&lt;/li>
&lt;li>一个应用程序&lt;strong>不能&lt;/strong>依赖这些ID来表示任何东西&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>De-normalized Tuple Data:&lt;/p>
&lt;p>如果两个表是相关的，DBMS可以 &amp;ldquo;pre-join&amp;quot;它们，所以这些表最终会出现在 在同一个页面上。这使得读取速度加快，因为DBMS只需要加载一个页面而不是两个 独立的页面。然而，这使得更新更加昂贵，因为DBMS需要更多的空间给每个 tuples&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222161346650" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161346650_hu37427914b57f6d5043c3ef126690e110_173412_a754a7e3373b1eff757670a5400a061e.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161346650_hu37427914b57f6d5043c3ef126690e110_173412_0911b0c56d26d1b17e1b5084d21fb464.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161346650_hu37427914b57f6d5043c3ef126690e110_173412_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161346650_hu37427914b57f6d5043c3ef126690e110_173412_a754a7e3373b1eff757670a5400a061e.webp"
width="760"
height="401"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="39-log-structured-storage">3.9 Log-Structured Storage&lt;/h2>
&lt;p>（也叫Append-only Sequence of Data） 参考: &lt;a href="https://www.cnblogs.com/muzhongjiang/p/15151758.html" target="_blank" rel="noopener">Log-Structured 结构&lt;/a>&lt;/p>
&lt;ul>
&lt;li>与Slotted-Page Design有关的问题是：
&lt;ul>
&lt;li>
&lt;p>Fragmentation: 删除tuple会在page中留下空隙。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Useless Disk I/O:&lt;/p>
&lt;p>由于非易失性存储的block-oriented的性质，需要读取整个块来获取tuple。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Random Disk I/O: 磁盘阅读器可能不得不跳到20个不同的地方来更新20个不同的tuples，这可能会非常慢。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>如果我们在一个&lt;strong>只允许创建新数据而不允许覆盖&lt;/strong>的系统上工作呢？日志结构的存储模型与这个假设相配合，解决了上面列出的一些问题。&lt;/p>
&lt;p>&lt;strong>Log-Structured Storage:&lt;/strong> DBMS不存储tuples，&lt;strong>只存储日志记录&lt;/strong>。&lt;/p>
&lt;ul>
&lt;li>将数据库如何被修改的记录存储到文件中（放入和删除）。每条日志包含tuples的唯一标识符&lt;/li>
&lt;li>要读取一条记录，DBMS会&lt;strong>从最新的到最旧的逆向扫描日志文件&lt;/strong>，并 &amp;ldquo;重新创建 &amp;ldquo;这个 tuple。&lt;/li>
&lt;li>写的快，读的可能慢。磁盘写入是连续的，现有的页面是不可改变的，这导致了随机磁盘I/O的减少。&lt;/li>
&lt;li>在append-only的存储上工作得很好，因为DBMS不能回溯并更新数据。&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222161821846" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161821846_hua80a0ff1847a6d1a6c9d3b75314bb106_64825_2925de20dcd852f9471f48dabd0fcb23.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161821846_hua80a0ff1847a6d1a6c9d3b75314bb106_64825_00586507062e203fe557843ecc7f1243.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161821846_hua80a0ff1847a6d1a6c9d3b75314bb106_64825_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161821846_hua80a0ff1847a6d1a6c9d3b75314bb106_64825_2925de20dcd852f9471f48dabd0fcb23.webp"
width="424"
height="434"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>The log will grow forever. The DBMS needs to periodically &lt;strong>compact&lt;/strong>(紧凑) pages to reduce wasted space.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222161836461" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161836461_hub1621e620434fb3b865eb5d8264521d8_64617_c2cf10f301cf5187656ce3f081399858.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161836461_hub1621e620434fb3b865eb5d8264521d8_64617_bfd0edee3f66195e04817c5518a68003.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161836461_hub1621e620434fb3b865eb5d8264521d8_64617_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161836461_hub1621e620434fb3b865eb5d8264521d8_64617_c2cf10f301cf5187656ce3f081399858.webp"
width="760"
height="276"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;ul>
&lt;li>由于不再需要时间信息，数据库可以&lt;strong>将日志压缩到一个按id排序的表&lt;/strong>中。这些被称为分类字符串表（SSTables），它们可以使tuple搜索非常快。&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222161958064" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161958064_hu853b98a7ab66e59b808393c705129b31_31074_1b4c2521981b41a66e203eaaadb83c6b.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161958064_hu853b98a7ab66e59b808393c705129b31_31074_dad1be2109155288503ef62dd1a9cd30.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161958064_hu853b98a7ab66e59b808393c705129b31_31074_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222161958064_hu853b98a7ab66e59b808393c705129b31_31074_1b4c2521981b41a66e203eaaadb83c6b.webp"
width="350"
height="325"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;ul>
&lt;li>紧凑化的问题是，DBMS最终会出现写入放大的情况。(&lt;strong>它一次又一次地重写相同的数据&lt;/strong>）。&lt;/li>
&lt;/ul>
&lt;p>Compaction coalesces larger log files into smaller files by removing unnecessary records.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222162056924" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222162056924_hu94b5ec96540e02aacf1a9c4b3c0322af_57974_acfb438b8cbb51498683bf00bf750498.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222162056924_hu94b5ec96540e02aacf1a9c4b3c0322af_57974_c3c50f7856f5ce4ae6704e9031d1a8c1.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222162056924_hu94b5ec96540e02aacf1a9c4b3c0322af_57974_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222162056924_hu94b5ec96540e02aacf1a9c4b3c0322af_57974_acfb438b8cbb51498683bf00bf750498.webp"
width="760"
height="234"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>Log-structured storage managers are more common today. This is partly due to the &lt;strong>proliferation&lt;/strong>(扩散) of RocksDB.&lt;/p>
&lt;h2 id="311-data-representation">3.11 Data Representation&lt;/h2>
&lt;p>A tuple is essentially a sequence of bytes.&lt;/p>
&lt;p>It&amp;rsquo;s the job of the DBMS to &lt;strong>interpret&lt;/strong> those bytes into attribute types and values.&lt;/p>
&lt;p>The DBMS&amp;rsquo;s &lt;strong>catalogs&lt;/strong>(目录) contain the schema information about tables(数据表示方案) that the system uses to figure out the tuple&amp;rsquo;s layout.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222162403262" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222162403262_hu70eda27e5caa1f7624547d63d7ed8d9b_93868_badd799e61d26959ac3480d2740cf2b7.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222162403262_hu70eda27e5caa1f7624547d63d7ed8d9b_93868_9db2e901358ffcc4e60ebb67fda9624d.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222162403262_hu70eda27e5caa1f7624547d63d7ed8d9b_93868_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222162403262_hu70eda27e5caa1f7624547d63d7ed8d9b_93868_badd799e61d26959ac3480d2740cf2b7.webp"
width="640"
height="327"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;ul>
&lt;li>&lt;strong>INTEGER, BIGINT, SMALLINT, TINYINT.&lt;/strong> (Integers)大多数DBMS使用IEEE-754标准规定的 &amp;ldquo;native &amp;ldquo;C/C++类型来存储整数。这些值是&lt;strong>固定长度&lt;/strong>的。&lt;/li>
&lt;li>&lt;strong>FLOAT, REAL&lt;/strong> (Variable Precision Numbers) 这些是不精确的、可变精度的数字类型, &amp;ldquo;native &amp;ldquo;C/C++类型,这些值也是&lt;strong>固定长度&lt;/strong>的。
&lt;ul>
&lt;li>&lt;strong>变精度数的运算比任意精度数的运算更快&lt;/strong>，因为CPU可以直接对其执行指令。然而，在进行计算时&lt;strong>可能会出现精度损失&lt;/strong>！&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>NUMERIC, DECIMAL.&lt;/strong>(Fixed-Point Precision Numbers) 通常&lt;strong>以精确的、可变长度&lt;/strong>的二进制表示法（像一个字符串）来存储.带有&lt;strong>额外的元数据&lt;/strong>，这些数据将告诉系统诸如&lt;strong>数据的长度和小数点应该在哪里&lt;/strong>。&lt;/li>
&lt;li>当误差不可接受的时候，DBMS就要付出性能的代价来提高精度。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>VARCHAR, VARBINARY, TEXT, BLOB&lt;/strong> Variable-Length Data&lt;/p>
&lt;ul>
&lt;li>代表任意长度的数据类型。它们通常是用一个header来存储的，这个header可以追踪到字符串的长度，以便于跳转到下一个值。它还可能包含一个数据的校验和。&lt;/li>
&lt;li>&lt;strong>大多数DBMS不允许一个tuple超过一个页面的大小。&lt;/strong> &lt;strong>但是！那些允许的系统将数据存储在一个特殊的 &amp;ldquo;溢出 &amp;ldquo;页&lt;/strong>上，并让tuple包含一个对该页的引用。这些溢出页可以包含指向其他溢出页的指针，直到所有的数据都可以被存储。(类似分级页表)&lt;/li>
&lt;li>有些系统会让你把这些大的数值存储在一个外部文件中，然后元组会包含一个指向该文件的指针。例如，如果数据库存储的是照片信息，DBMS可以将照片存储在外部文件中，而不是让它们占用DBMS中的大量空间。这样做的一个缺点是，DBMS&lt;strong>不能操作这个文件的内容&lt;/strong>。因此，No durability protections. No transaction protections.没有耐久性或交易保护。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>TIME, DATE, TIMESTAMP.&lt;/strong> Dates and Times 不同的系统对日期/时间的表示方法不同。通常情况下，它们被表示为一些单位时间 (自unix时代的（微/毫）秒）。&lt;/p>
&lt;p>&lt;strong>System Catalogs&lt;/strong>&lt;/p>
&lt;p>为了使DBMS能够识别tuple的内容，它维护了 INFORMATION_SCHEMA&lt;strong>内部目录&lt;/strong>来告诉它关于数据库的元数据。&lt;strong>元数据将包含关于数据库有哪些表和列的信息&lt;/strong>，以及它们的类型和值的顺序。&lt;/p>
&lt;p>大多数DBMS将其目录以其表的格式存储在自己的内部。他们使用 特殊代码来 &amp;ldquo;bootstrap &amp;ldquo;这些目录表。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222163207453" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222163207453_hu1de67d00dd19777e263b680b12012894_58781_72c0389207336ff887aa4ac718aef10b.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222163207453_hu1de67d00dd19777e263b680b12012894_58781_d8d8d09727a46772250e13fef7222bf5.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222163207453_hu1de67d00dd19777e263b680b12012894_58781_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222163207453_hu1de67d00dd19777e263b680b12012894_58781_72c0389207336ff887aa4ac718aef10b.webp"
width="651"
height="380"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222163222109" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222163222109_hucc8f4beb738041586f0e722c881afc7a_61914_602903fb3f3eac4fe1e67a69f5be2ced.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222163222109_hucc8f4beb738041586f0e722c881afc7a_61914_52129ab6a3c2ed22b595f15cf049d390.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222163222109_hucc8f4beb738041586f0e722c881afc7a_61914_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222163222109_hucc8f4beb738041586f0e722c881afc7a_61914_602903fb3f3eac4fe1e67a69f5be2ced.webp"
width="661"
height="367"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h1 id="l5-storage-models--compression">L5 Storage Models &amp;amp; Compression&lt;/h1>
&lt;h2 id="51-database-workloads">5.1 Database Workloads&lt;/h2>
&lt;p>OLTP: Online Transaction Processing&lt;/p>
&lt;ul>
&lt;li>
&lt;p>An OLTP workload is characterized by &lt;strong>fast, short running operations&lt;/strong>, simple queries that &lt;strong>operate on single entity at a time&lt;/strong>, and &lt;strong>repetitive operations&lt;/strong>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>An OLTP workload will typically handle &lt;strong>more writes than reads&lt;/strong>.&lt;/p>
&lt;blockquote>
&lt;p>An example of an OLTP workload is the Amazon storefront. Users can add things to their cart, they can make purchases, but the actions only affect their account.&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ul>
&lt;p>OLAP: Online Analytical Processing&lt;/p>
&lt;ul>
&lt;li>
&lt;p>An OLAP workload is characterized by &lt;strong>long running(长期运行), complex queries, reads on large portions&lt;/strong> of the database.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>In OLAP workloads, the database system is analyzing and &lt;strong>deriving&lt;/strong>(推导/添加) new data from existing data collected on the OLTP side.&lt;/p>
&lt;blockquote>
&lt;p>An example of an OLAP workload would be Amazon computing the most bought item in Pittsburgh on a day when its raining.&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ul>
&lt;p>HTAP: Hybrid Transaction + Analytical Processing&lt;/p>
&lt;p>A new type of workload which has become popular recently is HTAP, which is like &lt;strong>a combination which tries to do OLTP and OLAP together&lt;/strong> on the same database.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222165717923" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222165717923_hub0e80189cc2c5cb3a5257af30c0344c9_131577_0292e6a043d9305c6b098fefcb4dc65d.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222165717923_hub0e80189cc2c5cb3a5257af30c0344c9_131577_1519b8a1f5640119d79da7b248547314.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222165717923_hub0e80189cc2c5cb3a5257af30c0344c9_131577_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222165717923_hub0e80189cc2c5cb3a5257af30c0344c9_131577_0292e6a043d9305c6b098fefcb4dc65d.webp"
width="760"
height="421"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h2 id="52-storage-models">5.2 Storage Models&lt;/h2>
&lt;h3 id="n-ary-storage-model-nsm">N-Ary Storage Model (NSM)&lt;/h3>
&lt;p>In the n-ary storage model, the DBMS &lt;strong>stores all of the attributes for a single tuple contiguously in a single page&lt;/strong>&lt;/p>
&lt;p>This approach is &lt;strong>ideal for OLTP workloads&lt;/strong> where requests are insert-heavy and transactions tend to operate only an individual entity.&lt;/p>
&lt;p>It is ideal because it takes only one fetch to be able to get all of the attributes for a single tuple.&lt;/p>
&lt;p>Advantages:&lt;/p>
&lt;ul>
&lt;li>Fast inserts, updates, and deletes.&lt;/li>
&lt;li>Good for queries that need the entire tuple.&lt;/li>
&lt;/ul>
&lt;p>Disadvantages:&lt;/p>
&lt;ul>
&lt;li>Not good for &lt;strong>scanning large portions of the table&lt;/strong> and/or &lt;strong>a subset of the attributes.&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222164813494" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222164813494_huba6e0bab0a29c92faf18ea4e71a32e29_109880_c9725ffe5d520ec47aac014c07067a7a.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222164813494_huba6e0bab0a29c92faf18ea4e71a32e29_109880_e35880066c5994e6f0c71713fa0c4c6d.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222164813494_huba6e0bab0a29c92faf18ea4e71a32e29_109880_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222164813494_huba6e0bab0a29c92faf18ea4e71a32e29_109880_c9725ffe5d520ec47aac014c07067a7a.webp"
width="684"
height="464"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="decomposition-分解-storage-model-dsm">Decomposition 分解 Storage Model (DSM)&lt;/h3>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222165051507" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222165051507_hu9c03f1f657567e7c08df7e4576dd36b4_88960_0c0e1f70958b4350817e058ba88859a2.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222165051507_hu9c03f1f657567e7c08df7e4576dd36b4_88960_84ee7de04f474641008f5079f01fa063.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222165051507_hu9c03f1f657567e7c08df7e4576dd36b4_88960_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222165051507_hu9c03f1f657567e7c08df7e4576dd36b4_88960_0c0e1f70958b4350817e058ba88859a2.webp"
width="712"
height="388"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>This model is &lt;strong>ideal for OLAP&lt;/strong> workloads with many read-only queries that perform large scans over a subset of the table’s attributes.&lt;/p>
&lt;p>Advantages:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Reduces the amount of I/O wasted&lt;/strong> because the DBMS only reads the data that it needs for that query.&lt;/li>
&lt;li>Better query processing and data compression&lt;/li>
&lt;/ul>
&lt;p>Disadvantages:&lt;/p>
&lt;ul>
&lt;li>Slow for point queries, inserts, updates, and deletes because of tuple splitting/&lt;strong>stitching&lt;/strong>(缝合).&lt;/li>
&lt;/ul>
&lt;p>To &lt;strong>put the tuples back together&lt;/strong> when using a column store,there are two common approaches:&lt;/p>
&lt;p>fixed-length offsets(most common): Each value is the same length for an attribute&lt;/p>
&lt;p>Embedded Tuple Ids:Each value is stored with its tuple id in a column&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222165430923" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222165430923_hu884be268e032fdeb7a677f672b846f24_81619_b2995747ad547db94d64a161da8089db.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222165430923_hu884be268e032fdeb7a677f672b846f24_81619_1a31b3560becd543e3983206645f3cf7.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222165430923_hu884be268e032fdeb7a677f672b846f24_81619_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222165430923_hu884be268e032fdeb7a677f672b846f24_81619_b2995747ad547db94d64a161da8089db.webp"
width="760"
height="377"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h2 id="53-database-compression">5.3 Database Compression&lt;/h2>
&lt;blockquote>
&lt;ul>
&lt;li>
&lt;p>压缩操作被在&lt;strong>disk-based&lt;/strong> DBMSs广泛应用。因为disk的I/O总是瓶颈，所以压缩可以让系统提升性能，尤其是只读analyt Managical workloads上。&lt;/p>
&lt;p>如果事先对tuples进行了压缩，DBMS可以获取更多有用的tuple，但代价是要付出更大的压缩和解压的计算开销。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>内存中的DBMS更加复杂，因为它们不必从磁盘中获取数据来执行一个查询。 内存比磁盘快得多，但压缩数据库可以减少DRAM需求和处理。&lt;/p>
&lt;p>而且必须在速度和压缩率中取得一个平衡。压缩数据库可以减少DRAM的需求和查询执行过程中的CPU成本。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果数据集是完全随机的bits，那么我们没有办法进行压缩。然而，现实世界中的数据集有一些key properties 是可以进行压缩的。&lt;/p>
&lt;ul>
&lt;li>数据集往往具有高度倾斜的属性值分布（例如，Brown语料库的Zipfian分布）。&lt;/li>
&lt;li>数据集往往在同一元组的属性之间有很高的相关性（例如，邮政编码到城市。订单日期与发货日期）。 Manag&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Given this, we want a database compression scheme to have the following properties:&lt;/p>
&lt;ul>
&lt;li>Must produce &lt;strong>fixed-length values&lt;/strong>. The only exception is var-length data stored in separate pools. This because the DBMS should follow word-&lt;strong>alignment&lt;/strong>(对齐) and be able to access data using offsets.&lt;/li>
&lt;li>Allow the DBMS to &lt;strong>postpone&lt;/strong>(推迟) decompression as long as possible during query execution (late materialization).&lt;/li>
&lt;li>Must be &lt;strong>a lossless scheme&lt;/strong> because people do not like losing data. Any kind of lossy compression has to be performed at the application level.&lt;/li>
&lt;/ul>
&lt;h3 id="compression-granularity">Compression Granularity&lt;/h3>
&lt;p>在给DBMS增加压缩功能之前，我们需要决定我们要压缩什么样的数据。这个决定决定了压缩方案的可用性。有四个级别的压缩 Manag颗粒度（granularity）&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Block Level: 压缩同一张表的tuple块。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Tuple Level: 压缩整个tuples的内容（仅NSM）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Attribute Level: 在一个tuple内压缩单个属性值。可以针对同一tuple的多个属性。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Columnar Level:&lt;/p>
&lt;p>为多个tuple存储的一个或多个属性压缩多个值 (只限于DSM)。这允许更复杂的压缩方案。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="54-naive-compression">5.4 Naive Compression&lt;/h2>
&lt;p>DBMS使用一个&lt;strong>通用的算法&lt;/strong>对数据进行压缩 (e.g., gzip, LZO, LZ4, Snappy, Brotli, Oracle OZIP, Zstd)。 尽管DBMS可以使用几种压缩算法，但工程师们往往选择那些经常提供较低压缩率以换取更快的压缩/解压的算法。&lt;/p>
&lt;p>naive compression例子： &lt;strong>MySQL InnoDB&lt;/strong>&lt;/p>
&lt;p>DBMS对磁盘页面进行压缩，将其压缩到2KB的幂数，并将其存储到缓冲池中。然而，每次DBMS试图读取数据时，缓冲池中的压缩数据必须被解压&lt;/p>
&lt;p>缺点:&lt;/p>
&lt;ul>
&lt;li>由于访问数据&lt;strong>需要对压缩的数据进行解压&lt;/strong>，这就限制了压缩方案的范围。 如果目标是将整个表压缩成一个巨大的块，使用naive compression 方案是不可能的，因为每次访问都需要对整个表进行压缩/解压缩。 因此，对于MySQL来说，由于压缩范围有限，它将表分解成更小的块状。&lt;/li>
&lt;li>naive方案也没有考虑到数据的高级含义或语义。 该算法既不考虑数据的结构，也不考虑查询打算如何访问 数据。因此，这就&lt;strong>失去了利用late materialization 的机会&lt;/strong>，因为DBMS不能知道它何时能够延迟数据的解压。&lt;/li>
&lt;/ul>
&lt;h2 id="55-columnar-compression-柱状压缩">5.5 Columnar Compression 柱状压缩**&lt;/h2>
&lt;h3 id="run-length-encoding">Run-length Encoding&lt;/h3>
&lt;p>Compress runs of the same value in a single column into triplets:&lt;/p>
&lt;ul>
&lt;li>The value of the attribute.&lt;/li>
&lt;li>The start position in the column segment.&lt;/li>
&lt;li>The # of elements in the run.&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222170534215" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222170534215_hua4e94f5df4190ac6a4cb2081ee5bae21_52535_205fac9c1d51344ba77ad176c2aa57d7.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222170534215_hua4e94f5df4190ac6a4cb2081ee5bae21_52535_7c1f361f36253fa4c36314fb1dc5291d.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222170534215_hua4e94f5df4190ac6a4cb2081ee5bae21_52535_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222170534215_hua4e94f5df4190ac6a4cb2081ee5bae21_52535_205fac9c1d51344ba77ad176c2aa57d7.webp"
width="727"
height="383"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>Requires the columns to be sorted &lt;strong>intelligently&lt;/strong>(智能) to maximize compression opportunities.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222170706032" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222170706032_hua84612ef4007d4d9946188cfd8be97bb_36555_064b5f70fed9b64ec4039b8dc8cff6b5.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222170706032_hua84612ef4007d4d9946188cfd8be97bb_36555_a76950044ff733e9d5d314b23132fd6c.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222170706032_hua84612ef4007d4d9946188cfd8be97bb_36555_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222170706032_hua84612ef4007d4d9946188cfd8be97bb_36555_064b5f70fed9b64ec4039b8dc8cff6b5.webp"
width="693"
height="406"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="bit-packing-encoding">Bit-Packing Encoding&lt;/h3>
&lt;p>When values for an attribute are &lt;strong>always less than the value&amp;rsquo;s declared largest size,&lt;/strong> &lt;strong>store them as smaller data type&lt;/strong>.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222170800172" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222170800172_hu46b31a996c3f521c96953fd3435620cc_45759_a9f1efec0e024234e7aaefe39722348b.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222170800172_hu46b31a996c3f521c96953fd3435620cc_45759_8042099dbf818e90140c64761452fefb.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222170800172_hu46b31a996c3f521c96953fd3435620cc_45759_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222170800172_hu46b31a996c3f521c96953fd3435620cc_45759_a9f1efec0e024234e7aaefe39722348b.webp"
width="760"
height="189"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>Bit-packing variant that uses a &lt;strong>special marker&lt;/strong> to indicate when a value exceeds largest size and then maintain a look-up table to store them.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222170818530" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222170818530_hu97c6f66a875eded62edadc7467f078a1_46217_2eb479e5b8191b0f95d3234bcb4ad1bc.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222170818530_hu97c6f66a875eded62edadc7467f078a1_46217_a8ee8ad03b3461e63dbce31825e184fd.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222170818530_hu97c6f66a875eded62edadc7467f078a1_46217_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222170818530_hu97c6f66a875eded62edadc7467f078a1_46217_2eb479e5b8191b0f95d3234bcb4ad1bc.webp"
width="760"
height="187"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="bitmap-encoding">Bitmap Encoding&lt;/h3>
&lt;p>Store a separate bitmap for each unique value for an attribute where &lt;strong>an offset in the vector corresponds to a tuple.&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>The i th position in the Bitmap corresponds to the i th tuple in the table.&lt;/li>
&lt;li>Typically segmented into chunks to avoid allocating large blocks of contiguous memory. Only practical &lt;strong>if the value cardinality(基数) is low&lt;/strong>. Some DBMSs provide bitmap indexes.&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222171138540" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222171138540_huab479fb3d05c1d9c70bb01c8efde26f2_64903_cafe57d1b3648b09128cc49a5ff8d6bc.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222171138540_huab479fb3d05c1d9c70bb01c8efde26f2_64903_201d70af675d42e783e8b5b81b093844.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222171138540_huab479fb3d05c1d9c70bb01c8efde26f2_64903_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222171138540_huab479fb3d05c1d9c70bb01c8efde26f2_64903_cafe57d1b3648b09128cc49a5ff8d6bc.webp"
width="760"
height="387"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="delta-encoding">Delta Encoding&lt;/h3>
&lt;p>&lt;strong>Recording the difference&lt;/strong> between values that follow each other in the same column.&lt;/p>
&lt;ul>
&lt;li>Store base value in-line or in a separate look-up table.&lt;/li>
&lt;li>&lt;strong>Combine with RLE to get even better compression ratios.&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222171254392" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222171254392_hu4544ac5a826f509c4a673c460def9e0a_55990_331f471414a83ff3627dfa2947d69f3e.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222171254392_hu4544ac5a826f509c4a673c460def9e0a_55990_221ed394c99859231a398861ca0b947d.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222171254392_hu4544ac5a826f509c4a673c460def9e0a_55990_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222171254392_hu4544ac5a826f509c4a673c460def9e0a_55990_331f471414a83ff3627dfa2947d69f3e.webp"
width="760"
height="230"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="incremental-encoding">Incremental Encoding&lt;/h3>
&lt;p>Type of delta encoding that &lt;strong>avoids duplicating common prefixes/suffixes between consecutive tuples&lt;/strong>. This works best with sorted data.&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222171338403" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222171338403_hu7a5d9e6f86d19720fec133f61e26c137_73268_c5451d5937c6ba6a785ee7b45203b98d.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222171338403_hu7a5d9e6f86d19720fec133f61e26c137_73268_c74575a2c57aff662bede8e943f027a9.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222171338403_hu7a5d9e6f86d19720fec133f61e26c137_73268_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222171338403_hu7a5d9e6f86d19720fec133f61e26c137_73268_c5451d5937c6ba6a785ee7b45203b98d.webp"
width="760"
height="212"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h3 id="dictionary-encoding">Dictionary Encoding&lt;/h3>
&lt;p>Build a data structure that &lt;strong>maps variable-length values to a smaller integer identifier.&lt;/strong>&lt;/p>
&lt;p>Replace those values with their corresponding identifier in the dictionary data structure.&lt;/p>
&lt;ul>
&lt;li>Need to support fast encoding and decoding.
&lt;ul>
&lt;li>Encode/Locate: For a given uncompressed value, convert it into its compressed form.&lt;/li>
&lt;li>Decode/Extract: For a given compressed value, convert it back into its original form.&lt;/li>
&lt;li>No magic hash function will do this for us.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Need to also support range queries.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Most widely used compression scheme in DBMSs.&lt;/strong>&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="flex justify-center ">
&lt;div class="w-100" >&lt;img alt="image-20230222171632448" srcset="
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222171632448_hu85d19909300784701cd1e9eb06f25528_107171_4ff0b43f8b662b8b02b04023a05900b5.webp 400w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222171632448_hu85d19909300784701cd1e9eb06f25528_107171_46026c2a80f2ac66b89e41dd7a419b8b.webp 760w,
/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222171632448_hu85d19909300784701cd1e9eb06f25528_107171_1200x1200_fit_q85_h2_lanczos_3.webp 1200w"
src="https://ysyyhhh.github.io/blog/p0-c-primerhttps/15445.courses.cs.cmu.edu/fall2022/project0/img/image-20230222171632448_hu85d19909300784701cd1e9eb06f25528_107171_4ff0b43f8b662b8b02b04023a05900b5.webp"
width="760"
height="357"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h1 id="homework-2-storage--indexeshttps15445coursescscmuedufall2022fileshw2-cleanpdf">Homework #2 &lt;a href="https://15445.courses.cs.cmu.edu/fall2022/files/hw2-clean.pdf" target="_blank" rel="noopener">Storage &amp;amp; Indexes&lt;/a>&lt;/h1>
&lt;h2 id="question-1-storage-models">Question 1: Storage Models&lt;/h2>
&lt;p>a database with a single table &lt;strong>R(q_id,txns,total,failed)&lt;/strong>, where q_id is the &lt;strong>primary key&lt;/strong>, and &lt;strong>all attributes are the same fixed width.&lt;/strong>&lt;/p>
&lt;p>Suppose R has 20,000 tuples that fit into 100 pages, &lt;strong>Ignore any additional storage&lt;/strong> overhead for the table (e.g., page headers, tuple headers).&lt;/p>
&lt;p>Assumptions:&lt;/p>
&lt;ul>
&lt;li>The DBMS does &lt;strong>not have any additional meta-data&lt;/strong> (e.g., sort order, zone maps).&lt;/li>
&lt;li>R does &lt;strong>not have any indexes&lt;/strong> (including for primary key q_id)&lt;/li>
&lt;li>&lt;strong>None&lt;/strong> of R’s pages are already &lt;strong>in the buffer pool&lt;/strong>.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SELECT total - failed FROM R
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">WHERE q id = 96 AND txns &amp;gt; 420;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="a-suppose-the-dbms-uses-the-decomposition-storage-model-dsm-with-implicit-offsets">(a) Suppose the DBMS uses the decomposition storage model (DSM) with implicit offsets&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>i What is the &lt;strong>minimum number of pages&lt;/strong> that the DBMS will potentially have to read from disk to answer this query?&lt;/p>
&lt;p>题意是存在这样一条记录,找到该条记录最少的磁盘读次数.&lt;/p>
&lt;p>官方解答是: 4 pages. 1 to find the primary key, + 3 to access txns, total, failed at their corresponding offsets.&lt;/p>
&lt;p>因为使用分解存储模式DSM, 按列存储.&lt;/p>
&lt;p>因此找到主键后就可以通过偏移量找其他属性的值. 读盘次数的限制在找主键上.&lt;/p>
&lt;p>显然,找主键至少需要一次读盘.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ii What is the &lt;strong>maximum number of pages&lt;/strong> that the DBMS will potentially have to read from disk to answer this query?&lt;/p>
&lt;p>官方解答: 28 pages. &lt;strong>There are 25 pages per attribute.&lt;/strong> In the worst case, we scan through all 25 pages to find the primary key, and then + 3 to access txns, total, failed at their corresponding offsets.&lt;/p>
&lt;p>上题可知,找主键次数决定了读盘次数.&lt;/p>
&lt;p>也就是当q_id = 96的记录越靠后, 找主键次数越多.&lt;/p>
&lt;p>因为没有顺序,所以96是无用的信息.&lt;/p>
&lt;p>同时因为&lt;strong>有四个属性,且所有属性大小固定&lt;/strong>. 所以当每个属性都占25页时,且q_id=26所在的记录是最后一个(25),找主键次数最大为25次.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="bsuppose-the-dbms-uses-the-n-ary-storage-model-nsm">(b)Suppose the DBMS uses the N-ary storage model (NSM)&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>i. What is the minimum number of pages that the DBMS will potentially have to read from disk to answer this query?&lt;/p>
&lt;p>Solution: We find the tuple with the matching primary key on the first page. No need to look in other pages since all attributes are stored together.&lt;/p>
&lt;p>在第一页&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ii. [4 points] What is the maximum number of pages that the DBMS will potentially have to read from disk to answer this query?&lt;/p>
&lt;p>在最后一页 100&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="question-2-cuckoo-hashing">Question 2: Cuckoo Hashing&lt;/h2>
&lt;p>几道哈希表计算的题目,较简单&lt;/p>
&lt;p>2进制：0b，8进制：0o，10进制：无前缀，16进制：0x&lt;/p>
&lt;h2 id="question-3-extendible-hashing">Question 3: Extendible Hashing&lt;/h2>
&lt;p>Consider an extendible hashing structure such that:&lt;/p>
&lt;ul>
&lt;li>Each bucket can hold up to two records.&lt;/li>
&lt;li>The hashing function uses the lowest g bits, where g is the global depth.&lt;/li>
&lt;/ul>
&lt;p>题目是一个二进制可扩展哈希. 哈希函数是二进制最低g位.&lt;/p>
&lt;p>每个哈希值对应一个桶, 每个桶最多两个, 所有刚好就是二进制.&lt;/p>
&lt;h3 id="a-starting-from-an-empty-table-insert-keys-15-14-23-11-9">(a) Starting from an empty table, insert keys 15, 14, 23, 11, 9.&lt;/h3>
&lt;p>二进制表示&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">15: 00001111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">14: 00001110
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">23: 00010111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">11: 00001011
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">9 : 00001001
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>插入步骤(括号内为局部深度,全局深度为最大局部深度)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">插入15
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">全局: 1; 桶 1(1):15
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">14
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">全局: 1; 桶 1(1):15 ; 0(1):14
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">23
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">全局: 1; 桶 1(1):15,23; 0(1):14
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">11
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">全局: 1; 桶 1(1):15,23,11; 0(1):14
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">桶1此时有三条记录,需要扩展深度,扩展为2
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">全局: 2; 桶 11(2):15,23,11; 01(2):; 0(1):14
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">桶11此时有三条记录,需要扩展深度,扩展为3
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">全局: 3; 桶 111(3):15,23; 011(3):11;01(2):; 0(1):14
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">9
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">全局: 3; 桶 111(3):15,23; 011(3):11; 0(1):14; 01(2):9;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>
&lt;p>i. What is the global depth of the resulting table?&lt;/p>
&lt;p>显然,当g至少等于3的时候才能使得同一个哈希值最多对应两个记录.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ii. [4 points] What is the local depth the bucket containing 15?&lt;/p>
&lt;p>为3&lt;/p>
&lt;/li>
&lt;li>
&lt;p>iii. [4 points] What is the local depth of the bucket containing 14?&lt;/p>
&lt;p>为1&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="b-starting-from-the-result-in-a-you-insert-keys-12-5-7-13-2">(b) Starting from the result in (a), you insert keys 12, 5, 7, 13, 2.&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">15: 00001111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">14: 00001110
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">23: 00010111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">11: 00001011
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">9 : 00001001
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">此时 全局: 3; 桶 111(3):15,23; 011(3):11; 0(1):14; 01(2):9;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">12: 00001010
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">5 : 00000101
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">7 : 00000111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">13: 00001101
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">2 : 00000010
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">12
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">全局: 3; 桶 111(3):15,23; 011(3):11; 0(1):14,12; 01(2):9;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">5
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">全局: 3; 桶 111(3):15,23; 011(3):11; 0(1):14,12; 01(2):9;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">7
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">全局: 3; 桶 111(3):15,23; 011(3):11; 0(1):14,12; 1(1):9,5;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">此时111桶有3个,增加深度为4
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">全局: 4; 桶 1111(4):15;0111(4):23,7; 011(3):11; 0(1):14,12; 1(1):9,5;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">13
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">全局: 4; 桶 1111(4):15;0111(4):23,7; 011(3):11; 0(1):14,12; 1(1):9,5;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">01(2):13;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">2
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">全局: 4; 桶 1111(4):15;0111(4):23,7; 011(3):11; 0(1):14,12; 1(1):9,5;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">01(2):13;01(2):2
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>
&lt;p>i. [4 points] Which key will first cause a split (without doubling the size of the table)?&lt;/p>
&lt;p>这里的split操作指的是&lt;strong>增加桶的数量&lt;/strong>,而不double.也就是不增加全局深度.(增加全局深度会翻一倍)&lt;/p>
&lt;p>所以是13第一个增加了桶的数量.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ii. [4 points] Which key will first make the table double in size?&lt;/p>
&lt;p>7&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="c-now-consider-the-table-below-along-with-the-following-deletion-rules">(c) Now consider the table below, along with the following deletion rules:&lt;/h3>
&lt;ol>
&lt;li>If two buckets satisfy the following:&lt;/li>
&lt;/ol>
&lt;p>(a) They have the same local depth d&lt;/p>
&lt;p>(b) They share the first d − 1 bits of their indexes (e.g. b010 and b110 share the first 2 bits)&lt;/p>
&lt;p>(c) Their constituent elements fit in a single bucket. Then they can be merged into a single bucket with local depth d − 1.&lt;/p>
&lt;ol start="2">
&lt;li>If the global depth g becomes strictly greater than all local depths, then the table can be halved in size. The resulting global depth is g − 1.&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">00
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">28:11100
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">8 :01000
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">01
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">25:11001
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">10
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">30:11110
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">22:10110
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">18:10010
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">011
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">11:01011
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">27:11011
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">23:10111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">7 :00111
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Starting from the table above, delete keys 25, 18, 22, 27, 7.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">delete 25
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">00
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">28:11100
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">8 :01000
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">10
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">30:11110
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">22:10110
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">18:10010
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">011
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">11:01011
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">27:11011
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">23:10111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">7 :00111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">delete 18
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">00
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">28:11100
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">8 :01000
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">10
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">30:11110
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">22:10110
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">011
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">11:01011
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">27:11011
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">23:10111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">7 :00111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">delete 22
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">00
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">28:11100
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">8 :01000
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">10
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">30:11110
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">011
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">11:01011
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">27:11011
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">23:10111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">7 :00111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">此时00 和 10可进行合并
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">0
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">28:11100
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">8 :01000
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">30:11110
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">011
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">11:01011
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">27:11011
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">23:10111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">7 :00111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">delete 27
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">0
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">28:11100
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">8 :01000
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">30:11110
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">011
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">11:01011
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">23:10111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">7 :00111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">此时 011 和 111可合并为11,一次合并最多减少1, 此时global depth = 2
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">0
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">28:11100
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">8 :01000
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">30:11110
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">11
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">11:01011
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">23:10111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">7 :00111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">delete 7
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">0
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">28:11100
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">8 :01000
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">30:11110
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">11
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">11:01011
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">23:10111
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>i. Which deletion first causes a reduction in a local depth.&lt;/li>
&lt;/ul>
&lt;p>22&lt;/p>
&lt;ul>
&lt;li>
&lt;p>ii. Which deletion first causes a reduction in global depth.&lt;/p>
&lt;p>27&lt;/p>
&lt;p>Solution: Deleting 27 from bucket b011 allows it to merge with b111. Since these two buckets are the only ones of depth d = 3, this merge reduces the global depth to d = 2&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="question-4-btree">Question 4: B+Tree&lt;/h2>
&lt;p>还行,就是有个奇怪的点. 索引节点的值一般会出现在叶子节点上.&lt;/p>
&lt;p>最后一题是找出指定的节点 非法的地方.&lt;/p>
&lt;h1 id="p1">P1&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">1: 0001
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">2: 0010
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">3: 0011
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">4: 0100
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">5: 0101
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">6: 0110
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">7: 0111
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">8: 1000
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">9: 1001
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">1 2 3 4
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">全局1 1(1):1,3;0(1):2,4;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">5
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">全局1 1(1):1,3,5;0(1):2,4;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">全局2 01(2):1,5;11(2)3;0(1):2,4;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">6
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">全局2 01(2):1,5;11(2)3;00(2):4;10(2):2,6;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">7
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">全局2 01(2):1,5;11(2)3,7;00(2):4;10(2):2,6;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">8
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">全局2 01(2):1,5;11(2)3,7;00(2):4,8;10(2):2,6;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">9
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">全局2 01(2):1,5,9;11(2)3,7;00(2):4,8;10(2):2,6;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">全局3 001(3):1,9;101(3):5;11(2)3,7;00(2):4,8;10(2):2,6;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="lru-k">LRU-K&lt;/h2>
&lt;p>The LRU-K algorithm &lt;strong>evicts&lt;/strong>(剔除) a frame whose &lt;strong>backward k-distance&lt;/strong> is maximum of all frames in the replacer.&lt;/p>
&lt;p>&lt;strong>Backward k-distance&lt;/strong> is computed as the &lt;strong>difference&lt;/strong> in time between current timestamp and the timestamp of kth previous access.&lt;/p>
&lt;p>A frame with less than k historical accesses is given +inf as its backward k-distance. When &lt;strong>multipe frames have +inf backward k-distance&lt;/strong>, the replacer evicts the frame &lt;strong>with the earliest timestamp&lt;/strong>.&lt;/p>
&lt;p>先弄清楚逻辑在写，不要把时间花在无意义的bug上。&lt;/p>
&lt;h1 id="p2-btree">P2 B+Tree&lt;/h1>
&lt;h2 id="概述">概述&lt;/h2>
&lt;p>内部节点：索引作用&lt;/p>
&lt;p>叶子节点：包含真正的数据实体&lt;/p>
&lt;p>由于树是动态增长和收缩，所以要处理 split 和 merge&lt;/p>
&lt;blockquote>
&lt;p>Since the tree structure grows and shrink dynamically, you are required to handle the logic of split and merge.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>Checkpoint #1 — Due Date: Oct 11 @ 11:59pm&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&lt;a href="https://15445.courses.cs.cmu.edu/fall2022/project2/#b&amp;#43;tree-pages" target="_blank" rel="noopener">Task #1 - B+Tree Pages&lt;/a>&lt;/strong>&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://15445.courses.cs.cmu.edu/fall2022/project2/#b&amp;#43;tree-structure" target="_blank" rel="noopener">Task #2 - B+Tree Data Structure (Insertion, Deletion, Point Search)&lt;/a>&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Checkpoint #2 — Due Date: Oct 26 @ 11:59pm&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&lt;a href="https://15445.courses.cs.cmu.edu/fall2022/project2/#index-iterator" target="_blank" rel="noopener">Task #3 - Index Iterator&lt;/a>&lt;/strong>&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://15445.courses.cs.cmu.edu/fall2022/project2/#concurrent_index" target="_blank" rel="noopener">Task #4 - Concurrent Index&lt;/a>&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>该project 要依赖于上一个 buffer pool 的正确实现。&lt;/p>
&lt;p>由于第一个检查点与第二个检查点密切相关，在第二个检查点中，您将在现有的B+索引中实现索引抓取，因此我们传入了一个名为transaction的指针参数，其默认值为nullptr。在任务#4之前，您不需要更改或调用与参数相关的任何函数。&lt;/p>
&lt;h2 id="task-1---btree-pages">Task #1 - B+Tree Pages&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>&lt;a href="https://15445.courses.cs.cmu.edu/fall2022/project2/#b&amp;#43;tree-page" target="_blank" rel="noopener">B+Tree Parent Page&lt;/a>&lt;/strong>&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://15445.courses.cs.cmu.edu/fall2022/project2/#b&amp;#43;tree-internal-page" target="_blank" rel="noopener">B+Tree Internal Page&lt;/a>&lt;/strong>&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://15445.courses.cs.cmu.edu/fall2022/project2/#b&amp;#43;tree-leaf-page" target="_blank" rel="noopener">B+Tree Leaf Page&lt;/a>&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h3 id="btree-parent-page">B+Tree Parent Page&lt;/h3>
&lt;p>ParenPage 被 Internal Page 和 Leaf Page所继承。&lt;/p>
&lt;p>并且只包含了 子类 所共享的信息。&lt;/p>
&lt;p>&lt;strong>可以规定&lt;/strong> &lt;code>parent_page_id_&lt;/code> 为 &lt;code>INVALID_PAGE_ID&lt;/code> 表示根节点。&lt;/p>
&lt;p>| Variable Name | Size | Description | | &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; | &amp;mdash;- | &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; | | page_type_ | 4 | Page Type (internal or leaf) | | lsn_ | 4 | Log sequence number (Used in Project 4) | | size_ | 4 | Number of Key &amp;amp; Value pairs in page | | max_size_ | 4 | Max number of Key &amp;amp; Value pairs in page | | parent_page_id_ | 4 | Parent Page Id | | page_id_ | 4 | Self Page Id |&lt;/p>
&lt;h3 id="btree-internal-page">B+Tree Internal Page&lt;/h3>
&lt;ul>
&lt;li>不存储真实数据。只存储 m个有序 key和m+1个child 指针。&lt;/li>
&lt;li>因为key的数量和指针数量不相等。第一个key被设定为invalid。所有方法需要从第二个key开始（下标为1）&lt;/li>
&lt;li>实际存储如下&lt;/li>
&lt;li>键,指针,键,指针,&amp;hellip;,键,指针.&lt;/li>
&lt;li>此时有m+1个键,为了保证只有m个键,所以第一个键设置为无效的.&lt;/li>
&lt;/ul>
&lt;p>key的数量限制&lt;/p>
&lt;ul>
&lt;li>在任何时间，最少装了一半（half-full）。&lt;/li>
&lt;li>删除时，两个 half-full可以被joined 成为一个合法的 Internal Page
&lt;ul>
&lt;li>或者被重新分配来避免merge&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>当插入到一个fullpage时，可以被split成两个。&lt;/li>
&lt;li>This is an example of one of the many design choices that you will make in the implementation of the B+ Tree.&lt;/li>
&lt;/ul>
&lt;p>三个泛型 KeyType, ValueType, KeyComparator。&lt;/p>
&lt;p>&lt;strong>KeyType&lt;/strong> 不一定直接可用大于小于号比较，所以引入了 KeyComparator，从 cpp 文件中的实例化可以看出用的是 GenericKey 和 GenericComparator，查看二者源码可以得到以下信息：&lt;/p>
&lt;p>&lt;strong>GenericKey&lt;/strong> 可以调用 ToString() 函数得到其 int64 表示，然后用 **%ld 格式符打印。**这对我们后面调试时非常重要。 GenericComparator 的比较规则是：左边小于右边时，返回 -1；左边大于右边时，返回 1；相等返回 0。&lt;/p>
&lt;p>&lt;strong>ValueType&lt;/strong> 代表的是指向子页面的指针，从实例化可以看出实际只用了 page_id_t，也就是 &lt;strong>int&lt;/strong>。&lt;/p>
&lt;p>数据存储上，其理论结构应为 &amp;lt;指针，键，指针，键…，键，指针&amp;gt;，为方便存储，实际上&lt;strong>在头部多补了一个无效键&lt;/strong>，从而可以用一个 pair 的数组存储：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">#define MappingType std::pair&amp;lt;KeyType, ValueType&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">class BPlusTreeInternalPage : public BPlusTreePage {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">private:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // Flexible array member for page data.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> MappingType array_[1];
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>array_[1] 等价与 pair类型的指针.指向pair数组. 数组的每一个元素是&amp;lt;键,值&amp;gt;&lt;/p>
&lt;p>在内部节点中,值代表指针.(第一个元素的键是无效的,但值是存在的).&lt;/p>
&lt;p>因为节点对象使用的是预先分配好的固定空间，array_ 可以控制从该位置开始到 Page 的 data 结束为止的这一段空间。&lt;/p>
&lt;p>因此，节点对象的生命周期也不是由 new 和 delete，而是由 BufferPoolManager 管理.&lt;/p>
&lt;ul>
&lt;li>取一个页面，用 FetchPage；&lt;/li>
&lt;li>使用结束归还一个页面，用 UnpinPage。&lt;/li>
&lt;li>page_id_ 不仅是 B+ 树中节点的编号，同时也是这个节点使用的 Page 在 BufferPool 中的编号。&lt;/li>
&lt;/ul>
&lt;h3 id="btree-leaf-page">B+Tree Leaf Page&lt;/h3>
&lt;ul>
&lt;li>存储 m个有序key，m个 value 实体&lt;/li>
&lt;li>在这次实现中，value 仅仅是64位的record_id, 被用于定位真实的tuples的存储位置.
&lt;ul>
&lt;li>see &lt;code>RID&lt;/code> class defined under in &lt;code>src/include/common/rid.h&lt;/code>.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>对于键值对的数量限制与Internal Page一致.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>重要&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>尽管叶子节点和内部节点有相同类型的key.但他们值的类型不一样.
&lt;ul>
&lt;li>所以&lt;strong>max_size 也应该是不同的&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>每个节点的 &lt;strong>data_&lt;/strong>,都是从buffer pool 中fetch得到的 内存页面.
&lt;ul>
&lt;li>所以当写或读时,要先使用唯一的page_id,从buffer pool 中fetch 出来.&lt;/li>
&lt;li>然后使用 reinterpret cast, 转换成 叶子节点或内部节点.&lt;/li>
&lt;li>并且要在读或写操作结束后,unpin这个页面.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="task-2---btree-data-structure">Task #2 - B+Tree Data Structure&lt;/h2>
&lt;ul>
&lt;li>只支持 unique keys. 也就是说,当有重复的key插入时, 不进行任何操作并返回false&lt;/li>
&lt;li>同时当删除操作导致 页面key数量低于阈值时, 需要正确地执行 merge 和 redistribute(也叫做 coalescing) 操作.&lt;/li>
&lt;/ul>
&lt;p>对于checkpoint , B+Tree Index 只需要支持 &lt;strong>insertions&lt;/strong> (&lt;code>Insert()&lt;/code>), &lt;strong>point search&lt;/strong> (&lt;code>GetValue()&lt;/code>), and &lt;strong>deletes&lt;/strong> (&lt;code>Delete()&lt;/code>)&lt;/p>
&lt;p>插入操作 引起 split操作的情况:&lt;/p>
&lt;ul>
&lt;li>插入操作后, 叶子节点中 pair的数量 等于 max_size&lt;/li>
&lt;li>插入 操作前, 内部节点 孩子数量等于 max_size&lt;/li>
&lt;/ul>
&lt;p>因为写操作会导致, root_page_id的改变,所以也要在 &lt;strong>header page&lt;/strong> 同时更新 root_page_id (&lt;code>src/include/storage/page/header_page.h&lt;/code>).&lt;/p>
&lt;p>更新的方法是调用 &lt;code>UpdateRootPageId&lt;/code> (已经提供了)&lt;/p>
&lt;p>需要隐藏类型和比较.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">template &amp;lt;typename KeyType,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> typename ValueType,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> typename KeyComparator&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">class BPlusTree{
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // ---
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>KeyType&lt;/code>: 索引中key的类型,只可能是 &lt;code>GenericKey&lt;/code>.
&lt;ul>
&lt;li>GeneriKey真实的size是特定的.&lt;/li>
&lt;li>是通过模板参数指定和实例化的，并取决于索引属性的数据类型.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>ValueType&lt;/code>: 索引中值的类型. 只可能是 64-bit RID.&lt;/li>
&lt;li>&lt;code>KeyComparator&lt;/code>: 用来比较两个KeyType实例 大小关系. 左边小于右边时，返回 -1；左边大于右边时，返回 1；相等返回 0。&lt;/li>
&lt;/ul>
&lt;h2 id="checkpoint-1查找插入和删除">Checkpoint 1：查找，插入和删除&lt;/h2>
&lt;h3 id="约定">约定&lt;/h3>
&lt;p>这里约定 内部节点array中key 与子节点的关系.&lt;/p>
&lt;ul>
&lt;li>左子节点的keys &amp;lt;= 父节点的keys&lt;/li>
&lt;li>右子节点的keys &amp;gt; 父节点的keys&lt;/li>
&lt;/ul>
&lt;h3 id="查找">查找&lt;/h3>
&lt;p>给定key，返回查找的页面。&lt;/p>
&lt;p>页面的数据存在叶子节点中。&lt;/p>
&lt;p>因此要从根节点开始，一层一层往下找&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="n">findValue&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="n">Page&lt;/span> &lt;span class="n">page&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">KeyType&lt;/span> &lt;span class="n">key&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//二分查找 page的array中,找到最大的小于等于key的 pair
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">pair&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">GetLeaf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Page&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">KeyType&lt;/span> &lt;span class="n">key&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Page&lt;/span> &lt;span class="n">now&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">now&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">type&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">leaf&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">now&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">findValue&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">now&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">now&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">GetValue&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">KeyType&lt;/span> &lt;span class="n">key&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Page&lt;/span> &lt;span class="n">now&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">GetLeaf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//现在now为叶子节点,在叶子节点中找对应的值.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">findValue&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">now&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//如果返回值的key不相等则没找到.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//相等则返回找到
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="插入叶子节点">插入(叶子节点)&lt;/h3>
&lt;p>因为以下的操作都基于至少有一个根节点的情况.&lt;/p>
&lt;p>因此在最开始要判断是否为空树,如为空树则创建根, 直接返回&lt;/p>
&lt;p>首先看键存不存在,如果已经存在,则直接返回.&lt;/p>
&lt;p>因为B+树的真实数据存在叶子节点中. 因此插入的第一步就是在找到对应叶子节点,并**插入(叶子节点)**到对应位置.&lt;/p>
&lt;p>此后可能会引起分裂.&lt;/p>
&lt;ol>
&lt;li>先直接**插入(叶子节点)**到叶子节点中.&lt;/li>
&lt;li>当发现**插入(叶子节点)**后, 叶子节点的pair数量等于max_size时进行分裂.&lt;/li>
&lt;/ol>
&lt;p>split(page) 操作&lt;strong>这里不分内部叶子节点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>当前节点是full page,因此可以将当前节点分裂成 (左子节点 half full, 新父节点 , half full)&lt;/li>
&lt;li>其中新父节点的值是左子节点的最后一个.&lt;/li>
&lt;li>新父节点 需要 &lt;strong>插入(内部节点)&lt;/strong> 到原来的父节点中.
&lt;ul>
&lt;li>&lt;strong>插入(内部节点)前&lt;/strong>, 要判断 &lt;strong>原父节点的孩子数量是否等于max_size&lt;/strong>&lt;/li>
&lt;li>如果等于, 则先&lt;strong>将原父节点分裂&lt;/strong> 后.&lt;/li>
&lt;li>再执行当前的**插入(内部节点)**操作.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>特殊的. 如果page是根节点, 即没有原父亲节点.
&lt;ul>
&lt;li>则将 根节点 更新成新父节点后, 返回即可.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>插入(内部节点)&lt;/strong> : 因为在插入前已经处理好了插入操作的合法性,因此直接插入即可.&lt;/p>
&lt;p>伪代码:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="n">SetRoot&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">page_id&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">root_page_id&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">page_id&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//一定要调用 UpdateRootPageId
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">split&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">page&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//分裂出下面三个节点
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">left_page&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">right_page&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">new_parent_page&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="c1">//key为左节点的最后一个key, value为指向左节点的指针
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//判断是否为根节点
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">page&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">type&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">rootType&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">SetRoot&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">new_parent_page&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">page_id&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//获取父亲节点
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">parent_page&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">parent_page&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">isFull&lt;/span>&lt;span class="p">()){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">split&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">parent_page&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//将new_parent_page 插入到 parent_page中
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">parent_page&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">insert&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">Insert&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//判断是否为空树
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">valid&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Page&lt;/span> &lt;span class="n">new_page&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Page&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">SetRoot&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">newpage&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">page_id&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//先查找
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">Page&lt;/span> &lt;span class="n">leaf_page&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">GetLeaf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//直接调用叶子节点的插入
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">leaf_page&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Insert&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">leaf_page&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">Page&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">page&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="p">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">LeafPage&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">Insert&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Page&lt;/span> &lt;span class="n">new_page&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//直接插入,同时只需要更新指向 new_page 和 new_page的 next
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//满了就分裂.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">isFull&lt;/span>&lt;span class="p">()){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">split&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">InternalPage&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">Insert&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Page&lt;/span> &lt;span class="n">new_page&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//直接插入,但array中key的有效位置是从1开始
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//上面代码还需要考虑
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//页面的创建和释放
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="删除">删除&lt;/h3>
&lt;p>B+树最难的地方。但比起splay来说还是简单太多了。并且因为B+树只有叶子节点存值。在内部节点的删除上比B树简单了很多。&lt;/p>
&lt;p>删除的核心操作：&lt;/p>
&lt;ol>
&lt;li>叶子节点/内部节点删除元素后;
若小于下限,则按下面的优先级考虑;&lt;/li>
&lt;li>如相邻兄弟结点丰满（即 元素个数 大于 下限+1），则向兄弟结点&lt;strong>借&lt;/strong>一个元素。（具体是 先从相邻方向上的父亲结点变成借来的元素左右(这里具体要看借左边还是右边)，而后对应相邻的兄弟补回这个元素）。否则：&lt;/li>
&lt;li>与相邻的兄弟结点 &lt;strong>合并&lt;/strong>&lt;/li>
&lt;/ol>
&lt;p>父亲节点被删除后, 需要继续执行上面的操作.&lt;/p>
&lt;p>叶子节点和内部节点的差异:&lt;/p>
&lt;ul>
&lt;li>借
&lt;ul>
&lt;li>内部节点和B树操作一样, 先&lt;strong>从相邻方向上的父亲结点拿一个元素&lt;/strong>，而后&lt;strong>对应相邻的兄弟补回这个元素&lt;/strong>&lt;/li>
&lt;li>叶子节点的父亲只是索引节点,因此 把兄弟节点的元素拿来后, 父亲节点的值根据 从左边/右边拿 变成相应的合法的值即可.&lt;/li>
&lt;li>借的操作都&lt;strong>不会涉及父亲节点的删除&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>合并
&lt;ul>
&lt;li>内部节点和B树操作一样, 将兄弟和父亲节点一起合并. (也相当于删除了父亲节点)下限+(下限-1) + 1 等于上限,因此合法&lt;/li>
&lt;li>叶子节点是 两个叶子节点合并后直接删除父亲节点.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>特殊地,如果删除的是根节点的元素，且根结点只有一个元素，则&lt;strong>下降一层&lt;/strong>退出。&lt;/p>
&lt;ul>
&lt;li>因为只有一个待删除的元素，说明目前只有一个儿子结点（刚刚合并了）。&lt;/li>
&lt;li>直接将儿子结点作为根节点。&lt;/li>
&lt;/ul>
&lt;p>伪代码&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//tree的Remove操作
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">Remove&lt;/span>&lt;span class="p">(){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//1.判断是否为空
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">empty&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//返回
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//2.找到叶子结点，并在叶子结点中删除该元素
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">leaf_page&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="c1">//找到叶子节点
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//TODO 删除元素
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//3.判断叶子结点元素个数是是否小于下限
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span> &lt;span class="err">小于&lt;/span> &lt;span class="err">下限&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">UnderFlow&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">Underflow&lt;/span>&lt;span class="p">(){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//3.0 判断是否为根节点
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">IsRoot&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//根节点的下限是1.说明应该减少一层.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//3.0.1a找到根节点唯一的子节点.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//该子节点变为根节点.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//3.0.1b 根节点没有子节点
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//直接删除,树变成空树.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//3.1a. 找兄弟节点借
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">Borrow&lt;/span>&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//3.1a.1a找左兄弟节点借
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">borrow&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">left_&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//3.1a.1b左兄弟不能借，就找右兄弟节点借
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">borrow&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">right_&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//3.1b.借失败了，就准备合并
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">union&lt;/span>&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//3.1b.1a 左兄弟结点存在,就找左兄弟节点合并
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">have&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">left&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="k">union&lt;/span>&lt;span class="err">(&lt;/span>&lt;span class="nc">left_&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//3.1b.1b 没有左兄弟节点, 找右兄弟节点合并.(除根节点外肯定至少有一个兄弟节点)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">union&lt;/span>&lt;span class="err">(&lt;/span>&lt;span class="nc">right_&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">borrow&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">bro_page&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//如果兄弟节点的 size &amp;lt;= 下限,不能借
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">bro_page&lt;/span> &lt;span class="n">size&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="err">下限&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//否则可以借
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//是叶子结点
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//直接拿 对应兄弟结点最靠近的元素
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//是内部结点
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//加入的元素 = 中间父亲结点对应的元素
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//中间父亲结点对应的元素 = 兄弟结点最靠近的元素.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//兄弟结点最靠近的元素删除
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">union&lt;/span>&lt;span class="err">(&lt;/span>&lt;span class="nc">bro_page&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//是叶子结点
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//两个结点合并成一个结点
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//是内部结点
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//好像都是直接把右合并到左就可以.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//删除父亲结点中间的元素.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//如果父亲结点size 小于等于 下限
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//父亲结点采取下溢操作
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Why parallelism? Why efficiency?</title><link>https://ysyyhhh.github.io/blog/why-parallelism-why-efficiency/</link><pubDate>Fri, 01 Mar 2024 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/blog/why-parallelism-why-efficiency/</guid><description>&lt;h2 id="parallelism">Parallelism&lt;/h2>
&lt;p>加速比 Speed up 是指：
程序在单处理器上运行的时间 / 程序在多处理器上运行的时间&lt;/p>
&lt;p>我们一般会期望用两倍的硬件得到两倍的速度提升,但是实际上并不是这样的。&lt;/p>
&lt;p>制约性能提升可能的因素有:&lt;/p>
&lt;ul>
&lt;li>资源分配不均匀&lt;/li>
&lt;li>通信开销&lt;/li>
&lt;li>短板效应&lt;/li>
&lt;li>共享资源读写冲突&lt;/li>
&lt;/ul>
&lt;p>为什么要去了解硬件？&lt;/p>
&lt;ul>
&lt;li>什么是限制性能的因素？&lt;/li>
&lt;li>导致性能瓶颈的原因是什么？&lt;/li>
&lt;/ul>
&lt;h2 id="efficiency">Efficiency&lt;/h2>
&lt;p>fast != efficient&lt;/p>
&lt;ul>
&lt;li>什么是效率？
尽可能地利用资源，减少浪费&lt;/li>
&lt;/ul>
&lt;p>比如按时间租用服务器。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>并行程序的挑战：&lt;/p>
&lt;ul>
&lt;li>负载均衡 Load balance&lt;/li>
&lt;li>通信延迟 Communication latency&lt;/li>
&lt;li>集体工作时，真正用于计算的时间很少&lt;/li>
&lt;/ul></description></item><item><title>openai 相关QA</title><link>https://ysyyhhh.github.io/blog/openai-%E7%9B%B8%E5%85%B3qa/</link><pubDate>Fri, 08 Dec 2023 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/blog/openai-%E7%9B%B8%E5%85%B3qa/</guid><description>&lt;h2 id="无法连接">无法连接&lt;/h2>
&lt;p>Q:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">openai.error.APIConnectionError: Error communicating with OpenAI: HTTPSConnectionPool&lt;span class="o">(&lt;/span>&lt;span class="nv">host&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;api.openai.com&amp;#39;&lt;/span>, &lt;span class="nv">port&lt;/span>&lt;span class="o">=&lt;/span>443&lt;span class="o">)&lt;/span>: Max retries exceeded with url: /v1/chat/completions &lt;span class="o">(&lt;/span>Caused by ProxyError&lt;span class="o">(&lt;/span>&lt;span class="s1">&amp;#39;Unable to connect to proxy&amp;#39;&lt;/span>, SSLError&lt;span class="o">(&lt;/span>SSLZeroReturnError&lt;span class="o">(&lt;/span>6, &lt;span class="s1">&amp;#39;TLS/SSL connection has been closed (EOF) (_ssl.c:1131)&amp;#39;&lt;/span>&lt;span class="o">))))&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>A:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">问题出在模块 urllib3 的版本，报错的是 1.26.3，没报错的是 1.25.11
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">在原报错环境中使用下面命令重装低版本 urllib3：
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">pip install &lt;span class="nv">urllib3&lt;/span>&lt;span class="o">==&lt;/span>1.25.11
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">然后测试果然就没问题了。
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>杂</title><link>https://ysyyhhh.github.io/blog/%E6%9D%82/</link><pubDate>Sun, 23 Jul 2023 00:00:00 +0000</pubDate><guid>https://ysyyhhh.github.io/blog/%E6%9D%82/</guid><description>&lt;p>session权限问题&lt;/p>
&lt;p>&lt;a href="https://blog.51cto.com/u_15162069/2778036" target="_blank" rel="noopener">https://blog.51cto.com/u_15162069/2778036&lt;/a>&lt;/p>
&lt;h5 id="rsa前后端解密出错">RSA前后端解密出错&lt;/h5>
&lt;p>14：07&lt;/p>
&lt;p>JSEncrypt支持的是&lt;a href="https://so.csdn.net/so/search?q=openssl&amp;amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener">openssl&lt;/a>生成的pkcs1格式私钥，java需要pkcs8格式私钥，公钥格式不变&lt;/p>
&lt;p>前端加入替换 encodeURI(encodeData).replace(/\+/g, &amp;lsquo;%2B&amp;rsquo;)&lt;/p>
&lt;p>后端接口加入 URLDecoder.decode(password,&amp;ldquo;UTF-8&amp;rdquo;);&lt;/p>
&lt;p>&lt;a href="https://blog.csdn.net/qq_42979402/article/details/109184787" target="_blank" rel="noopener">https://blog.csdn.net/qq_42979402/article/details/109184787&lt;/a>&lt;/p>
&lt;p>真正错误是密码加了hash函数后，返回值是数字而不是字符串！！！&lt;/p>
&lt;h4 id="数据库返回乱码">数据库返回乱码&lt;/h4>
&lt;p>&lt;a href="https://www.cnblogs.com/fanbi/p/13940432.html" target="_blank" rel="noopener">https://www.cnblogs.com/fanbi/p/13940432.html&lt;/a>&lt;/p>
&lt;h4 id="实际上是apigateway-放入-header-后再取出-乱码httpsblogcsdnnetqq_31277409articledetails118544597">&lt;a href="https://blog.csdn.net/qq_31277409/article/details/118544597" target="_blank" rel="noopener">实际上是apigateway 放入 header 后再取出 乱码&lt;/a>&lt;/h4>
&lt;h4 id="存储过程返回多结果集并接收">存储过程返回多结果集并接收&lt;/h4>
&lt;h4 id="test时报错-aop之类的">test时报错 AOP之类的&lt;/h4>
&lt;p>&lt;a href="https://blog.csdn.net/crxk_/article/details/103196146" target="_blank" rel="noopener">禁用字节码校验&lt;/a>&lt;/p></description></item></channel></rss>