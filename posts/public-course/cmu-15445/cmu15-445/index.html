<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>P0 [C++ Primer](https://15445.courses.cs.cmu.edu/fall2022/project0/) | ysyy's blog</title>
<meta name=keywords content="cmu-15445"><meta name=description content="L1 Relational Model & Relational Algebra 1.1 Databases 数据库：an organized collection of inter-related data that models some aspect of the real-world 数据库管理系统 DBMS：the software that manages a database 1.2 Flat File Strawman 数据库常常以CSV(comma-sepa"><meta name=author content="Ysyy"><link rel=canonical href=https://ysyyhhh.github.io/posts/public-course/cmu-15445/cmu15-445/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://ysyyhhh.github.io/img/Q.gif><link rel=icon type=image/png sizes=16x16 href=https://ysyyhhh.github.io/img/Q.gif><link rel=icon type=image/png sizes=32x32 href=https://ysyyhhh.github.io/img/Q.gif><link rel=apple-touch-icon href=https://ysyyhhh.github.io/img/Q.gif><link rel=mask-icon href=https://ysyyhhh.github.io/img/Q.gif><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://ysyyhhh.github.io/posts/public-course/cmu-15445/cmu15-445/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="P0 [C++ Primer](https://15445.courses.cs.cmu.edu/fall2022/project0/)"><meta property="og:description" content="L1 Relational Model & Relational Algebra 1.1 Databases 数据库：an organized collection of inter-related data that models some aspect of the real-world 数据库管理系统 DBMS：the software that manages a database 1.2 Flat File Strawman 数据库常常以CSV(comma-sepa"><meta property="og:type" content="article"><meta property="og:url" content="https://ysyyhhh.github.io/posts/public-course/cmu-15445/cmu15-445/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-03-01T00:00:00+00:00"><meta property="article:modified_time" content="2024-03-01T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="P0 [C++ Primer](https://15445.courses.cs.cmu.edu/fall2022/project0/)"><meta name=twitter:description content="L1 Relational Model & Relational Algebra 1.1 Databases 数据库：an organized collection of inter-related data that models some aspect of the real-world 数据库管理系统 DBMS：the software that manages a database 1.2 Flat File Strawman 数据库常常以CSV(comma-sepa"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ysyyhhh.github.io/posts/"},{"@type":"ListItem","position":2,"name":"P0 [C++ Primer](https://15445.courses.cs.cmu.edu/fall2022/project0/)","item":"https://ysyyhhh.github.io/posts/public-course/cmu-15445/cmu15-445/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"P0 [C++ Primer](https://15445.courses.cs.cmu.edu/fall2022/project0/)","name":"P0 [C\u002b\u002b Primer](https:\/\/15445.courses.cs.cmu.edu\/fall2022\/project0\/)","description":"L1 Relational Model \u0026amp; Relational Algebra 1.1 Databases 数据库：an organized collection of inter-related data that models some aspect of the real-world 数据库管理系统 DBMS：the software that manages a database 1.2 Flat File Strawman 数据库常常以CSV(comma-sepa","keywords":["cmu-15445"],"articleBody":"L1 Relational Model \u0026 Relational Algebra 1.1 Databases 数据库：an organized collection of inter-related data that models some aspect of the real-world\n数据库管理系统 DBMS：the software that manages a database\n1.2 Flat File Strawman 数据库常常以CSV(comma-separated value)文件的形式存储，由DBMS进行管理。每次应用程序要读取或者更新记录时，都必须解析文件(parse files)。\n1.3 Database Management System A general-purpose(通用) DBMS is designed to allow the definition, creation, querying, update, and administration of databases in accordance with some data model. A data model is a collection of concepts for describing the data in database Examples: relational (most common), NoSQL (key/value, graph), array/matrix/vectors A schema(模式) is a description of a particular collection of data based on a data model 早期，数据库应用很难建立和维护，因为逻辑层和物理层之间存在着紧密的耦合。\n逻辑层： 描述了数据库有哪些实体和属性。 物理层： 是这些实体和属性的存储方式。 所以早期的数据库，一旦改变了物理层，逻辑层也得跟着变。\n1.4 Relational Model 人们每次改变物理层都要重新写数据管理系统，故Ted Codd注意到后提出了关系模型。\nThe relational model defines a database abstraction based on relations to avoid maintenance overhead(维护开销).\n三要点:\nStore database in simple data structures (relations). Access data through high-level language, DBMS figures out(找出) best execution strategy. Physical storage left up to(取决于) the DBMS implementation. 三概念\nThe relational data model defines three concepts:\nStructure: The definition of relations and their contents. This is the attributes the relations have and the values that those attributes can hold. Integrity(完整性): Ensure the database’s contents satisfy constraints. 实体完整性 entity integrity:主属性不能为空 参照完整性 referential integrity: 外键的值必须存在 用户定义的完整性 An example constraint would be that any value for the year attribute has to be a number. Manipulation: How to access and modify a database’s contents. 关系:\nA relation is an unordered set that contains the relationship of attributes that represent entities. So the DBMS can store them in any way it wants, allowing for optimization(允许优化).\n元组:\nA tuple is a set of attribute values (also known as its domain 域 一组相同数据类型的值的集合) in the relation. Originally, values had to be atomic or scalar(标量), but now values can also be lists or nested(嵌套) data structures. Every attribute can be a special value, NULL, which means for a given tuple the attribute is undefined.\n关系:\nA relation with n attributes is called an n-ary relation.\n键\nA relation’s primary key uniquely identifies a single tuple.\nSome DBMSs automatically create an internal primary key if you do not define one. A lot of DBMSs have support for autogenerated keys so an application does not have to manually increment(手动增加) the keys, but a primary key is still required for some DBMSs. A foreign key specifies that an attribute from one relation has to map to a tuple in another relation.\n1.5 Data Manipulation Languages (DMLs) Methods to store and retrieve information from a database.\nThere are two classes of languages for this:\nProcedural(程序上的): The query specifies the (high-level) strategy the DBMS should use to find the desired result based on sets / bags. (relational algebra 代数) Non-Procedural (Declarative 声明): The query specifies only what data is wanted and not how to find it. (relational calculus 微积分/关系演算) 一般现在都是用第二种的，我不管DBMS用什么策略，我只需要你给我我想要的数据。\n1.6 Relational Algebra 关系代数 Relational Algebra is a set of fundamental operations to retrieve(检索) and manipulate tuples in a relation.\nEach operator takes in(需要) one or more relations as inputs, and outputs a new relation. To write queries we can “chain(链)” these operators together to create more complex operations.\n5种基本关系操作\n选择,投影,并,差,笛卡儿积 传统集合运算\n二目运算: 并,差,交,笛卡尔积 专门的关系运算\n选择selection ,投影projection,连接 join,除 dividen 选择:在关系R中,选择符合条件的元组,是从行的角度进行运算.\n投影:在关系R中,选择出若干属性列组成新的关系,从列的角度\n连接:两个关系的笛卡尔积中,选取属性中满足一定条件的元组\n自然连接 内连接: 不保留悬浮元组. 外连接 outer join : 保留悬浮元组(填NULL)的连接 左连接 left outer join: 只保留左边关系R中的悬浮空组. 右连接 right outer join: 只保留右边关系R中的悬浮空组. 除: R除以S得到T, 则T包含所有在R而不在S的属性及其值. 且T和S的所有组合都在R中.\nL2 Modern SQL 2.1 Relation Languages 用户只需要使用声明性语言（即SQL）来指定他们想要的结果。DBMS 负责确定产生该答案的最有效计划。\n关系代数基于 sets (unordered, no duplicates)。 SQL基于 bags (unordered, allows duplicates)\n2.2 SQL History SEQUEL Structured English Query Language\nSQL Structured Query Language\n该语言由不同类别的命令组成：\nDML Data Manipulation Language SELECT, INSERT, UPDATE, DELETE DDL Data Definition Language Schema definitions for tables, indexes, views, and other objects. DCL Data Control Language Security, access controls. SQL仍在不断发展的\n2.3 Join 结合一个或多个表的列，产生一个新的表。用来表达涉及跨越多个表的数据的查询\nCREATE TABLE student ( sid INT PRIMARY KEY, name VARCHAR(16), login VARCHAR(32) UNIQUE, age SMALLINT, gpa FLOAT ); CREATE TABLE course ( cid VARCHAR(32) PRIMARY KEY, name VARCHAR(32) NOT NULL ); CREATE TABLE enrolled ( sid INT REFERENCES student (sid), cid VARCHAR(32) REFERENCES course (cid), grade CHAR(1) ); 找出在15-721拿到A的学术 SELECT s.name FROM enrolled AS e, student AS s WHERE e.grade = 'A' AND e.cid = '15-721' AND e.sid = s.sid; 2.4 Aggregates 聚合函数 聚合函数接受一组列表，然后产生一个单一的标量值作为其输出。基本上只能在SELECT输出列表中使用！\n函数：\nAVG MIN MAX COUNT 当使用goup时,聚合函数输出为每个组的输出.\nhaving 在聚合计算的基础过滤输出结果.而不是where\nSELECT AVG(s.gpa) AS avg_gpa, e.cid FROM enrolled AS e, student AS s WHERE e.sid = s.sid GROUP BY e.cid HAVING avg_gpa \u003e 3.9; 2.5 Sting Operation SQL标准是区分大小写的，而且只能是单引号！有一些函数可以处理字符串，可以在查询的任何部分使用。\nPattern Matching:\nLike 关键字\n% : matches any substrings (including empty). _ : matches any one character String Function: SUBSTRING(S, B, E) UPPER(S)\nConcatenation(连接) : || concatenate two or more strings together into a single string\n2.6 Date and Time 时间函数\n当前日期时间 NOW(), CURRENT_TIMESTAMP() 当前UNIX时间戳 UNIX_TIMESTAMP() 当前日期 CURRENT_DATE() 当前时间 CURRENT_TIME() 日期时间转换函数\n当前时间戳转换为北京时间 FROM_UNIXTIME() 北京时间转换为时间戳 UNIX_TIMESTAMP() 时间中解析年月日时间 DATE_FORMAT(date, format) select DATE_FORMAT('2021-01-01 08:30:50','%Y-%m-%d') 日期时间运算函数\n在某个时间的基础上加上或者减去某个时间 DATE_ADD(date,INTERVAL expr unit) DATE_SUB(date,INTERVAL expr unit)\n返回两个日期值之间的天数 DATEDIFF(expr1,expr2))\nselect DATEDIFF('2021-01-02','2021-01-01') 时间差函数 TIMESTAMPDIFF(unit,datetime_expr1,datetime_expr2)\nunit：天(DAY)、小时(HOUR），分钟(MINUTE)和秒(SECOND)，TIMESTAMPDIFF函数比DATEDIFF函数用起来更加灵活\n2.7 Output Redirection 你可以告诉DBMS将查询结果存储到另一个表中，而不是将查询结果返回给客户端（例如，终端）。结果存储到另一个表中。然后你可以在随后的查询中访问这些数据\nNew Table: 将查询的输出存储到一个新的（永久）表中。\nSELECT DISTINCT cid INTO CourseIds FROM enrolled; Exustubg Table:\n将查询的输出存储到数据库中已经存在的表中。该表 目标表必须有与目标表相同数量和相同类型的列，但输出查询中的列名不需要匹配。\nINSERT INTO CourseIds (SELECT DISTINCT cid FROM enrolled) 2.8 Output Control 可以用ORDER BY来对输出进行排序,后面可以加DESC, ASC来指定排序策略\n输出的数量可以用LIMIT n 进行指定,当然也可以用OFFSET 来提供一个bias。\nELECT sid, grade FROM enrolled WHERE cid = '15-721' ORDER BY grade; SELECT sid, name FROM student WHERE login LIKE '%@cs' LIMIT 20 OFFSET 10; 2.9 Nested Queries 在其他查询中调用查询，在单个查询中执行更复杂的逻辑。嵌套查询往往难以优化。\n外部查询的范围包括在内部查询中（即内部查询可以访问来自外部查询），反之不行。\n内部查询几乎可以出现在一个查询的任何部分。\nSELECT Output Targets\nSELECT (SELECT 1) AS one FROM student; FROM Clause(条件):\nSELECT name FROM student AS s, (SELECT sid FROM enrolled) AS e WHERE s.sid = e.sid; WHERE Clause SELECT name FROM student WHERE sid IN ( SELECT sid FROM enrolled ); 例子： 获取在15-445中注册的学生名字 SELECT name FROM student WHERE sid IN ( SELECT sid FROM enrolled WHERE cid = '15-445' ); 请注意，根据它在查询中出现的位置，sid有不同的范围。\n例子： 找到注册了至少一门课的最大的学生id\nSELECT student.sid, name FROM student JOIN (SELECT MAX(sid) AS sid FROM enrolled) AS max_e ON student.sid = max_e.sid; Nested Query Results Expressions: 关键字：\nALL Must satisfy expression for all rows in sub-query ANY Must satisfy expression for at least one row in sub-query. IN Equivalent to =ANY(). EXISTS At least one row is returned. 例子： 找到所有没有学生注册的课\nSELECT * FROM course WHERE NOT EXISTS( SELECT * FROM enrolled WHERE course.cid = enrolled.cid ); 2.10 Window Functions 函数： 窗口函数可以是我们上面讨论的任何一个聚合函数。也有一些特殊的窗口函数。\nROW_NUMBER: 当前列的数字 RANK: 当前列的顺序 Grouping: OVER子句指定了在计算窗口函数时如何对图元进行分组。使用PARTITION BY来指定分组\nSELECT cid, sid, ROW_NUMBER() OVER (PARTITION BY cid) FROM enrolled ORDER BY cid; 我们也可以在OVER中放入ORDER BY，以确保结果的确定性排序，即使数据库内部发生变化。\nSELECT *, ROW_NUMBER() OVER (ORDER BY cid) FROM enrolled ORDER BY cid; 重要提示：\nDBMS在窗函数排序后计算RANK，而在排序前计算ROW_NUMBER。\n找到每门课程中成绩第二高的学生\nSELECT * FROM ( SELECT *, RANK() OVER (PARTITION BY cid ORDER BY grade ASC) AS rank FROM enrolled) AS ranking WHERE ranking.rank = 2; 2.11. Commom Table Expressions 在编写更复杂的查询时，通用表表达式（CTE）是窗口或嵌套查询的一种替代方法。复杂的查询时，可以替代窗口或嵌套查询。它们提供了一种方法来为用户在一个更大的查询中编写辅助语句.\n可以理解为一个辅助表。\nWITH子句将内部查询的输出与一个具有该名称的临时结果绑定。\n例子： 生成一个名为cteName的CTE，其中包含一个单一属性设置为 “1 “的元组。从这个CTE中选择所有属性。\nWITH cteName AS ( SELECT 1 ) SELECT * FROM cteName; 我们可以在AS之前将输出列绑定到名称上\nWITH cteName (col1, col2) AS ( SELECT 1, 2 ) SELECT col1 + col2 FROM cteName; 一个查询可能包含多个CTE声明\nWITH cte1 (col1) AS (SELECT 1), cte2 (col2) AS (SELECT 2) SELECT * FROM cte1, cte2; 递归能力 在WITH后面添加RECURSIVE关键字允许CTE引用自己。这使得在SQL查询中可以实现递归。有了递归的CTE，SQL被证明是图灵完备的，这意味着它在计算上的表现力不亚于更多的通用编程语言\n例子：打印从1到10的数字\nWITH RECURSIVE cteSource (counter) AS ( ( SELECT 1 ) UNION ( SELECT counter + 1 FROM cteSource WHERE counter \u003c 10 ) ) SELECT * FROM cteSource; Homework #1 - SQL CASE 语句\nSELECT name, CASE when died is not null then died-born else '2022' - born END as age FROM people where born \u003e= '1900' ORDER by age DESC,name LIMIT 20; CAST AS TEXT 转换成字符串，字符串连接用 ||\nselect CAST(titles.premiered/10*10 AS TEXT) || 's' as decade, round(avg(rating),2) as avg, max(rating) as top, min(rating) as min, count(*) as NUM_RELEASES from ratings join titles on titles.title_id = ratings.title_id where decade is not null GROUP by decade order by avg DESC,decade limit 20; 第一个with后，用,隔开\nwith person_title as ( select people.name, people.person_id, crew.title_id from people join crew on crew.person_id = people.person_id join titles on titles.title_id = crew.title_id where born = 1955 and titles.type = \"movie\" ), person_avg as ( select person_title.name,round(avg(rating),2) as avg from RATINGS join person_title on person_title.title_id = ratings.title_id group by person_title.person_id ), quantiles as ( select * ,NTILE(10) OVER (ORDER BY avg ASC) as QuantileRating from person_avg ) select name,avg from quantiles where QuantileRating = 9 order by avg DESC,name; 把表格数据压缩成一行，用，隔开\nwith p as( select akas.title as dubbed from titles join akas on akas.title_id = titles.title_id where primary_title = \"House of the Dragon\" and type = \"tvSeries\" group by primary_title,dubbed order by dubbed ) select GROUP_CONCAT(dubbed,', ') from p; L3 -4Database Storage 3.1 Storage The DBMS assumes that the primary storage location of the database is on non-volatile disk.\nThe DBMS’s components manage the movement of data between non-volatile and volatile storage.\nVolatile Devices:\nVolatile means that if you pull the power from the machine, then the data is lost. Volatile storage supports fast random access with byte-addressable locations. This means that the program can jump to any byte address and get the data that is there. For our purposes, we will always refer to this storage class as “memory.” Non-Volatile Devices:\nNon-volatile means that the storage device does not require continuous power in order for the device to retain the bits that it is storing. It is also block/page addressable. This means that in order to read a value at a particular offset, the program first has to load the 4 KB page into memory that holds the value the program wants to read. Non-volatile storage is traditionally better at sequential access (reading multiple contiguous chunks of data at the same time). We will refer to this as “disk.” We will not make a (major) distinction between solid-state storage (SSD) and spinning hard drives (HDD). 3.2 Disk-Oriented DBMS Overview The database is all on disk, and the data in database files is organized into pages, with the first page being the directory page.\nTo operate on the data, the DBMS needs to bring the data into memory. It does this by having a buffer pool that manages the data movement back and forth between disk and memory\nThe DBMS also has an execution engine that will execute queries. The execution engine will ask the buffer pool for a specific page, and the buffer pool will take care of bringing that page into memory and giving the execution engine a pointer to that page in memory.\nThe buffer pool manager will ensure that the page is there while the execution engine operates on that part of memory.\n3.3 DBMS vs OS DBMS的一个高级设计目标是支持超过可用内存量的数据库。因为访问disk的代价很大，所以使用disk应该要小心。我们不希望从磁盘上访问数据时停顿太久，从而拖慢其他一切。我们希望DBMS能够处理在等待从磁盘获取数据时，能够处理其他查询。 这个高层次的设计目标就像虚拟内存一样，有一个大的地址空间和一个供操作系统从磁盘引入页面的地方。 实现这种虚拟内存的方法之一是使用mmap来映射进程地址空间中的文件内容，这使得操作系统负责在磁盘和内存之间来回移动页面。 但不幸的是，如果mmap遇到页面故障，进程将会被阻塞。 如果你需要写入，你永远不想在你的DBMS中使用mmap。 DBMS（几乎）总是想自己控制事情，而且可以做得更好，因为它知道更多关于被访问的数据和被处理的查询。 可以通过使用操作系统： madvise: 告诉操作系统你打算何时读某些页面。 mlock: 告诉操作系统不要把内存范围换到磁盘上。 msync: 告诉操作系统将内存范围刷新到磁盘。 出于正确性和性能的考虑，我们不建议在DBMS中使用mmap。\n3.4 File Storage 在其最基本的形式中，DBMS将数据库存储为磁盘上的文件。有些可能使用文件层次结构，有些则可能使用单个文件 操作系统对这些文件的内容一无所知。只有DBMS知道如何解读它们的内容，因为它是以DBMS特有的方式编码的。 DBMS的存储管理器负责管理数据库的文件。它将文件表示为一个 页的集合。它还跟踪哪些数据被读和写到了页面上，以及这些页面有多少可用空间。这些页面中还有多少可用空间。 3.5 Database Pages DBMS将数据库组织在一个或多个文件中的固定大小的数据块，称为页。页面可以包含不同种类的数据（tuple、indexes等）。 大多数系统不会将这些类型混合在一页中。 有些系统会要求页面是自成一体（self-contained）的，也就是说，阅读每个页面所需的所有信息都在页面本身。读取每一页的所有信息都在页面本身 Each page is given a unique identifier. The DBMS uses an indirection layer to map page IDs to physical locations. There are three different notions of “pages” in a DBMS:\nHardware Page (usually 4KB) OS Page (usually 4KB) Database Page (512B-16KB) 存储设备保证写的操作是atomic 原子的。 这意味着，如果我们的数据库页面比我们的硬件页面大，DBMS将不得不采取额外的措施 以确保数据被安全地写出来。 因为当系统崩溃时，程序可能已经完成了将数据库页面写入磁盘的一部分\nDifferent DBMSs manage pages in files on disk in different ways.\nHeap File Organization Tree File Organization Sequential / Sorted File Organization (ISAM) Hashing File Organization At this point in the hierarchy(层次结构) we don’t need to know anything about what is inside of the pages.\n3.6 Database Heap A heap file is an unordered collection of pages with tuples that are stored in random order.\nCreate / Get / Write / Delete Page Must also support iterating over all pages. DBMS可以通过使用页面的链接列表或页面目录在磁盘上找到一个给定的页面ID\nLinked List: Header page持有指向自由页列表和数据页列表的指针。然而，如果 DBMS正在寻找一个特定的页面，它必须在数据页列表上进行顺序扫描，直到它找到它要找的页面。\nPage Directory:\nDBMS维护特殊的页面，跟踪数据页的位置以及每页的可用空间。\nNeed meta-data to keep track of what pages exist in multiple files and which ones have free space.\n3.7 Page Layout 每个页面都包括一个header，记录关于页面内容的元数据。 Page size Checksum DBMS version Transaction visibility Self-containment(自成一体) (Some systems like Oracle require this.) For any page storage architecture, we now need to decide how to organize the data inside of the page.\nWe are still assuming that we are only storing tuples.\nTwo approaches:\nTuple-oriented (其实是 slotted-page) 页面将slots映射到offsets,slot array 记录对应tuple的便宜量 Header keeps track of the number of used slots, the offset of the starting location of the last used slot, and a slot array, which keeps track of the location of the start of each tuple. To add a tuple, the slot array will grow from the beginning to the end, and the data of the tuples will grow from end to the beginning. The page is considered full when the slot array and the tuple data meet Log-structured 3.8 Tuple Layout tuple 内部的结构\ntuples本质上是一个字节序列。DBMS的工作是将这些字节解释为属性类型和值。\nTuple Header：包含了tuple的元数据\nDBMS的并发控制协议的可见性信息。关于哪个事务创建/修改了该元组 NULL值的位图。 注意，DBMS不需要在这里存储关于数据库模式的元数据。 Tuple Data：数据的实际属性\n属性通常按照你创建表时指定的顺序存储 大多数DBMS不允许一个tuple超过一个页面的大小。 Unique Identifier\n数据库中的每个tuple都被分配一个唯一的标识符 一般是：page_id + (offset or slow) 一个应用程序不能依赖这些ID来表示任何东西 De-normalized Tuple Data:\n如果两个表是相关的，DBMS可以 “pre-join\"它们，所以这些表最终会出现在 在同一个页面上。这使得读取速度加快，因为DBMS只需要加载一个页面而不是两个 独立的页面。然而，这使得更新更加昂贵，因为DBMS需要更多的空间给每个 tuples\n3.9 Log-Structured Storage （也叫Append-only Sequence of Data） 参考: Log-Structured 结构\n与Slotted-Page Design有关的问题是： Fragmentation: 删除tuple会在page中留下空隙。\nUseless Disk I/O:\n由于非易失性存储的block-oriented的性质，需要读取整个块来获取tuple。\nRandom Disk I/O: 磁盘阅读器可能不得不跳到20个不同的地方来更新20个不同的tuples，这可能会非常慢。\n如果我们在一个只允许创建新数据而不允许覆盖的系统上工作呢？日志结构的存储模型与这个假设相配合，解决了上面列出的一些问题。\nLog-Structured Storage: DBMS不存储tuples，只存储日志记录。\n将数据库如何被修改的记录存储到文件中（放入和删除）。每条日志包含tuples的唯一标识符 要读取一条记录，DBMS会从最新的到最旧的逆向扫描日志文件，并 “重新创建 “这个 tuple。 写的快，读的可能慢。磁盘写入是连续的，现有的页面是不可改变的，这导致了随机磁盘I/O的减少。 在append-only的存储上工作得很好，因为DBMS不能回溯并更新数据。 The log will grow forever. The DBMS needs to periodically compact(紧凑) pages to reduce wasted space.\n由于不再需要时间信息，数据库可以将日志压缩到一个按id排序的表中。这些被称为分类字符串表（SSTables），它们可以使tuple搜索非常快。 紧凑化的问题是，DBMS最终会出现写入放大的情况。(它一次又一次地重写相同的数据）。 Compaction coalesces larger log files into smaller files by removing unnecessary records.\nLog-structured storage managers are more common today. This is partly due to the proliferation(扩散) of RocksDB.\n3.11 Data Representation A tuple is essentially a sequence of bytes.\nIt’s the job of the DBMS to interpret those bytes into attribute types and values.\nThe DBMS’s catalogs(目录) contain the schema information about tables(数据表示方案) that the system uses to figure out the tuple’s layout.\nINTEGER, BIGINT, SMALLINT, TINYINT. (Integers)大多数DBMS使用IEEE-754标准规定的 “native “C/C++类型来存储整数。这些值是固定长度的。 FLOAT, REAL (Variable Precision Numbers) 这些是不精确的、可变精度的数字类型, “native “C/C++类型,这些值也是固定长度的。 变精度数的运算比任意精度数的运算更快，因为CPU可以直接对其执行指令。然而，在进行计算时可能会出现精度损失！ NUMERIC, DECIMAL.(Fixed-Point Precision Numbers) 通常以精确的、可变长度的二进制表示法（像一个字符串）来存储.带有额外的元数据，这些数据将告诉系统诸如数据的长度和小数点应该在哪里。 当误差不可接受的时候，DBMS就要付出性能的代价来提高精度。 VARCHAR, VARBINARY, TEXT, BLOB Variable-Length Data\n代表任意长度的数据类型。它们通常是用一个header来存储的，这个header可以追踪到字符串的长度，以便于跳转到下一个值。它还可能包含一个数据的校验和。 大多数DBMS不允许一个tuple超过一个页面的大小。 但是！那些允许的系统将数据存储在一个特殊的 “溢出 “页上，并让tuple包含一个对该页的引用。这些溢出页可以包含指向其他溢出页的指针，直到所有的数据都可以被存储。(类似分级页表) 有些系统会让你把这些大的数值存储在一个外部文件中，然后元组会包含一个指向该文件的指针。例如，如果数据库存储的是照片信息，DBMS可以将照片存储在外部文件中，而不是让它们占用DBMS中的大量空间。这样做的一个缺点是，DBMS不能操作这个文件的内容。因此，No durability protections. No transaction protections.没有耐久性或交易保护。 TIME, DATE, TIMESTAMP. Dates and Times 不同的系统对日期/时间的表示方法不同。通常情况下，它们被表示为一些单位时间 (自unix时代的（微/毫）秒）。\nSystem Catalogs\n为了使DBMS能够识别tuple的内容，它维护了 INFORMATION_SCHEMA内部目录来告诉它关于数据库的元数据。元数据将包含关于数据库有哪些表和列的信息，以及它们的类型和值的顺序。\n大多数DBMS将其目录以其表的格式存储在自己的内部。他们使用 特殊代码来 “bootstrap “这些目录表。\nL5 Storage Models \u0026 Compression 5.1 Database Workloads OLTP: Online Transaction Processing\nAn OLTP workload is characterized by fast, short running operations, simple queries that operate on single entity at a time, and repetitive operations.\nAn OLTP workload will typically handle more writes than reads.\nAn example of an OLTP workload is the Amazon storefront. Users can add things to their cart, they can make purchases, but the actions only affect their account.\nOLAP: Online Analytical Processing\nAn OLAP workload is characterized by long running(长期运行), complex queries, reads on large portions of the database.\nIn OLAP workloads, the database system is analyzing and deriving(推导/添加) new data from existing data collected on the OLTP side.\nAn example of an OLAP workload would be Amazon computing the most bought item in Pittsburgh on a day when its raining.\nHTAP: Hybrid Transaction + Analytical Processing\nA new type of workload which has become popular recently is HTAP, which is like a combination which tries to do OLTP and OLAP together on the same database.\n5.2 Storage Models N-Ary Storage Model (NSM) In the n-ary storage model, the DBMS stores all of the attributes for a single tuple contiguously in a single page\nThis approach is ideal for OLTP workloads where requests are insert-heavy and transactions tend to operate only an individual entity.\nIt is ideal because it takes only one fetch to be able to get all of the attributes for a single tuple.\nAdvantages:\nFast inserts, updates, and deletes. Good for queries that need the entire tuple. Disadvantages:\nNot good for scanning large portions of the table and/or a subset of the attributes. Decomposition 分解 Storage Model (DSM) This model is ideal for OLAP workloads with many read-only queries that perform large scans over a subset of the table’s attributes.\nAdvantages:\nReduces the amount of I/O wasted because the DBMS only reads the data that it needs for that query. Better query processing and data compression Disadvantages:\nSlow for point queries, inserts, updates, and deletes because of tuple splitting/stitching(缝合). To put the tuples back together when using a column store,there are two common approaches:\nfixed-length offsets(most common): Each value is the same length for an attribute\nEmbedded Tuple Ids:Each value is stored with its tuple id in a column\n5.3 Database Compression 压缩操作被在disk-based DBMSs广泛应用。因为disk的I/O总是瓶颈，所以压缩可以让系统提升性能，尤其是只读analyt Managical workloads上。\n如果事先对tuples进行了压缩，DBMS可以获取更多有用的tuple，但代价是要付出更大的压缩和解压的计算开销。\n内存中的DBMS更加复杂，因为它们不必从磁盘中获取数据来执行一个查询。 内存比磁盘快得多，但压缩数据库可以减少DRAM需求和处理。\n而且必须在速度和压缩率中取得一个平衡。压缩数据库可以减少DRAM的需求和查询执行过程中的CPU成本。\n如果数据集是完全随机的bits，那么我们没有办法进行压缩。然而，现实世界中的数据集有一些key properties 是可以进行压缩的。\n数据集往往具有高度倾斜的属性值分布（例如，Brown语料库的Zipfian分布）。 数据集往往在同一元组的属性之间有很高的相关性（例如，邮政编码到城市。订单日期与发货日期）。 Manag Given this, we want a database compression scheme to have the following properties:\nMust produce fixed-length values. The only exception is var-length data stored in separate pools. This because the DBMS should follow word-alignment(对齐) and be able to access data using offsets. Allow the DBMS to postpone(推迟) decompression as long as possible during query execution (late materialization). Must be a lossless scheme because people do not like losing data. Any kind of lossy compression has to be performed at the application level. Compression Granularity 在给DBMS增加压缩功能之前，我们需要决定我们要压缩什么样的数据。这个决定决定了压缩方案的可用性。有四个级别的压缩 Manag颗粒度（granularity）\nBlock Level: 压缩同一张表的tuple块。\nTuple Level: 压缩整个tuples的内容（仅NSM）。\nAttribute Level: 在一个tuple内压缩单个属性值。可以针对同一tuple的多个属性。\nColumnar Level:\n为多个tuple存储的一个或多个属性压缩多个值 (只限于DSM)。这允许更复杂的压缩方案。\n5.4 Naive Compression DBMS使用一个通用的算法对数据进行压缩 (e.g., gzip, LZO, LZ4, Snappy, Brotli, Oracle OZIP, Zstd)。 尽管DBMS可以使用几种压缩算法，但工程师们往往选择那些经常提供较低压缩率以换取更快的压缩/解压的算法。\nnaive compression例子： MySQL InnoDB\nDBMS对磁盘页面进行压缩，将其压缩到2KB的幂数，并将其存储到缓冲池中。然而，每次DBMS试图读取数据时，缓冲池中的压缩数据必须被解压\n缺点:\n由于访问数据需要对压缩的数据进行解压，这就限制了压缩方案的范围。 如果目标是将整个表压缩成一个巨大的块，使用naive compression 方案是不可能的，因为每次访问都需要对整个表进行压缩/解压缩。 因此，对于MySQL来说，由于压缩范围有限，它将表分解成更小的块状。 naive方案也没有考虑到数据的高级含义或语义。 该算法既不考虑数据的结构，也不考虑查询打算如何访问 数据。因此，这就失去了利用late materialization 的机会，因为DBMS不能知道它何时能够延迟数据的解压。 5.5 Columnar Compression 柱状压缩** Run-length Encoding Compress runs of the same value in a single column into triplets:\nThe value of the attribute. The start position in the column segment. The # of elements in the run. Requires the columns to be sorted intelligently(智能) to maximize compression opportunities.\nBit-Packing Encoding When values for an attribute are always less than the value’s declared largest size, store them as smaller data type.\nBit-packing variant that uses a special marker to indicate when a value exceeds largest size and then maintain a look-up table to store them.\nBitmap Encoding Store a separate bitmap for each unique value for an attribute where an offset in the vector corresponds to a tuple.\nThe i th position in the Bitmap corresponds to the i th tuple in the table. Typically segmented into chunks to avoid allocating large blocks of contiguous memory. Only practical if the value cardinality(基数) is low. Some DBMSs provide bitmap indexes. Delta Encoding Recording the difference between values that follow each other in the same column.\nStore base value in-line or in a separate look-up table. Combine with RLE to get even better compression ratios. Incremental Encoding Type of delta encoding that avoids duplicating common prefixes/suffixes between consecutive tuples. This works best with sorted data.\nDictionary Encoding Build a data structure that maps variable-length values to a smaller integer identifier.\nReplace those values with their corresponding identifier in the dictionary data structure.\nNeed to support fast encoding and decoding. Encode/Locate: For a given uncompressed value, convert it into its compressed form. Decode/Extract: For a given compressed value, convert it back into its original form. No magic hash function will do this for us. Need to also support range queries. Most widely used compression scheme in DBMSs.\nHomework #2 Storage \u0026 Indexes Question 1: Storage Models a database with a single table R(q_id,txns,total,failed), where q_id is the primary key, and all attributes are the same fixed width.\nSuppose R has 20,000 tuples that fit into 100 pages, Ignore any additional storage overhead for the table (e.g., page headers, tuple headers).\nAssumptions:\nThe DBMS does not have any additional meta-data (e.g., sort order, zone maps). R does not have any indexes (including for primary key q_id) None of R’s pages are already in the buffer pool. SELECT total - failed FROM R WHERE q id = 96 AND txns \u003e 420; (a) Suppose the DBMS uses the decomposition storage model (DSM) with implicit offsets i What is the minimum number of pages that the DBMS will potentially have to read from disk to answer this query?\n题意是存在这样一条记录,找到该条记录最少的磁盘读次数.\n官方解答是: 4 pages. 1 to find the primary key, + 3 to access txns, total, failed at their corresponding offsets.\n因为使用分解存储模式DSM, 按列存储.\n因此找到主键后就可以通过偏移量找其他属性的值. 读盘次数的限制在找主键上.\n显然,找主键至少需要一次读盘.\nii What is the maximum number of pages that the DBMS will potentially have to read from disk to answer this query?\n官方解答: 28 pages. There are 25 pages per attribute. In the worst case, we scan through all 25 pages to find the primary key, and then + 3 to access txns, total, failed at their corresponding offsets.\n上题可知,找主键次数决定了读盘次数.\n也就是当q_id = 96的记录越靠后, 找主键次数越多.\n因为没有顺序,所以96是无用的信息.\n同时因为有四个属性,且所有属性大小固定. 所以当每个属性都占25页时,且q_id=26所在的记录是最后一个(25),找主键次数最大为25次.\n(b)Suppose the DBMS uses the N-ary storage model (NSM) i. What is the minimum number of pages that the DBMS will potentially have to read from disk to answer this query?\nSolution: We find the tuple with the matching primary key on the first page. No need to look in other pages since all attributes are stored together.\n在第一页\nii. [4 points] What is the maximum number of pages that the DBMS will potentially have to read from disk to answer this query?\n在最后一页 100\nQuestion 2: Cuckoo Hashing 几道哈希表计算的题目,较简单\n2进制：0b，8进制：0o，10进制：无前缀，16进制：0x\nQuestion 3: Extendible Hashing Consider an extendible hashing structure such that:\nEach bucket can hold up to two records. The hashing function uses the lowest g bits, where g is the global depth. 题目是一个二进制可扩展哈希. 哈希函数是二进制最低g位.\n每个哈希值对应一个桶, 每个桶最多两个, 所有刚好就是二进制.\n(a) Starting from an empty table, insert keys 15, 14, 23, 11, 9. 二进制表示\n15: 00001111 14: 00001110 23: 00010111 11: 00001011 9 : 00001001 插入步骤(括号内为局部深度,全局深度为最大局部深度)\n插入15 全局: 1; 桶 1(1):15 14 全局: 1; 桶 1(1):15 ; 0(1):14 23 全局: 1; 桶 1(1):15,23; 0(1):14 11 全局: 1; 桶 1(1):15,23,11; 0(1):14 桶1此时有三条记录,需要扩展深度,扩展为2 全局: 2; 桶 11(2):15,23,11; 01(2):; 0(1):14 桶11此时有三条记录,需要扩展深度,扩展为3 全局: 3; 桶 111(3):15,23; 011(3):11;01(2):; 0(1):14 9 全局: 3; 桶 111(3):15,23; 011(3):11; 0(1):14; 01(2):9; i. What is the global depth of the resulting table?\n显然,当g至少等于3的时候才能使得同一个哈希值最多对应两个记录.\nii. [4 points] What is the local depth the bucket containing 15?\n为3\niii. [4 points] What is the local depth of the bucket containing 14?\n为1\n(b) Starting from the result in (a), you insert keys 12, 5, 7, 13, 2. 15: 00001111 14: 00001110 23: 00010111 11: 00001011 9 : 00001001 此时 全局: 3; 桶 111(3):15,23; 011(3):11; 0(1):14; 01(2):9; 12: 00001010 5 : 00000101 7 : 00000111 13: 00001101 2 : 00000010 12 全局: 3; 桶 111(3):15,23; 011(3):11; 0(1):14,12; 01(2):9; 5 全局: 3; 桶 111(3):15,23; 011(3):11; 0(1):14,12; 01(2):9; 7 全局: 3; 桶 111(3):15,23; 011(3):11; 0(1):14,12; 1(1):9,5; 此时111桶有3个,增加深度为4 全局: 4; 桶 1111(4):15;0111(4):23,7; 011(3):11; 0(1):14,12; 1(1):9,5; 13 全局: 4; 桶 1111(4):15;0111(4):23,7; 011(3):11; 0(1):14,12; 1(1):9,5; 01(2):13; 2 全局: 4; 桶 1111(4):15;0111(4):23,7; 011(3):11; 0(1):14,12; 1(1):9,5; 01(2):13;01(2):2 i. [4 points] Which key will first cause a split (without doubling the size of the table)?\n这里的split操作指的是增加桶的数量,而不double.也就是不增加全局深度.(增加全局深度会翻一倍)\n所以是13第一个增加了桶的数量.\nii. [4 points] Which key will first make the table double in size?\n7\n(c) Now consider the table below, along with the following deletion rules: If two buckets satisfy the following: (a) They have the same local depth d\n(b) They share the first d − 1 bits of their indexes (e.g. b010 and b110 share the first 2 bits)\n(c) Their constituent elements fit in a single bucket. Then they can be merged into a single bucket with local depth d − 1.\nIf the global depth g becomes strictly greater than all local depths, then the table can be halved in size. The resulting global depth is g − 1. 00 28:11100 8 :01000 01 25:11001 10 30:11110 22:10110 18:10010 011 11:01011 27:11011 111 23:10111 7 :00111 Starting from the table above, delete keys 25, 18, 22, 27, 7.\ndelete 25 00 28:11100 8 :01000 10 30:11110 22:10110 18:10010 011 11:01011 27:11011 111 23:10111 7 :00111 delete 18 00 28:11100 8 :01000 10 30:11110 22:10110 011 11:01011 27:11011 111 23:10111 7 :00111 delete 22 00 28:11100 8 :01000 10 30:11110 011 11:01011 27:11011 111 23:10111 7 :00111 此时00 和 10可进行合并 0 28:11100 8 :01000 30:11110 011 11:01011 27:11011 111 23:10111 7 :00111 delete 27 0 28:11100 8 :01000 30:11110 011 11:01011 111 23:10111 7 :00111 此时 011 和 111可合并为11,一次合并最多减少1, 此时global depth = 2 0 28:11100 8 :01000 30:11110 11 11:01011 23:10111 7 :00111 delete 7 0 28:11100 8 :01000 30:11110 11 11:01011 23:10111 i. Which deletion first causes a reduction in a local depth. 22\nii. Which deletion first causes a reduction in global depth.\n27\nSolution: Deleting 27 from bucket b011 allows it to merge with b111. Since these two buckets are the only ones of depth d = 3, this merge reduces the global depth to d = 2\nQuestion 4: B+Tree 还行,就是有个奇怪的点. 索引节点的值一般会出现在叶子节点上.\n最后一题是找出指定的节点 非法的地方.\nP1 1: 0001 2: 0010 3: 0011 4: 0100 5: 0101 6: 0110 7: 0111 8: 1000 9: 1001 1 2 3 4 全局1 1(1):1,3;0(1):2,4; 5 全局1 1(1):1,3,5;0(1):2,4; 全局2 01(2):1,5;11(2)3;0(1):2,4; 6 全局2 01(2):1,5;11(2)3;00(2):4;10(2):2,6; 7 全局2 01(2):1,5;11(2)3,7;00(2):4;10(2):2,6; 8 全局2 01(2):1,5;11(2)3,7;00(2):4,8;10(2):2,6; 9 全局2 01(2):1,5,9;11(2)3,7;00(2):4,8;10(2):2,6; 全局3 001(3):1,9;101(3):5;11(2)3,7;00(2):4,8;10(2):2,6; LRU-K The LRU-K algorithm evicts(剔除) a frame whose backward k-distance is maximum of all frames in the replacer.\nBackward k-distance is computed as the difference in time between current timestamp and the timestamp of kth previous access.\nA frame with less than k historical accesses is given +inf as its backward k-distance. When multipe frames have +inf backward k-distance, the replacer evicts the frame with the earliest timestamp.\n先弄清楚逻辑在写，不要把时间花在无意义的bug上。\nP2 B+Tree 概述 内部节点：索引作用\n叶子节点：包含真正的数据实体\n由于树是动态增长和收缩，所以要处理 split 和 merge\nSince the tree structure grows and shrink dynamically, you are required to handle the logic of split and merge.\nCheckpoint #1 — Due Date: Oct 11 @ 11:59pm\nTask #1 - B+Tree Pages Task #2 - B+Tree Data Structure (Insertion, Deletion, Point Search) Checkpoint #2 — Due Date: Oct 26 @ 11:59pm\nTask #3 - Index Iterator Task #4 - Concurrent Index 该project 要依赖于上一个 buffer pool 的正确实现。\n由于第一个检查点与第二个检查点密切相关，在第二个检查点中，您将在现有的B+索引中实现索引抓取，因此我们传入了一个名为transaction的指针参数，其默认值为nullptr。在任务#4之前，您不需要更改或调用与参数相关的任何函数。\nTask #1 - B+Tree Pages B+Tree Parent Page B+Tree Internal Page B+Tree Leaf Page B+Tree Parent Page ParenPage 被 Internal Page 和 Leaf Page所继承。\n并且只包含了 子类 所共享的信息。\n可以规定 parent_page_id_ 为 INVALID_PAGE_ID 表示根节点。\n| Variable Name | Size | Description | | ————— | —- | ————————————— | | page_type_ | 4 | Page Type (internal or leaf) | | lsn_ | 4 | Log sequence number (Used in Project 4) | | size_ | 4 | Number of Key \u0026 Value pairs in page | | max_size_ | 4 | Max number of Key \u0026 Value pairs in page | | parent_page_id_ | 4 | Parent Page Id | | page_id_ | 4 | Self Page Id |\nB+Tree Internal Page 不存储真实数据。只存储 m个有序 key和m+1个child 指针。 因为key的数量和指针数量不相等。第一个key被设定为invalid。所有方法需要从第二个key开始（下标为1） 实际存储如下 键,指针,键,指针,…,键,指针. 此时有m+1个键,为了保证只有m个键,所以第一个键设置为无效的. key的数量限制\n在任何时间，最少装了一半（half-full）。 删除时，两个 half-full可以被joined 成为一个合法的 Internal Page 或者被重新分配来避免merge 当插入到一个fullpage时，可以被split成两个。 This is an example of one of the many design choices that you will make in the implementation of the B+ Tree. 三个泛型 KeyType, ValueType, KeyComparator。\nKeyType 不一定直接可用大于小于号比较，所以引入了 KeyComparator，从 cpp 文件中的实例化可以看出用的是 GenericKey 和 GenericComparator，查看二者源码可以得到以下信息：\nGenericKey 可以调用 ToString() 函数得到其 int64 表示，然后用 **%ld 格式符打印。**这对我们后面调试时非常重要。 GenericComparator 的比较规则是：左边小于右边时，返回 -1；左边大于右边时，返回 1；相等返回 0。\nValueType 代表的是指向子页面的指针，从实例化可以看出实际只用了 page_id_t，也就是 int。\n数据存储上，其理论结构应为 \u003c指针，键，指针，键…，键，指针\u003e，为方便存储，实际上在头部多补了一个无效键，从而可以用一个 pair 的数组存储：\n#define MappingType std::pair ... class BPlusTreeInternalPage : public BPlusTreePage { ... private: // Flexible array member for page data. MappingType array_[1]; } array_[1] 等价与 pair类型的指针.指向pair数组. 数组的每一个元素是\u003c键,值\u003e\n在内部节点中,值代表指针.(第一个元素的键是无效的,但值是存在的).\n因为节点对象使用的是预先分配好的固定空间，array_ 可以控制从该位置开始到 Page 的 data 结束为止的这一段空间。\n因此，节点对象的生命周期也不是由 new 和 delete，而是由 BufferPoolManager 管理.\n取一个页面，用 FetchPage； 使用结束归还一个页面，用 UnpinPage。 page_id_ 不仅是 B+ 树中节点的编号，同时也是这个节点使用的 Page 在 BufferPool 中的编号。 B+Tree Leaf Page 存储 m个有序key，m个 value 实体 在这次实现中，value 仅仅是64位的record_id, 被用于定位真实的tuples的存储位置. see RID class defined under in src/include/common/rid.h. 对于键值对的数量限制与Internal Page一致. 重要\n尽管叶子节点和内部节点有相同类型的key.但他们值的类型不一样. 所以max_size 也应该是不同的 每个节点的 data_,都是从buffer pool 中fetch得到的 内存页面. 所以当写或读时,要先使用唯一的page_id,从buffer pool 中fetch 出来. 然后使用 reinterpret cast, 转换成 叶子节点或内部节点. 并且要在读或写操作结束后,unpin这个页面. Task #2 - B+Tree Data Structure 只支持 unique keys. 也就是说,当有重复的key插入时, 不进行任何操作并返回false 同时当删除操作导致 页面key数量低于阈值时, 需要正确地执行 merge 和 redistribute(也叫做 coalescing) 操作. 对于checkpoint , B+Tree Index 只需要支持 insertions (Insert()), point search (GetValue()), and deletes (Delete())\n插入操作 引起 split操作的情况:\n插入操作后, 叶子节点中 pair的数量 等于 max_size 插入 操作前, 内部节点 孩子数量等于 max_size 因为写操作会导致, root_page_id的改变,所以也要在 header page 同时更新 root_page_id (src/include/storage/page/header_page.h).\n更新的方法是调用 UpdateRootPageId (已经提供了)\n需要隐藏类型和比较.\ntemplate ","wordCount":"14714","inLanguage":"zh","datePublished":"2024-03-01T00:00:00Z","dateModified":"2024-03-01T00:00:00Z","author":[{"@type":"Person","name":"Ysyy"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://ysyyhhh.github.io/posts/public-course/cmu-15445/cmu15-445/"},"publisher":{"@type":"Organization","name":"ysyy's blog","logo":{"@type":"ImageObject","url":"https://ysyyhhh.github.io/img/Q.gif"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ysyyhhh.github.io/ accesskey=h title="Ysyy's Blog (Alt + H)"><img src=https://ysyyhhh.github.io/img/Q.gif alt aria-label=logo height=35>Ysyy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=https://ysyyhhh.github.io/search title="🔍 搜索 (Alt + /)" accesskey=/><span>🔍 搜索</span></a></li><li><a href=https://ysyyhhh.github.io/ title="🏠 主页"><span>🏠 主页</span></a></li><li><a href=https://ysyyhhh.github.io/posts/ title="📚 文章"><span>📚 文章</span></a></li><li><a href=https://ysyyhhh.github.io/tags/ title="🧩 标签"><span>🧩 标签</span></a></li><li><a href=https://ysyyhhh.github.io/archives/ title="⏱️ 时间轴"><span>⏱️ 时间轴</span></a></li><li><a href=https://ysyyhhh.github.io/about/ title="🙋🏻‍♂️ 关于"><span>🙋🏻‍♂️ 关于</span></a></li><li><a href=https://ysyyhhh.github.io/links/ title="🤝 友链"><span>🤝 友链</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ysyyhhh.github.io/>主页</a>&nbsp;»&nbsp;<a href=https://ysyyhhh.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">P0 [C++ Primer](https://15445.courses.cs.cmu.edu/fall2022/project0/)</h1><div class=post-meta><span title='2024-03-01 00:00:00 +0000 UTC'>2024-03-01</span>&nbsp;·&nbsp;30 分钟&nbsp;·&nbsp;Ysyy</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#l1-relational-model--relational-algebra aria-label="L1 Relational Model & Relational Algebra">L1 Relational Model & Relational Algebra</a><ul><li><a href=#11-databases aria-label="1.1 Databases">1.1 Databases</a></li><li><a href=#12-flat-file-strawman aria-label="1.2 Flat File Strawman">1.2 Flat File Strawman</a></li><li><a href=#13-database-management-system aria-label="1.3 Database Management System">1.3 Database Management System</a></li><li><a href=#14-relational-model aria-label="1.4 Relational Model">1.4 Relational Model</a></li><li><a href=#15-data-manipulation-languages-dmls aria-label="1.5 Data Manipulation Languages (DMLs)">1.5 Data Manipulation Languages (DMLs)</a></li><li><a href=#16-relational-algebra-%e5%85%b3%e7%b3%bb%e4%bb%a3%e6%95%b0 aria-label="1.6 Relational Algebra 关系代数">1.6 Relational Algebra 关系代数</a></li></ul></li><li><a href=#l2-modern-sql aria-label="L2 Modern SQL">L2 Modern SQL</a><ul><li><a href=#21-relation-languages aria-label="2.1 Relation Languages">2.1 Relation Languages</a></li><li><a href=#22-sql-history aria-label="2.2 SQL History">2.2 SQL History</a></li><li><a href=#23-join aria-label="2.3 Join">2.3 Join</a></li><li><a href=#24-aggregates-%e8%81%9a%e5%90%88%e5%87%bd%e6%95%b0 aria-label="2.4 Aggregates 聚合函数">2.4 Aggregates 聚合函数</a></li><li><a href=#25-sting-operation aria-label="2.5 Sting Operation">2.5 Sting Operation</a></li><li><a href=#26-date-and-time aria-label="2.6 Date and Time">2.6 Date and Time</a></li><li><a href=#27-output-redirection aria-label="2.7 Output Redirection">2.7 Output Redirection</a></li><li><a href=#28-output-control aria-label="2.8 Output Control">2.8 Output Control</a></li><li><a href=#29-nested-queries aria-label="2.9 Nested Queries">2.9 Nested Queries</a><ul><li><a href=#nested-query-results-expressions aria-label="Nested Query Results Expressions:">Nested Query Results Expressions:</a></li></ul></li><li><a href=#210-window-functions aria-label="2.10 Window Functions">2.10 Window Functions</a></li><li><a href=#211-commom-table-expressions aria-label="2.11. Commom Table Expressions">2.11. Commom Table Expressions</a></li></ul></li><li><a href=#homework-1---sql aria-label="Homework #1 - SQL">Homework #1 - SQL</a></li><li><a href=#l3--4database-storage aria-label="L3 -4Database Storage">L3 -4Database Storage</a><ul><li><a href=#31-storage aria-label="3.1 Storage">3.1 Storage</a></li><li><a href=#32-disk-oriented-dbms-overview aria-label="3.2 Disk-Oriented DBMS Overview">3.2 Disk-Oriented DBMS Overview</a></li><li><a href=#33-dbms-vs-os aria-label="3.3 DBMS vs OS">3.3 DBMS vs OS</a></li><li><a href=#34-file-storage aria-label="3.4 File Storage">3.4 File Storage</a></li><li><a href=#35-database-pages aria-label="3.5 Database Pages">3.5 Database Pages</a></li><li><a href=#36-database-heap aria-label="3.6 Database Heap">3.6 Database Heap</a></li><li><a href=#37-page-layout aria-label="3.7 Page Layout">3.7 Page Layout</a></li><li><a href=#38-tuple-layout aria-label="3.8 Tuple Layout">3.8 Tuple Layout</a></li><li><a href=#39-log-structured-storage aria-label="3.9 Log-Structured Storage">3.9 Log-Structured Storage</a></li><li><a href=#311-data-representation aria-label="3.11 Data Representation">3.11 Data Representation</a></li></ul></li><li><a href=#l5-storage-models--compression aria-label="L5 Storage Models & Compression">L5 Storage Models & Compression</a><ul><li><a href=#51-database-workloads aria-label="5.1 Database Workloads">5.1 Database Workloads</a></li><li><a href=#52-storage-models aria-label="5.2 Storage Models">5.2 Storage Models</a><ul><li><a href=#n-ary-storage-model-nsm aria-label="N-Ary Storage Model (NSM)">N-Ary Storage Model (NSM)</a></li><li><a href=#decomposition-%e5%88%86%e8%a7%a3-storage-model-dsm aria-label="Decomposition 分解 Storage Model (DSM)">Decomposition 分解 Storage Model (DSM)</a></li></ul></li><li><a href=#53-database-compression aria-label="5.3 Database Compression">5.3 Database Compression</a><ul><li><a href=#compression-granularity aria-label="Compression Granularity">Compression Granularity</a></li></ul></li><li><a href=#54-naive-compression aria-label="5.4 Naive Compression">5.4 Naive Compression</a></li><li><a href=#55-columnar-compression-%e6%9f%b1%e7%8a%b6%e5%8e%8b%e7%bc%a9 aria-label="5.5 Columnar Compression 柱状压缩**">5.5 Columnar Compression 柱状压缩**</a><ul><li><a href=#run-length-encoding aria-label="Run-length Encoding">Run-length Encoding</a></li><li><a href=#bit-packing-encoding aria-label="Bit-Packing Encoding">Bit-Packing Encoding</a></li><li><a href=#bitmap-encoding aria-label="Bitmap Encoding">Bitmap Encoding</a></li><li><a href=#delta-encoding aria-label="Delta Encoding">Delta Encoding</a></li><li><a href=#incremental-encoding aria-label="Incremental Encoding">Incremental Encoding</a></li><li><a href=#dictionary-encoding aria-label="Dictionary Encoding">Dictionary Encoding</a></li></ul></li></ul></li><li><a href=#homework-2-storage--indexeshttps15445coursescscmuedufall2022fileshw2-cleanpdf aria-label="Homework #2 Storage & Indexes">Homework #2 Storage & Indexes</a><ul><li><a href=#question-1-storage-models aria-label="Question 1: Storage Models">Question 1: Storage Models</a><ul><li><a href=#a-suppose-the-dbms-uses-the-decomposition-storage-model-dsm-with-implicit-offsets aria-label="(a) Suppose the DBMS uses the decomposition storage model (DSM) with implicit offsets">(a) Suppose the DBMS uses the decomposition storage model (DSM) with implicit offsets</a></li><li><a href=#bsuppose-the-dbms-uses-the-n-ary-storage-model-nsm aria-label="(b)Suppose the DBMS uses the N-ary storage model (NSM)">(b)Suppose the DBMS uses the N-ary storage model (NSM)</a></li></ul></li><li><a href=#question-2-cuckoo-hashing aria-label="Question 2: Cuckoo Hashing">Question 2: Cuckoo Hashing</a></li><li><a href=#question-3-extendible-hashing aria-label="Question 3: Extendible Hashing">Question 3: Extendible Hashing</a><ul><li><a href=#a-starting-from-an-empty-table-insert-keys-15-14-23-11-9 aria-label="(a) Starting from an empty table, insert keys 15, 14, 23, 11, 9.">(a) Starting from an empty table, insert keys 15, 14, 23, 11, 9.</a></li><li><a href=#b-starting-from-the-result-in-a-you-insert-keys-12-5-7-13-2 aria-label="(b) Starting from the result in (a), you insert keys 12, 5, 7, 13, 2.">(b) Starting from the result in (a), you insert keys 12, 5, 7, 13, 2.</a></li><li><a href=#c-now-consider-the-table-below-along-with-the-following-deletion-rules aria-label="(c) Now consider the table below, along with the following deletion rules:">(c) Now consider the table below, along with the following deletion rules:</a></li></ul></li><li><a href=#question-4-btree aria-label="Question 4: B+Tree">Question 4: B+Tree</a></li></ul></li><li><a href=#p1 aria-label=P1>P1</a><ul><li><a href=#lru-k aria-label=LRU-K>LRU-K</a></li></ul></li><li><a href=#p2-btree aria-label="P2 B+Tree">P2 B+Tree</a><ul><li><a href=#%e6%a6%82%e8%bf%b0 aria-label=概述>概述</a></li><li><a href=#task-1---btree-pages aria-label="Task #1 - B+Tree Pages">Task #1 - B+Tree Pages</a><ul><li><a href=#btree-parent-page aria-label="B+Tree Parent Page">B+Tree Parent Page</a></li><li><a href=#btree-internal-page aria-label="B+Tree Internal Page">B+Tree Internal Page</a></li><li><a href=#btree-leaf-page aria-label="B+Tree Leaf Page">B+Tree Leaf Page</a></li></ul></li><li><a href=#task-2---btree-data-structure aria-label="Task #2 - B+Tree Data Structure">Task #2 - B+Tree Data Structure</a></li><li><a href=#checkpoint-1%e6%9f%a5%e6%89%be%e6%8f%92%e5%85%a5%e5%92%8c%e5%88%a0%e9%99%a4 aria-label="Checkpoint 1：查找，插入和删除">Checkpoint 1：查找，插入和删除</a><ul><li><a href=#%e7%ba%a6%e5%ae%9a aria-label=约定>约定</a></li><li><a href=#%e6%9f%a5%e6%89%be aria-label=查找>查找</a></li><li><a href=#%e6%8f%92%e5%85%a5%e5%8f%b6%e5%ad%90%e8%8a%82%e7%82%b9 aria-label=插入(叶子节点)>插入(叶子节点)</a></li><li><a href=#%e5%88%a0%e9%99%a4 aria-label=删除>删除</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h1 id=l1-relational-model--relational-algebra>L1 Relational Model & Relational Algebra<a hidden class=anchor aria-hidden=true href=#l1-relational-model--relational-algebra>#</a></h1><h2 id=11-databases>1.1 Databases<a hidden class=anchor aria-hidden=true href=#11-databases>#</a></h2><p>数据库：an organized collection of inter-related data that models some aspect of the real-world</p><p>数据库管理系统 DBMS：the software that manages a database</p><h2 id=12-flat-file-strawman>1.2 Flat File Strawman<a hidden class=anchor aria-hidden=true href=#12-flat-file-strawman>#</a></h2><p>数据库常常以CSV(comma-separated value)文件的形式存储，由DBMS进行管理。每次应用程序要读取或者更新记录时，都必须解析文件(parse files)。</p><h2 id=13-database-management-system>1.3 Database Management System<a hidden class=anchor aria-hidden=true href=#13-database-management-system>#</a></h2><ul><li>A general-purpose(通用) <strong>DBMS</strong> is designed to allow the definition, creation, querying, update, and administration of databases in accordance with some <strong>data model</strong>.</li><li>A <strong>data model</strong> is a collection of concepts for describing the data in database<ul><li>Examples: <strong>relational</strong> (most common), NoSQL (<strong>key/value</strong>, graph), array/matrix/vectors</li></ul></li><li>A <strong>schema</strong>(模式) is a description of a particular collection of data based on a <strong>data model</strong></li></ul><p>早期，数据库应用很难建立和维护，因为逻辑层和物理层之间存在着紧密的耦合。</p><ul><li>逻辑层： 描述了数据库有哪些实体和属性。</li><li>物理层： 是这些实体和属性的存储方式。</li></ul><p>所以早期的数据库，一旦改变了物理层，逻辑层也得跟着变。</p><h2 id=14-relational-model>1.4 Relational Model<a hidden class=anchor aria-hidden=true href=#14-relational-model>#</a></h2><p>人们每次改变物理层都要重新写数据管理系统，故Ted Codd注意到后提出了关系模型。</p><p>The relational model defines a database abstraction based on relations to avoid <strong>maintenance overhead</strong>(维护开销).</p><p>三要点:</p><ul><li>Store database in simple data structures (relations).</li><li>Access data through high-level language, DBMS <strong>figures out</strong>(找出) best execution strategy.</li><li>Physical storage <strong>left up to</strong>(取决于) the DBMS implementation.</li></ul><p>三概念</p><p>The relational data model defines three concepts:</p><ul><li>Structure: The definition of relations and their contents. This is the attributes the relations have and the values that those attributes can hold.</li><li><strong>Integrity</strong>(完整性): Ensure the database’s contents satisfy constraints.<ul><li>实体完整性 entity integrity:主属性不能为空</li><li>参照完整性 referential integrity: 外键的值必须存在</li><li>用户定义的完整性<ul><li>An example constraint would be that any value for the year attribute has to be a number.</li></ul></li></ul></li><li>Manipulation: How to access and modify a database’s contents.</li></ul><p>关系:</p><p><strong>A relation</strong> is an <strong>unordered</strong> set that contains the relationship of attributes that represent entities. So the DBMS can store them in any way it wants, allowing for <strong>optimization</strong>(允许优化).</p><p>元组:</p><p><strong>A tuple</strong> is a set of <strong>attribute values</strong> (also known as its <strong>domain</strong> 域 一组相同数据类型的值的集合) in the relation. <strong>Originally</strong>, values had to be atomic or scalar(标量), but <strong>now</strong> values can also be lists or <strong>nested</strong>(嵌套) data structures. Every attribute can be a special value, <strong>NULL</strong>, which means for a given tuple the attribute is <strong>undefined</strong>.</p><p>关系:</p><p><strong>A relation</strong> with n attributes is called <strong>an n-ary relation</strong>.</p><p>键</p><p><strong>A relation’s primary key</strong> uniquely identifies a single tuple.</p><ul><li>Some DBMSs automatically create an internal primary key if you do not define one.</li><li>A lot of DBMSs have support for autogenerated keys so an application does not have to <strong>manually increment</strong>(手动增加) the keys, but a primary key is still required for some DBMSs.</li></ul><p><strong>A foreign key</strong> specifies that an attribute from one relation has to map to a tuple in another relation.</p><h2 id=15-data-manipulation-languages-dmls>1.5 Data Manipulation Languages (DMLs)<a hidden class=anchor aria-hidden=true href=#15-data-manipulation-languages-dmls>#</a></h2><p>Methods to store and retrieve information from a database.</p><p>There are two classes of languages for this:</p><ul><li><strong>Procedural</strong>(程序上的): The query <strong>specifies the (high-level) strategy</strong> the DBMS should use to find <strong>the desired result based on sets / bags.</strong> (relational <strong>algebra</strong> 代数)</li><li>Non-Procedural (<strong>Declarative</strong> 声明): The query specifies only what data is wanted and not how to find it. (relational <strong>calculus</strong> 微积分/关系演算)</li></ul><p>一般现在都是用第二种的，我不管DBMS用什么<strong>策略</strong>，我只需要你给我我想要的数据。</p><h2 id=16-relational-algebra-关系代数>1.6 Relational Algebra 关系代数<a hidden class=anchor aria-hidden=true href=#16-relational-algebra-关系代数>#</a></h2><p><strong>Relational Algebra</strong> is a set of fundamental operations to <strong>retrieve</strong>(检索) and manipulate tuples in a relation.</p><p>Each operator <strong>takes in</strong>(需要) one or more relations as inputs, and outputs a new relation. To write queries we can “<strong>chain</strong>(链)” these operators together to create more complex operations.</p><p>5种基本<strong>关系操作</strong></p><ul><li>选择,投影,并,差,笛卡儿积</li></ul><p>传统<strong>集合运算</strong></p><ul><li>二目运算: 并,差,交,笛卡尔积</li></ul><p>专门的<strong>关系运算</strong></p><ul><li>选择selection ,投影projection,连接 join,除 dividen</li></ul><p>选择:在<strong>关系R</strong>中,选择符合条件的<strong>元组</strong>,是从行的角度进行运算.</p><p>投影:在<strong>关系R</strong>中,选择出<strong>若干属性列</strong>组成新的关系,从列的角度</p><p>连接:两个关系的<strong>笛卡尔积</strong>中,选取属性中满足一定条件的元组</p><ul><li>自然连接 内连接: 不保留悬浮元组.</li><li>外连接 outer join : 保留<strong>悬浮元组</strong>(填NULL)的连接</li><li>左连接 left outer join: 只保留<strong>左边关系R</strong>中的悬浮空组.</li><li>右连接 right outer join: 只保留<strong>右边关系R</strong>中的悬浮空组.</li></ul><p>除: R除以S得到T, 则T包含所有<strong>在R而不在S</strong>的<strong>属性及其值</strong>. 且T和S的所有组合都在R中.</p><h1 id=l2-modern-sql>L2 Modern SQL<a hidden class=anchor aria-hidden=true href=#l2-modern-sql>#</a></h1><h2 id=21-relation-languages>2.1 Relation Languages<a hidden class=anchor aria-hidden=true href=#21-relation-languages>#</a></h2><p>用户只需要使用声明性语言（即SQL）来指定他们想要的结果。DBMS 负责确定产生该答案的最有效计划。</p><p>关系代数基于 sets (unordered, no duplicates)。 SQL基于 bags (unordered, allows duplicates)</p><h2 id=22-sql-history>2.2 SQL History<a hidden class=anchor aria-hidden=true href=#22-sql-history>#</a></h2><ul><li><p>SEQUEL Structured English Query Language</p><p>SQL Structured Query Language</p></li><li><p>该语言由不同类别的命令组成：</p><ul><li><strong>DML</strong> Data Manipulation Language <code>SELECT, INSERT, UPDATE, DELETE</code></li><li><strong>DDL</strong> Data Definition Language Schema definitions for tables, indexes, views, and other objects.</li><li><strong>DCL</strong> Data Control Language Security, access controls.</li></ul></li><li><p>SQL仍在不断发展的</p></li></ul><h2 id=23-join>2.3 Join<a hidden class=anchor aria-hidden=true href=#23-join>#</a></h2><p>结合一个或多个表的列，产生一个新的表。用来表达涉及跨越多个表的数据的查询</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>CREATE TABLE student (
</span></span><span style=display:flex><span>    sid INT PRIMARY KEY,
</span></span><span style=display:flex><span>    name VARCHAR(16),
</span></span><span style=display:flex><span>    login VARCHAR(32) UNIQUE,
</span></span><span style=display:flex><span>    age SMALLINT,
</span></span><span style=display:flex><span>    gpa FLOAT
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>CREATE TABLE course (
</span></span><span style=display:flex><span>    cid VARCHAR(32) PRIMARY KEY,
</span></span><span style=display:flex><span>    name VARCHAR(32) NOT NULL
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>CREATE TABLE enrolled (
</span></span><span style=display:flex><span>    sid INT REFERENCES student (sid),
</span></span><span style=display:flex><span>    cid VARCHAR(32) REFERENCES course (cid),
</span></span><span style=display:flex><span>    grade CHAR(1)
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>找出在15-721拿到A的学术
</span></span><span style=display:flex><span>SELECT s.name
</span></span><span style=display:flex><span>FROM enrolled AS e, student AS s
</span></span><span style=display:flex><span>WHERE e.grade = &#39;A&#39; AND e.cid = &#39;15-721&#39;
</span></span><span style=display:flex><span>AND e.sid = s.sid;
</span></span></code></pre></div><h2 id=24-aggregates-聚合函数>2.4 Aggregates 聚合函数<a hidden class=anchor aria-hidden=true href=#24-aggregates-聚合函数>#</a></h2><p>聚合函数接受一组列表，然后产生一个单一的标量值作为其输出。基本上只能在SELECT输出列表中使用！</p><p>函数：</p><ul><li><code>AVG</code></li><li><code>MIN</code></li><li><code>MAX</code></li><li><code>COUNT</code></li></ul><p>当使用goup时,聚合函数输出为每个组的输出.</p><p>having 在聚合计算的基础过滤输出结果.而不是where</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>SELECT AVG(s.gpa) AS avg_gpa, e.cid
</span></span><span style=display:flex><span>FROM enrolled AS e, student AS s
</span></span><span style=display:flex><span>WHERE e.sid = s.sid
</span></span><span style=display:flex><span>GROUP BY e.cid
</span></span><span style=display:flex><span>HAVING avg_gpa &gt; 3.9;
</span></span></code></pre></div><h2 id=25-sting-operation>2.5 Sting Operation<a hidden class=anchor aria-hidden=true href=#25-sting-operation>#</a></h2><p><strong>SQL标准</strong>是<strong>区分大小写</strong>的，而且只能是<strong>单引号</strong>！有一些函数可以处理字符串，可以在查询的任何部分使用。</p><ul><li><p><strong>Pattern Matching</strong>:</p><p>Like 关键字</p><ul><li><code>%</code> : matches any substrings (including empty).</li><li><code>_</code> : matches any one character</li></ul></li><li><p><strong>String Function:</strong> <code>SUBSTRING(S, B, E)</code> <code>UPPER(S)</code></p></li><li><p><strong>Concatenation</strong>(连接) : <code>||</code> concatenate two or more strings together into a single string</p></li></ul><h2 id=26-date-and-time>2.6 Date and Time<a hidden class=anchor aria-hidden=true href=#26-date-and-time>#</a></h2><ul><li><p>时间函数</p><ul><li>当前日期时间 <code>NOW()</code>, <code>CURRENT_TIMESTAMP()</code></li><li>当前UNIX时间戳 <code>UNIX_TIMESTAMP()</code></li><li>当前日期 <code>CURRENT_DATE()</code></li><li>当前时间 <code>CURRENT_TIME()</code></li></ul></li><li><p>日期时间转换函数</p><ul><li>当前时间戳转换为北京时间 <code>FROM_UNIXTIME()</code></li><li>北京时间转换为时间戳 <code>UNIX_TIMESTAMP()</code></li><li>时间中解析年月日时间 <code>DATE_FORMAT(date, format)</code></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>select DATE_FORMAT(&#39;2021-01-01 08:30:50&#39;,&#39;%Y-%m-%d&#39;)
</span></span></code></pre></div></li><li><p>日期时间运算函数</p><ol><li><p>在某个时间的基础上加上或者减去某个时间 <code>DATE_ADD(date,INTERVAL expr unit)</code> <code>DATE_SUB(date,INTERVAL expr unit)</code></p></li><li><p>返回两个日期值之间的天数 <code>DATEDIFF(expr1,expr2))</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>select DATEDIFF(&#39;2021-01-02&#39;,&#39;2021-01-01&#39;)
</span></span></code></pre></div></li><li><p>时间差函数 <code>TIMESTAMPDIFF(unit,datetime_expr1,datetime_expr2)</code></p><p>unit：天(DAY)、小时(HOUR），分钟(MINUTE)和秒(SECOND)，TIMESTAMPDIFF函数比DATEDIFF函数用起来更加灵活</p></li></ol></li></ul><h2 id=27-output-redirection>2.7 Output Redirection<a hidden class=anchor aria-hidden=true href=#27-output-redirection>#</a></h2><p>你可以告诉DBMS将查询结果存储到另一个表中，而不是将查询结果返回给客户端（例如，终端）。结果存储到另一个表中。然后你可以在随后的查询中访问这些数据</p><ul><li><p>New Table: 将查询的输出存储到一个新的（永久）表中。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>SELECT DISTINCT cid INTO CourseIds FROM enrolled;
</span></span></code></pre></div></li><li><p>Exustubg Table:</p><p>将<strong>查询的输出存储到数据库中已经存在的表</strong>中。该表 目标表必须有与目标表相同数量和相同类型的列，但输出查询中的列名不需要匹配。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>INSERT INTO CourseIds (SELECT DISTINCT cid FROM enrolled)
</span></span></code></pre></div></li></ul><h2 id=28-output-control>2.8 Output Control<a hidden class=anchor aria-hidden=true href=#28-output-control>#</a></h2><p>可以用ORDER BY来对输出进行排序,后面可以加<code>DESC</code>, <code>ASC</code>来指定排序策略</p><p>输出的数量可以用<code>LIMIT n</code> 进行指定,当然也可以用<code>OFFSET</code> 来提供一个bias。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>ELECT sid, grade FROM enrolled WHERE cid = &#39;15-721&#39;
</span></span><span style=display:flex><span>ORDER BY grade;
</span></span><span style=display:flex><span>SELECT sid, name FROM student WHERE login LIKE &#39;%@cs&#39;
</span></span><span style=display:flex><span>LIMIT 20 OFFSET 10;
</span></span></code></pre></div><h2 id=29-nested-queries>2.9 Nested Queries<a hidden class=anchor aria-hidden=true href=#29-nested-queries>#</a></h2><p>在其他查询中调用查询，在单个查询中执行更复杂的逻辑。嵌套查询往往难以优化。</p><p>外部查询的范围包括在内部查询中（即<strong>内部查询可以访问来自外部查询</strong>），反之不行。</p><ul><li><p>内部查询几乎可以出现在一个查询的任何部分。</p><ol><li><p><code>SELECT</code> Output Targets</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>SELECT (SELECT 1) AS one FROM student;
</span></span></code></pre></div></li><li><p><code>FROM</code> <strong>Clause</strong>(条件):</p></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>SELECT name
</span></span><span style=display:flex><span>    FROM student AS s, (SELECT sid FROM enrolled) AS e
</span></span><span style=display:flex><span>    WHERE s.sid = e.sid;
</span></span></code></pre></div><ol start=3><li><code>WHERE</code> Clause</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>SELECT name FROM student
</span></span><span style=display:flex><span>	WHERE sid IN ( SELECT sid FROM enrolled );
</span></span></code></pre></div><ul><li>例子： 获取在15-445中注册的学生名字</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>SELECT name FROM student
</span></span><span style=display:flex><span>    WHERE sid IN (
</span></span><span style=display:flex><span>        SELECT sid FROM enrolled
</span></span><span style=display:flex><span>        WHERE cid = &#39;15-445&#39;
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><p>请注意，根据它在查询中出现的位置，sid有不同的范围。</p><ul><li><p>例子： 找到注册了至少一门课的最大的学生id</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>SELECT student.sid, name
</span></span><span style=display:flex><span>    FROM student
</span></span><span style=display:flex><span>    JOIN (SELECT MAX(sid) AS sid
</span></span><span style=display:flex><span>        FROM enrolled) AS max_e
</span></span><span style=display:flex><span>    ON student.sid = max_e.sid;
</span></span></code></pre></div></li></ul><h3 id=nested-query-results-expressions>Nested Query Results Expressions:<a hidden class=anchor aria-hidden=true href=#nested-query-results-expressions>#</a></h3><ul><li><p>关键字：</p><ul><li><code>ALL</code> Must satisfy expression for all rows in sub-query</li><li><code>ANY</code> Must satisfy expression for at least one row in sub-query.</li><li><code>IN</code> Equivalent to =ANY().</li><li><code>EXISTS</code> At least one row is returned.</li></ul></li><li><p>例子： 找到所有没有学生注册的课</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>SELECT * FROM course
</span></span><span style=display:flex><span>    WHERE NOT EXISTS(
</span></span><span style=display:flex><span>        SELECT * FROM enrolled
</span></span><span style=display:flex><span>        WHERE course.cid = enrolled.cid
</span></span><span style=display:flex><span>);
</span></span></code></pre></div></li></ul><h2 id=210-window-functions>2.10 Window Functions<a hidden class=anchor aria-hidden=true href=#210-window-functions>#</a></h2><ul><li><p>函数： 窗口函数可以是我们上面讨论的任何一个聚合函数。也有一些特殊的窗口函数。</p><ol><li><code>ROW_NUMBER</code>: 当前列的数字</li><li><code>RANK</code>: 当前列的顺序</li></ol></li><li><p>Grouping: <strong>OVER子句指定了在计算窗口函数时如何对图元进行分组</strong>。使用<strong>PARTITION BY</strong>来指定分组</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>SELECT cid, sid, ROW_NUMBER() OVER (PARTITION BY cid)
</span></span><span style=display:flex><span>	FROM enrolled ORDER BY cid;
</span></span></code></pre></div><p>我们也可以在OVER中放入ORDER BY，以确保结果的确定性排序，即使数据库内部发生变化。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>SELECT *, ROW_NUMBER() OVER (ORDER BY cid)
</span></span><span style=display:flex><span>	FROM enrolled ORDER BY cid;
</span></span></code></pre></div></li><li><p><strong>重要提示：</strong></p></li><li><p>DBMS在窗函数排序后计算<code>RANK</code>，而在排序前计算<code>ROW_NUMBER</code>。</p><ul><li><p>找到每门课程中成绩第二高的学生</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>SELECT * FROM (
</span></span><span style=display:flex><span>    SELECT *, RANK() OVER (PARTITION BY cid
</span></span><span style=display:flex><span>        ORDER BY grade ASC) AS rank
</span></span><span style=display:flex><span>    FROM enrolled) AS ranking
</span></span><span style=display:flex><span>WHERE ranking.rank = 2;
</span></span></code></pre></div></li></ul></li></ul><h2 id=211-commom-table-expressions>2.11. Commom Table Expressions<a hidden class=anchor aria-hidden=true href=#211-commom-table-expressions>#</a></h2><p>在编写更复杂的查询时，通用表表达式（CTE）是窗口或嵌套查询的一种替代方法。复杂的查询时，可以替代窗口或嵌套查询。它们提供了一种方法来为用户在一个更大的查询中编写辅助语句.</p><p>可以理解为一个辅助表。</p><p><code>WITH</code>子句将内部查询的输出与一个具有该名称的临时结果绑定。</p><ul><li><p>例子： 生成一个名为cteName的CTE，其中包含一个单一属性设置为 &ldquo;1 &ldquo;的元组。从这个CTE中选择所有属性。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>WITH cteName AS (
</span></span><span style=display:flex><span>	SELECT 1
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>SELECT * FROM cteName;
</span></span></code></pre></div><p>我们可以在AS之前将输出列绑定到名称上</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>WITH cteName (col1, col2) AS (
</span></span><span style=display:flex><span>	SELECT 1, 2
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>SELECT col1 + col2 FROM cteName;
</span></span></code></pre></div><p>一个查询可能包含多个CTE声明</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>WITH cte1 (col1) AS (SELECT 1), cte2 (col2) AS (SELECT 2)
</span></span><span style=display:flex><span>SELECT * FROM cte1, cte2;
</span></span></code></pre></div></li><li><p>递归能力 在WITH后面<strong>添加RECURSIVE关键字</strong>允许CTE引用自己。这使得在SQL查询中可以实现递归。有了递归的CTE，SQL被证明是图灵完备的，这意味着它在计算上的表现力不亚于更多的通用编程语言</p></li><li><p>例子：打印从1到10的数字</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>WITH RECURSIVE cteSource (counter) AS (
</span></span><span style=display:flex><span>    ( SELECT 1 )
</span></span><span style=display:flex><span>    UNION
</span></span><span style=display:flex><span>    ( SELECT counter + 1 FROM cteSource
</span></span><span style=display:flex><span>    	WHERE counter &lt; 10 )
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>SELECT * FROM cteSource;
</span></span></code></pre></div></li></ul><h1 id=homework-1---sql>Homework #1 - SQL<a hidden class=anchor aria-hidden=true href=#homework-1---sql>#</a></h1><p>CASE 语句</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>SELECT name,
</span></span><span style=display:flex><span>   CASE 
</span></span><span style=display:flex><span>       when died is not null
</span></span><span style=display:flex><span>       then died-born 
</span></span><span style=display:flex><span>       else &#39;2022&#39; - born
</span></span><span style=display:flex><span>   END as age
</span></span><span style=display:flex><span>FROM people
</span></span><span style=display:flex><span>where born &gt;= &#39;1900&#39;
</span></span><span style=display:flex><span>ORDER by age DESC,name 
</span></span><span style=display:flex><span>LIMIT 20;
</span></span></code></pre></div><p>CAST AS TEXT 转换成字符串，字符串连接用 ||</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>select 
</span></span><span style=display:flex><span>CAST(titles.premiered/10*10 AS TEXT)  || &#39;s&#39; as decade,
</span></span><span style=display:flex><span>round(avg(rating),2) as avg,
</span></span><span style=display:flex><span>max(rating) as top,
</span></span><span style=display:flex><span>min(rating) as min,
</span></span><span style=display:flex><span>count(*) as NUM_RELEASES
</span></span><span style=display:flex><span>from ratings
</span></span><span style=display:flex><span>join titles on titles.title_id = ratings.title_id
</span></span><span style=display:flex><span>where decade is not null
</span></span><span style=display:flex><span>GROUP by decade
</span></span><span style=display:flex><span>order by avg DESC,decade
</span></span><span style=display:flex><span>limit 20;
</span></span></code></pre></div><p>第一个with后，用,隔开</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>with person_title as (
</span></span><span style=display:flex><span>    select people.name,
</span></span><span style=display:flex><span>    people.person_id,
</span></span><span style=display:flex><span>    crew.title_id
</span></span><span style=display:flex><span>    from people
</span></span><span style=display:flex><span>    join crew on crew.person_id = people.person_id
</span></span><span style=display:flex><span>    join titles on titles.title_id = crew.title_id
</span></span><span style=display:flex><span>    where born = 1955 and titles.type = &#34;movie&#34;
</span></span><span style=display:flex><span>),
</span></span><span style=display:flex><span>person_avg as (
</span></span><span style=display:flex><span>    select person_title.name,round(avg(rating),2) as avg
</span></span><span style=display:flex><span>    from RATINGS
</span></span><span style=display:flex><span>    join person_title on person_title.title_id = ratings.title_id
</span></span><span style=display:flex><span>    group by person_title.person_id
</span></span><span style=display:flex><span>),
</span></span><span style=display:flex><span>quantiles as (
</span></span><span style=display:flex><span>    select * ,NTILE(10) OVER (ORDER BY avg ASC) as QuantileRating from person_avg
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>select 
</span></span><span style=display:flex><span>name,avg
</span></span><span style=display:flex><span>from quantiles
</span></span><span style=display:flex><span>where QuantileRating = 9
</span></span><span style=display:flex><span>order by avg DESC,name;
</span></span></code></pre></div><p>把表格数据压缩成一行，用，隔开</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>with p as(
</span></span><span style=display:flex><span>    select akas.title as dubbed
</span></span><span style=display:flex><span>    from titles
</span></span><span style=display:flex><span>    join akas on akas.title_id = titles.title_id
</span></span><span style=display:flex><span>    where primary_title = &#34;House of the Dragon&#34; and type = &#34;tvSeries&#34;
</span></span><span style=display:flex><span>    group by primary_title,dubbed
</span></span><span style=display:flex><span>    order by dubbed
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>select GROUP_CONCAT(dubbed,&#39;, &#39;) from p;
</span></span></code></pre></div><h1 id=l3--4database-storage>L3 -4Database Storage<a hidden class=anchor aria-hidden=true href=#l3--4database-storage>#</a></h1><h2 id=31-storage>3.1 Storage<a hidden class=anchor aria-hidden=true href=#31-storage>#</a></h2><p>The DBMS assumes that the primary storage location of the database is on non-volatile disk.</p><p>The DBMS&rsquo;s components manage the movement of data between non-volatile and volatile storage.</p><p><img loading=lazy src=img/image-20230222153223421.png alt=image-20230222153223421></p><p>Volatile Devices:</p><ul><li>Volatile means that if you pull the power from the machine, then the data is lost.</li><li>Volatile storage supports fast <strong>random access</strong> with byte-addressable locations. This means that the program can jump to any byte address and get the data that is there.</li><li>For our purposes, we will always refer to this storage class as “memory.”</li></ul><p>Non-Volatile Devices:</p><ul><li>Non-volatile means that the storage device does not require continuous power in order for the device to retain the bits that it is storing.</li><li>It is also block/page addressable. This means that <strong>in order to read a value at a particular offset</strong>, the program <strong>first has to load the 4 KB page into memory</strong> that holds the value the program wants to read.</li><li>Non-volatile storage is <strong>traditionally better at sequential access</strong> (reading multiple contiguous chunks of data at the same time).</li><li>We will refer to this as “disk.” We will not make a (major) distinction between solid-state storage (SSD) and spinning hard drives (HDD).</li></ul><p><img loading=lazy src=img/image-20230222153508116.png alt=image-20230222153508116></p><h2 id=32-disk-oriented-dbms-overview>3.2 Disk-Oriented DBMS Overview<a hidden class=anchor aria-hidden=true href=#32-disk-oriented-dbms-overview>#</a></h2><p>The database is <strong>all on disk</strong>, and the data in database files is organized into pages, with the first page being the directory page.</p><p>To operate on the data, the DBMS needs to bring the data into memory. It does this by <strong>having a buffer pool</strong> that <strong>manages the data movement back and forth</strong> between disk and memory</p><p>The DBMS also has an <strong>execution engine</strong> that will execute queries. The execution engine will <strong>ask the buffer pool for a specific page</strong>, and the buffer pool will take care of bringing that page into memory and <strong>giving the execution engine a pointer</strong> to that page in memory.</p><p>The buffer pool manager will <strong>ensure</strong> that <strong>the page is there while the execution engine operates on that part of memory</strong>.</p><h2 id=33-dbms-vs-os>3.3 DBMS vs OS<a hidden class=anchor aria-hidden=true href=#33-dbms-vs-os>#</a></h2><ul><li>DBMS的一个<strong>高级设计目标是支持超过可用内存量</strong>的数据库。因为访问disk的代价很大，所以使用disk应该要小心。我们不希望从磁盘上访问数据时停顿太久，从而拖慢其他一切。我们希望DBMS能够处理在等待从磁盘获取数据时，能够处理其他查询。</li><li>这个高层次的设计目标就像虚拟内存一样，有一个大的地址空间和一个供操作系统从磁盘引入页面的地方。</li><li>实现这种虚拟内存的方法之一是使用mmap来映射进程地址空间中的文件内容，这使得操作系统负责在磁盘和内存之间来回移动页面。 但不幸的是，如果<strong>mmap遇到页面故障，进程将会被阻塞</strong>。<ul><li>如果你需要写入，你永远不想在你的DBMS中使用mmap。</li><li>DBMS（几乎）总是想自己控制事情，而且可以做得更好，因为它知道更多关于被访问的数据和被处理的查询。</li></ul></li><li>可以通过使用操作系统：<ul><li><code>madvise</code>: 告诉操作系统你打算何时读某些页面。</li><li><code>mlock</code>: 告诉操作系统不要把内存范围换到磁盘上。</li><li><code>msync</code>: 告诉操作系统将内存范围刷新到磁盘。</li></ul></li></ul><p><strong>出于正确性和性能的考虑，我们不建议在DBMS中使用</strong><code>mmap</code>。</p><h2 id=34-file-storage>3.4 File Storage<a hidden class=anchor aria-hidden=true href=#34-file-storage>#</a></h2><ul><li>在其最基本的形式中，DBMS将<strong>数据库存储为磁盘上的文件</strong>。有些可能使用文件层次结构，有些则可能使用单个文件</li><li>操作系统对这些文件的内容一无所知。<strong>只有DBMS知道如何解读它们的内容</strong>，因为它是以DBMS特有的方式编码的。</li><li>DBMS的存储管理器负责管理数据库的文件。它将文件表示为一个 页的集合。它还跟踪哪些数据被读和写到了页面上，以及这些页面有多少可用空间。这些页面中还有多少可用空间。</li></ul><h2 id=35-database-pages>3.5 Database Pages<a hidden class=anchor aria-hidden=true href=#35-database-pages>#</a></h2><ul><li>DBMS将数据库组织在<strong>一个或多个文件中的固定大小的数据块</strong>，称为页。页面可以包含不同种类的数据（tuple、indexes等）。</li></ul><blockquote><ul><li>大多数系统不会将这些类型混合在一页中。 有些系统会要求页面是自成一体（self-contained）的，也就是说，阅读每个页面所需的所有信息都在页面本身。读取每一页的所有信息都在页面本身</li></ul></blockquote><ul><li>Each page is given a unique identifier.<ul><li>The DBMS uses an indirection layer to map page IDs to physical locations.</li></ul></li></ul><p>There are three different <strong>notions</strong> of &ldquo;pages&rdquo; in a DBMS:</p><ul><li>Hardware Page (usually 4KB)</li><li>OS Page (usually 4KB)</li><li>Database Page (512B-16KB)</li></ul><p>存储设备保证写的操作是atomic 原子的。 这意味着，如果我们的数据库页面比我们的硬件页面大，DBMS将不得不采取额外的措施 以确保数据被安全地写出来。 因为当系统崩溃时，程序可能已经完成了将数据库页面写入磁盘的一部分</p><p>Different DBMSs manage pages in files on disk in different ways.</p><ul><li>Heap File Organization</li><li>Tree File Organization</li><li>Sequential / Sorted File Organization (ISAM)</li><li>Hashing File Organization</li></ul><p>At this point in the <strong>hierarchy</strong>(层次结构) we don&rsquo;t need to know anything about what is inside of the pages.</p><h2 id=36-database-heap>3.6 Database Heap<a hidden class=anchor aria-hidden=true href=#36-database-heap>#</a></h2><p>A <strong>heap file</strong> is an <strong>unordered</strong> collection of pages with tuples that are stored in random order.</p><ul><li>Create / Get / Write / Delete Page</li><li>Must also support iterating over all pages.</li></ul><p>DBMS可以通过使用页面的链接列表或页面目录在磁盘上找到一个给定的页面ID</p><ol><li><p>Linked List: Header page持有指向自由页列表和数据页列表的指针。然而，如果 DBMS正在寻找一个特定的页面，它必须在数据页列表上进行顺序扫描，直到它找到它要找的页面。</p></li><li><p>Page Directory:</p><p>DBMS维护特殊的页面，跟踪数据页的位置以及每页的可用空间。</p></li></ol><p><img loading=lazy src=img/image-20230222155657027.png alt=image-20230222155657027></p><p><img loading=lazy src=img/image-20230222155526907.png alt=image-20230222155526907></p><p>Need <strong>meta-data</strong> to keep track of what pages exist in multiple files and which ones have free space.</p><h2 id=37-page-layout>3.7 Page Layout<a hidden class=anchor aria-hidden=true href=#37-page-layout>#</a></h2><ul><li>每个页面都包括一个header，记录关于页面内容的元数据。<ul><li>Page size</li><li>Checksum</li><li>DBMS version</li><li>Transaction visibility</li><li>Self-containment(自成一体) (Some systems like Oracle require this.)</li></ul></li></ul><p>For any page storage architecture, we now need to decide <strong>how to organize the data inside of the page.</strong></p><p>We are still assuming that we are only storing <strong>tuples</strong>.</p><p>Two approaches:</p><ul><li><strong>Tuple</strong>-oriented (其实是 <strong>slotted-page</strong>)<ul><li>页面将slots映射到offsets,slot array 记录对应tuple的便宜量</li><li>Header keeps track of the number of used slots, the offset of the starting location of the last used slot, and a slot array, which keeps track of the location of the start of each tuple.</li><li>To add a tuple, the slot array will grow from the beginning to the end, and the data of the tuples will grow from end to the beginning. The page is considered full when the slot array and the tuple data meet</li></ul></li><li>Log-structured</li></ul><p><img loading=lazy src=img/image-20230222161048229.png alt=image-20230222161048229></p><h2 id=38-tuple-layout>3.8 Tuple Layout<a hidden class=anchor aria-hidden=true href=#38-tuple-layout>#</a></h2><p>tuple 内部的结构</p><p>tuples本质上是一个字节序列。DBMS的工作是将这些字节解释为属性类型和值。</p><ul><li><p>Tuple Header：包含了tuple的元数据</p><ul><li>DBMS的并发控制协议的可见性信息。关于哪个事务创建/修改了该元组</li><li>NULL值的位图。</li><li>注意，DBMS不需要在这里存储关于数据库模式的元数据。</li></ul></li><li><p>Tuple Data：数据的实际属性</p><ul><li>属性通常按照你创建表时指定的顺序存储</li><li>大多数DBMS不允许一个tuple超过一个页面的大小。</li></ul></li><li><p>Unique Identifier</p><ul><li>数据库中的每个tuple都被分配一个唯一的标识符</li><li><img loading=lazy src=img/image-20230222161450033.png alt=image-20230222161450033></li><li>一般是：<code>page_id + (offset or slow)</code></li><li>一个应用程序<strong>不能</strong>依赖这些ID来表示任何东西</li></ul></li><li><p>De-normalized Tuple Data:</p><p>如果两个表是相关的，DBMS可以 &ldquo;pre-join"它们，所以这些表最终会出现在 在同一个页面上。这使得读取速度加快，因为DBMS只需要加载一个页面而不是两个 独立的页面。然而，这使得更新更加昂贵，因为DBMS需要更多的空间给每个 tuples</p><p><img loading=lazy src=img/image-20230222161346650.png alt=image-20230222161346650></p></li></ul><h2 id=39-log-structured-storage>3.9 Log-Structured Storage<a hidden class=anchor aria-hidden=true href=#39-log-structured-storage>#</a></h2><p>（也叫Append-only Sequence of Data） 参考: <a href=https://www.cnblogs.com/muzhongjiang/p/15151758.html>Log-Structured 结构</a></p><ul><li>与Slotted-Page Design有关的问题是：<ul><li><p>Fragmentation: 删除tuple会在page中留下空隙。</p></li><li><p>Useless Disk I/O:</p><p>由于非易失性存储的block-oriented的性质，需要读取整个块来获取tuple。</p></li><li><p>Random Disk I/O: 磁盘阅读器可能不得不跳到20个不同的地方来更新20个不同的tuples，这可能会非常慢。</p></li></ul></li></ul><p>如果我们在一个<strong>只允许创建新数据而不允许覆盖</strong>的系统上工作呢？日志结构的存储模型与这个假设相配合，解决了上面列出的一些问题。</p><p><strong>Log-Structured Storage:</strong> DBMS不存储tuples，<strong>只存储日志记录</strong>。</p><ul><li>将数据库如何被修改的记录存储到文件中（放入和删除）。每条日志包含tuples的唯一标识符</li><li>要读取一条记录，DBMS会<strong>从最新的到最旧的逆向扫描日志文件</strong>，并 &ldquo;重新创建 &ldquo;这个 tuple。</li><li>写的快，读的可能慢。磁盘写入是连续的，现有的页面是不可改变的，这导致了随机磁盘I/O的减少。</li><li>在append-only的存储上工作得很好，因为DBMS不能回溯并更新数据。</li></ul><p><img loading=lazy src=img/image-20230222161821846.png alt=image-20230222161821846></p><p>The log will grow forever. The DBMS needs to periodically <strong>compact</strong>(紧凑) pages to reduce wasted space.</p><p><img loading=lazy src=img/image-20230222161836461.png alt=image-20230222161836461></p><ul><li>由于不再需要时间信息，数据库可以<strong>将日志压缩到一个按id排序的表</strong>中。这些被称为分类字符串表（SSTables），它们可以使tuple搜索非常快。</li></ul><p><img loading=lazy src=img/image-20230222161958064.png alt=image-20230222161958064></p><ul><li>紧凑化的问题是，DBMS最终会出现写入放大的情况。(<strong>它一次又一次地重写相同的数据</strong>）。</li></ul><p>Compaction coalesces larger log files into smaller files by removing unnecessary records.</p><p><img loading=lazy src=img/image-20230222162056924.png alt=image-20230222162056924></p><p>Log-structured storage managers are more common today. This is partly due to the <strong>proliferation</strong>(扩散) of RocksDB.</p><h2 id=311-data-representation>3.11 Data Representation<a hidden class=anchor aria-hidden=true href=#311-data-representation>#</a></h2><p>A tuple is essentially a sequence of bytes.</p><p>It&rsquo;s the job of the DBMS to <strong>interpret</strong> those bytes into attribute types and values.</p><p>The DBMS&rsquo;s <strong>catalogs</strong>(目录) contain the schema information about tables(数据表示方案) that the system uses to figure out the tuple&rsquo;s layout.</p><p><img loading=lazy src=img/image-20230222162403262.png alt=image-20230222162403262></p><ul><li><strong>INTEGER, BIGINT, SMALLINT, TINYINT.</strong> (Integers)大多数DBMS使用IEEE-754标准规定的 &ldquo;native &ldquo;C/C++类型来存储整数。这些值是<strong>固定长度</strong>的。</li><li><strong>FLOAT, REAL</strong> (Variable Precision Numbers) 这些是不精确的、可变精度的数字类型, &ldquo;native &ldquo;C/C++类型,这些值也是<strong>固定长度</strong>的。<ul><li><strong>变精度数的运算比任意精度数的运算更快</strong>，因为CPU可以直接对其执行指令。然而，在进行计算时<strong>可能会出现精度损失</strong>！</li></ul></li><li><strong>NUMERIC, DECIMAL.</strong>(Fixed-Point Precision Numbers) 通常<strong>以精确的、可变长度</strong>的二进制表示法（像一个字符串）来存储.带有<strong>额外的元数据</strong>，这些数据将告诉系统诸如<strong>数据的长度和小数点应该在哪里</strong>。</li><li>当误差不可接受的时候，DBMS就要付出性能的代价来提高精度。</li></ul><p><strong>VARCHAR, VARBINARY, TEXT, BLOB</strong> Variable-Length Data</p><ul><li>代表任意长度的数据类型。它们通常是用一个header来存储的，这个header可以追踪到字符串的长度，以便于跳转到下一个值。它还可能包含一个数据的校验和。</li><li><strong>大多数DBMS不允许一个tuple超过一个页面的大小。</strong> <strong>但是！那些允许的系统将数据存储在一个特殊的 &ldquo;溢出 &ldquo;页</strong>上，并让tuple包含一个对该页的引用。这些溢出页可以包含指向其他溢出页的指针，直到所有的数据都可以被存储。(类似分级页表)</li><li>有些系统会让你把这些大的数值存储在一个外部文件中，然后元组会包含一个指向该文件的指针。例如，如果数据库存储的是照片信息，DBMS可以将照片存储在外部文件中，而不是让它们占用DBMS中的大量空间。这样做的一个缺点是，DBMS<strong>不能操作这个文件的内容</strong>。因此，No durability protections. No transaction protections.没有耐久性或交易保护。</li></ul><p><strong>TIME, DATE, TIMESTAMP.</strong> Dates and Times 不同的系统对日期/时间的表示方法不同。通常情况下，它们被表示为一些单位时间 (自unix时代的（微/毫）秒）。</p><p><strong>System Catalogs</strong></p><p>为了使DBMS能够识别tuple的内容，它维护了 INFORMATION_SCHEMA<strong>内部目录</strong>来告诉它关于数据库的元数据。<strong>元数据将包含关于数据库有哪些表和列的信息</strong>，以及它们的类型和值的顺序。</p><p>大多数DBMS将其目录以其表的格式存储在自己的内部。他们使用 特殊代码来 &ldquo;bootstrap &ldquo;这些目录表。</p><p><img loading=lazy src=img/image-20230222163207453.png alt=image-20230222163207453></p><p><img loading=lazy src=img/image-20230222163222109.png alt=image-20230222163222109></p><h1 id=l5-storage-models--compression>L5 Storage Models & Compression<a hidden class=anchor aria-hidden=true href=#l5-storage-models--compression>#</a></h1><h2 id=51-database-workloads>5.1 Database Workloads<a hidden class=anchor aria-hidden=true href=#51-database-workloads>#</a></h2><p>OLTP: Online Transaction Processing</p><ul><li><p>An OLTP workload is characterized by <strong>fast, short running operations</strong>, simple queries that <strong>operate on single entity at a time</strong>, and <strong>repetitive operations</strong>.</p></li><li><p>An OLTP workload will typically handle <strong>more writes than reads</strong>.</p><blockquote><p>An example of an OLTP workload is the Amazon storefront. Users can add things to their cart, they can make purchases, but the actions only affect their account.</p></blockquote></li></ul><p>OLAP: Online Analytical Processing</p><ul><li><p>An OLAP workload is characterized by <strong>long running(长期运行), complex queries, reads on large portions</strong> of the database.</p></li><li><p>In OLAP workloads, the database system is analyzing and <strong>deriving</strong>(推导/添加) new data from existing data collected on the OLTP side.</p><blockquote><p>An example of an OLAP workload would be Amazon computing the most bought item in Pittsburgh on a day when its raining.</p></blockquote></li></ul><p>HTAP: Hybrid Transaction + Analytical Processing</p><p>A new type of workload which has become popular recently is HTAP, which is like <strong>a combination which tries to do OLTP and OLAP together</strong> on the same database.</p><p><img loading=lazy src=img/image-20230222165717923.png alt=image-20230222165717923></p><h2 id=52-storage-models>5.2 Storage Models<a hidden class=anchor aria-hidden=true href=#52-storage-models>#</a></h2><h3 id=n-ary-storage-model-nsm>N-Ary Storage Model (NSM)<a hidden class=anchor aria-hidden=true href=#n-ary-storage-model-nsm>#</a></h3><p>In the n-ary storage model, the DBMS <strong>stores all of the attributes for a single tuple contiguously in a single page</strong></p><p>This approach is <strong>ideal for OLTP workloads</strong> where requests are insert-heavy and transactions tend to operate only an individual entity.</p><p>It is ideal because it takes only one fetch to be able to get all of the attributes for a single tuple.</p><p>Advantages:</p><ul><li>Fast inserts, updates, and deletes.</li><li>Good for queries that need the entire tuple.</li></ul><p>Disadvantages:</p><ul><li>Not good for <strong>scanning large portions of the table</strong> and/or <strong>a subset of the attributes.</strong></li></ul><p><img loading=lazy src=img/image-20230222164813494.png alt=image-20230222164813494></p><h3 id=decomposition-分解-storage-model-dsm>Decomposition 分解 Storage Model (DSM)<a hidden class=anchor aria-hidden=true href=#decomposition-分解-storage-model-dsm>#</a></h3><p><img loading=lazy src=img/image-20230222165051507.png alt=image-20230222165051507></p><p>This model is <strong>ideal for OLAP</strong> workloads with many read-only queries that perform large scans over a subset of the table’s attributes.</p><p>Advantages:</p><ul><li><strong>Reduces the amount of I/O wasted</strong> because the DBMS only reads the data that it needs for that query.</li><li>Better query processing and data compression</li></ul><p>Disadvantages:</p><ul><li>Slow for point queries, inserts, updates, and deletes because of tuple splitting/<strong>stitching</strong>(缝合).</li></ul><p>To <strong>put the tuples back together</strong> when using a column store,there are two common approaches:</p><p>fixed-length offsets(most common): Each value is the same length for an attribute</p><p>Embedded Tuple Ids:Each value is stored with its tuple id in a column</p><p><img loading=lazy src=img/image-20230222165430923.png alt=image-20230222165430923></p><h2 id=53-database-compression>5.3 Database Compression<a hidden class=anchor aria-hidden=true href=#53-database-compression>#</a></h2><blockquote><ul><li><p>压缩操作被在<strong>disk-based</strong> DBMSs广泛应用。因为disk的I/O总是瓶颈，所以压缩可以让系统提升性能，尤其是只读analyt Managical workloads上。</p><p>如果事先对tuples进行了压缩，DBMS可以获取更多有用的tuple，但代价是要付出更大的压缩和解压的计算开销。</p></li><li><p>内存中的DBMS更加复杂，因为它们不必从磁盘中获取数据来执行一个查询。 内存比磁盘快得多，但压缩数据库可以减少DRAM需求和处理。</p><p>而且必须在速度和压缩率中取得一个平衡。压缩数据库可以减少DRAM的需求和查询执行过程中的CPU成本。</p></li><li><p>如果数据集是完全随机的bits，那么我们没有办法进行压缩。然而，现实世界中的数据集有一些key properties 是可以进行压缩的。</p><ul><li>数据集往往具有高度倾斜的属性值分布（例如，Brown语料库的Zipfian分布）。</li><li>数据集往往在同一元组的属性之间有很高的相关性（例如，邮政编码到城市。订单日期与发货日期）。 Manag</li></ul></li></ul></blockquote><p>Given this, we want a database compression scheme to have the following properties:</p><ul><li>Must produce <strong>fixed-length values</strong>. The only exception is var-length data stored in separate pools. This because the DBMS should follow word-<strong>alignment</strong>(对齐) and be able to access data using offsets.</li><li>Allow the DBMS to <strong>postpone</strong>(推迟) decompression as long as possible during query execution (late materialization).</li><li>Must be <strong>a lossless scheme</strong> because people do not like losing data. Any kind of lossy compression has to be performed at the application level.</li></ul><h3 id=compression-granularity>Compression Granularity<a hidden class=anchor aria-hidden=true href=#compression-granularity>#</a></h3><p>在给DBMS增加压缩功能之前，我们需要决定我们要压缩什么样的数据。这个决定决定了压缩方案的可用性。有四个级别的压缩 Manag颗粒度（granularity）</p><ul><li><p>Block Level: 压缩同一张表的tuple块。</p></li><li><p>Tuple Level: 压缩整个tuples的内容（仅NSM）。</p></li><li><p>Attribute Level: 在一个tuple内压缩单个属性值。可以针对同一tuple的多个属性。</p></li><li><p>Columnar Level:</p><p>为多个tuple存储的一个或多个属性压缩多个值 (只限于DSM)。这允许更复杂的压缩方案。</p></li></ul><h2 id=54-naive-compression>5.4 Naive Compression<a hidden class=anchor aria-hidden=true href=#54-naive-compression>#</a></h2><p>DBMS使用一个<strong>通用的算法</strong>对数据进行压缩 (e.g., gzip, LZO, LZ4, Snappy, Brotli, Oracle OZIP, Zstd)。 尽管DBMS可以使用几种压缩算法，但工程师们往往选择那些经常提供较低压缩率以换取更快的压缩/解压的算法。</p><p>naive compression例子： <strong>MySQL InnoDB</strong></p><p>DBMS对磁盘页面进行压缩，将其压缩到2KB的幂数，并将其存储到缓冲池中。然而，每次DBMS试图读取数据时，缓冲池中的压缩数据必须被解压</p><p>缺点:</p><ul><li>由于访问数据<strong>需要对压缩的数据进行解压</strong>，这就限制了压缩方案的范围。 如果目标是将整个表压缩成一个巨大的块，使用naive compression 方案是不可能的，因为每次访问都需要对整个表进行压缩/解压缩。 因此，对于MySQL来说，由于压缩范围有限，它将表分解成更小的块状。</li><li>naive方案也没有考虑到数据的高级含义或语义。 该算法既不考虑数据的结构，也不考虑查询打算如何访问 数据。因此，这就<strong>失去了利用late materialization 的机会</strong>，因为DBMS不能知道它何时能够延迟数据的解压。</li></ul><h2 id=55-columnar-compression-柱状压缩>5.5 Columnar Compression 柱状压缩**<a hidden class=anchor aria-hidden=true href=#55-columnar-compression-柱状压缩>#</a></h2><h3 id=run-length-encoding>Run-length Encoding<a hidden class=anchor aria-hidden=true href=#run-length-encoding>#</a></h3><p>Compress runs of the same value in a single column into triplets:</p><ul><li>The value of the attribute.</li><li>The start position in the column segment.</li><li>The # of elements in the run.</li></ul><p><img loading=lazy src=img/image-20230222170534215.png alt=image-20230222170534215></p><p>Requires the columns to be sorted <strong>intelligently</strong>(智能) to maximize compression opportunities.</p><p><img loading=lazy src=img/image-20230222170706032.png alt=image-20230222170706032></p><h3 id=bit-packing-encoding>Bit-Packing Encoding<a hidden class=anchor aria-hidden=true href=#bit-packing-encoding>#</a></h3><p>When values for an attribute are <strong>always less than the value&rsquo;s declared largest size,</strong> <strong>store them as smaller data type</strong>.</p><p><img loading=lazy src=img/image-20230222170800172.png alt=image-20230222170800172></p><p>Bit-packing variant that uses a <strong>special marker</strong> to indicate when a value exceeds largest size and then maintain a look-up table to store them.</p><p><img loading=lazy src=img/image-20230222170818530.png alt=image-20230222170818530></p><h3 id=bitmap-encoding>Bitmap Encoding<a hidden class=anchor aria-hidden=true href=#bitmap-encoding>#</a></h3><p>Store a separate bitmap for each unique value for an attribute where <strong>an offset in the vector corresponds to a tuple.</strong></p><ul><li>The i th position in the Bitmap corresponds to the i th tuple in the table.</li><li>Typically segmented into chunks to avoid allocating large blocks of contiguous memory. Only practical <strong>if the value cardinality(基数) is low</strong>. Some DBMSs provide bitmap indexes.</li></ul><p><img loading=lazy src=img/image-20230222171138540.png alt=image-20230222171138540></p><h3 id=delta-encoding>Delta Encoding<a hidden class=anchor aria-hidden=true href=#delta-encoding>#</a></h3><p><strong>Recording the difference</strong> between values that follow each other in the same column.</p><ul><li>Store base value in-line or in a separate look-up table.</li><li><strong>Combine with RLE to get even better compression ratios.</strong></li></ul><p><img loading=lazy src=img/image-20230222171254392.png alt=image-20230222171254392></p><h3 id=incremental-encoding>Incremental Encoding<a hidden class=anchor aria-hidden=true href=#incremental-encoding>#</a></h3><p>Type of delta encoding that <strong>avoids duplicating common prefixes/suffixes between consecutive tuples</strong>. This works best with sorted data.</p><p><img loading=lazy src=img/image-20230222171338403.png alt=image-20230222171338403></p><h3 id=dictionary-encoding>Dictionary Encoding<a hidden class=anchor aria-hidden=true href=#dictionary-encoding>#</a></h3><p>Build a data structure that <strong>maps variable-length values to a smaller integer identifier.</strong></p><p>Replace those values with their corresponding identifier in the dictionary data structure.</p><ul><li>Need to support fast encoding and decoding.<ul><li>Encode/Locate: For a given uncompressed value, convert it into its compressed form.</li><li>Decode/Extract: For a given compressed value, convert it back into its original form.</li><li>No magic hash function will do this for us.</li></ul></li><li>Need to also support range queries.</li></ul><p><strong>Most widely used compression scheme in DBMSs.</strong></p><p><img loading=lazy src=img/image-20230222171632448.png alt=image-20230222171632448></p><h1 id=homework-2-storage--indexeshttps15445coursescscmuedufall2022fileshw2-cleanpdf>Homework #2 <a href=https://15445.courses.cs.cmu.edu/fall2022/files/hw2-clean.pdf>Storage & Indexes</a><a hidden class=anchor aria-hidden=true href=#homework-2-storage--indexeshttps15445coursescscmuedufall2022fileshw2-cleanpdf>#</a></h1><h2 id=question-1-storage-models>Question 1: Storage Models<a hidden class=anchor aria-hidden=true href=#question-1-storage-models>#</a></h2><p>a database with a single table <strong>R(q_id,txns,total,failed)</strong>, where q_id is the <strong>primary key</strong>, and <strong>all attributes are the same fixed width.</strong></p><p>Suppose R has 20,000 tuples that fit into 100 pages, <strong>Ignore any additional storage</strong> overhead for the table (e.g., page headers, tuple headers).</p><p>Assumptions:</p><ul><li>The DBMS does <strong>not have any additional meta-data</strong> (e.g., sort order, zone maps).</li><li>R does <strong>not have any indexes</strong> (including for primary key q_id)</li><li><strong>None</strong> of R’s pages are already <strong>in the buffer pool</strong>.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>SELECT total - failed FROM R
</span></span><span style=display:flex><span>WHERE q id = 96 AND txns &gt; 420;
</span></span></code></pre></div><h3 id=a-suppose-the-dbms-uses-the-decomposition-storage-model-dsm-with-implicit-offsets>(a) Suppose the DBMS uses the decomposition storage model (DSM) with implicit offsets<a hidden class=anchor aria-hidden=true href=#a-suppose-the-dbms-uses-the-decomposition-storage-model-dsm-with-implicit-offsets>#</a></h3><ul><li><p>i What is the <strong>minimum number of pages</strong> that the DBMS will potentially have to read from disk to answer this query?</p><p>题意是存在这样一条记录,找到该条记录最少的磁盘读次数.</p><p>官方解答是: 4 pages. 1 to find the primary key, + 3 to access txns, total, failed at their corresponding offsets.</p><p>因为使用分解存储模式DSM, 按列存储.</p><p>因此找到主键后就可以通过偏移量找其他属性的值. 读盘次数的限制在找主键上.</p><p>显然,找主键至少需要一次读盘.</p></li><li><p>ii What is the <strong>maximum number of pages</strong> that the DBMS will potentially have to read from disk to answer this query?</p><p>官方解答: 28 pages. <strong>There are 25 pages per attribute.</strong> In the worst case, we scan through all 25 pages to find the primary key, and then + 3 to access txns, total, failed at their corresponding offsets.</p><p>上题可知,找主键次数决定了读盘次数.</p><p>也就是当q_id = 96的记录越靠后, 找主键次数越多.</p><p>因为没有顺序,所以96是无用的信息.</p><p>同时因为<strong>有四个属性,且所有属性大小固定</strong>. 所以当每个属性都占25页时,且q_id=26所在的记录是最后一个(25),找主键次数最大为25次.</p></li></ul><h3 id=bsuppose-the-dbms-uses-the-n-ary-storage-model-nsm>(b)Suppose the DBMS uses the N-ary storage model (NSM)<a hidden class=anchor aria-hidden=true href=#bsuppose-the-dbms-uses-the-n-ary-storage-model-nsm>#</a></h3><ul><li><p>i. What is the minimum number of pages that the DBMS will potentially have to read from disk to answer this query?</p><p>Solution: We find the tuple with the matching primary key on the first page. No need to look in other pages since all attributes are stored together.</p><p>在第一页</p></li><li><p>ii. [4 points] What is the maximum number of pages that the DBMS will potentially have to read from disk to answer this query?</p><p>在最后一页 100</p></li></ul><h2 id=question-2-cuckoo-hashing>Question 2: Cuckoo Hashing<a hidden class=anchor aria-hidden=true href=#question-2-cuckoo-hashing>#</a></h2><p>几道哈希表计算的题目,较简单</p><p>2进制：0b，8进制：0o，10进制：无前缀，16进制：0x</p><h2 id=question-3-extendible-hashing>Question 3: Extendible Hashing<a hidden class=anchor aria-hidden=true href=#question-3-extendible-hashing>#</a></h2><p>Consider an extendible hashing structure such that:</p><ul><li>Each bucket can hold up to two records.</li><li>The hashing function uses the lowest g bits, where g is the global depth.</li></ul><p>题目是一个二进制可扩展哈希. 哈希函数是二进制最低g位.</p><p>每个哈希值对应一个桶, 每个桶最多两个, 所有刚好就是二进制.</p><h3 id=a-starting-from-an-empty-table-insert-keys-15-14-23-11-9>(a) Starting from an empty table, insert keys 15, 14, 23, 11, 9.<a hidden class=anchor aria-hidden=true href=#a-starting-from-an-empty-table-insert-keys-15-14-23-11-9>#</a></h3><p>二进制表示</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>15: 00001111
</span></span><span style=display:flex><span>14: 00001110
</span></span><span style=display:flex><span>23: 00010111
</span></span><span style=display:flex><span>11: 00001011
</span></span><span style=display:flex><span>9 : 00001001
</span></span></code></pre></div><p>插入步骤(括号内为局部深度,全局深度为最大局部深度)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>插入15
</span></span><span style=display:flex><span>全局: 1; 桶 1(1):15
</span></span><span style=display:flex><span>14
</span></span><span style=display:flex><span>全局: 1; 桶 1(1):15 ; 0(1):14
</span></span><span style=display:flex><span>23
</span></span><span style=display:flex><span>全局: 1; 桶 1(1):15,23; 0(1):14
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>11
</span></span><span style=display:flex><span>全局: 1; 桶 1(1):15,23,11; 0(1):14
</span></span><span style=display:flex><span>桶1此时有三条记录,需要扩展深度,扩展为2
</span></span><span style=display:flex><span>全局: 2; 桶 11(2):15,23,11; 01(2):; 0(1):14
</span></span><span style=display:flex><span>桶11此时有三条记录,需要扩展深度,扩展为3
</span></span><span style=display:flex><span>全局: 3; 桶 111(3):15,23; 011(3):11;01(2):; 0(1):14
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>9
</span></span><span style=display:flex><span>全局: 3; 桶 111(3):15,23; 011(3):11; 0(1):14; 01(2):9;
</span></span></code></pre></div><ul><li><p>i. What is the global depth of the resulting table?</p><p>显然,当g至少等于3的时候才能使得同一个哈希值最多对应两个记录.</p></li><li><p>ii. [4 points] What is the local depth the bucket containing 15?</p><p>为3</p></li><li><p>iii. [4 points] What is the local depth of the bucket containing 14?</p><p>为1</p></li></ul><h3 id=b-starting-from-the-result-in-a-you-insert-keys-12-5-7-13-2>(b) Starting from the result in (a), you insert keys 12, 5, 7, 13, 2.<a hidden class=anchor aria-hidden=true href=#b-starting-from-the-result-in-a-you-insert-keys-12-5-7-13-2>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>15: 00001111
</span></span><span style=display:flex><span>14: 00001110
</span></span><span style=display:flex><span>23: 00010111
</span></span><span style=display:flex><span>11: 00001011
</span></span><span style=display:flex><span>9 : 00001001
</span></span><span style=display:flex><span>此时 全局: 3; 桶 111(3):15,23; 011(3):11; 0(1):14; 01(2):9;
</span></span><span style=display:flex><span>12: 00001010
</span></span><span style=display:flex><span>5 : 00000101
</span></span><span style=display:flex><span>7 : 00000111
</span></span><span style=display:flex><span>13: 00001101
</span></span><span style=display:flex><span>2 : 00000010
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>12
</span></span><span style=display:flex><span>全局: 3; 桶 111(3):15,23; 011(3):11; 0(1):14,12; 01(2):9;
</span></span><span style=display:flex><span>5
</span></span><span style=display:flex><span>全局: 3; 桶 111(3):15,23; 011(3):11; 0(1):14,12; 01(2):9;
</span></span><span style=display:flex><span>7
</span></span><span style=display:flex><span>全局: 3; 桶 111(3):15,23; 011(3):11; 0(1):14,12; 1(1):9,5;
</span></span><span style=display:flex><span>此时111桶有3个,增加深度为4
</span></span><span style=display:flex><span>全局: 4; 桶 1111(4):15;0111(4):23,7; 011(3):11; 0(1):14,12; 1(1):9,5;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>13
</span></span><span style=display:flex><span>全局: 4; 桶 1111(4):15;0111(4):23,7; 011(3):11; 0(1):14,12; 1(1):9,5;
</span></span><span style=display:flex><span>01(2):13;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>2
</span></span><span style=display:flex><span>全局: 4; 桶 1111(4):15;0111(4):23,7; 011(3):11; 0(1):14,12; 1(1):9,5;
</span></span><span style=display:flex><span>01(2):13;01(2):2
</span></span></code></pre></div><ul><li><p>i. [4 points] Which key will first cause a split (without doubling the size of the table)?</p><p>这里的split操作指的是<strong>增加桶的数量</strong>,而不double.也就是不增加全局深度.(增加全局深度会翻一倍)</p><p>所以是13第一个增加了桶的数量.</p></li><li><p>ii. [4 points] Which key will first make the table double in size?</p><p>7</p></li></ul><h3 id=c-now-consider-the-table-below-along-with-the-following-deletion-rules>(c) Now consider the table below, along with the following deletion rules:<a hidden class=anchor aria-hidden=true href=#c-now-consider-the-table-below-along-with-the-following-deletion-rules>#</a></h3><ol><li>If two buckets satisfy the following:</li></ol><p>(a) They have the same local depth d</p><p>(b) They share the first d − 1 bits of their indexes (e.g. b010 and b110 share the first 2 bits)</p><p>(c) Their constituent elements fit in a single bucket. Then they can be merged into a single bucket with local depth d − 1.</p><ol start=2><li>If the global depth g becomes strictly greater than all local depths, then the table can be halved in size. The resulting global depth is g − 1.</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>00
</span></span><span style=display:flex><span>28:11100
</span></span><span style=display:flex><span>8 :01000
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>01
</span></span><span style=display:flex><span>25:11001
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>10
</span></span><span style=display:flex><span>30:11110
</span></span><span style=display:flex><span>22:10110
</span></span><span style=display:flex><span>18:10010
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>011
</span></span><span style=display:flex><span>11:01011
</span></span><span style=display:flex><span>27:11011
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>111
</span></span><span style=display:flex><span>23:10111
</span></span><span style=display:flex><span>7 :00111
</span></span></code></pre></div><p>Starting from the table above, delete keys 25, 18, 22, 27, 7.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>delete 25
</span></span><span style=display:flex><span>00
</span></span><span style=display:flex><span>28:11100
</span></span><span style=display:flex><span>8 :01000
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>10
</span></span><span style=display:flex><span>30:11110
</span></span><span style=display:flex><span>22:10110
</span></span><span style=display:flex><span>18:10010
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>011
</span></span><span style=display:flex><span>11:01011
</span></span><span style=display:flex><span>27:11011
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>111
</span></span><span style=display:flex><span>23:10111
</span></span><span style=display:flex><span>7 :00111
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>delete 18
</span></span><span style=display:flex><span>00
</span></span><span style=display:flex><span>28:11100
</span></span><span style=display:flex><span>8 :01000
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>10
</span></span><span style=display:flex><span>30:11110
</span></span><span style=display:flex><span>22:10110
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>011
</span></span><span style=display:flex><span>11:01011
</span></span><span style=display:flex><span>27:11011
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>111
</span></span><span style=display:flex><span>23:10111
</span></span><span style=display:flex><span>7 :00111
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>delete 22
</span></span><span style=display:flex><span>00
</span></span><span style=display:flex><span>28:11100
</span></span><span style=display:flex><span>8 :01000
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>10
</span></span><span style=display:flex><span>30:11110
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>011
</span></span><span style=display:flex><span>11:01011
</span></span><span style=display:flex><span>27:11011
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>111
</span></span><span style=display:flex><span>23:10111
</span></span><span style=display:flex><span>7 :00111
</span></span><span style=display:flex><span>此时00 和 10可进行合并
</span></span><span style=display:flex><span>0
</span></span><span style=display:flex><span>28:11100
</span></span><span style=display:flex><span>8 :01000
</span></span><span style=display:flex><span>30:11110
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>011
</span></span><span style=display:flex><span>11:01011
</span></span><span style=display:flex><span>27:11011
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>111
</span></span><span style=display:flex><span>23:10111
</span></span><span style=display:flex><span>7 :00111
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>delete 27
</span></span><span style=display:flex><span>0
</span></span><span style=display:flex><span>28:11100
</span></span><span style=display:flex><span>8 :01000
</span></span><span style=display:flex><span>30:11110
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>011
</span></span><span style=display:flex><span>11:01011
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>111
</span></span><span style=display:flex><span>23:10111
</span></span><span style=display:flex><span>7 :00111
</span></span><span style=display:flex><span>此时 011 和 111可合并为11,一次合并最多减少1, 此时global depth = 2
</span></span><span style=display:flex><span>0
</span></span><span style=display:flex><span>28:11100
</span></span><span style=display:flex><span>8 :01000
</span></span><span style=display:flex><span>30:11110
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>11
</span></span><span style=display:flex><span>11:01011
</span></span><span style=display:flex><span>23:10111
</span></span><span style=display:flex><span>7 :00111
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>delete 7
</span></span><span style=display:flex><span>0
</span></span><span style=display:flex><span>28:11100
</span></span><span style=display:flex><span>8 :01000
</span></span><span style=display:flex><span>30:11110
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>11
</span></span><span style=display:flex><span>11:01011
</span></span><span style=display:flex><span>23:10111
</span></span></code></pre></div><ul><li>i. Which deletion first causes a reduction in a local depth.</li></ul><p>22</p><ul><li><p>ii. Which deletion first causes a reduction in global depth.</p><p>27</p><p>Solution: Deleting 27 from bucket b011 allows it to merge with b111. Since these two buckets are the only ones of depth d = 3, this merge reduces the global depth to d = 2</p></li></ul><h2 id=question-4-btree>Question 4: B+Tree<a hidden class=anchor aria-hidden=true href=#question-4-btree>#</a></h2><p>还行,就是有个奇怪的点. 索引节点的值一般会出现在叶子节点上.</p><p>最后一题是找出指定的节点 非法的地方.</p><h1 id=p1>P1<a hidden class=anchor aria-hidden=true href=#p1>#</a></h1><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>1: 0001
</span></span><span style=display:flex><span>2: 0010
</span></span><span style=display:flex><span>3: 0011
</span></span><span style=display:flex><span>4: 0100
</span></span><span style=display:flex><span>5: 0101
</span></span><span style=display:flex><span>6: 0110
</span></span><span style=display:flex><span>7: 0111
</span></span><span style=display:flex><span>8: 1000
</span></span><span style=display:flex><span>9: 1001
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>1 2 3 4
</span></span><span style=display:flex><span>全局1 1(1):1,3;0(1):2,4;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>5
</span></span><span style=display:flex><span>全局1 1(1):1,3,5;0(1):2,4;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>全局2 01(2):1,5;11(2)3;0(1):2,4;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>6
</span></span><span style=display:flex><span>全局2 01(2):1,5;11(2)3;00(2):4;10(2):2,6;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>7
</span></span><span style=display:flex><span>全局2 01(2):1,5;11(2)3,7;00(2):4;10(2):2,6;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>8
</span></span><span style=display:flex><span>全局2 01(2):1,5;11(2)3,7;00(2):4,8;10(2):2,6;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>9
</span></span><span style=display:flex><span>全局2 01(2):1,5,9;11(2)3,7;00(2):4,8;10(2):2,6;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>全局3 001(3):1,9;101(3):5;11(2)3,7;00(2):4,8;10(2):2,6;
</span></span></code></pre></div><h2 id=lru-k>LRU-K<a hidden class=anchor aria-hidden=true href=#lru-k>#</a></h2><p>The LRU-K algorithm <strong>evicts</strong>(剔除) a frame whose <strong>backward k-distance</strong> is maximum of all frames in the replacer.</p><p><strong>Backward k-distance</strong> is computed as the <strong>difference</strong> in time between current timestamp and the timestamp of kth previous access.</p><p>A frame with less than k historical accesses is given +inf as its backward k-distance. When <strong>multipe frames have +inf backward k-distance</strong>, the replacer evicts the frame <strong>with the earliest timestamp</strong>.</p><p>先弄清楚逻辑在写，不要把时间花在无意义的bug上。</p><h1 id=p2-btree>P2 B+Tree<a hidden class=anchor aria-hidden=true href=#p2-btree>#</a></h1><h2 id=概述>概述<a hidden class=anchor aria-hidden=true href=#概述>#</a></h2><p>内部节点：索引作用</p><p>叶子节点：包含真正的数据实体</p><p>由于树是动态增长和收缩，所以要处理 split 和 merge</p><blockquote><p>Since the tree structure grows and shrink dynamically, you are required to handle the logic of split and merge.</p></blockquote><p><strong>Checkpoint #1 — Due Date: Oct 11 @ 11:59pm</strong></p><ul><li><strong><a href=https://15445.courses.cs.cmu.edu/fall2022/project2/#b+tree-pages>Task #1 - B+Tree Pages</a></strong></li><li><strong><a href=https://15445.courses.cs.cmu.edu/fall2022/project2/#b+tree-structure>Task #2 - B+Tree Data Structure (Insertion, Deletion, Point Search)</a></strong></li></ul><p><strong>Checkpoint #2 — Due Date: Oct 26 @ 11:59pm</strong></p><ul><li><strong><a href=https://15445.courses.cs.cmu.edu/fall2022/project2/#index-iterator>Task #3 - Index Iterator</a></strong></li><li><strong><a href=https://15445.courses.cs.cmu.edu/fall2022/project2/#concurrent_index>Task #4 - Concurrent Index</a></strong></li></ul><p>该project 要依赖于上一个 buffer pool 的正确实现。</p><p>由于第一个检查点与第二个检查点密切相关，在第二个检查点中，您将在现有的B+索引中实现索引抓取，因此我们传入了一个名为transaction的指针参数，其默认值为nullptr。在任务#4之前，您不需要更改或调用与参数相关的任何函数。</p><h2 id=task-1---btree-pages>Task #1 - B+Tree Pages<a hidden class=anchor aria-hidden=true href=#task-1---btree-pages>#</a></h2><ul><li><strong><a href=https://15445.courses.cs.cmu.edu/fall2022/project2/#b+tree-page>B+Tree Parent Page</a></strong></li><li><strong><a href=https://15445.courses.cs.cmu.edu/fall2022/project2/#b+tree-internal-page>B+Tree Internal Page</a></strong></li><li><strong><a href=https://15445.courses.cs.cmu.edu/fall2022/project2/#b+tree-leaf-page>B+Tree Leaf Page</a></strong></li></ul><h3 id=btree-parent-page>B+Tree Parent Page<a hidden class=anchor aria-hidden=true href=#btree-parent-page>#</a></h3><p>ParenPage 被 Internal Page 和 Leaf Page所继承。</p><p>并且只包含了 子类 所共享的信息。</p><p><strong>可以规定</strong> <code>parent_page_id_</code> 为 <code>INVALID_PAGE_ID</code> 表示根节点。</p><p>| Variable Name | Size | Description | | &mdash;&mdash;&mdash;&mdash;&mdash; | &mdash;- | &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash; | | page_type_ | 4 | Page Type (internal or leaf) | | lsn_ | 4 | Log sequence number (Used in Project 4) | | size_ | 4 | Number of Key & Value pairs in page | | max_size_ | 4 | Max number of Key & Value pairs in page | | parent_page_id_ | 4 | Parent Page Id | | page_id_ | 4 | Self Page Id |</p><h3 id=btree-internal-page>B+Tree Internal Page<a hidden class=anchor aria-hidden=true href=#btree-internal-page>#</a></h3><ul><li>不存储真实数据。只存储 m个有序 key和m+1个child 指针。</li><li>因为key的数量和指针数量不相等。第一个key被设定为invalid。所有方法需要从第二个key开始（下标为1）</li><li>实际存储如下</li><li>键,指针,键,指针,&mldr;,键,指针.</li><li>此时有m+1个键,为了保证只有m个键,所以第一个键设置为无效的.</li></ul><p>key的数量限制</p><ul><li>在任何时间，最少装了一半（half-full）。</li><li>删除时，两个 half-full可以被joined 成为一个合法的 Internal Page<ul><li>或者被重新分配来避免merge</li></ul></li><li>当插入到一个fullpage时，可以被split成两个。</li><li>This is an example of one of the many design choices that you will make in the implementation of the B+ Tree.</li></ul><p>三个泛型 KeyType, ValueType, KeyComparator。</p><p><strong>KeyType</strong> 不一定直接可用大于小于号比较，所以引入了 KeyComparator，从 cpp 文件中的实例化可以看出用的是 GenericKey 和 GenericComparator，查看二者源码可以得到以下信息：</p><p><strong>GenericKey</strong> 可以调用 ToString() 函数得到其 int64 表示，然后用 **%ld 格式符打印。**这对我们后面调试时非常重要。 GenericComparator 的比较规则是：左边小于右边时，返回 -1；左边大于右边时，返回 1；相等返回 0。</p><p><strong>ValueType</strong> 代表的是指向子页面的指针，从实例化可以看出实际只用了 page_id_t，也就是 <strong>int</strong>。</p><p>数据存储上，其理论结构应为 &lt;指针，键，指针，键…，键，指针>，为方便存储，实际上<strong>在头部多补了一个无效键</strong>，从而可以用一个 pair 的数组存储：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>#define MappingType std::pair&lt;KeyType, ValueType&gt;
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>class BPlusTreeInternalPage : public BPlusTreePage {
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>private:
</span></span><span style=display:flex><span>  // Flexible array member for page data.
</span></span><span style=display:flex><span>  MappingType array_[1];
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>array_[1] 等价与 pair类型的指针.指向pair数组. 数组的每一个元素是&lt;键,值></p><p>在内部节点中,值代表指针.(第一个元素的键是无效的,但值是存在的).</p><p>因为节点对象使用的是预先分配好的固定空间，array_ 可以控制从该位置开始到 Page 的 data 结束为止的这一段空间。</p><p>因此，节点对象的生命周期也不是由 new 和 delete，而是由 BufferPoolManager 管理.</p><ul><li>取一个页面，用 FetchPage；</li><li>使用结束归还一个页面，用 UnpinPage。</li><li>page_id_ 不仅是 B+ 树中节点的编号，同时也是这个节点使用的 Page 在 BufferPool 中的编号。</li></ul><h3 id=btree-leaf-page>B+Tree Leaf Page<a hidden class=anchor aria-hidden=true href=#btree-leaf-page>#</a></h3><ul><li>存储 m个有序key，m个 value 实体</li><li>在这次实现中，value 仅仅是64位的record_id, 被用于定位真实的tuples的存储位置.<ul><li>see <code>RID</code> class defined under in <code>src/include/common/rid.h</code>.</li></ul></li><li>对于键值对的数量限制与Internal Page一致.</li></ul><p><strong>重要</strong></p><ul><li>尽管叶子节点和内部节点有相同类型的key.但他们值的类型不一样.<ul><li>所以<strong>max_size 也应该是不同的</strong></li></ul></li><li>每个节点的 <strong>data_</strong>,都是从buffer pool 中fetch得到的 内存页面.<ul><li>所以当写或读时,要先使用唯一的page_id,从buffer pool 中fetch 出来.</li><li>然后使用 reinterpret cast, 转换成 叶子节点或内部节点.</li><li>并且要在读或写操作结束后,unpin这个页面.</li></ul></li></ul><h2 id=task-2---btree-data-structure>Task #2 - B+Tree Data Structure<a hidden class=anchor aria-hidden=true href=#task-2---btree-data-structure>#</a></h2><ul><li>只支持 unique keys. 也就是说,当有重复的key插入时, 不进行任何操作并返回false</li><li>同时当删除操作导致 页面key数量低于阈值时, 需要正确地执行 merge 和 redistribute(也叫做 coalescing) 操作.</li></ul><p>对于checkpoint , B+Tree Index 只需要支持 <strong>insertions</strong> (<code>Insert()</code>), <strong>point search</strong> (<code>GetValue()</code>), and <strong>deletes</strong> (<code>Delete()</code>)</p><p>插入操作 引起 split操作的情况:</p><ul><li>插入操作后, 叶子节点中 pair的数量 等于 max_size</li><li>插入 操作前, 内部节点 孩子数量等于 max_size</li></ul><p>因为写操作会导致, root_page_id的改变,所以也要在 <strong>header page</strong> 同时更新 root_page_id (<code>src/include/storage/page/header_page.h</code>).</p><p>更新的方法是调用 <code>UpdateRootPageId</code> (已经提供了)</p><p>需要隐藏类型和比较.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>template &lt;typename KeyType,
</span></span><span style=display:flex><span>          typename ValueType,
</span></span><span style=display:flex><span>          typename KeyComparator&gt;
</span></span><span style=display:flex><span>class BPlusTree{
</span></span><span style=display:flex><span>   // ---
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><ul><li><code>KeyType</code>: 索引中key的类型,只可能是 <code>GenericKey</code>.<ul><li>GeneriKey真实的size是特定的.</li><li>是通过模板参数指定和实例化的，并取决于索引属性的数据类型.</li></ul></li><li><code>ValueType</code>: 索引中值的类型. 只可能是 64-bit RID.</li><li><code>KeyComparator</code>: 用来比较两个KeyType实例 大小关系. 左边小于右边时，返回 -1；左边大于右边时，返回 1；相等返回 0。</li></ul><h2 id=checkpoint-1查找插入和删除>Checkpoint 1：查找，插入和删除<a hidden class=anchor aria-hidden=true href=#checkpoint-1查找插入和删除>#</a></h2><h3 id=约定>约定<a hidden class=anchor aria-hidden=true href=#约定>#</a></h3><p>这里约定 内部节点array中key 与子节点的关系.</p><ul><li>左子节点的keys &lt;= 父节点的keys</li><li>右子节点的keys > 父节点的keys</li></ul><h3 id=查找>查找<a hidden class=anchor aria-hidden=true href=#查找>#</a></h3><p>给定key，返回查找的页面。</p><p>页面的数据存在叶子节点中。</p><p>因此要从根节点开始，一层一层往下找</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span>findValue(<span style=color:#66d9ef>const</span> Page page,KeyType key){
</span></span><span style=display:flex><span>    <span style=color:#75715e>//二分查找 page的array中,找到最大的小于等于key的 pair
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> pair;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>GetLeaf(Page root,KeyType key){
</span></span><span style=display:flex><span>    Page now <span style=color:#f92672>=</span> root;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span>(now.type <span style=color:#f92672>!=</span> leaf){
</span></span><span style=display:flex><span>        now <span style=color:#f92672>=</span> findValue(now,key);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> now;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>GetValue(KeyType key){
</span></span><span style=display:flex><span>    Page now <span style=color:#f92672>=</span> GetLeaf(root,key);
</span></span><span style=display:flex><span>    <span style=color:#75715e>//现在now为叶子节点,在叶子节点中找对应的值.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    findValue(now,key);
</span></span><span style=display:flex><span>    <span style=color:#75715e>//如果返回值的key不相等则没找到.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//相等则返回找到
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h3 id=插入叶子节点>插入(叶子节点)<a hidden class=anchor aria-hidden=true href=#插入叶子节点>#</a></h3><p>因为以下的操作都基于至少有一个根节点的情况.</p><p>因此在最开始要判断是否为空树,如为空树则创建根, 直接返回</p><p>首先看键存不存在,如果已经存在,则直接返回.</p><p>因为B+树的真实数据存在叶子节点中. 因此插入的第一步就是在找到对应叶子节点,并**插入(叶子节点)**到对应位置.</p><p>此后可能会引起分裂.</p><ol><li>先直接**插入(叶子节点)**到叶子节点中.</li><li>当发现**插入(叶子节点)**后, 叶子节点的pair数量等于max_size时进行分裂.</li></ol><p>split(page) 操作<strong>这里不分内部叶子节点</strong></p><ul><li>当前节点是full page,因此可以将当前节点分裂成 (左子节点 half full, 新父节点 , half full)</li><li>其中新父节点的值是左子节点的最后一个.</li><li>新父节点 需要 <strong>插入(内部节点)</strong> 到原来的父节点中.<ul><li><strong>插入(内部节点)前</strong>, 要判断 <strong>原父节点的孩子数量是否等于max_size</strong></li><li>如果等于, 则先<strong>将原父节点分裂</strong> 后.</li><li>再执行当前的**插入(内部节点)**操作.</li></ul></li><li>特殊的. 如果page是根节点, 即没有原父亲节点.<ul><li>则将 根节点 更新成新父节点后, 返回即可.</li></ul></li></ul><p><strong>插入(内部节点)</strong> : 因为在插入前已经处理好了插入操作的合法性,因此直接插入即可.</p><p>伪代码:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span>SetRoot(page_id){
</span></span><span style=display:flex><span> root_page_id <span style=color:#f92672>=</span> page_id;
</span></span><span style=display:flex><span>    <span style=color:#75715e>//一定要调用 UpdateRootPageId
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>split(page){
</span></span><span style=display:flex><span>    <span style=color:#75715e>//分裂出下面三个节点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    left_page, right_page;
</span></span><span style=display:flex><span>    new_parent_page;<span style=color:#75715e>//key为左节点的最后一个key, value为指向左节点的指针
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>//判断是否为根节点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span>(page.type <span style=color:#f92672>==</span> rootType){
</span></span><span style=display:flex><span>       SetRoot(new_parent_page.page_id);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> ;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>//获取父亲节点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    parent_page;    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(parent_page.isFull()){
</span></span><span style=display:flex><span>        split(parent_page);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>//将new_parent_page 插入到 parent_page中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    parent_page.insert();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>Insert(key,value){
</span></span><span style=display:flex><span>    <span style=color:#75715e>//判断是否为空树
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span>(root <span style=color:#f92672>==</span> valid){
</span></span><span style=display:flex><span>        Page new_page <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Page(key,value);
</span></span><span style=display:flex><span>        SetRoot(newpage.page_id);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> ;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>//先查找
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Page leaf_page <span style=color:#f92672>=</span> GetLeaf(root,key);
</span></span><span style=display:flex><span>    <span style=color:#75715e>//直接调用叶子节点的插入
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    leaf_page.Insert(leaf_page, Page <span style=color:#66d9ef>new</span> page(key,value));
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>LeafPage<span style=color:#f92672>::</span>Insert(Page new_page){
</span></span><span style=display:flex><span>    <span style=color:#75715e>//直接插入,同时只需要更新指向 new_page 和 new_page的 next
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>//满了就分裂.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span>(isFull()){
</span></span><span style=display:flex><span>        split();
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>InternalPage<span style=color:#f92672>::</span>Insert(Page new_page){
</span></span><span style=display:flex><span>    <span style=color:#75715e>//直接插入,但array中key的有效位置是从1开始
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span><span style=color:#75715e>//上面代码还需要考虑
</span></span></span><span style=display:flex><span><span style=color:#75715e>//页面的创建和释放
</span></span></span></code></pre></div><h3 id=删除>删除<a hidden class=anchor aria-hidden=true href=#删除>#</a></h3><p>B+树最难的地方。但比起splay来说还是简单太多了。并且因为B+树只有叶子节点存值。在内部节点的删除上比B树简单了很多。</p><p>删除的核心操作：</p><ol><li>叶子节点/内部节点删除元素后;
若小于下限,则按下面的优先级考虑;</li><li>如相邻兄弟结点丰满（即 元素个数 大于 下限+1），则向兄弟结点<strong>借</strong>一个元素。（具体是 先从相邻方向上的父亲结点变成借来的元素左右(这里具体要看借左边还是右边)，而后对应相邻的兄弟补回这个元素）。否则：</li><li>与相邻的兄弟结点 <strong>合并</strong></li></ol><p>父亲节点被删除后, 需要继续执行上面的操作.</p><p>叶子节点和内部节点的差异:</p><ul><li>借<ul><li>内部节点和B树操作一样, 先<strong>从相邻方向上的父亲结点拿一个元素</strong>，而后<strong>对应相邻的兄弟补回这个元素</strong></li><li>叶子节点的父亲只是索引节点,因此 把兄弟节点的元素拿来后, 父亲节点的值根据 从左边/右边拿 变成相应的合法的值即可.</li><li>借的操作都<strong>不会涉及父亲节点的删除</strong></li></ul></li><li>合并<ul><li>内部节点和B树操作一样, 将兄弟和父亲节点一起合并. (也相当于删除了父亲节点)下限+(下限-1) + 1 等于上限,因此合法</li><li>叶子节点是 两个叶子节点合并后直接删除父亲节点.</li></ul></li></ul><p>特殊地,如果删除的是根节点的元素，且根结点只有一个元素，则<strong>下降一层</strong>退出。</p><ul><li>因为只有一个待删除的元素，说明目前只有一个儿子结点（刚刚合并了）。</li><li>直接将儿子结点作为根节点。</li></ul><p>伪代码</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>//tree的Remove操作
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>Remove(){
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>//1.判断是否为空
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span>(empty){
</span></span><span style=display:flex><span>    <span style=color:#75715e>//返回
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>//2.找到叶子结点，并在叶子结点中删除该元素
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    leaf_page;<span style=color:#75715e>//找到叶子节点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//TODO 删除元素
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>//3.判断叶子结点元素个数是是否小于下限
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span>( <span style=color:#960050;background-color:#1e0010>小于</span> <span style=color:#960050;background-color:#1e0010>下限</span>){
</span></span><span style=display:flex><span>        UnderFlow()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>Underflow(){
</span></span><span style=display:flex><span>            <span style=color:#75715e>//3.0 判断是否为根节点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span>(IsRoot){
</span></span><span style=display:flex><span>           <span style=color:#75715e>//根节点的下限是1.说明应该减少一层.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            
</span></span><span style=display:flex><span>           <span style=color:#75715e>//3.0.1a找到根节点唯一的子节点.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>           <span style=color:#75715e>//该子节点变为根节点.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#75715e>//3.0.1b 根节点没有子节点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>//直接删除,树变成空树.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>           <span style=color:#66d9ef>return</span> 
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>//3.1a. 找兄弟节点借
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        Borrow{
</span></span><span style=display:flex><span>        	<span style=color:#75715e>//3.1a.1a找左兄弟节点借
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span>(borrow(left_){
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> 
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#75715e>//3.1a.1b左兄弟不能借，就找右兄弟节点借
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span>(borrow(right_){
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> 
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>//3.1b.借失败了，就准备合并
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>union</span>{
</span></span><span style=display:flex><span>            <span style=color:#75715e>//3.1b.1a 左兄弟结点存在,就找左兄弟节点合并
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span>(have(left) <span style=color:#f92672>&amp;&amp;</span> <span style=color:#66d9ef>union</span><span style=color:#960050;background-color:#1e0010>(</span><span style=color:#a6e22e>left_</span>){
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> 
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#75715e>//3.1b.1b 没有左兄弟节点, 找右兄弟节点合并.(除根节点外肯定至少有一个兄弟节点)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span>(<span style=color:#66d9ef>union</span><span style=color:#960050;background-color:#1e0010>(</span><span style=color:#a6e22e>right_</span>){
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> 
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>borrow(bro_page){
</span></span><span style=display:flex><span>    <span style=color:#75715e>//如果兄弟节点的 size &lt;= 下限,不能借
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span>(bro_page size <span style=color:#f92672>&lt;=</span> <span style=color:#960050;background-color:#1e0010>下限</span>){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> ;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>//否则可以借
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>//是叶子结点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//直接拿 对应兄弟结点最靠近的元素
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>//是内部结点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>//加入的元素 = 中间父亲结点对应的元素
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//中间父亲结点对应的元素 = 兄弟结点最靠近的元素.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//兄弟结点最靠近的元素删除
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>               
</span></span><span style=display:flex><span><span style=color:#66d9ef>union</span><span style=color:#960050;background-color:#1e0010>(</span><span style=color:#a6e22e>bro_page</span>){
</span></span><span style=display:flex><span>    <span style=color:#75715e>//是叶子结点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//两个结点合并成一个结点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>//是内部结点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//好像都是直接把右合并到左就可以.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>//删除父亲结点中间的元素.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//如果父亲结点size 小于等于 下限
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//父亲结点采取下溢操作
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://ysyyhhh.github.io/tags/cmu-15445/>Cmu-15445</a></li></ul><nav class=paginav><a class=prev href=https://ysyyhhh.github.io/posts/paper/llm/nobert/><span class=title>« 上一页</span><br><span>NoRBERT：使用迁移学习改进需求分类任务</span>
</a><a class=next href=https://ysyyhhh.github.io/posts/tool/sql/redis/><span class=title>下一页 »</span><br><span>redis</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share P0 [C++ Primer](https://15445.courses.cs.cmu.edu/fall2022/project0/) on x" href="https://x.com/intent/tweet/?text=P0%20%5bC%2b%2b%20Primer%5d%28https%3a%2f%2f15445.courses.cs.cmu.edu%2ffall2022%2fproject0%2f%29&amp;url=https%3a%2f%2fysyyhhh.github.io%2fposts%2fpublic-course%2fcmu-15445%2fcmu15-445%2f&amp;hashtags=cmu-15445"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share P0 [C++ Primer](https://15445.courses.cs.cmu.edu/fall2022/project0/) on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fysyyhhh.github.io%2fposts%2fpublic-course%2fcmu-15445%2fcmu15-445%2f&amp;title=P0%20%5bC%2b%2b%20Primer%5d%28https%3a%2f%2f15445.courses.cs.cmu.edu%2ffall2022%2fproject0%2f%29&amp;summary=P0%20%5bC%2b%2b%20Primer%5d%28https%3a%2f%2f15445.courses.cs.cmu.edu%2ffall2022%2fproject0%2f%29&amp;source=https%3a%2f%2fysyyhhh.github.io%2fposts%2fpublic-course%2fcmu-15445%2fcmu15-445%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share P0 [C++ Primer](https://15445.courses.cs.cmu.edu/fall2022/project0/) on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fysyyhhh.github.io%2fposts%2fpublic-course%2fcmu-15445%2fcmu15-445%2f&title=P0%20%5bC%2b%2b%20Primer%5d%28https%3a%2f%2f15445.courses.cs.cmu.edu%2ffall2022%2fproject0%2f%29"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share P0 [C++ Primer](https://15445.courses.cs.cmu.edu/fall2022/project0/) on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fysyyhhh.github.io%2fposts%2fpublic-course%2fcmu-15445%2fcmu15-445%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share P0 [C++ Primer](https://15445.courses.cs.cmu.edu/fall2022/project0/) on whatsapp" href="https://api.whatsapp.com/send?text=P0%20%5bC%2b%2b%20Primer%5d%28https%3a%2f%2f15445.courses.cs.cmu.edu%2ffall2022%2fproject0%2f%29%20-%20https%3a%2f%2fysyyhhh.github.io%2fposts%2fpublic-course%2fcmu-15445%2fcmu15-445%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share P0 [C++ Primer](https://15445.courses.cs.cmu.edu/fall2022/project0/) on telegram" href="https://telegram.me/share/url?text=P0%20%5bC%2b%2b%20Primer%5d%28https%3a%2f%2f15445.courses.cs.cmu.edu%2ffall2022%2fproject0%2f%29&amp;url=https%3a%2f%2fysyyhhh.github.io%2fposts%2fpublic-course%2fcmu-15445%2fcmu15-445%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share P0 [C++ Primer](https://15445.courses.cs.cmu.edu/fall2022/project0/) on ycombinator" href="https://news.ycombinator.com/submitlink?t=P0%20%5bC%2b%2b%20Primer%5d%28https%3a%2f%2f15445.courses.cs.cmu.edu%2ffall2022%2fproject0%2f%29&u=https%3a%2f%2fysyyhhh.github.io%2fposts%2fpublic-course%2fcmu-15445%2fcmu15-445%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://ysyyhhh.github.io/>ysyy's blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>