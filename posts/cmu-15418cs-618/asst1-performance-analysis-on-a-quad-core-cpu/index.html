<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>asst1 | ysyy's blog</title>
<meta name=keywords content="cmu-15418&amp;cs-618"><meta name=description content="参考 任务 Program 1: Parallel Fractal Generation Using Threads (20 points) 提示: 需要先看CMU15-418/CS149的L2再完成Pro1 任务描述: 用多线程画mandelbrot fractal. 代码中给"><meta name=author content="Ysyy"><link rel=canonical href=/posts/cmu-15418cs-618/asst1-performance-analysis-on-a-quad-core-cpu/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.js onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=img/Q.gif><link rel=icon type=image/png sizes=16x16 href=img/Q.gif><link rel=icon type=image/png sizes=32x32 href=img/Q.gif><link rel=apple-touch-icon href=img/Q.gif><link rel=mask-icon href=img/Q.gif><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="asst1"><meta property="og:description" content="参考 任务 Program 1: Parallel Fractal Generation Using Threads (20 points) 提示: 需要先看CMU15-418/CS149的L2再完成Pro1 任务描述: 用多线程画mandelbrot fractal. 代码中给"><meta property="og:type" content="article"><meta property="og:url" content="/posts/cmu-15418cs-618/asst1-performance-analysis-on-a-quad-core-cpu/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-11-05T00:00:00+00:00"><meta property="article:modified_time" content="2024-01-05T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="asst1"><meta name=twitter:description content="参考 任务 Program 1: Parallel Fractal Generation Using Threads (20 points) 提示: 需要先看CMU15-418/CS149的L2再完成Pro1 任务描述: 用多线程画mandelbrot fractal. 代码中给"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"/posts/"},{"@type":"ListItem","position":3,"name":"asst1","item":"/posts/cmu-15418cs-618/asst1-performance-analysis-on-a-quad-core-cpu/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"asst1","name":"asst1","description":"参考 任务 Program 1: Parallel Fractal Generation Using Threads (20 points) 提示: 需要先看CMU15-418/CS149的L2再完成Pro1 任务描述: 用多线程画mandelbrot fractal. 代码中给","keywords":["cmu-15418\u0026cs-618"],"articleBody":"参考\n任务\nProgram 1: Parallel Fractal Generation Using Threads (20 points) 提示: 需要先看CMU15-418/CS149的L2再完成Pro1\n任务描述: 用多线程画mandelbrot fractal.\n代码中给出了串行的实现, 你需要实现多线程的版本.\n多线程版本中只需要修改 workerThreadStart函数. 不需要手动创建线程, 也不需要手动join线程. 直接调用mandelbrotThread().\n1.1 \u0026 1.2, 计算在2,3,4,5,6,7,8,16,32个线程下的加速比 编写并观察 workerThreadStart函数的实现:\n345void workerThreadStart(WorkerArgs *const args) { // TODO FOR CS149 STUDENTS: Implement the body of the worker // thread here. Each thread should make a call to mandelbrotSerial() // to compute a part of the output image. For example, in a // program that uses two threads, thread 0 could compute the top // half of the image and thread 1 could compute the bottom half. // printf(\"Hello world from thread %d\\n\", args-\u003ethreadId); double startTime = CycleTimer::currentSeconds(); // 每个线程负责的行数(除不尽的部分由最后一个线程负责) int height = args-\u003eheight / args-\u003enumThreads; int startRow = args-\u003ethreadId * height; int numRows = height; if (args-\u003ethreadId == args-\u003enumThreads - 1) { // 如果是最后一个线程，那么就要把除不尽的部分也算上 numRows = height + args-\u003eheight % args-\u003enumThreads; } printf(\"Thread %d startRow: %d, numRows: %d\\n\", args-\u003ethreadId, startRow, numRows); mandelbrotSerial(args-\u003ex0, args-\u003ey0, args-\u003ex1, args-\u003ey1, args-\u003ewidth, args-\u003eheight, startRow, numRows, args-\u003emaxIterations, args-\u003eoutput); double endTime = CycleTimer::currentSeconds(); printf(\"Thread %d time: %.3f ms\\n\", args-\u003ethreadId, (endTime - startTime) * 1000); } 结果:\n线程数 加速比 2 1.97 3 1.63 4 2.31 5 2.37 6 3.08 7 3.15 8 3.74 16 5.14 可以观察到，加速比和线程数并不是线性相关.\n猜测原因 猜测可能的原因有:\n线程通信的开销 每个线程分配的任务不均匀 1.3 查看每个线程的执行时间,验证猜想 当线程数为4时, 每个线程的执行时间如下: Thread 0 time: 63.974 ms Thread 3 time: 65.563 ms Thread 2 time: 259.972 ms Thread 1 time: 260.669 ms\n当线程数为8时, 每个线程的执行时间如下: Thread 0 time: 13.702 ms Thread 7 time: 16.831 ms Thread 1 time: 57.324 ms Thread 6 time: 61.069 ms Thread 5 time: 113.431 ms Thread 2 time: 115.753 ms Thread 4 time: 164.736 ms Thread 3 time: 166.306 ms\n可以看到,中间线程分配的任务更多,执行时间更长. 因此在增加线程数时,加速比并不是线性增加的.\n1.4 任务描述:\n解决上面的问题,使得加速比更接近线性. 如: 8线程时的加速比需要在7~8之间. 解决方法需要具有适用性, 适用所有的线程数. tips: 有一个非常简单的静态赋值可以实现这个目标，并且线程之间不需要通信/同步.\n解决方案 思路: 根据代码可知, 每行的计算是独立的, 因此可以将每行分配给不同的线程. 但由上面的实验可知,中间行的计算量比较大.\n因此我们不应该直接平均切分行, 而是以线程数量为步长,线程交叉依次分配行. 即 第i个线程分配k*n+i行.\nvoid workerThreadStart(WorkerArgs *const args) { // TODO FOR CS149 STUDENTS: Implement the body of the worker // thread here. Each thread should make a call to mandelbrotSerial() // to compute a part of the output image. For example, in a // program that uses two threads, thread 0 could compute the top // half of the image and thread 1 could compute the bottom half. // printf(\"Hello world from thread %d\\n\", args-\u003ethreadId); double startTime = CycleTimer::currentSeconds(); /* 方案1 // 每个线程负责的行数(除不尽的部分由最后一个线程负责) int baseHeight = args-\u003eheight / args-\u003enumThreads; int startRow = args-\u003ethreadId * baseHeight; int numRows = baseHeight; int yu = args-\u003eheight % args-\u003enumThreads; // 均匀分配剩余行 if (args-\u003ethreadId \u003c yu) { numRows++; } startRow += std::min(args-\u003ethreadId, yu); printf(\"Thread %d startRow: %d, numRows: %d\\n\", args-\u003ethreadId, startRow, numRows); mandelbrotSerial(args-\u003ex0, args-\u003ey0, args-\u003ex1, args-\u003ey1, args-\u003ewidth, args-\u003eheight, startRow, numRows, args-\u003emaxIterations, args-\u003eoutput); */ // 方案2, 依次分配行 int height = args-\u003eheight; for (int i = args-\u003ethreadId; i \u003c height; i += args-\u003enumThreads) { mandelbrotSerial(args-\u003ex0, args-\u003ey0, args-\u003ex1, args-\u003ey1, args-\u003ewidth, args-\u003eheight, i, 1, args-\u003emaxIterations, args-\u003eoutput); } double endTime = CycleTimer::currentSeconds(); printf(\"Thread %d time: %.3f ms\\n\", args-\u003ethreadId, (endTime - startTime) * 1000); } 输出结果:\nThread 3 time: 88.842 ms Thread 1 time: 89.680 ms Thread 0 time: 89.717 ms Thread 7 time: 90.280 ms Thread 5 time: 90.715 ms Thread 6 time: 90.743 ms Thread 2 time: 91.049 ms Thread 4 time: 92.982 ms [mandelbrot thread]: [93.318] ms Wrote image file mandelbrot-thread.ppm (7.10x speedup from 8 threads)\n上面的解决方案使得每个线程的执行时间基本相同,因此加速比接近线性. 在8线程时,加速比为7.1.\n1.5 16线程和8线程的加速比 现在16线程是否明显优于8线程? 给出是或否的原因. (6.45x speedup from 16 threads) 16线程并没有明显由于8线程,反而还更慢. 原因:\n电脑本身是4核, 超线程后是8线程. 16线程时线程切换反而导致开销增加. 总结 pro1的目的是为了认识到并行计算的overhead, 以及多线程在计算上也应该是依次交替分配的. 不能简单的平均分配.\npro1是通过垂直分割来实现并行计算. 而向量化是通过水平分割来实现并行计算.\nprogram-2-vectorizing-code-using-simd-intrinsics 前提: L2 任务描述： 使用SIMD指令(CS149intrin.h提供的),来实现clampedExpVector函数.\n示例函数:\nvoid absVector(float* values, float* output, int N) { __cs149_vec_float x; __cs149_vec_float result; __cs149_vec_float zero = _cs149_vset_float(0.f); __cs149_mask maskAll, maskIsNegative, maskIsNotNegative; // Note: Take a careful look at this loop indexing. This example // code is not guaranteed to work when (N % VECTOR_WIDTH) != 0. // Why is that the case? for (int i=0; i\u003cN; i+=VECTOR_WIDTH) { // All ones maskAll = _cs149_init_ones(); // All zeros maskIsNegative = _cs149_init_ones(0); // Load vector of values from contiguous memory addresses _cs149_vload_float(x, values+i, maskAll); // x = values[i]; // Set mask according to predicate _cs149_vlt_float(maskIsNegative, x, zero, maskAll); // if (x \u003c 0) { // Execute instruction using mask (\"if\" clause) _cs149_vsub_float(result, zero, x, maskIsNegative); // output[i] = -x; // Inverse maskIsNegative to generate \"else\" mask maskIsNotNegative = _cs149_mask_not(maskIsNegative); // } else { // Execute instruction (\"else\" clause) _cs149_vload_float(result, values+i, maskIsNotNegative); // output[i] = x; } // Write results back to memory _cs149_vstore_float(output+i, result, maskAll); } } 示例函数absVector并不能适用于所有情况,原因如下: 当n%VECTOR_WIDTH != 0时, 会越界.\n1\u00262 实现clampedExpVector函数 void clampedExpVector(float *values, int *exponents, float *output, int N) { // // CS149 STUDENTS TODO: Implement your vectorized version of // clampedExpSerial() here. // // Your solution should work for any value of // N and VECTOR_WIDTH, not just when VECTOR_WIDTH divides N // __cs149_vec_float one, nine; __cs149_vec_int zeroInt, oneInt; oneInt = _cs149_vset_int(1); zeroInt = _cs149_vset_int(0); one = _cs149_vset_float(1.f); nine = _cs149_vset_float(9.999999f); for (int i = 0; i \u003c N; i += VECTOR_WIDTH) { __cs149_mask maskAll, maskIsZero, maskIsNotZero; __cs149_vec_float x; __cs149_vec_int y; // All ones maskAll = _cs149_init_ones(); // All zeros maskIsZero = _cs149_init_ones(0); // 防止在最后一次循环时，i+VECTOR_WIDTH超出N if (i + VECTOR_WIDTH \u003e N) { maskAll = _cs149_init_ones(N - i); } // float x = values[i]; _cs149_vload_float(x, values + i, maskAll); // int y = exponents[i]; _cs149_vload_int(y, exponents + i, maskAll); // if (y == 0) _cs149_veq_int(maskIsZero, y, zeroInt, maskAll); // { // output[i] = 1.f; // } _cs149_vstore_float(output + i, one, maskIsZero); // else maskIsNotZero = _cs149_mask_not(maskIsZero); // 消除最后一次循环时，i+VECTOR_WIDTH超出N的情况 maskIsNotZero = _cs149_mask_and(maskIsNotZero, maskAll); { // float result = x; __cs149_vec_float result = x; // int count = y - 1; __cs149_vec_int count; _cs149_vsub_int(count, y, oneInt, maskIsNotZero); // 哪些count\u003e0 __cs149_mask countMark; _cs149_vgt_int(countMark, count, zeroInt, maskIsNotZero); // while (count \u003e 0) while (_cs149_cntbits(countMark) \u003e 0) { // result *= x; _cs149_vmult_float(result, result, x, countMark); // count--; _cs149_vsub_int(count, count, oneInt, countMark); // 哪些count\u003e0 _cs149_vgt_int(countMark, count, zeroInt, countMark); } // if (result \u003e 9.999999f) __cs149_mask gtNineMask; _cs149_vgt_float(gtNineMask, result, nine, maskIsNotZero); // { reult = 9.999999f;} _cs149_vmove_float(result, nine, gtNineMask); // output[i] = result; _cs149_vstore_float(output + i, result, maskIsNotZero); } } } 通过init_ones来防止在有n%vectorWith!=0时 越界.\n在最开始的maskAll时设置 在取反码后也要设置一次 count循环: 通过设置一个mask来标记哪些count\u003e0, 从而实现循环.\n修改vectorWidth为2, 4, 8, to 16来回答: Does the vector utilization increase, decrease or stay the same as VECTOR_WIDTH changes? Why?\nvectorWidth为2时, 结果如下: ****************** Printing Vector Unit Statistics ******************* Vector Width: 2 Total Vector Instructions: 162728 Vector Utilization: 77.0% Utilized Vector Lanes: 250653 Total Vector Lanes: 325456\nvectorWidth为4时, 结果如下: ****************** Printing Vector Unit Statistics ******************* Vector Width: 3 Total Vector Instructions: 119440 Vector Utilization: 72.2% Utilized Vector Lanes: 258879 Total Vector Lanes: 358320\nvectorWidth为8时, 结果如下: ****************** Printing Vector Unit Statistics ******************* Vector Width: 8 Total Vector Instructions: 51628 Vector Utilization: 66.0% Utilized Vector Lanes: 272539 Total Vector Lanes: 413024\nvectorWidth为16时, 结果如下: ****************** Printing Vector Unit Statistics ******************* Vector Width: 16 Total Vector Instructions: 26968 Vector Utilization: 64.2% Utilized Vector Lanes: 277188 Total Vector Lanes: 431488\n可以发现, 随着vectorWidth的增加, vectorUtilization也在减少.\n原因: 有多个条件语句,当vectorWidth增加时, 每次在某个条件中不执行的指令也会增加.\n3 实现arraySumVector float arraySumVector(float *values, int N) { // // CS149 STUDENTS TODO: Implement your vectorized version of arraySumSerial here // __cs149_vec_float sum = _cs149_vset_float(0.f); for (int i = 0; i \u003c N; i += VECTOR_WIDTH) { __cs149_mask maskAll; __cs149_vec_float x; // All ones maskAll = _cs149_init_ones(); // 防止在最后一次循环时，i+VECTOR_WIDTH超出N if (i + VECTOR_WIDTH \u003e N) { maskAll = _cs149_init_ones(N - i); } // float x = values[i]; _cs149_vload_float(x, values + i, maskAll); // sum += x; _cs149_vadd_float(sum, sum, x, maskAll); } float result = 0.f; // log2(VECTOR_WIDTH)内解决 for (int i = 0; i \u003c log2(VECTOR_WIDTH); i++) { // 使用_cs149_hadd_float函数，将sum中的每两个元素相加 // 再使用_cs149_interleave_float函数，将sum中的每两个元素交叉放置 // 重复log2(VECTOR_WIDTH)次 _cs149_hadd_float(sum, sum); _cs149_interleave_float(sum, sum); } // 将sum中的第一个元素赋值给result result = sum.value[0]; return result; } 假设VECTOR_WIDTHs始终是N的因子.\n可以实现在O(N/VECTOR_WIDTH + log2(VECTOR_WIDTH))的时间内完成计算.\n最后的log2实现方式. 提示中给了两个函数 hadd: 将每两个元素相加 interleave: 将每两个元素交叉放置\n因此我们可以类似与归并排序的方式,将sum中的每两个元素相加,再将每两个元素交叉放置. 重复log2(VECTOR_WIDTH)次后,第一个元素就是结果.\nprogram-3 ISPC 前提: L3\npart1 ISPC basic 任务:学习ISPC基本概念和编写.\nISPC是一种编译器,可以将C代码编译为SIMD指令.\npart2 ISPC task 任务描述: 观察ISPCtask执行的结果\n1 启动mandelbrot_ispc –tasks\n结果: [mandelbrot serial]: [424.881] ms Wrote image file mandelbrot-serial.ppm [mandelbrot ispc]: [97.180] ms Wrote image file mandelbrot-ispc.ppm [mandelbrot multicore ispc]: [48.986] ms Wrote image file mandelbrot-task-ispc.ppm (4.37x speedup from ISPC) (8.67x speedup from task ISPC)\n因为设置了两个task所以大约是两倍的加速比 对于 ISPC\n2 修改mandelbrot_ispc_withtasks()中的task数量, you should be able to achieve performance that exceeds the sequential version of the code by over 32 times! How did you determine how many tasks to create? Why does the number you chose work best?\n根据机器的最大超线程数量设置 我设置了16个task, 因为我的机器是4核8线程, 16个task可以使得每个线程都有两个task.\n3 what happens when you launch 10,000 ISPC tasks? What happens when you launch 10,000 threads?\n向量加速\n思考题: Q: Why are there two different mechanisms (foreach and launch) for expressing independent, parallelizable work to the ISPC system? A:foreach是将一个任务分配给多个线程,而launch是将多个任务分配给多个线程.\nQ: Couldn’t the system just partition the many iterations of foreach across all cores and also emit the appropriate SIMD code for the cores? A:\nprogram-4 Iterative sqrt (15 points) 用sqrt复习ISPC的基本概念\n1 运行结果: [sqrt serial]: [1316.793] ms [sqrt ispc]: [301.134] ms [sqrt task ispc]: [52.439] ms (4.37x speedup from ISPC) (25.11x speedup from task ISPC) 4.37x speedup due to SIMD 25.11 / 4.37 = 5.74x speedup due to multi-core\n2 构造数组使得加速比最大.\n全部数为2.998. 思路: 因为每个元素相同可以让计算更均匀,2.998可以充分调动cpu 结构: (5.60x speedup from ISPC) (30.39x speedup from task ISPC)\n3 构造数组使得加速比最小.\n全部数为1 思路: 1的sqrt计算迭代最少.\n结果: (2.50x speedup from ISPC) (3.08x speedup from task ISPC)\nprogram-5 BLAS saxpy (10 points) 1 运行观察加速比 [saxpy ispc]: [25.098] ms [11.874] GB/s [1.594] GFLOPS [saxpy task ispc]: [18.438] ms [16.164] GB/s [2.169] GFLOPS (1.36x speedup from use of tasks)\n因为需要访问内存所以加速比不高.\n2 Even though saxpy loads one element from X, one element from Y, and writes one element to result the multiplier by 4 is correct. Why is this the case? (Hint, think about how CPU caches work.)\n当程序写入结果的一个元素时，它首先将包含这个元素的缓存行提取到缓存中。这需要一个内存操作。然后，当不需要这个缓存行时，它将从缓存中闪现出来，这需要另一个内存操作。\n","wordCount":"3674","inLanguage":"zh","datePublished":"2023-11-05T00:00:00Z","dateModified":"2024-01-05T00:00:00Z","author":[{"@type":"Person","name":"Ysyy"}],"mainEntityOfPage":{"@type":"WebPage","@id":"/posts/cmu-15418cs-618/asst1-performance-analysis-on-a-quad-core-cpu/"},"publisher":{"@type":"Organization","name":"ysyy's blog","logo":{"@type":"ImageObject","url":"img/Q.gif"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href accesskey=h title="Ysyy's Blog (Alt + H)"><img src=img/Q.gif alt aria-label=logo height=35>Ysyy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=search title="🔍 搜索 (Alt + /)" accesskey=/><span>🔍 搜索</span></a></li><li><a href=/ title="🏠 主页"><span>🏠 主页</span></a></li><li><a href=posts title="📚 文章"><span>📚 文章</span></a></li><li><a href=tags title="🧩 标签"><span>🧩 标签</span></a></li><li><a href=archives/ title="⏱️ 时间轴"><span>⏱️ 时间轴</span></a></li><li><a href=about title="🙋🏻‍♂️ 关于"><span>🙋🏻‍♂️ 关于</span></a></li><li><a href=links title="🤝 友链"><span>🤝 友链</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href>主页</a>&nbsp;»&nbsp;<a href=/posts/>Posts</a></div><h1 class=post-title>asst1</h1><div class=post-meta>&lt;span title='2023-11-05 00:00:00 +0000 UTC'>2023-11-05&lt;/span>&amp;nbsp;·&amp;nbsp;8 分钟&amp;nbsp;·&amp;nbsp;Ysyy</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#program-1-parallel-fractal-generation-using-threads-20-pointshttpsgithubcomstanford-cs149asst1program-1-parallel-fractal-generation-using-threads-20-points aria-label="Program 1: Parallel Fractal Generation Using Threads (20 points)"><a href=https://github.com/stanford-cs149/asst1#program-1-parallel-fractal-generation-using-threads-20-points>Program 1: Parallel Fractal Generation Using Threads (20 points)</a></a><ul><li><a href=#11--12-%e8%ae%a1%e7%ae%97%e5%9c%a823456781632%e4%b8%aa%e7%ba%bf%e7%a8%8b%e4%b8%8b%e7%9a%84%e5%8a%a0%e9%80%9f%e6%af%94 aria-label="1.1 &amp;amp; 1.2, 计算在2,3,4,5,6,7,8,16,32个线程下的加速比">1.1 & 1.2, 计算在2,3,4,5,6,7,8,16,32个线程下的加速比</a><ul><li><a href=#%e7%bc%96%e5%86%99%e5%b9%b6%e8%a7%82%e5%af%9f aria-label=编写并观察>编写并观察</a></li><li><a href=#%e7%8c%9c%e6%b5%8b%e5%8e%9f%e5%9b%a0 aria-label=猜测原因>猜测原因</a></li></ul></li><li><a href=#13-%e6%9f%a5%e7%9c%8b%e6%af%8f%e4%b8%aa%e7%ba%bf%e7%a8%8b%e7%9a%84%e6%89%a7%e8%a1%8c%e6%97%b6%e9%97%b4%e9%aa%8c%e8%af%81%e7%8c%9c%e6%83%b3 aria-label="1.3 查看每个线程的执行时间,验证猜想">1.3 查看每个线程的执行时间,验证猜想</a></li><li><a href=#14 aria-label=1.4>1.4</a><ul><li><a href=#%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88 aria-label=解决方案>解决方案</a></li></ul></li><li><a href=#15-16%e7%ba%bf%e7%a8%8b%e5%92%8c8%e7%ba%bf%e7%a8%8b%e7%9a%84%e5%8a%a0%e9%80%9f%e6%af%94 aria-label="1.5 16线程和8线程的加速比">1.5 16线程和8线程的加速比</a></li><li><a href=#%e6%80%bb%e7%bb%93 aria-label=总结>总结</a></li></ul></li><li><a href=#program-2-vectorizing-code-using-simd-intrinsics aria-label=program-2-vectorizing-code-using-simd-intrinsics>program-2-vectorizing-code-using-simd-intrinsics</a><ul><li><a href=#12-%e5%ae%9e%e7%8e%b0clampedexpvector%e5%87%bd%e6%95%b0 aria-label="1&amp;amp;2 实现clampedExpVector函数">1&amp;2 实现clampedExpVector函数</a></li><li><a href=#3-%e5%ae%9e%e7%8e%b0arraysumvector aria-label="3 实现arraySumVector">3 实现arraySumVector</a></li></ul></li><li><a href=#program-3-ispc aria-label="program-3 ISPC">program-3 ISPC</a><ul><li><a href=#part1-ispc-basic aria-label="part1 ISPC basic">part1 ISPC basic</a></li><li><a href=#part2-ispc-task aria-label="part2 ISPC task">part2 ISPC task</a><ul><li><a href=#1 aria-label=1>1</a></li><li><a href=#2 aria-label=2>2</a></li><li><a href=#3 aria-label=3>3</a></li></ul></li></ul></li><li><a href=#program-4-iterative-sqrt-15-points aria-label="program-4 Iterative sqrt (15 points)">program-4 Iterative sqrt (15 points)</a><ul><li><a href=#1-1 aria-label=1>1</a></li><li><a href=#2-1 aria-label=2>2</a></li><li><a href=#3-1 aria-label=3>3</a></li></ul></li><li><a href=#program-5-blas-saxpy-10-points aria-label="program-5 BLAS saxpy (10 points)">program-5 BLAS saxpy (10 points)</a><ul><li><a href=#1-2 aria-label=1>1</a></li><li><a href=#2-2 aria-label=2>2</a></li></ul></li></ul></div></details></div><div class=post-content><p><a href=https://www.cnblogs.com/kalicener/p/16824312.html>参考</a></p><p><a href=https://github.com/stanford-cs149/asst1>任务</a></p><h2 id=program-1-parallel-fractal-generation-using-threads-20-pointshttpsgithubcomstanford-cs149asst1program-1-parallel-fractal-generation-using-threads-20-points><a href=https://github.com/stanford-cs149/asst1#program-1-parallel-fractal-generation-using-threads-20-points>Program 1: Parallel Fractal Generation Using Threads (20 points)</a><a hidden class=anchor aria-hidden=true href=#program-1-parallel-fractal-generation-using-threads-20-pointshttpsgithubcomstanford-cs149asst1program-1-parallel-fractal-generation-using-threads-20-points>#</a></h2><p>提示:
需要先看CMU15-418/CS149的L2再完成Pro1</p><p>任务描述:
用多线程画mandelbrot fractal.</p><p>代码中给出了串行的实现, 你需要实现多线程的版本.</p><p>多线程版本中只需要修改 <code>workerThreadStart</code>函数.
不需要手动创建线程, 也不需要手动join线程.
直接调用mandelbrotThread().</p><h3 id=11--12-计算在23456781632个线程下的加速比>1.1 & 1.2, 计算在2,3,4,5,6,7,8,16,32个线程下的加速比<a hidden class=anchor aria-hidden=true href=#11--12-计算在23456781632个线程下的加速比>#</a></h3><h4 id=编写并观察>编写并观察<a hidden class=anchor aria-hidden=true href=#编写并观察>#</a></h4><p>workerThreadStart函数的实现:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#ae81ff>345</span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>workerThreadStart</span>(WorkerArgs <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> args)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// TODO FOR CS149 STUDENTS: Implement the body of the worker
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// thread here. Each thread should make a call to mandelbrotSerial()
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// to compute a part of the output image.  For example, in a
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// program that uses two threads, thread 0 could compute the top
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// half of the image and thread 1 could compute the bottom half.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// printf(&#34;Hello world from thread %d\n&#34;, args-&gt;threadId);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>double</span> startTime <span style=color:#f92672>=</span> CycleTimer<span style=color:#f92672>::</span>currentSeconds();
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 每个线程负责的行数(除不尽的部分由最后一个线程负责)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> height <span style=color:#f92672>=</span> args<span style=color:#f92672>-&gt;</span>height <span style=color:#f92672>/</span> args<span style=color:#f92672>-&gt;</span>numThreads;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> startRow <span style=color:#f92672>=</span> args<span style=color:#f92672>-&gt;</span>threadId <span style=color:#f92672>*</span> height;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> numRows <span style=color:#f92672>=</span> height;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (args<span style=color:#f92672>-&gt;</span>threadId <span style=color:#f92672>==</span> args<span style=color:#f92672>-&gt;</span>numThreads <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 如果是最后一个线程，那么就要把除不尽的部分也算上
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        numRows <span style=color:#f92672>=</span> height <span style=color:#f92672>+</span> args<span style=color:#f92672>-&gt;</span>height <span style=color:#f92672>%</span> args<span style=color:#f92672>-&gt;</span>numThreads;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;Thread %d startRow: %d, numRows: %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, args<span style=color:#f92672>-&gt;</span>threadId, startRow, numRows);
</span></span><span style=display:flex><span>    mandelbrotSerial(args<span style=color:#f92672>-&gt;</span>x0, args<span style=color:#f92672>-&gt;</span>y0, args<span style=color:#f92672>-&gt;</span>x1, args<span style=color:#f92672>-&gt;</span>y1,
</span></span><span style=display:flex><span>                     args<span style=color:#f92672>-&gt;</span>width, args<span style=color:#f92672>-&gt;</span>height,
</span></span><span style=display:flex><span>                     startRow, numRows,
</span></span><span style=display:flex><span>                     args<span style=color:#f92672>-&gt;</span>maxIterations, args<span style=color:#f92672>-&gt;</span>output);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> endTime <span style=color:#f92672>=</span> CycleTimer<span style=color:#f92672>::</span>currentSeconds();
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;Thread %d time: %.3f ms</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, args<span style=color:#f92672>-&gt;</span>threadId, (endTime <span style=color:#f92672>-</span> startTime) <span style=color:#f92672>*</span> <span style=color:#ae81ff>1000</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>结果:</p><table><thead><tr><th>线程数</th><th>加速比</th></tr></thead><tbody><tr><td>2</td><td>1.97</td></tr><tr><td>3</td><td>1.63</td></tr><tr><td>4</td><td>2.31</td></tr><tr><td>5</td><td>2.37</td></tr><tr><td>6</td><td>3.08</td></tr><tr><td>7</td><td>3.15</td></tr><tr><td>8</td><td>3.74</td></tr><tr><td>16</td><td>5.14</td></tr></tbody></table><p>可以观察到，加速比和线程数并不是线性相关.</p><h4 id=猜测原因>猜测原因<a hidden class=anchor aria-hidden=true href=#猜测原因>#</a></h4><p>猜测可能的原因有:</p><ul><li>线程通信的开销</li><li>每个线程分配的任务不均匀</li></ul><h3 id=13-查看每个线程的执行时间验证猜想>1.3 查看每个线程的执行时间,验证猜想<a hidden class=anchor aria-hidden=true href=#13-查看每个线程的执行时间验证猜想>#</a></h3><p>当线程数为4时, 每个线程的执行时间如下:
Thread 0 time: 63.974 ms
Thread 3 time: 65.563 ms
Thread 2 time: 259.972 ms
Thread 1 time: 260.669 ms</p><p>当线程数为8时, 每个线程的执行时间如下:
Thread 0 time: 13.702 ms
Thread 7 time: 16.831 ms
Thread 1 time: 57.324 ms
Thread 6 time: 61.069 ms
Thread 5 time: 113.431 ms
Thread 2 time: 115.753 ms
Thread 4 time: 164.736 ms
Thread 3 time: 166.306 ms</p><p>可以看到,中间线程分配的任务更多,执行时间更长.
因此在增加线程数时,加速比并不是线性增加的.</p><h3 id=14>1.4<a hidden class=anchor aria-hidden=true href=#14>#</a></h3><p>任务描述:</p><ul><li>解决上面的问题,使得加速比更接近线性.<ul><li>如: 8线程时的加速比需要在7~8之间.</li></ul></li><li>解决方法需要具有适用性, 适用所有的线程数.</li></ul><p>tips:
有一个非常简单的静态赋值可以实现这个目标，并且线程之间不需要通信/同步.</p><h4 id=解决方案>解决方案<a hidden class=anchor aria-hidden=true href=#解决方案>#</a></h4><p>思路:
根据代码可知, 每行的计算是独立的, 因此可以将每行分配给不同的线程.
但由上面的实验可知,中间行的计算量比较大.</p><p>因此我们不应该直接平均切分行, 而是以线程数量为步长,线程交叉依次分配行.
即 第i个线程分配k*n+i行.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>workerThreadStart</span>(WorkerArgs <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> args)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// TODO FOR CS149 STUDENTS: Implement the body of the worker
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// thread here. Each thread should make a call to mandelbrotSerial()
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// to compute a part of the output image.  For example, in a
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// program that uses two threads, thread 0 could compute the top
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// half of the image and thread 1 could compute the bottom half.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// printf(&#34;Hello world from thread %d\n&#34;, args-&gt;threadId);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>double</span> startTime <span style=color:#f92672>=</span> CycleTimer<span style=color:#f92672>::</span>currentSeconds();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>    方案1
</span></span></span><span style=display:flex><span><span style=color:#75715e>    // 每个线程负责的行数(除不尽的部分由最后一个线程负责)
</span></span></span><span style=display:flex><span><span style=color:#75715e>    int baseHeight = args-&gt;height / args-&gt;numThreads;
</span></span></span><span style=display:flex><span><span style=color:#75715e>    int startRow = args-&gt;threadId * baseHeight;
</span></span></span><span style=display:flex><span><span style=color:#75715e>    int numRows = baseHeight;
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>    int yu = args-&gt;height % args-&gt;numThreads;
</span></span></span><span style=display:flex><span><span style=color:#75715e>    // 均匀分配剩余行
</span></span></span><span style=display:flex><span><span style=color:#75715e>    if (args-&gt;threadId &lt; yu)
</span></span></span><span style=display:flex><span><span style=color:#75715e>    {
</span></span></span><span style=display:flex><span><span style=color:#75715e>        numRows++;
</span></span></span><span style=display:flex><span><span style=color:#75715e>    }
</span></span></span><span style=display:flex><span><span style=color:#75715e>    startRow += std::min(args-&gt;threadId, yu);
</span></span></span><span style=display:flex><span><span style=color:#75715e>    printf(&#34;Thread %d startRow: %d, numRows: %d\n&#34;, args-&gt;threadId, startRow, numRows);
</span></span></span><span style=display:flex><span><span style=color:#75715e>    mandelbrotSerial(args-&gt;x0, args-&gt;y0, args-&gt;x1, args-&gt;y1,
</span></span></span><span style=display:flex><span><span style=color:#75715e>                     args-&gt;width, args-&gt;height,
</span></span></span><span style=display:flex><span><span style=color:#75715e>                     startRow, numRows,
</span></span></span><span style=display:flex><span><span style=color:#75715e>                     args-&gt;maxIterations, args-&gt;output);
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>    */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 方案2, 依次分配行
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> height <span style=color:#f92672>=</span> args<span style=color:#f92672>-&gt;</span>height;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> args<span style=color:#f92672>-&gt;</span>threadId; i <span style=color:#f92672>&lt;</span> height; i <span style=color:#f92672>+=</span> args<span style=color:#f92672>-&gt;</span>numThreads)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        mandelbrotSerial(args<span style=color:#f92672>-&gt;</span>x0, args<span style=color:#f92672>-&gt;</span>y0, args<span style=color:#f92672>-&gt;</span>x1, args<span style=color:#f92672>-&gt;</span>y1,
</span></span><span style=display:flex><span>                         args<span style=color:#f92672>-&gt;</span>width, args<span style=color:#f92672>-&gt;</span>height,
</span></span><span style=display:flex><span>                         i, <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>                         args<span style=color:#f92672>-&gt;</span>maxIterations, args<span style=color:#f92672>-&gt;</span>output);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> endTime <span style=color:#f92672>=</span> CycleTimer<span style=color:#f92672>::</span>currentSeconds();
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;Thread %d time: %.3f ms</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, args<span style=color:#f92672>-&gt;</span>threadId, (endTime <span style=color:#f92672>-</span> startTime) <span style=color:#f92672>*</span> <span style=color:#ae81ff>1000</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>输出结果:</p><p>Thread 3 time: 88.842 ms
Thread 1 time: 89.680 ms
Thread 0 time: 89.717 ms
Thread 7 time: 90.280 ms
Thread 5 time: 90.715 ms
Thread 6 time: 90.743 ms
Thread 2 time: 91.049 ms
Thread 4 time: 92.982 ms
[mandelbrot thread]: [93.318] ms
Wrote image file mandelbrot-thread.ppm
(7.10x speedup from 8 threads)</p><p>上面的解决方案使得每个线程的执行时间基本相同,因此加速比接近线性.
在8线程时,加速比为7.1.</p><h3 id=15-16线程和8线程的加速比>1.5 16线程和8线程的加速比<a hidden class=anchor aria-hidden=true href=#15-16线程和8线程的加速比>#</a></h3><p>现在16线程是否明显优于8线程? 给出是或否的原因.
(6.45x speedup from 16 threads)
16线程并没有明显由于8线程,反而还更慢.
原因:</p><ul><li>电脑本身是4核, 超线程后是8线程.</li><li>16线程时线程切换反而导致开销增加.</li></ul><h3 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h3><p>pro1的目的是为了认识到并行计算的overhead, 以及多线程在计算上也应该是依次交替分配的. 不能简单的平均分配.</p><p>pro1是通过垂直分割来实现并行计算.
而向量化是通过水平分割来实现并行计算.</p><h2 id=program-2-vectorizing-code-using-simd-intrinsics>program-2-vectorizing-code-using-simd-intrinsics<a hidden class=anchor aria-hidden=true href=#program-2-vectorizing-code-using-simd-intrinsics>#</a></h2><p>前提: L2
任务描述：
使用SIMD指令(CS149intrin.h提供的),来实现clampedExpVector函数.</p><p>示例函数:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>absVector</span>(<span style=color:#66d9ef>float</span><span style=color:#f92672>*</span> values, <span style=color:#66d9ef>float</span><span style=color:#f92672>*</span> output, <span style=color:#66d9ef>int</span> N) {
</span></span><span style=display:flex><span>  __cs149_vec_float x;
</span></span><span style=display:flex><span>  __cs149_vec_float result;
</span></span><span style=display:flex><span>  __cs149_vec_float zero <span style=color:#f92672>=</span> _cs149_vset_float(<span style=color:#ae81ff>0.f</span>);
</span></span><span style=display:flex><span>  __cs149_mask maskAll, maskIsNegative, maskIsNotNegative;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//  Note: Take a careful look at this loop indexing.  This example
</span></span></span><span style=display:flex><span><span style=color:#75715e>//  code is not guaranteed to work when (N % VECTOR_WIDTH) != 0.
</span></span></span><span style=display:flex><span><span style=color:#75715e>//  Why is that the case?
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; i<span style=color:#f92672>&lt;</span>N; i<span style=color:#f92672>+=</span>VECTOR_WIDTH) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// All ones
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    maskAll <span style=color:#f92672>=</span> _cs149_init_ones();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// All zeros
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    maskIsNegative <span style=color:#f92672>=</span> _cs149_init_ones(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Load vector of values from contiguous memory addresses
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    _cs149_vload_float(x, values<span style=color:#f92672>+</span>i, maskAll);               <span style=color:#75715e>// x = values[i];
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Set mask according to predicate
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    _cs149_vlt_float(maskIsNegative, x, zero, maskAll);     <span style=color:#75715e>// if (x &lt; 0) {
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Execute instruction using mask (&#34;if&#34; clause)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    _cs149_vsub_float(result, zero, x, maskIsNegative);      <span style=color:#75715e>//   output[i] = -x;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Inverse maskIsNegative to generate &#34;else&#34; mask
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    maskIsNotNegative <span style=color:#f92672>=</span> _cs149_mask_not(maskIsNegative);     <span style=color:#75715e>// } else {
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Execute instruction (&#34;else&#34; clause)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    _cs149_vload_float(result, values<span style=color:#f92672>+</span>i, maskIsNotNegative); <span style=color:#75715e>//   output[i] = x; }
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Write results back to memory
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    _cs149_vstore_float(output<span style=color:#f92672>+</span>i, result, maskAll);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>示例函数absVector并不能适用于所有情况,原因如下:
当n%VECTOR_WIDTH != 0时, 会越界.</p><h3 id=12-实现clampedexpvector函数>1&amp;2 实现clampedExpVector函数<a hidden class=anchor aria-hidden=true href=#12-实现clampedexpvector函数>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>clampedExpVector</span>(<span style=color:#66d9ef>float</span> <span style=color:#f92672>*</span>values, <span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>exponents, <span style=color:#66d9ef>float</span> <span style=color:#f92672>*</span>output, <span style=color:#66d9ef>int</span> N)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// CS149 STUDENTS TODO: Implement your vectorized version of
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// clampedExpSerial() here.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// Your solution should work for any value of
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// N and VECTOR_WIDTH, not just when VECTOR_WIDTH divides N
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  __cs149_vec_float one, nine;
</span></span><span style=display:flex><span>  __cs149_vec_int zeroInt, oneInt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  oneInt <span style=color:#f92672>=</span> _cs149_vset_int(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>  zeroInt <span style=color:#f92672>=</span> _cs149_vset_int(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>  one <span style=color:#f92672>=</span> _cs149_vset_float(<span style=color:#ae81ff>1.f</span>);
</span></span><span style=display:flex><span>  nine <span style=color:#f92672>=</span> _cs149_vset_float(<span style=color:#ae81ff>9.999999f</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> N; i <span style=color:#f92672>+=</span> VECTOR_WIDTH)
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    __cs149_mask maskAll, maskIsZero, maskIsNotZero;
</span></span><span style=display:flex><span>    __cs149_vec_float x;
</span></span><span style=display:flex><span>    __cs149_vec_int y;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// All ones
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    maskAll <span style=color:#f92672>=</span> _cs149_init_ones();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// All zeros
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    maskIsZero <span style=color:#f92672>=</span> _cs149_init_ones(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 防止在最后一次循环时，i+VECTOR_WIDTH超出N
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>+</span> VECTOR_WIDTH <span style=color:#f92672>&gt;</span> N)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      maskAll <span style=color:#f92672>=</span> _cs149_init_ones(N <span style=color:#f92672>-</span> i);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// float x = values[i];
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    _cs149_vload_float(x, values <span style=color:#f92672>+</span> i, maskAll);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// int y = exponents[i];
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    _cs149_vload_int(y, exponents <span style=color:#f92672>+</span> i, maskAll);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// if (y == 0)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    _cs149_veq_int(maskIsZero, y, zeroInt, maskAll);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// {
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//   output[i] = 1.f;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// }
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    _cs149_vstore_float(output <span style=color:#f92672>+</span> i, one, maskIsZero);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// else
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    maskIsNotZero <span style=color:#f92672>=</span> _cs149_mask_not(maskIsZero);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 消除最后一次循环时，i+VECTOR_WIDTH超出N的情况
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    maskIsNotZero <span style=color:#f92672>=</span> _cs149_mask_and(maskIsNotZero, maskAll);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// float result = x;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      __cs149_vec_float result <span style=color:#f92672>=</span> x;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// int count = y - 1;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      __cs149_vec_int count;
</span></span><span style=display:flex><span>      _cs149_vsub_int(count, y, oneInt, maskIsNotZero);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 哪些count&gt;0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      __cs149_mask countMark;
</span></span><span style=display:flex><span>      _cs149_vgt_int(countMark, count, zeroInt, maskIsNotZero);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// while (count &gt; 0)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>while</span> (_cs149_cntbits(countMark) <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>      {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// result *= x;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        _cs149_vmult_float(result, result, x, countMark);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// count--;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        _cs149_vsub_int(count, count, oneInt, countMark);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 哪些count&gt;0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        _cs149_vgt_int(countMark, count, zeroInt, countMark);
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// if (result &gt; 9.999999f)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      __cs149_mask gtNineMask;
</span></span><span style=display:flex><span>      _cs149_vgt_float(gtNineMask, result, nine, maskIsNotZero);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// { reult = 9.999999f;}
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      _cs149_vmove_float(result, nine, gtNineMask);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// output[i] = result;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>      _cs149_vstore_float(output <span style=color:#f92672>+</span> i, result, maskIsNotZero);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>通过init_ones来防止在有n%vectorWith!=0时 越界.</p><ul><li>在最开始的maskAll时设置</li><li>在取反码后也要设置一次</li></ul><p>count循环:
通过设置一个mask来标记哪些count>0, 从而实现循环.</p><p>修改vectorWidth为2, 4, 8, to 16来回答:
Does the vector utilization increase, decrease or stay the same as VECTOR_WIDTH changes? Why?</p><p>vectorWidth为2时, 结果如下:
****************** Printing Vector Unit Statistics *******************
Vector Width: 2
Total Vector Instructions: 162728
Vector Utilization: 77.0%
Utilized Vector Lanes: 250653
Total Vector Lanes: 325456</p><p>vectorWidth为4时, 结果如下:
****************** Printing Vector Unit Statistics *******************
Vector Width: 3
Total Vector Instructions: 119440
Vector Utilization: 72.2%
Utilized Vector Lanes: 258879
Total Vector Lanes: 358320</p><p>vectorWidth为8时, 结果如下:
****************** Printing Vector Unit Statistics *******************
Vector Width: 8
Total Vector Instructions: 51628
Vector Utilization: 66.0%
Utilized Vector Lanes: 272539
Total Vector Lanes: 413024</p><p>vectorWidth为16时, 结果如下:
****************** Printing Vector Unit Statistics *******************
Vector Width: 16
Total Vector Instructions: 26968
Vector Utilization: 64.2%
Utilized Vector Lanes: 277188
Total Vector Lanes: 431488</p><p>可以发现, 随着vectorWidth的增加, vectorUtilization也在减少.</p><p>原因:
有多个条件语句,当vectorWidth增加时, 每次在某个条件中不执行的指令也会增加.</p><h3 id=3-实现arraysumvector>3 实现arraySumVector<a hidden class=anchor aria-hidden=true href=#3-实现arraysumvector>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>float</span> <span style=color:#a6e22e>arraySumVector</span>(<span style=color:#66d9ef>float</span> <span style=color:#f92672>*</span>values, <span style=color:#66d9ef>int</span> N)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// CS149 STUDENTS TODO: Implement your vectorized version of arraySumSerial here
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>  __cs149_vec_float sum <span style=color:#f92672>=</span> _cs149_vset_float(<span style=color:#ae81ff>0.f</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> N; i <span style=color:#f92672>+=</span> VECTOR_WIDTH)
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    __cs149_mask maskAll;
</span></span><span style=display:flex><span>    __cs149_vec_float x;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// All ones
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    maskAll <span style=color:#f92672>=</span> _cs149_init_ones();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 防止在最后一次循环时，i+VECTOR_WIDTH超出N
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>+</span> VECTOR_WIDTH <span style=color:#f92672>&gt;</span> N)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      maskAll <span style=color:#f92672>=</span> _cs149_init_ones(N <span style=color:#f92672>-</span> i);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// float x = values[i];
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    _cs149_vload_float(x, values <span style=color:#f92672>+</span> i, maskAll);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// sum += x;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    _cs149_vadd_float(sum, sum, x, maskAll);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>float</span> result <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.f</span>;
</span></span><span style=display:flex><span>  <span style=color:#75715e>// log2(VECTOR_WIDTH)内解决
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> log2(VECTOR_WIDTH); i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 使用_cs149_hadd_float函数，将sum中的每两个元素相加
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 再使用_cs149_interleave_float函数，将sum中的每两个元素交叉放置
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 重复log2(VECTOR_WIDTH)次
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    _cs149_hadd_float(sum, sum);
</span></span><span style=display:flex><span>    _cs149_interleave_float(sum, sum);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 将sum中的第一个元素赋值给result
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  result <span style=color:#f92672>=</span> sum.value[<span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> result;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>假设VECTOR_WIDTHs始终是N的因子.</p><p>可以实现在O(N/VECTOR_WIDTH + log2(VECTOR_WIDTH))的时间内完成计算.</p><p>最后的log2实现方式.
提示中给了两个函数
hadd: 将每两个元素相加
interleave: 将每两个元素交叉放置</p><p>因此我们可以类似与归并排序的方式,将sum中的每两个元素相加,再将每两个元素交叉放置.
重复log2(VECTOR_WIDTH)次后,第一个元素就是结果.</p><h2 id=program-3-ispc>program-3 ISPC<a hidden class=anchor aria-hidden=true href=#program-3-ispc>#</a></h2><p>前提: L3</p><h3 id=part1-ispc-basic>part1 ISPC basic<a hidden class=anchor aria-hidden=true href=#part1-ispc-basic>#</a></h3><p>任务:学习ISPC基本概念和编写.</p><p>ISPC是一种编译器,可以将C代码编译为SIMD指令.</p><h3 id=part2-ispc-task>part2 ISPC task<a hidden class=anchor aria-hidden=true href=#part2-ispc-task>#</a></h3><p>任务描述:
观察ISPCtask执行的结果</p><h4 id=1>1<a hidden class=anchor aria-hidden=true href=#1>#</a></h4><p>启动mandelbrot_ispc &ndash;tasks</p><p>结果:
[mandelbrot serial]: [424.881] ms
Wrote image file mandelbrot-serial.ppm
[mandelbrot ispc]: [97.180] ms
Wrote image file mandelbrot-ispc.ppm
[mandelbrot multicore ispc]: [48.986] ms
Wrote image file mandelbrot-task-ispc.ppm
(4.37x speedup from ISPC)
(8.67x speedup from task ISPC)</p><p>因为设置了两个task所以大约是两倍的加速比 对于 ISPC</p><h4 id=2>2<a hidden class=anchor aria-hidden=true href=#2>#</a></h4><p>修改mandelbrot_ispc_withtasks()中的task数量,
you should be able to achieve performance that exceeds the sequential version of the code by over 32 times!
How did you determine how many tasks to create?
Why does the number you chose work best?</p><p>根据机器的最大超线程数量设置
我设置了16个task, 因为我的机器是4核8线程, 16个task可以使得每个线程都有两个task.</p><h4 id=3>3<a hidden class=anchor aria-hidden=true href=#3>#</a></h4><p>what happens when you launch 10,000 ISPC tasks? What happens when you launch 10,000 threads?</p><p>向量加速</p><p>思考题:
Q: Why are there two different mechanisms (foreach and launch) for expressing independent, parallelizable work to the ISPC system?
A:foreach是将一个任务分配给多个线程,而launch是将多个任务分配给多个线程.</p><p>Q: Couldn&rsquo;t the system just partition the many iterations of foreach across all cores and also emit the appropriate SIMD code for the cores?
A:</p><h2 id=program-4-iterative-sqrt-15-points>program-4 Iterative sqrt (15 points)<a hidden class=anchor aria-hidden=true href=#program-4-iterative-sqrt-15-points>#</a></h2><p>用sqrt复习ISPC的基本概念</p><h3 id=1-1>1<a hidden class=anchor aria-hidden=true href=#1-1>#</a></h3><p>运行结果:
[sqrt serial]: [1316.793] ms
[sqrt ispc]: [301.134] ms
[sqrt task ispc]: [52.439] ms
(4.37x speedup from ISPC)
(25.11x speedup from task ISPC)
4.37x speedup due to SIMD
25.11 / 4.37 = 5.74x speedup due to multi-core</p><h3 id=2-1>2<a hidden class=anchor aria-hidden=true href=#2-1>#</a></h3><p>构造数组使得加速比最大.</p><p>全部数为2.998.
思路:
因为每个元素相同可以让计算更均匀,2.998可以充分调动cpu
结构:
(5.60x speedup from ISPC)
(30.39x speedup from task ISPC)</p><h3 id=3-1>3<a hidden class=anchor aria-hidden=true href=#3-1>#</a></h3><p>构造数组使得加速比最小.</p><p>全部数为1
思路:
1的sqrt计算迭代最少.</p><p>结果:
(2.50x speedup from ISPC)
(3.08x speedup from task ISPC)</p><h2 id=program-5-blas-saxpy-10-points>program-5 BLAS saxpy (10 points)<a hidden class=anchor aria-hidden=true href=#program-5-blas-saxpy-10-points>#</a></h2><h3 id=1-2>1<a hidden class=anchor aria-hidden=true href=#1-2>#</a></h3><p>运行观察加速比
[saxpy ispc]: [25.098] ms [11.874] GB/s [1.594] GFLOPS
[saxpy task ispc]: [18.438] ms [16.164] GB/s [2.169] GFLOPS
(1.36x speedup from use of tasks)</p><p>因为需要访问内存所以加速比不高.</p><h3 id=2-2>2<a hidden class=anchor aria-hidden=true href=#2-2>#</a></h3><p>Even though saxpy loads one element from X, one element from Y, and writes one element to result the multiplier by 4 is correct. Why is this the case? (Hint, think about how CPU caches work.)</p><p>当程序写入结果的一个元素时，它首先将包含这个元素的缓存行提取到缓存中。这需要一个内存操作。然后，当不需要这个缓存行时，它将从缓存中闪现出来，这需要另一个内存操作。</p></div><footer class=post-footer><ul class=post-tags><li><a href=/tags/cmu-15418cs-618/>cmu-15418&amp;cs-618</a></li></ul><nav class=paginav><a class=prev href=/posts/cmu-15418cs-618/l3/><span class=title>« 上一页</span><br><span>Abstraction vs implementation</span>
</a><a class=next href=/posts/cmu-15418cs-618/l2/><span class=title>下一页 »</span><br><span>L2</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share asst1 on twitter" href="https://twitter.com/intent/tweet/?text=asst1&amp;url=%2fposts%2fcmu-15418cs-618%2fasst1-performance-analysis-on-a-quad-core-cpu%2f&amp;hashtags=cmu-15418%26cs-618"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share asst1 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=%2fposts%2fcmu-15418cs-618%2fasst1-performance-analysis-on-a-quad-core-cpu%2f&amp;title=asst1&amp;summary=asst1&amp;source=%2fposts%2fcmu-15418cs-618%2fasst1-performance-analysis-on-a-quad-core-cpu%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share asst1 on reddit" href="https://reddit.com/submit?url=%2fposts%2fcmu-15418cs-618%2fasst1-performance-analysis-on-a-quad-core-cpu%2f&title=asst1"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share asst1 on facebook" href="https://facebook.com/sharer/sharer.php?u=%2fposts%2fcmu-15418cs-618%2fasst1-performance-analysis-on-a-quad-core-cpu%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share asst1 on whatsapp" href="https://api.whatsapp.com/send?text=asst1%20-%20%2fposts%2fcmu-15418cs-618%2fasst1-performance-analysis-on-a-quad-core-cpu%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share asst1 on telegram" href="https://telegram.me/share/url?text=asst1&amp;url=%2fposts%2fcmu-15418cs-618%2fasst1-performance-analysis-on-a-quad-core-cpu%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share asst1 on ycombinator" href="https://news.ycombinator.com/submitlink?t=asst1&u=%2fposts%2fcmu-15418cs-618%2fasst1-performance-analysis-on-a-quad-core-cpu%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2024 <a href>ysyy's blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>