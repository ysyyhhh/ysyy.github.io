<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>asst2 | ysyy's blog</title>
<meta name=keywords content="cmu-15418&amp;cs-618"><meta name=description content="C++ Sync thread的使用 #include <thread> #include <stdio.h> void my_func(int thread_id, int num_threads) { printf(&#34;Hello from spawned thread %d of %d\n&#34;, thread_id, num_threads); } int main(int argc, char** argv) { std::thread t0 = std::thread(my_func, 0, 2); std::thread t1 = std::thread(my_func, 1, 2); printf(&#34;The main thread is running concurrently with spawned threads.\n&#34;); t0.join(); t1.join(); printf(&#34;Spawned threads have terminated at this point.\n&#34;); return 0; }"><meta name=author content="Ysyy"><link rel=canonical href=/posts/cmu-15418cs-618/asst2/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.js onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=img/Q.gif><link rel=icon type=image/png sizes=16x16 href=img/Q.gif><link rel=icon type=image/png sizes=32x32 href=img/Q.gif><link rel=apple-touch-icon href=img/Q.gif><link rel=mask-icon href=img/Q.gif><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="asst2"><meta property="og:description" content="C++ Sync thread的使用 #include <thread> #include <stdio.h> void my_func(int thread_id, int num_threads) { printf(&#34;Hello from spawned thread %d of %d\n&#34;, thread_id, num_threads); } int main(int argc, char** argv) { std::thread t0 = std::thread(my_func, 0, 2); std::thread t1 = std::thread(my_func, 1, 2); printf(&#34;The main thread is running concurrently with spawned threads.\n&#34;); t0.join(); t1.join(); printf(&#34;Spawned threads have terminated at this point.\n&#34;); return 0; }"><meta property="og:type" content="article"><meta property="og:url" content="/posts/cmu-15418cs-618/asst2/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-12-18T00:00:00+00:00"><meta property="article:modified_time" content="2024-01-11T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="asst2"><meta name=twitter:description content="C++ Sync thread的使用 #include <thread> #include <stdio.h> void my_func(int thread_id, int num_threads) { printf(&#34;Hello from spawned thread %d of %d\n&#34;, thread_id, num_threads); } int main(int argc, char** argv) { std::thread t0 = std::thread(my_func, 0, 2); std::thread t1 = std::thread(my_func, 1, 2); printf(&#34;The main thread is running concurrently with spawned threads.\n&#34;); t0.join(); t1.join(); printf(&#34;Spawned threads have terminated at this point.\n&#34;); return 0; }"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"/posts/"},{"@type":"ListItem","position":3,"name":"asst2","item":"/posts/cmu-15418cs-618/asst2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"asst2","name":"asst2","description":"C++ Sync thread的使用 #include \u0026lt;thread\u0026gt; #include \u0026lt;stdio.h\u0026gt; void my_func(int thread_id, int num_threads) { printf(\u0026#34;Hello from spawned thread %d of %d\\n\u0026#34;, thread_id, num_threads); } int main(int argc, char** argv) { std::thread t0 = std::thread(my_func, 0, 2); std::thread t1 = std::thread(my_func, 1, 2); printf(\u0026#34;The main thread is running concurrently with spawned threads.\\n\u0026#34;); t0.join(); t1.join(); printf(\u0026#34;Spawned threads have terminated at this point.\\n\u0026#34;); return 0; }","keywords":["cmu-15418\u0026cs-618"],"articleBody":"C++ Sync thread的使用 #include #include void my_func(int thread_id, int num_threads) { printf(\"Hello from spawned thread %d of %d\\n\", thread_id, num_threads); } int main(int argc, char** argv) { std::thread t0 = std::thread(my_func, 0, 2); std::thread t1 = std::thread(my_func, 1, 2); printf(\"The main thread is running concurrently with spawned threads.\\n\"); t0.join(); t1.join(); printf(\"Spawned threads have terminated at this point.\\n\"); return 0; } mutex #include #include #include #include #include #include std::map\u003cstd::string, std::string\u003e g_pages; std::mutex g_pages_mutex; void save_page(const std::string\u0026 url) { // simulate a long page fetch std::this_thread::sleep_for(std::chrono::seconds(2)); std::string result = \"fake content\"; std::lock_guard\u003cstd::mutex\u003e guard(g_pages_mutex); g_pages[url] = result; } int main() { std::thread t1(save_page, \"http://foo\"); std::thread t2(save_page, \"http://bar\"); t1.join(); t2.join(); // safe to access g_pages without lock now, as the threads are joined for (const auto\u0026 pair : g_pages) std::cout \u003c\u003c pair.first \u003c\u003c \" =\u003e \" \u003c\u003c pair.second \u003c\u003c '\\n'; } Output\nhttp://bar =\u003e fake content http://foo =\u003e fake content condition_variable 线程调用 wait (lock)来指示它希望等待来自另一个线程的通知。\n注意，互斥对象(包装在 std: : only _ lock 中)被传递给 wait ()调用。当通知线程时，条件变量将获得锁。\n这意味着当调用 wait ()返回时，调用线程是锁的当前持有者。锁通常用于保护线程现在需要检查的共享变量，以确保它正在等待的条件为真。\n创建 N 个线程。N-1个线程等待来自线程0的通知，然后在接到通知后，自动递增一个受共享互斥锁保护的计数器。\n/* * Wrapper class around a counter, a condition variable, and a mutex. */ class ThreadState { public: std::condition_variable *condition_variable_; std::mutex *mutex_; int counter_; int num_waiting_threads_; ThreadState(int num_waiting_threads) { condition_variable_ = new std::condition_variable(); mutex_ = new std::mutex(); counter_ = 0; num_waiting_threads_ = num_waiting_threads; } ~ThreadState() { delete condition_variable_; delete mutex_; } }; void signal_fn(ThreadState *thread_state) { // Acquire mutex to make sure the shared counter is read in a // consistent state. thread_state-\u003emutex_-\u003elock(); while (thread_state-\u003ecounter_ \u003c thread_state-\u003enum_waiting_threads_) { thread_state-\u003emutex_-\u003eunlock(); // Release the mutex before calling `notify_all()` to make sure // waiting threads have a chance to make progress. thread_state-\u003econdition_variable_-\u003enotify_all(); // Re-acquire the mutex to read the shared counter again. thread_state-\u003emutex_-\u003elock(); } thread_state-\u003emutex_-\u003eunlock(); } void wait_fn(ThreadState *thread_state) { // A lock must be held in order to wait on a condition variable. // This lock is atomically released before the thread goes to sleep // when `wait()` is called. The lock is atomically re-acquired when // the thread is woken up using `notify_all()`. std::unique_lock\u003cstd::mutex\u003e lk(*thread_state-\u003emutex_); thread_state-\u003econdition_variable_-\u003ewait(lk); // Increment the shared counter with the lock re-acquired to inform the // signaling thread that this waiting thread has successfully been // woken up. thread_state-\u003ecounter_++; printf(\"Lock re-acquired after wait()...\\n\"); lk.unlock(); } /* * Signaling thread spins until each waiting thread increments a shared * counter after being woken up from the `wait()` method. */ void condition_variable_example() { int num_threads = 3; printf(\"==============================================================\\n\"); printf(\"Starting %d threads for signal-and-waiting...\\n\", num_threads); std::thread *threads = new std::thread[num_threads]; ThreadState *thread_state = new ThreadState(num_threads - 1); threads[0] = std::thread(signal_fn, thread_state); for (int i = 1; i \u003c num_threads; i++) { threads[i] = std::thread(wait_fn, thread_state); } for (int i = 0; i \u003c num_threads; i++) { threads[i].join(); } printf(\"==============================================================\\n\"); delete thread_state; delete[] threads; } part_a step 1 实现TaskSystemParallelSpawn void TaskSystemParallelSpawn::run(IRunnable *runnable, int num_total_tasks) { // // TODO: CS149 students will modify the implementation of this // method in Part A. The implementation provided below runs all // tasks sequentially on the calling thread. // std::atomic\u003cint\u003e taskId(0); int num_threads = this-\u003enum_threads; std::thread threads[num_threads]; // 交叉分配任务 for (int i = 0; i \u003c num_threads; i++) { threads[i] = std::thread([\u0026, i]() { int task_id = taskId.fetch_add(1); while (task_id \u003c num_total_tasks) { runnable-\u003erunTask(task_id, num_total_tasks); task_id = taskId.fetch_add(1); } }); } for (int i = 0; i \u003c num_threads; i++) { threads[i].join(); } // printf(\"done\\n\"); } Q:How will you assign tasks to your worker threads? Should you consider static or dynamic assignment of tasks to threads? A:交叉分配任务，动态分配任务\nQ:How will you ensure that all tasks are executed exactly once? A:使用原子变量taskId\nstep 2 实现 TaskSystemParallelThreadPoolSpinning step1 的overhead主要是创建线程的开销(尤其是计算量低的任务上)，因此使用线程池可以减少开销\n要求: 在TestSystem 创建时,或者在run时创建线程池\nQ1: 作为一个开始的实现，我们建议您将worker threads设计为连续循环，始终检查它们是否有更多的工作要执行。(进入 while 循环直到条件为真的线程通常称为“spinning”) 那么worker thread 如何确定有work要执行呢？\nTaskSystemParallelThreadPoolSpinning::TaskSystemParallelThreadPoolSpinning(int num_threads) : ITaskSystem(num_threads) { // // TODO: CS149 student implementations may decide to perform setup // operations (such as thread pool construction) here. // Implementations are free to add new class member variables // (requiring changes to tasksys.h). // exit_flag_ = false; for (int i = 0; i \u003c num_threads; i++) { threads.emplace_back(\u0026TaskSystemParallelThreadPoolSpinning::func, this); } } TaskSystemParallelThreadPoolSpinning::~TaskSystemParallelThreadPoolSpinning() { exit_flag_ = true; for (auto \u0026thread : threads) { thread.join(); } } void TaskSystemParallelThreadPoolSpinning::run(IRunnable *runnable, int num_total_tasks) { // // TODO: CS149 students will modify the implementation of this // method in Part A. The implementation provided below runs all // tasks sequentially on the calling thread. // // printf(\"run\\n\"); runnable_ = runnable; num_tasks_ = num_total_tasks; num_tasks_done_ = num_total_tasks; for (int i = 0; i \u003c num_total_tasks; i++) { tasks_mutex_.lock(); tasks_.push(i); tasks_mutex_.unlock(); } while (num_tasks_done_ \u003c num_total_tasks) { std::this_thread::yield(); }; // Q:为什么要使用yield // A:因为如果不使用yield，那么线程会一直占用CPU，导致其他线程无法运行 // Q:那我直接死循环呢 // A:死循环会导致CPU占用率100%，导致其他线程无法运行 } Q2:确保 run ()实现所需的同步行为是非常重要的。如何更改 run ()的实现以确定批量任务启动中的所有任务都已完成？ A:使用原子变量num_tasks_done_，每个任务完成时，num_tasks_done_加一，当num_tasks_done_等于num_total_tasks时，所有任务完成\nstep 3 实现 TaskSystemParallelThreadPoolSleeping Step2的缺点： 当线程“spin”等待某些操作时，它们会利用 CPU 核心的执行资源。\n例如，工作线程可能会循环等待新任务到达。 另一个例子是，主线程可能会循环等待辅助线程完成所有任务，这样它就可以从 run ()调用返回。 这可能会影响性能，因为即使这些线程没有做有用的工作，也会使用 CPU 资源来运行这些线程。\n在任务的这一部分中，我们希望您通过让线程处于休眠状态来提高任务系统的效率，直到它们所等待的条件得到满足。\n您的实现可以选择使用条件变量来实现此行为。条件变量是一个同步原语，它允许线程在等待条件存在时休眠(不占用 CPU 处理资源)。其他线程向等待唤醒的线程发出“信号”，以查看它们所等待的条件是否已经满足。例如，如果没有工作要做，您的工作线程可能会处于休眠状态(这样它们就不会从尝试执行有用工作的线程那里占用 CPU 资源)。另一个例子是，调用 run ()的主应用程序线程可能希望在等待批量任务启动中的所有任务由工作线程完成时休眠。(否则，一个旋转的主线程将从工作线程那里夺走 CPU 资源!)有关 C + + 中条件变量的更多信息，请参见我们的 C + + 同步教程。\n您在这部分作业中的实现可能需要考虑棘手的race conditions 。您需要考虑许多可能的线程行为交错\n您可能需要考虑编写额外的测试用例来测试您的系统。赋值入门代码包括评分脚本用于评分代码性能的工作负载，但是我们也将使用一组更广泛的工作负载来测试您的实现的正确性，而我们在入门代码中并没有提供这些工作负载！\nThe assignment starter code includes the workloads that the grading script will use to grade the performance of your code, but we will also test the correctness of your implementation using a wider set of workloads that we are not providing in the starter code!\ntasksys.h\n/* * TaskSystemParallelThreadPoolSleeping: This class is the student's * optimized implementation of a parallel task execution engine that uses * a thread pool. See definition of ITaskSystem in * itasksys.h for documentation of the ITaskSystem interface. */ class TaskSystemParallelThreadPoolSleeping : public ITaskSystem { public: TaskSystemParallelThreadPoolSleeping(int num_threads); ~TaskSystemParallelThreadPoolSleeping(); const char *name(); void run(IRunnable *runnable, int num_total_tasks); TaskID runAsyncWithDeps(IRunnable *runnable, int num_total_tasks, const std::vector\u003cTaskID\u003e \u0026deps); void sync(); private: std::vector\u003cstd::thread\u003e threads; int num_tasks_; bool exit_flag_; std::atomic\u003cint\u003e num_tasks_done_; std::queue\u003cint\u003e tasks_; std::mutex tasks_mutex_; IRunnable *runnable_{}; void func(); std::condition_variable *queue_condition_ = new std::condition_variable(); std::condition_variable *all_done_condition_ = new std::condition_variable(); int num_waiting_threads_; std::atomic\u003cint\u003e num_tasks_remaining_; std::mutex all_done_mutex_; }; tasksys.cpp\n/* * ================================================================ * Parallel Thread Pool Sleeping Task System Implementation * ================================================================ */ const char *TaskSystemParallelThreadPoolSleeping::name() { return \"Parallel + Thread Pool + Sleep\"; } void TaskSystemParallelThreadPoolSleeping::func() { int task_id; while (!exit_flag_) { task_id = -1; while (task_id == -1) { std::unique_lock\u003cstd::mutex\u003e lk(tasks_mutex_); // 等待任务 queue_condition_-\u003ewait(lk, [] { return 1; }); if (exit_flag_) { return; } if (!tasks_.empty()) { task_id = tasks_.front(); tasks_.pop(); } } runnable_-\u003erunTask(task_id, num_tasks_); num_tasks_remaining_--; if (!num_tasks_remaining_) { // 通知主线程 // printf(\"notify_all_done\\n\"); all_done_condition_-\u003enotify_one(); } else { // 通知其他线程 // printf(\"notify_all\\n\"); queue_condition_-\u003enotify_one(); } } } TaskSystemParallelThreadPoolSleeping::TaskSystemParallelThreadPoolSleeping(int num_threads) : ITaskSystem(num_threads) { // // TODO: CS149 student implementations may decide to perform setup // operations (such as thread pool construction) here. // Implementations are free to add new class member variables // (requiring changes to tasksys.h). // exit_flag_ = false; for (int i = 0; i \u003c num_threads; i++) { threads.emplace_back(\u0026TaskSystemParallelThreadPoolSleeping::func, this); } } TaskSystemParallelThreadPoolSleeping::~TaskSystemParallelThreadPoolSleeping() { // // TODO: CS149 student implementations may decide to perform cleanup // operations (such as thread pool shutdown construction) here. // Implementations are free to add new class member variables // (requiring changes to tasksys.h). // exit_flag_ = true; queue_condition_-\u003enotify_all(); for (auto \u0026thread : threads) { thread.join(); } } void TaskSystemParallelThreadPoolSleeping::run(IRunnable *runnable, int num_total_tasks) { // // TODO: CS149 students will modify the implementation of this // method in Parts A and B. The implementation provided below runs all // tasks sequentially on the calling thread. // runnable_ = runnable; num_tasks_ = num_total_tasks; num_tasks_remaining_ = num_total_tasks; tasks_mutex_.lock(); for (int i = 0; i \u003c num_total_tasks; i++) { tasks_.push(i); } tasks_mutex_.unlock(); // 通知其他线程 queue_condition_-\u003enotify_all(); // printf(\"run\\n\"); while (num_tasks_remaining_) { std::unique_lock\u003cstd::mutex\u003e lk2(all_done_mutex_); all_done_condition_-\u003ewait(lk2, [] { return 1; }); } // printf(\"all done\\n\"); // printf(\"all done\\n\"); } 结果分析:\nsleep对spin的提升效果不明显，可能是因为任务太少，线程切换的开销比较大.\n运行结果:\n================================================================================ Running task system grading harness... (11 total tests) - Detected CPU with 16 execution contexts - Task system configured to use at most 8 threads ================================================================================ ================================================================================ Executing test: super_super_light... Reference binary: ./runtasks_ref_linux Results for: super_super_light STUDENT REFERENCE PERF? [Serial] 5.281 5.788 0.91 (OK) [Parallel + Always Spawn] 95.221 92.995 1.02 (OK) [Parallel + Thread Pool + Spin] 10.877 10.446 1.04 (OK) [Parallel + Thread Pool + Sleep] 6.943 42.705 0.16 (OK) ================================================================================ Executing test: super_light... Reference binary: ./runtasks_ref_linux Results for: super_light STUDENT REFERENCE PERF? [Serial] 37.497 37.844 0.99 (OK) [Parallel + Always Spawn] 108.136 108.805 0.99 (OK) [Parallel + Thread Pool + Spin] 10.777 13.615 0.79 (OK) [Parallel + Thread Pool + Sleep] 10.274 44.686 0.23 (OK) ================================================================================ Executing test: ping_pong_equal... Reference binary: ./runtasks_ref_linux Results for: ping_pong_equal STUDENT REFERENCE PERF? [Serial] 603.419 606.739 0.99 (OK) [Parallel + Always Spawn] 167.412 178.638 0.94 (OK) [Parallel + Thread Pool + Spin] 105.983 123.525 0.86 (OK) [Parallel + Thread Pool + Sleep] 108.243 148.316 0.73 (OK) ================================================================================ Executing test: ping_pong_unequal... Reference binary: ./runtasks_ref_linux Results for: ping_pong_unequal STUDENT REFERENCE PERF? [Serial] 1126.19 1109.329 1.02 (OK) [Parallel + Always Spawn] 259.271 260.822 0.99 (OK) [Parallel + Thread Pool + Spin] 199.088 198.013 1.01 (OK) [Parallel + Thread Pool + Sleep] 198.777 214.293 0.93 (OK) ================================================================================ Executing test: recursive_fibonacci... Reference binary: ./runtasks_ref_linux Results for: recursive_fibonacci STUDENT REFERENCE PERF? [Serial] 1052.273 1128.069 0.93 (OK) [Parallel + Always Spawn] 156.014 172.113 0.91 (OK) [Parallel + Thread Pool + Spin] 156.31 171.337 0.91 (OK) [Parallel + Thread Pool + Sleep] 156.462 166.476 0.94 (OK) ================================================================================ Executing test: math_operations_in_tight_for_loop... Reference binary: ./runtasks_ref_linux Results for: math_operations_in_tight_for_loop STUDENT REFERENCE PERF? [Serial] 411.426 423.96 0.97 (OK) [Parallel + Always Spawn] 537.747 532.353 1.01 (OK) [Parallel + Thread Pool + Spin] 99.286 104.844 0.95 (OK) [Parallel + Thread Pool + Sleep] 95.817 239.76 0.40 (OK) ================================================================================ Executing test: math_operations_in_tight_for_loop_fewer_tasks... Reference binary: ./runtasks_ref_linux Results for: math_operations_in_tight_for_loop_fewer_tasks STUDENT REFERENCE PERF? [Serial] 413.681 415.961 0.99 (OK) [Parallel + Always Spawn] 514.021 505.234 1.02 (OK) [Parallel + Thread Pool + Spin] 108.644 117.702 0.92 (OK) [Parallel + Thread Pool + Sleep] 106.84 260.724 0.41 (OK) ================================================================================ Executing test: math_operations_in_tight_for_loop_fan_in... Reference binary: ./runtasks_ref_linux Results for: math_operations_in_tight_for_loop_fan_in STUDENT REFERENCE PERF? [Serial] 212.534 211.52 1.00 (OK) [Parallel + Always Spawn] 76.402 76.09 1.00 (OK) [Parallel + Thread Pool + Spin] 37.203 39.662 0.94 (OK) [Parallel + Thread Pool + Sleep] 36.523 57.039 0.64 (OK) ================================================================================ Executing test: math_operations_in_tight_for_loop_reduction_tree... Reference binary: ./runtasks_ref_linux Results for: math_operations_in_tight_for_loop_reduction_tree STUDENT REFERENCE PERF? [Serial] 208.076 207.488 1.00 (OK) [Parallel + Always Spawn] 45.054 45.227 1.00 (OK) [Parallel + Thread Pool + Spin] 33.079 33.9 0.98 (OK) [Parallel + Thread Pool + Sleep] 34.502 38.389 0.90 (OK) ================================================================================ Executing test: spin_between_run_calls... Reference binary: ./runtasks_ref_linux Results for: spin_between_run_calls STUDENT REFERENCE PERF? [Serial] 353.553 382.373 0.92 (OK) [Parallel + Always Spawn] 180.401 197.119 0.92 (OK) [Parallel + Thread Pool + Spin] 205.374 222.315 0.92 (OK) [Parallel + Thread Pool + Sleep] 214.819 197.579 1.09 (OK) ================================================================================ Executing test: mandelbrot_chunked... Reference binary: ./runtasks_ref_linux Results for: mandelbrot_chunked STUDENT REFERENCE PERF? [Serial] 257.289 256.815 1.00 (OK) [Parallel + Always Spawn] 34.395 34.058 1.01 (OK) [Parallel + Thread Pool + Spin] 34.241 34.922 0.98 (OK) [Parallel + Thread Pool + Sleep] 35.191 35.273 1.00 (OK) ================================================================================ Overall performance results [Serial] : All passed Perf [Parallel + Always Spawn] : All passed Perf [Parallel + Thread Pool + Spin] : All passed Perf [Parallel + Thread Pool + Sleep] : All passed Perf part_b 在任务的 B 部分中，您将扩展您的 A 部分任务系统实现，以支持可能依赖于以前任务的任务的异步启动。这些任务间依赖关系创建了任务执行库必须遵守的调度约束。\nITaskSystem 接口还有一个方法:\nvirtual TaskID runAsyncWithDeps(IRunnable* runnable, int num_total_tasks, const std::vector\u003cTaskID\u003e\u0026 deps) = 0; RunAsyncWithDeps ()类似于 run () ，因为它也用于执行 num total asks 任务的批量启动。但是，它与 run ()在许多方面有所不同…\nAsynchronous Task Launch 首先，使用 runAsyncWithDeps ()创建的任务由任务系统与调用线程异步执行。\n这意味着 runAsyncWithDeps ()应该立即返回给调用方，即使任务尚未完成执行。\n该方法返回与此批量任务启动关联的唯一标识符。\n调用线程可以通过调用 sync ()来确定大容量任务启动的实际完成时间。\nvirtual void sync() = 0;\n只有当与之前所有批量任务启动关联的任务完成时，sync ()才返回给调用方。例如，考虑以下代码:\n// assume taskA and taskB are valid instances of IRunnable... std::vector\u003cTaskID\u003e noDeps; // empty vector ITaskSystem *t = new TaskSystem(num_threads); // bulk launch of 4 tasks TaskID launchA = t-\u003erunAsyncWithDeps(taskA, 4, noDeps); // bulk launch of 8 tasks TaskID launchB = t-\u003erunAsyncWithDeps(taskB, 8, noDeps); // at this point tasks associated with launchA and launchB // may still be running t-\u003esync(); // at this point all 12 tasks associated with launchA and launchB // are guaranteed to have terminated 如上面的注释中所述，在线程调用sync() runAsyncWithDeps() ) 的任务已完成。 准确地说， runAsyncWithDeps()告诉您的任务系统执行新的批量任务启动，但您的实现可以灵活地在下次调用sync()之前随时执行这些任务。 请注意，此规范意味着无法保证您的实现在从 launchB 启动任务之前先执行 launchA 中的任务！\nSupport for Explicit Dependencies runAsyncWithDeps()的第二个关键细节是它的第三个参数：TaskID 标识符向量，必须引用之前使用runAsyncWithDeps()启动的批量任务。 该向量指定当前批量任务启动中的任务所依赖的先前任务。 因此，在依赖向量中给出的启动中的所有任务完成之前，您的任务运行时无法开始执行当前批量任务启动中的任何任务！ 例如，考虑以下示例：\nstd::vector\u003cTaskID\u003e noDeps; // empty vector std::vector\u003cTaskID\u003e depOnA; std::vector\u003cTaskID\u003e depOnBC; ITaskSystem *t = new TaskSystem(num_threads); TaskID launchA = t-\u003erunAsyncWithDeps(taskA, 128, noDeps); depOnA.push_back(launchA); TaskID launchB = t-\u003erunAsyncWithDeps(taskB, 2, depOnA); TaskID launchC = t-\u003erunAsyncWithDeps(taskC, 6, depOnA); depOnBC.push_back(launchB); depOnBC.push_back(launchC); TaskID launchD = t-\u003erunAsyncWithDeps(taskD, 32, depOnBC); t-\u003esync(); 上面的代码有四个批量任务启动（taskA：128 个任务，taskB：2 个任务，taskC：6 个任务，taskD：32 个任务）。 请注意，任务 B 和任务 C 的启动取决于任务 A。 taskD 的批量启动 ( launchD ) 取决于launchB和launchC的结果。 因此，虽然您的任务运行时可以按任意顺序（包括并行）处理与launchB和launchC关联的任务，但这些启动中的所有任务必须在launchA的任务完成后开始执行，并且它们必须在运行时开始之前完成从launchD执行任何任务。\n我们可以通过任务图直观地说明这些依赖关系。 任务图是有向无环图 (DAG)，其中图中的节点对应于批量任务启动，从节点 X 到节点 Y 的边表示 Y 对 X 输出的依赖关系。上述代码的任务图是： 请注意，如果您在具有八个执行上下文的 Myth 计算机上运行上面的示例，则并行调度launchB和launchC中的任务的能力可能非常有用，因为单独的批量任务启动都不足以使用所有执行机器的资源。\nTask 您必须从 A 部分扩展任务系统实现，才能正确实现TaskSystem::runAsyncWithDeps()和TaskSystem::sync() 。 与 A 部分一样，我们为您提供以下入门提示：\nIt may be helpful to think about the behavior of runAsyncWithDeps() as pushing a record corresponding to the bulk task launch, or perhaps records corresponding to each of the tasks in the bulk task launch onto a “work queue”. Once the record to work to do is in the queue, runAsyncWithDeps() can return to the caller. The trick in this part of the assignment is performing the appropriate bookkeeping to track dependencies. What must be done when all the tasks in a bulk task launch complete? (This is the point when new tasks may become available to run.) It can be helpful to have two data structures in your implementation: (1) a structure representing tasks that have been added to the system via a call to runAsyncWithDeps(), but are not yet ready to execute because they depend on tasks that are still running (these tasks are “waiting” for others to finish) and (2) a “ready queue” of tasks that are not waiting on any prior tasks to finish and can safely be run as soon as a worker thread is available to process them. You need not worry about integer wrap around when generating unique task launch ids. We will not hit your task system with over 2^31 bulk task launches. You can assume all programs will either call only run() or only runAsyncWithDeps(); that is, you do not need to handle the case where a run() call needs to wait for all proceeding calls to runAsyncWithDeps() to finish. 在part_b/子目录中实现B部分实现，以与正确的参考实现（ part_b/runtasks_ref_* ）进行比较。\n","wordCount":"4588","inLanguage":"zh","datePublished":"2023-12-18T00:00:00Z","dateModified":"2024-01-11T00:00:00Z","author":[{"@type":"Person","name":"Ysyy"}],"mainEntityOfPage":{"@type":"WebPage","@id":"/posts/cmu-15418cs-618/asst2/"},"publisher":{"@type":"Organization","name":"ysyy's blog","logo":{"@type":"ImageObject","url":"img/Q.gif"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href accesskey=h title="Ysyy's Blog (Alt + H)"><img src=img/Q.gif alt aria-label=logo height=35>Ysyy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=search title="🔍 搜索 (Alt + /)" accesskey=/><span>🔍 搜索</span></a></li><li><a href=/ title="🏠 主页"><span>🏠 主页</span></a></li><li><a href=posts title="📚 文章"><span>📚 文章</span></a></li><li><a href=tags title="🧩 标签"><span>🧩 标签</span></a></li><li><a href=archives/ title="⏱️ 时间轴"><span>⏱️ 时间轴</span></a></li><li><a href=about title="🙋🏻‍♂️ 关于"><span>🙋🏻‍♂️ 关于</span></a></li><li><a href=links title="🤝 友链"><span>🤝 友链</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href>主页</a>&nbsp;»&nbsp;<a href=/posts/>Posts</a></div><h1 class=post-title>asst2</h1><div class=post-meta>&lt;span title='2023-12-18 00:00:00 +0000 UTC'>2023-12-18&lt;/span>&amp;nbsp;·&amp;nbsp;10 分钟&amp;nbsp;·&amp;nbsp;Ysyy</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#c-sync aria-label="C++ Sync">C++ Sync</a><ul><li><a href=#thread%e7%9a%84%e4%bd%bf%e7%94%a8 aria-label=thread的使用>thread的使用</a></li><li><a href=#mutex aria-label=mutex>mutex</a></li><li><a href=#condition_variable aria-label=condition_variable>condition_variable</a></li></ul></li><li><a href=#part_a aria-label=part_a>part_a</a><ul><li><a href=#step-1-%e5%ae%9e%e7%8e%b0tasksystemparallelspawn aria-label="step 1 实现TaskSystemParallelSpawn">step 1 实现TaskSystemParallelSpawn</a></li><li><a href=#step-2-%e5%ae%9e%e7%8e%b0--tasksystemparallelthreadpoolspinning aria-label="step 2 实现  TaskSystemParallelThreadPoolSpinning">step 2 实现 TaskSystemParallelThreadPoolSpinning</a></li><li><a href=#step-3-%e5%ae%9e%e7%8e%b0-tasksystemparallelthreadpoolsleeping aria-label="step 3 实现 TaskSystemParallelThreadPoolSleeping">step 3 实现 TaskSystemParallelThreadPoolSleeping</a></li></ul></li><li><a href=#part_b aria-label=part_b>part_b</a><ul><li><a href=#asynchronous-task-launch aria-label="Asynchronous Task Launch">Asynchronous Task Launch</a></li><li><a href=#support-for-explicit-dependencies aria-label="Support for Explicit Dependencies">Support for Explicit Dependencies</a></li><li><a href=#task aria-label=Task>Task</a></li></ul></li></ul></div></details></div><div class=post-content><h2 id=c-sync>C++ Sync<a hidden class=anchor aria-hidden=true href=#c-sync>#</a></h2><h3 id=thread的使用>thread的使用<a hidden class=anchor aria-hidden=true href=#thread的使用>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;thread&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>my_func</span>(<span style=color:#66d9ef>int</span> thread_id, <span style=color:#66d9ef>int</span> num_threads) {
</span></span><span style=display:flex><span> printf(<span style=color:#e6db74>&#34;Hello from spawned thread %d of %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, thread_id, num_threads);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span><span style=color:#f92672>**</span> argv) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  std<span style=color:#f92672>::</span><span style=color:#66d9ef>thread</span> t0 <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span><span style=color:#66d9ef>thread</span>(my_func, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>  std<span style=color:#f92672>::</span><span style=color:#66d9ef>thread</span> t1 <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span><span style=color:#66d9ef>thread</span>(my_func, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  printf(<span style=color:#e6db74>&#34;The main thread is running concurrently with spawned threads.</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  t0.join();
</span></span><span style=display:flex><span>  t1.join();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  printf(<span style=color:#e6db74>&#34;Spawned threads have terminated at this point.</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=mutex>mutex<a hidden class=anchor aria-hidden=true href=#mutex>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;chrono&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;map&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;mutex&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;thread&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> 
</span></span><span style=display:flex><span>std<span style=color:#f92672>::</span>map<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>string, std<span style=color:#f92672>::</span>string<span style=color:#f92672>&gt;</span> g_pages;
</span></span><span style=display:flex><span>std<span style=color:#f92672>::</span>mutex g_pages_mutex;
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>save_page</span>(<span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>string<span style=color:#f92672>&amp;</span> url)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// simulate a long page fetch
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>this_thread<span style=color:#f92672>::</span>sleep_for(std<span style=color:#f92672>::</span>chrono<span style=color:#f92672>::</span>seconds(<span style=color:#ae81ff>2</span>));
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>string result <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;fake content&#34;</span>;
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>lock_guard<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>mutex<span style=color:#f92672>&gt;</span> guard(g_pages_mutex);
</span></span><span style=display:flex><span>    g_pages[url] <span style=color:#f92672>=</span> result;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() 
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span><span style=color:#66d9ef>thread</span> t1(save_page, <span style=color:#e6db74>&#34;http://foo&#34;</span>);
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span><span style=color:#66d9ef>thread</span> t2(save_page, <span style=color:#e6db74>&#34;http://bar&#34;</span>);
</span></span><span style=display:flex><span>    t1.join();
</span></span><span style=display:flex><span>    t2.join();
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>    <span style=color:#75715e>// safe to access g_pages without lock now, as the threads are joined
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> pair : g_pages)
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> pair.first <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; =&gt; &#34;</span> <span style=color:#f92672>&lt;&lt;</span> pair.second <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Output</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>http://bar <span style=color:#f92672>=</span>&gt; fake content
</span></span><span style=display:flex><span>http://foo <span style=color:#f92672>=</span>&gt; fake content
</span></span></code></pre></div><h3 id=condition_variable>condition_variable<a hidden class=anchor aria-hidden=true href=#condition_variable>#</a></h3><p>线程调用 wait (lock)来指示它希望等待来自另一个线程的通知。</p><p>注意，互斥对象(包装在 std: : only _ lock 中)被传递给 wait ()调用。当通知线程时，条件变量将获得锁。</p><p>这意味着当调用 wait ()返回时，调用线程是锁的当前持有者。锁通常用于保护线程现在需要检查的共享变量，以确保它正在等待的条件为真。</p><p>创建 N 个线程。N-1个线程等待来自线程0的通知，然后在接到通知后，自动递增一个受共享互斥锁保护的计数器。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Wrapper class around a counter, a condition variable, and a mutex.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ThreadState</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>condition_variable <span style=color:#f92672>*</span>condition_variable_;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>mutex <span style=color:#f92672>*</span>mutex_;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> counter_;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> num_waiting_threads_;
</span></span><span style=display:flex><span>    ThreadState(<span style=color:#66d9ef>int</span> num_waiting_threads)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        condition_variable_ <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> std<span style=color:#f92672>::</span>condition_variable();
</span></span><span style=display:flex><span>        mutex_ <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> std<span style=color:#f92672>::</span>mutex();
</span></span><span style=display:flex><span>        counter_ <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        num_waiting_threads_ <span style=color:#f92672>=</span> num_waiting_threads;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#f92672>~</span>ThreadState()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>delete</span> condition_variable_;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>delete</span> mutex_;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>signal_fn</span>(ThreadState <span style=color:#f92672>*</span>thread_state)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Acquire mutex to make sure the shared counter is read in a
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// consistent state.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    thread_state<span style=color:#f92672>-&gt;</span>mutex_<span style=color:#f92672>-&gt;</span>lock();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (thread_state<span style=color:#f92672>-&gt;</span>counter_ <span style=color:#f92672>&lt;</span> thread_state<span style=color:#f92672>-&gt;</span>num_waiting_threads_)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        thread_state<span style=color:#f92672>-&gt;</span>mutex_<span style=color:#f92672>-&gt;</span>unlock();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Release the mutex before calling `notify_all()` to make sure
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// waiting threads have a chance to make progress.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        thread_state<span style=color:#f92672>-&gt;</span>condition_variable_<span style=color:#f92672>-&gt;</span>notify_all();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Re-acquire the mutex to read the shared counter again.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        thread_state<span style=color:#f92672>-&gt;</span>mutex_<span style=color:#f92672>-&gt;</span>lock();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    thread_state<span style=color:#f92672>-&gt;</span>mutex_<span style=color:#f92672>-&gt;</span>unlock();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>wait_fn</span>(ThreadState <span style=color:#f92672>*</span>thread_state)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// A lock must be held in order to wait on a condition variable.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// This lock is atomically released before the thread goes to sleep
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// when `wait()` is called. The lock is atomically re-acquired when
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// the thread is woken up using `notify_all()`.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>unique_lock<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>mutex<span style=color:#f92672>&gt;</span> lk(<span style=color:#f92672>*</span>thread_state<span style=color:#f92672>-&gt;</span>mutex_);
</span></span><span style=display:flex><span>    thread_state<span style=color:#f92672>-&gt;</span>condition_variable_<span style=color:#f92672>-&gt;</span>wait(lk);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Increment the shared counter with the lock re-acquired to inform the
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// signaling thread that this waiting thread has successfully been
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// woken up.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    thread_state<span style=color:#f92672>-&gt;</span>counter_<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;Lock re-acquired after wait()...</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    lk.unlock();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Signaling thread spins until each waiting thread increments a shared
</span></span></span><span style=display:flex><span><span style=color:#75715e> * counter after being woken up from the `wait()` method.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>condition_variable_example</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> num_threads <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;==============================================================</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;Starting %d threads for signal-and-waiting...</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, num_threads);
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span><span style=color:#66d9ef>thread</span> <span style=color:#f92672>*</span>threads <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> std<span style=color:#f92672>::</span><span style=color:#66d9ef>thread</span>[num_threads];
</span></span><span style=display:flex><span>    ThreadState <span style=color:#f92672>*</span>thread_state <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ThreadState(num_threads <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    threads[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span><span style=color:#66d9ef>thread</span>(signal_fn, thread_state);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;</span> num_threads; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        threads[i] <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span><span style=color:#66d9ef>thread</span>(wait_fn, thread_state);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> num_threads; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        threads[i].join();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;==============================================================</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>delete</span> thread_state;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>delete</span>[] threads;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=part_a>part_a<a hidden class=anchor aria-hidden=true href=#part_a>#</a></h2><h3 id=step-1-实现tasksystemparallelspawn>step 1 实现TaskSystemParallelSpawn<a hidden class=anchor aria-hidden=true href=#step-1-实现tasksystemparallelspawn>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>void</span> TaskSystemParallelSpawn<span style=color:#f92672>::</span>run(IRunnable <span style=color:#f92672>*</span>runnable, <span style=color:#66d9ef>int</span> num_total_tasks)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// TODO: CS149 students will modify the implementation of this
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// method in Part A.  The implementation provided below runs all
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// tasks sequentially on the calling thread.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>atomic<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> taskId(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> num_threads <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>num_threads;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span><span style=color:#66d9ef>thread</span> threads[num_threads];
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 交叉分配任务
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> num_threads; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        threads[i] <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span><span style=color:#66d9ef>thread</span>([<span style=color:#f92672>&amp;</span>, i]()
</span></span><span style=display:flex><span>                                 {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>int</span> task_id <span style=color:#f92672>=</span> taskId.fetch_add(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>while</span> (task_id <span style=color:#f92672>&lt;</span> num_total_tasks)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    runnable<span style=color:#f92672>-&gt;</span>runTask(task_id, num_total_tasks);
</span></span><span style=display:flex><span>                    task_id <span style=color:#f92672>=</span> taskId.fetch_add(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>                } });
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> num_threads; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        threads[i].join();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// printf(&#34;done\n&#34;);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>Q:How will you assign tasks to your worker threads? Should you consider static or dynamic assignment of tasks to threads?
A:交叉分配任务，动态分配任务</p><p>Q:How will you ensure that all tasks are executed exactly once?
A:使用原子变量taskId</p><h3 id=step-2-实现--tasksystemparallelthreadpoolspinning>step 2 实现 TaskSystemParallelThreadPoolSpinning<a hidden class=anchor aria-hidden=true href=#step-2-实现--tasksystemparallelthreadpoolspinning>#</a></h3><p>step1 的overhead主要是创建线程的开销(尤其是计算量低的任务上)，因此使用线程池可以减少开销</p><p>要求: 在TestSystem 创建时,或者在run时创建线程池</p><p>Q1: 作为一个开始的实现，我们建议您将worker threads设计为连续循环，始终检查它们是否有更多的工作要执行。(进入 while 循环直到条件为真的线程通常称为“spinning”)
那么worker thread 如何确定有work要执行呢？</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>TaskSystemParallelThreadPoolSpinning<span style=color:#f92672>::</span>TaskSystemParallelThreadPoolSpinning(<span style=color:#66d9ef>int</span> num_threads) <span style=color:#f92672>:</span> ITaskSystem(num_threads)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// TODO: CS149 student implementations may decide to perform setup
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// operations (such as thread pool construction) here.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Implementations are free to add new class member variables
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// (requiring changes to tasksys.h).
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    exit_flag_ <span style=color:#f92672>=</span> false;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> num_threads; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        threads.emplace_back(<span style=color:#f92672>&amp;</span>TaskSystemParallelThreadPoolSpinning<span style=color:#f92672>::</span>func, <span style=color:#66d9ef>this</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>TaskSystemParallelThreadPoolSpinning<span style=color:#f92672>::~</span>TaskSystemParallelThreadPoolSpinning()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    exit_flag_ <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>thread</span> <span style=color:#f92672>:</span> threads)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>thread</span>.join();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> TaskSystemParallelThreadPoolSpinning<span style=color:#f92672>::</span>run(IRunnable <span style=color:#f92672>*</span>runnable, <span style=color:#66d9ef>int</span> num_total_tasks)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// TODO: CS149 students will modify the implementation of this
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// method in Part A.  The implementation provided below runs all
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// tasks sequentially on the calling thread.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// printf(&#34;run\n&#34;);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    runnable_ <span style=color:#f92672>=</span> runnable;
</span></span><span style=display:flex><span>    num_tasks_ <span style=color:#f92672>=</span> num_total_tasks;
</span></span><span style=display:flex><span>    num_tasks_done_ <span style=color:#f92672>=</span> num_total_tasks;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> num_total_tasks; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        tasks_mutex_.lock();
</span></span><span style=display:flex><span>        tasks_.push(i);
</span></span><span style=display:flex><span>        tasks_mutex_.unlock();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (num_tasks_done_ <span style=color:#f92672>&lt;</span> num_total_tasks)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>this_thread<span style=color:#f92672>::</span>yield();
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Q:为什么要使用yield
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// A:因为如果不使用yield，那么线程会一直占用CPU，导致其他线程无法运行
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Q:那我直接死循环呢
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// A:死循环会导致CPU占用率100%，导致其他线程无法运行
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>Q2:确保 run ()实现所需的同步行为是非常重要的。如何更改 run ()的实现以确定批量任务启动中的所有任务都已完成？
A:使用原子变量num_tasks_done_，每个任务完成时，num_tasks_done_加一，当num_tasks_done_等于num_total_tasks时，所有任务完成</p><h3 id=step-3-实现-tasksystemparallelthreadpoolsleeping>step 3 实现 TaskSystemParallelThreadPoolSleeping<a hidden class=anchor aria-hidden=true href=#step-3-实现-tasksystemparallelthreadpoolsleeping>#</a></h3><p>Step2的缺点：
当线程“spin”等待某些操作时，它们会利用 CPU 核心的执行资源。</p><ul><li>例如，工作线程可能会循环等待新任务到达。</li><li>另一个例子是，主线程可能会循环等待辅助线程完成所有任务，这样它就可以从 run ()调用返回。</li></ul><p>这可能会影响性能，因为即使这些线程没有做有用的工作，也会使用 CPU 资源来运行这些线程。</p><p>在任务的这一部分中，我们希望您通过让线程处于休眠状态来提高任务系统的效率，直到它们所等待的条件得到满足。</p><p>您的实现可以选择使用条件变量来实现此行为。条件变量是一个同步原语，它允许线程在等待条件存在时休眠(不占用 CPU 处理资源)。其他线程向等待唤醒的线程发出“信号”，以查看它们所等待的条件是否已经满足。例如，如果没有工作要做，您的工作线程可能会处于休眠状态(这样它们就不会从尝试执行有用工作的线程那里占用 CPU 资源)。另一个例子是，调用 run ()的主应用程序线程可能希望在等待批量任务启动中的所有任务由工作线程完成时休眠。(否则，一个旋转的主线程将从工作线程那里夺走 CPU 资源!)有关 C + + 中条件变量的更多信息，请参见我们的 C + + 同步教程。</p><p>您在这部分作业中的实现可能需要考虑棘手的race conditions 。您需要考虑许多可能的线程行为交错</p><p>您可能需要考虑编写额外的测试用例来测试您的系统。赋值入门代码包括评分脚本用于评分代码性能的工作负载，但是我们也将使用一组更广泛的工作负载来测试您的实现的正确性，而我们在入门代码中并没有提供这些工作负载！</p><p>The assignment starter code includes the workloads that the grading script will use to grade the performance of your code, but we will also test the correctness of your implementation using a wider set of workloads that we are not providing in the starter code!</p><p>tasksys.h</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * TaskSystemParallelThreadPoolSleeping: This class is the student&#39;s
</span></span></span><span style=display:flex><span><span style=color:#75715e> * optimized implementation of a parallel task execution engine that uses
</span></span></span><span style=display:flex><span><span style=color:#75715e> * a thread pool. See definition of ITaskSystem in
</span></span></span><span style=display:flex><span><span style=color:#75715e> * itasksys.h for documentation of the ITaskSystem interface.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TaskSystemParallelThreadPoolSleeping</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> ITaskSystem
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    TaskSystemParallelThreadPoolSleeping(<span style=color:#66d9ef>int</span> num_threads);
</span></span><span style=display:flex><span>    <span style=color:#f92672>~</span>TaskSystemParallelThreadPoolSleeping();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>name</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>(IRunnable <span style=color:#f92672>*</span>runnable, <span style=color:#66d9ef>int</span> num_total_tasks);
</span></span><span style=display:flex><span>    TaskID <span style=color:#a6e22e>runAsyncWithDeps</span>(IRunnable <span style=color:#f92672>*</span>runnable, <span style=color:#66d9ef>int</span> num_total_tasks,
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>TaskID<span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>deps);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sync</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span><span style=color:#66d9ef>thread</span><span style=color:#f92672>&gt;</span> threads;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> num_tasks_;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> exit_flag_;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>atomic<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> num_tasks_done_;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>queue<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> tasks_;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>mutex tasks_mutex_;
</span></span><span style=display:flex><span>    IRunnable <span style=color:#f92672>*</span>runnable_{};
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>func</span>();
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>condition_variable <span style=color:#f92672>*</span>queue_condition_ <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> std<span style=color:#f92672>::</span>condition_variable();
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>condition_variable <span style=color:#f92672>*</span>all_done_condition_ <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> std<span style=color:#f92672>::</span>condition_variable();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> num_waiting_threads_;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>atomic<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> num_tasks_remaining_;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>mutex all_done_mutex_;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>tasksys.cpp</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * ================================================================
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Parallel Thread Pool Sleeping Task System Implementation
</span></span></span><span style=display:flex><span><span style=color:#75715e> * ================================================================
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>TaskSystemParallelThreadPoolSleeping<span style=color:#f92672>::</span>name()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;Parallel + Thread Pool + Sleep&#34;</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> TaskSystemParallelThreadPoolSleeping<span style=color:#f92672>::</span>func()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> task_id;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>exit_flag_)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        task_id <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (task_id <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            std<span style=color:#f92672>::</span>unique_lock<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>mutex<span style=color:#f92672>&gt;</span> lk(tasks_mutex_);
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 等待任务
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            queue_condition_<span style=color:#f92672>-&gt;</span>wait(lk, []
</span></span><span style=display:flex><span>                                   { <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>; });
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (exit_flag_)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>tasks_.empty())
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                task_id <span style=color:#f92672>=</span> tasks_.front();
</span></span><span style=display:flex><span>                tasks_.pop();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        runnable_<span style=color:#f92672>-&gt;</span>runTask(task_id, num_tasks_);
</span></span><span style=display:flex><span>        num_tasks_remaining_<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>num_tasks_remaining_)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 通知主线程
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// printf(&#34;notify_all_done\n&#34;);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            all_done_condition_<span style=color:#f92672>-&gt;</span>notify_one();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 通知其他线程
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// printf(&#34;notify_all\n&#34;);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            queue_condition_<span style=color:#f92672>-&gt;</span>notify_one();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>TaskSystemParallelThreadPoolSleeping<span style=color:#f92672>::</span>TaskSystemParallelThreadPoolSleeping(<span style=color:#66d9ef>int</span> num_threads) <span style=color:#f92672>:</span> ITaskSystem(num_threads)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// TODO: CS149 student implementations may decide to perform setup
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// operations (such as thread pool construction) here.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Implementations are free to add new class member variables
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// (requiring changes to tasksys.h).
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    exit_flag_ <span style=color:#f92672>=</span> false;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> num_threads; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        threads.emplace_back(<span style=color:#f92672>&amp;</span>TaskSystemParallelThreadPoolSleeping<span style=color:#f92672>::</span>func, <span style=color:#66d9ef>this</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>TaskSystemParallelThreadPoolSleeping<span style=color:#f92672>::~</span>TaskSystemParallelThreadPoolSleeping()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// TODO: CS149 student implementations may decide to perform cleanup
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// operations (such as thread pool shutdown construction) here.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Implementations are free to add new class member variables
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// (requiring changes to tasksys.h).
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    exit_flag_ <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>    queue_condition_<span style=color:#f92672>-&gt;</span>notify_all();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>thread</span> <span style=color:#f92672>:</span> threads)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>thread</span>.join();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> TaskSystemParallelThreadPoolSleeping<span style=color:#f92672>::</span>run(IRunnable <span style=color:#f92672>*</span>runnable, <span style=color:#66d9ef>int</span> num_total_tasks)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// TODO: CS149 students will modify the implementation of this
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// method in Parts A and B.  The implementation provided below runs all
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// tasks sequentially on the calling thread.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    runnable_ <span style=color:#f92672>=</span> runnable;
</span></span><span style=display:flex><span>    num_tasks_ <span style=color:#f92672>=</span> num_total_tasks;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    num_tasks_remaining_ <span style=color:#f92672>=</span> num_total_tasks;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    tasks_mutex_.lock();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> num_total_tasks; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        tasks_.push(i);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    tasks_mutex_.unlock();
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 通知其他线程
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    queue_condition_<span style=color:#f92672>-&gt;</span>notify_all();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// printf(&#34;run\n&#34;);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (num_tasks_remaining_)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>unique_lock<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>mutex<span style=color:#f92672>&gt;</span> lk2(all_done_mutex_);
</span></span><span style=display:flex><span>        all_done_condition_<span style=color:#f92672>-&gt;</span>wait(lk2, []
</span></span><span style=display:flex><span>                                  { <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>; });
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// printf(&#34;all done\n&#34;);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// printf(&#34;all done\n&#34;);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>结果分析:</p><p>sleep对spin的提升效果不明显，可能是因为任务太少，线程切换的开销比较大.</p><p>运行结果:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#f92672>================================================================================</span>
</span></span><span style=display:flex><span>Running task system grading harness... <span style=color:#f92672>(</span><span style=color:#ae81ff>11</span> total tests<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  - Detected CPU with <span style=color:#ae81ff>16</span> execution contexts
</span></span><span style=display:flex><span>  - Task system configured to use at most <span style=color:#ae81ff>8</span> threads
</span></span><span style=display:flex><span><span style=color:#f92672>================================================================================</span>
</span></span><span style=display:flex><span><span style=color:#f92672>================================================================================</span>
</span></span><span style=display:flex><span>Executing test: super_super_light...
</span></span><span style=display:flex><span>Reference binary: ./runtasks_ref_linux
</span></span><span style=display:flex><span>Results <span style=color:#66d9ef>for</span>: super_super_light
</span></span><span style=display:flex><span>                                        STUDENT   REFERENCE   PERF?
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Serial<span style=color:#f92672>]</span>                                5.281     5.788       0.91  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Always Spawn<span style=color:#f92672>]</span>               95.221    92.995      1.02  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Thread Pool + Spin<span style=color:#f92672>]</span>         10.877    10.446      1.04  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Thread Pool + Sleep<span style=color:#f92672>]</span>        6.943     42.705      0.16  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>================================================================================</span>
</span></span><span style=display:flex><span>Executing test: super_light...
</span></span><span style=display:flex><span>Reference binary: ./runtasks_ref_linux
</span></span><span style=display:flex><span>Results <span style=color:#66d9ef>for</span>: super_light
</span></span><span style=display:flex><span>                                        STUDENT   REFERENCE   PERF?
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Serial<span style=color:#f92672>]</span>                                37.497    37.844      0.99  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Always Spawn<span style=color:#f92672>]</span>               108.136   108.805     0.99  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Thread Pool + Spin<span style=color:#f92672>]</span>         10.777    13.615      0.79  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Thread Pool + Sleep<span style=color:#f92672>]</span>        10.274    44.686      0.23  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>================================================================================</span>
</span></span><span style=display:flex><span>Executing test: ping_pong_equal...
</span></span><span style=display:flex><span>Reference binary: ./runtasks_ref_linux
</span></span><span style=display:flex><span>Results <span style=color:#66d9ef>for</span>: ping_pong_equal
</span></span><span style=display:flex><span>                                        STUDENT   REFERENCE   PERF?
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Serial<span style=color:#f92672>]</span>                                603.419   606.739     0.99  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Always Spawn<span style=color:#f92672>]</span>               167.412   178.638     0.94  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Thread Pool + Spin<span style=color:#f92672>]</span>         105.983   123.525     0.86  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Thread Pool + Sleep<span style=color:#f92672>]</span>        108.243   148.316     0.73  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>================================================================================</span>
</span></span><span style=display:flex><span>Executing test: ping_pong_unequal...
</span></span><span style=display:flex><span>Reference binary: ./runtasks_ref_linux
</span></span><span style=display:flex><span>Results <span style=color:#66d9ef>for</span>: ping_pong_unequal
</span></span><span style=display:flex><span>                                        STUDENT   REFERENCE   PERF?
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Serial<span style=color:#f92672>]</span>                                1126.19   1109.329    1.02  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Always Spawn<span style=color:#f92672>]</span>               259.271   260.822     0.99  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Thread Pool + Spin<span style=color:#f92672>]</span>         199.088   198.013     1.01  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Thread Pool + Sleep<span style=color:#f92672>]</span>        198.777   214.293     0.93  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>================================================================================</span>
</span></span><span style=display:flex><span>Executing test: recursive_fibonacci...
</span></span><span style=display:flex><span>Reference binary: ./runtasks_ref_linux
</span></span><span style=display:flex><span>Results <span style=color:#66d9ef>for</span>: recursive_fibonacci
</span></span><span style=display:flex><span>                                        STUDENT   REFERENCE   PERF?
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Serial<span style=color:#f92672>]</span>                                1052.273  1128.069    0.93  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Always Spawn<span style=color:#f92672>]</span>               156.014   172.113     0.91  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Thread Pool + Spin<span style=color:#f92672>]</span>         156.31    171.337     0.91  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Thread Pool + Sleep<span style=color:#f92672>]</span>        156.462   166.476     0.94  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>================================================================================</span>
</span></span><span style=display:flex><span>Executing test: math_operations_in_tight_for_loop...
</span></span><span style=display:flex><span>Reference binary: ./runtasks_ref_linux
</span></span><span style=display:flex><span>Results <span style=color:#66d9ef>for</span>: math_operations_in_tight_for_loop
</span></span><span style=display:flex><span>                                        STUDENT   REFERENCE   PERF?
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Serial<span style=color:#f92672>]</span>                                411.426   423.96      0.97  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Always Spawn<span style=color:#f92672>]</span>               537.747   532.353     1.01  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Thread Pool + Spin<span style=color:#f92672>]</span>         99.286    104.844     0.95  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Thread Pool + Sleep<span style=color:#f92672>]</span>        95.817    239.76      0.40  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>================================================================================</span>
</span></span><span style=display:flex><span>Executing test: math_operations_in_tight_for_loop_fewer_tasks...
</span></span><span style=display:flex><span>Reference binary: ./runtasks_ref_linux
</span></span><span style=display:flex><span>Results <span style=color:#66d9ef>for</span>: math_operations_in_tight_for_loop_fewer_tasks
</span></span><span style=display:flex><span>                                        STUDENT   REFERENCE   PERF?
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Serial<span style=color:#f92672>]</span>                                413.681   415.961     0.99  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Always Spawn<span style=color:#f92672>]</span>               514.021   505.234     1.02  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Thread Pool + Spin<span style=color:#f92672>]</span>         108.644   117.702     0.92  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Thread Pool + Sleep<span style=color:#f92672>]</span>        106.84    260.724     0.41  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>================================================================================</span>
</span></span><span style=display:flex><span>Executing test: math_operations_in_tight_for_loop_fan_in...
</span></span><span style=display:flex><span>Reference binary: ./runtasks_ref_linux
</span></span><span style=display:flex><span>Results <span style=color:#66d9ef>for</span>: math_operations_in_tight_for_loop_fan_in
</span></span><span style=display:flex><span>                                        STUDENT   REFERENCE   PERF?
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Serial<span style=color:#f92672>]</span>                                212.534   211.52      1.00  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Always Spawn<span style=color:#f92672>]</span>               76.402    76.09       1.00  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Thread Pool + Spin<span style=color:#f92672>]</span>         37.203    39.662      0.94  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Thread Pool + Sleep<span style=color:#f92672>]</span>        36.523    57.039      0.64  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>================================================================================</span>
</span></span><span style=display:flex><span>Executing test: math_operations_in_tight_for_loop_reduction_tree...
</span></span><span style=display:flex><span>Reference binary: ./runtasks_ref_linux
</span></span><span style=display:flex><span>Results <span style=color:#66d9ef>for</span>: math_operations_in_tight_for_loop_reduction_tree
</span></span><span style=display:flex><span>                                        STUDENT   REFERENCE   PERF?
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Serial<span style=color:#f92672>]</span>                                208.076   207.488     1.00  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Always Spawn<span style=color:#f92672>]</span>               45.054    45.227      1.00  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Thread Pool + Spin<span style=color:#f92672>]</span>         33.079    33.9        0.98  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Thread Pool + Sleep<span style=color:#f92672>]</span>        34.502    38.389      0.90  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>================================================================================</span>
</span></span><span style=display:flex><span>Executing test: spin_between_run_calls...
</span></span><span style=display:flex><span>Reference binary: ./runtasks_ref_linux
</span></span><span style=display:flex><span>Results <span style=color:#66d9ef>for</span>: spin_between_run_calls
</span></span><span style=display:flex><span>                                        STUDENT   REFERENCE   PERF?
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Serial<span style=color:#f92672>]</span>                                353.553   382.373     0.92  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Always Spawn<span style=color:#f92672>]</span>               180.401   197.119     0.92  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Thread Pool + Spin<span style=color:#f92672>]</span>         205.374   222.315     0.92  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Thread Pool + Sleep<span style=color:#f92672>]</span>        214.819   197.579     1.09  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>================================================================================</span>
</span></span><span style=display:flex><span>Executing test: mandelbrot_chunked...
</span></span><span style=display:flex><span>Reference binary: ./runtasks_ref_linux
</span></span><span style=display:flex><span>Results <span style=color:#66d9ef>for</span>: mandelbrot_chunked
</span></span><span style=display:flex><span>                                        STUDENT   REFERENCE   PERF?
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Serial<span style=color:#f92672>]</span>                                257.289   256.815     1.00  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Always Spawn<span style=color:#f92672>]</span>               34.395    34.058      1.01  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Thread Pool + Spin<span style=color:#f92672>]</span>         34.241    34.922      0.98  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Thread Pool + Sleep<span style=color:#f92672>]</span>        35.191    35.273      1.00  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>================================================================================</span>
</span></span><span style=display:flex><span>Overall performance results
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Serial<span style=color:#f92672>]</span>                                : All passed Perf
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Always Spawn<span style=color:#f92672>]</span>               : All passed Perf
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Thread Pool + Spin<span style=color:#f92672>]</span>         : All passed Perf
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Thread Pool + Sleep<span style=color:#f92672>]</span>        : All passed Perf
</span></span></code></pre></div><h2 id=part_b>part_b<a hidden class=anchor aria-hidden=true href=#part_b>#</a></h2><p>在任务的 B 部分中，您将扩展您的 A 部分任务系统实现，以支持可能依赖于以前任务的任务的异步启动。这些任务间依赖关系创建了任务执行库必须遵守的调度约束。</p><p>ITaskSystem 接口还有一个方法:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>virtual</span> TaskID <span style=color:#a6e22e>runAsyncWithDeps</span>(IRunnable<span style=color:#f92672>*</span> runnable, <span style=color:#66d9ef>int</span> num_total_tasks,
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>TaskID<span style=color:#f92672>&gt;&amp;</span> deps) <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span></code></pre></div><p>RunAsyncWithDeps ()类似于 run () ，因为它也用于执行 num <em>total</em> asks 任务的批量启动。但是，它与 run ()在许多方面有所不同&mldr;</p><h3 id=asynchronous-task-launch>Asynchronous Task Launch<a hidden class=anchor aria-hidden=true href=#asynchronous-task-launch>#</a></h3><p>首先，使用 runAsyncWithDeps ()创建的任务由任务系统与调用线程异步执行。</p><p>这意味着 runAsyncWithDeps ()应该立即返回给调用方，即使任务尚未完成执行。</p><p>该方法返回与此批量任务启动关联的唯一标识符。</p><p>调用线程可以通过调用 sync ()来确定大容量任务启动的实际完成时间。</p><p><code>virtual void sync() = 0;</code></p><p>只有当与之前所有批量任务启动关联的任务完成时，sync ()才返回给调用方。例如，考虑以下代码:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>// assume taskA and taskB are valid instances of IRunnable...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>TaskID<span style=color:#f92672>&gt;</span> noDeps;  <span style=color:#75715e>// empty vector
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>ITaskSystem <span style=color:#f92672>*</span>t <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> TaskSystem(num_threads);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// bulk launch of 4 tasks
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>TaskID launchA <span style=color:#f92672>=</span> t<span style=color:#f92672>-&gt;</span>runAsyncWithDeps(taskA, <span style=color:#ae81ff>4</span>, noDeps);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// bulk launch of 8 tasks
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>TaskID launchB <span style=color:#f92672>=</span> t<span style=color:#f92672>-&gt;</span>runAsyncWithDeps(taskB, <span style=color:#ae81ff>8</span>, noDeps);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// at this point tasks associated with launchA and launchB
</span></span></span><span style=display:flex><span><span style=color:#75715e>// may still be running
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>t<span style=color:#f92672>-&gt;</span>sync();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// at this point all 12 tasks associated with launchA and launchB
</span></span></span><span style=display:flex><span><span style=color:#75715e>// are guaranteed to have terminated
</span></span></span></code></pre></div><p>如上面的注释中所述，在线程调用sync() runAsyncWithDeps() ) 的任务已完成。 准确地说， runAsyncWithDeps()告诉您的任务系统执行新的批量任务启动，但您的实现可以灵活地在下次调用sync()之前随时执行这些任务。 请注意，此规范意味着无法保证您的实现在从 launchB 启动任务之前先执行 launchA 中的任务！</p><h3 id=support-for-explicit-dependencies>Support for Explicit Dependencies<a hidden class=anchor aria-hidden=true href=#support-for-explicit-dependencies>#</a></h3><p>runAsyncWithDeps()的第二个关键细节是它的第三个参数：TaskID 标识符向量，必须引用之前使用runAsyncWithDeps()启动的批量任务。 该向量指定当前批量任务启动中的任务所依赖的先前任务。 因此，在依赖向量中给出的启动中的所有任务完成之前，您的任务运行时无法开始执行当前批量任务启动中的任何任务！ 例如，考虑以下示例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span>std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>TaskID<span style=color:#f92672>&gt;</span> noDeps;  <span style=color:#75715e>// empty vector
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>TaskID<span style=color:#f92672>&gt;</span> depOnA;   
</span></span><span style=display:flex><span>std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>TaskID<span style=color:#f92672>&gt;</span> depOnBC;   
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ITaskSystem <span style=color:#f92672>*</span>t <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> TaskSystem(num_threads);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>TaskID launchA <span style=color:#f92672>=</span> t<span style=color:#f92672>-&gt;</span>runAsyncWithDeps(taskA, <span style=color:#ae81ff>128</span>, noDeps);    
</span></span><span style=display:flex><span>depOnA.push_back(launchA);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>TaskID launchB <span style=color:#f92672>=</span> t<span style=color:#f92672>-&gt;</span>runAsyncWithDeps(taskB, <span style=color:#ae81ff>2</span>, depOnA);
</span></span><span style=display:flex><span>TaskID launchC <span style=color:#f92672>=</span> t<span style=color:#f92672>-&gt;</span>runAsyncWithDeps(taskC, <span style=color:#ae81ff>6</span>, depOnA);
</span></span><span style=display:flex><span>depOnBC.push_back(launchB);
</span></span><span style=display:flex><span>depOnBC.push_back(launchC);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>TaskID launchD <span style=color:#f92672>=</span> t<span style=color:#f92672>-&gt;</span>runAsyncWithDeps(taskD, <span style=color:#ae81ff>32</span>, depOnBC);            
</span></span><span style=display:flex><span>t<span style=color:#f92672>-&gt;</span>sync();
</span></span></code></pre></div><p>上面的代码有四个批量任务启动（taskA：128 个任务，taskB：2 个任务，taskC：6 个任务，taskD：32 个任务）。 请注意，任务 B 和任务 C 的启动取决于任务 A。 taskD 的批量启动 ( launchD ) 取决于launchB和launchC的结果。 因此，虽然您的任务运行时可以按任意顺序（包括并行）处理与launchB和launchC关联的任务，但这些启动中的所有任务必须在launchA的任务完成后开始执行，并且它们必须在运行时开始之前完成从launchD执行任何任务。</p><p>我们可以通过任务图直观地说明这些依赖关系。 任务图是有向无环图 (DAG)，其中图中的节点对应于批量任务启动，从节点 X 到节点 Y 的边表示 Y 对 X 输出的依赖关系。上述代码的任务图是：
<img loading=lazy src=https://github.com/jeremyephron/asst2/raw/master/figs/task_graph.png alt="Alt text"></p><p>请注意，如果您在具有八个执行上下文的 Myth 计算机上运行上面的示例，则并行调度launchB和launchC中的任务的能力可能非常有用，因为单独的批量任务启动都不足以使用所有执行机器的资源。</p><h3 id=task>Task<a hidden class=anchor aria-hidden=true href=#task>#</a></h3><p>您必须从 A 部分扩展任务系统实现，才能正确实现TaskSystem::runAsyncWithDeps()和TaskSystem::sync() 。 与 A 部分一样，我们为您提供以下入门提示：</p><ul><li>It may be helpful to think about the behavior of runAsyncWithDeps() as pushing a record corresponding to the bulk task launch, or perhaps records corresponding to each of the tasks in the bulk task launch onto a &ldquo;work queue&rdquo;. Once the record to work to do is in the queue, runAsyncWithDeps() can return to the caller.</li><li>The trick in this part of the assignment is performing the appropriate bookkeeping to track dependencies. What must be done when all the tasks in a bulk task launch complete? (This is the point when new tasks may become available to run.)</li><li>It can be helpful to have two data structures in your implementation: (1) a structure representing tasks that have been added to the system via a call to runAsyncWithDeps(), but are not yet ready to execute because they depend on tasks that are still running (these tasks are &ldquo;waiting&rdquo; for others to finish) and (2) a &ldquo;ready queue&rdquo; of tasks that are not waiting on any prior tasks to finish and can safely be run as soon as a worker thread is available to process them.</li><li>You need not worry about integer wrap around when generating unique task launch ids. We will not hit your task system with over 2^31 bulk task launches.</li><li>You can assume all programs will either call only run() or only runAsyncWithDeps(); that is, you do not need to handle the case where a run() call needs to wait for all proceeding calls to runAsyncWithDeps() to finish.</li></ul><p>在part_b/子目录中实现B部分实现，以与正确的参考实现（ part_b/runtasks_ref_* ）进行比较。</p></div><footer class=post-footer><ul class=post-tags><li><a href=/tags/cmu-15418cs-618/>cmu-15418&amp;cs-618</a></li></ul><nav class=paginav><a class=prev href=/posts/tips/windows%E4%B8%8B%E7%9A%84%E5%AD%90%E7%B3%BB%E7%BB%9F/><span class=title>« 上一页</span><br><span>windows 下的子系统</span>
</a><a class=next href=/posts/tools/docker/docker/><span class=title>下一页 »</span><br><span>docker Usage</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share asst2 on twitter" href="https://twitter.com/intent/tweet/?text=asst2&amp;url=%2fposts%2fcmu-15418cs-618%2fasst2%2f&amp;hashtags=cmu-15418%26cs-618"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share asst2 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=%2fposts%2fcmu-15418cs-618%2fasst2%2f&amp;title=asst2&amp;summary=asst2&amp;source=%2fposts%2fcmu-15418cs-618%2fasst2%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share asst2 on reddit" href="https://reddit.com/submit?url=%2fposts%2fcmu-15418cs-618%2fasst2%2f&title=asst2"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share asst2 on facebook" href="https://facebook.com/sharer/sharer.php?u=%2fposts%2fcmu-15418cs-618%2fasst2%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share asst2 on whatsapp" href="https://api.whatsapp.com/send?text=asst2%20-%20%2fposts%2fcmu-15418cs-618%2fasst2%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share asst2 on telegram" href="https://telegram.me/share/url?text=asst2&amp;url=%2fposts%2fcmu-15418cs-618%2fasst2%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share asst2 on ycombinator" href="https://news.ycombinator.com/submitlink?t=asst2&u=%2fposts%2fcmu-15418cs-618%2fasst2%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2024 <a href>ysyy's blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>