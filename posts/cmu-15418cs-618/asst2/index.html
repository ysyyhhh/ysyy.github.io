<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>asst2 | ysyy's blog</title>
<meta name=keywords content="cmu-15418&amp;cs-618"><meta name=description content="C++ Sync threadçš„ä½¿ç”¨ #include <thread> #include <stdio.h> void my_func(int thread_id, int num_threads) { printf(&#34;Hello from spawned thread %d of %d\n&#34;, thread_id, num_threads); } int main(int argc, char** argv) { std::thread t0 = std::thread(my_func, 0, 2); std::thread t1 = std::thread(my_func, 1, 2); printf(&#34;The main thread is running concurrently with spawned threads.\n&#34;); t0.join(); t1.join(); printf(&#34;Spawned threads have terminated at this point.\n&#34;); return 0; }"><meta name=author content="Ysyy"><link rel=canonical href=/posts/cmu-15418cs-618/asst2/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.js onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=img/Q.gif><link rel=icon type=image/png sizes=16x16 href=img/Q.gif><link rel=icon type=image/png sizes=32x32 href=img/Q.gif><link rel=apple-touch-icon href=img/Q.gif><link rel=mask-icon href=img/Q.gif><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="asst2"><meta property="og:description" content="C++ Sync threadçš„ä½¿ç”¨ #include <thread> #include <stdio.h> void my_func(int thread_id, int num_threads) { printf(&#34;Hello from spawned thread %d of %d\n&#34;, thread_id, num_threads); } int main(int argc, char** argv) { std::thread t0 = std::thread(my_func, 0, 2); std::thread t1 = std::thread(my_func, 1, 2); printf(&#34;The main thread is running concurrently with spawned threads.\n&#34;); t0.join(); t1.join(); printf(&#34;Spawned threads have terminated at this point.\n&#34;); return 0; }"><meta property="og:type" content="article"><meta property="og:url" content="/posts/cmu-15418cs-618/asst2/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-12-18T00:00:00+00:00"><meta property="article:modified_time" content="2024-01-11T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="asst2"><meta name=twitter:description content="C++ Sync threadçš„ä½¿ç”¨ #include <thread> #include <stdio.h> void my_func(int thread_id, int num_threads) { printf(&#34;Hello from spawned thread %d of %d\n&#34;, thread_id, num_threads); } int main(int argc, char** argv) { std::thread t0 = std::thread(my_func, 0, 2); std::thread t1 = std::thread(my_func, 1, 2); printf(&#34;The main thread is running concurrently with spawned threads.\n&#34;); t0.join(); t1.join(); printf(&#34;Spawned threads have terminated at this point.\n&#34;); return 0; }"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"/posts/"},{"@type":"ListItem","position":3,"name":"asst2","item":"/posts/cmu-15418cs-618/asst2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"asst2","name":"asst2","description":"C++ Sync threadçš„ä½¿ç”¨ #include \u0026lt;thread\u0026gt; #include \u0026lt;stdio.h\u0026gt; void my_func(int thread_id, int num_threads) { printf(\u0026#34;Hello from spawned thread %d of %d\\n\u0026#34;, thread_id, num_threads); } int main(int argc, char** argv) { std::thread t0 = std::thread(my_func, 0, 2); std::thread t1 = std::thread(my_func, 1, 2); printf(\u0026#34;The main thread is running concurrently with spawned threads.\\n\u0026#34;); t0.join(); t1.join(); printf(\u0026#34;Spawned threads have terminated at this point.\\n\u0026#34;); return 0; }","keywords":["cmu-15418\u0026cs-618"],"articleBody":"C++ Sync threadçš„ä½¿ç”¨ #include #include void my_func(int thread_id, int num_threads) { printf(\"Hello from spawned thread %d of %d\\n\", thread_id, num_threads); } int main(int argc, char** argv) { std::thread t0 = std::thread(my_func, 0, 2); std::thread t1 = std::thread(my_func, 1, 2); printf(\"The main thread is running concurrently with spawned threads.\\n\"); t0.join(); t1.join(); printf(\"Spawned threads have terminated at this point.\\n\"); return 0; } mutex #include #include #include #include #include #include std::map\u003cstd::string, std::string\u003e g_pages; std::mutex g_pages_mutex; void save_page(const std::string\u0026 url) { // simulate a long page fetch std::this_thread::sleep_for(std::chrono::seconds(2)); std::string result = \"fake content\"; std::lock_guard\u003cstd::mutex\u003e guard(g_pages_mutex); g_pages[url] = result; } int main() { std::thread t1(save_page, \"http://foo\"); std::thread t2(save_page, \"http://bar\"); t1.join(); t2.join(); // safe to access g_pages without lock now, as the threads are joined for (const auto\u0026 pair : g_pages) std::cout \u003c\u003c pair.first \u003c\u003c \" =\u003e \" \u003c\u003c pair.second \u003c\u003c '\\n'; } Output\nhttp://bar =\u003e fake content http://foo =\u003e fake content condition_variable çº¿ç¨‹è°ƒç”¨ wait (lock)æ¥æŒ‡ç¤ºå®ƒå¸Œæœ›ç­‰å¾…æ¥è‡ªå¦ä¸€ä¸ªçº¿ç¨‹çš„é€šçŸ¥ã€‚\næ³¨æ„ï¼Œäº’æ–¥å¯¹è±¡(åŒ…è£…åœ¨ std: : only _ lock ä¸­)è¢«ä¼ é€’ç»™ wait ()è°ƒç”¨ã€‚å½“é€šçŸ¥çº¿ç¨‹æ—¶ï¼Œæ¡ä»¶å˜é‡å°†è·å¾—é”ã€‚\nè¿™æ„å‘³ç€å½“è°ƒç”¨ wait ()è¿”å›æ—¶ï¼Œè°ƒç”¨çº¿ç¨‹æ˜¯é”çš„å½“å‰æŒæœ‰è€…ã€‚é”é€šå¸¸ç”¨äºä¿æŠ¤çº¿ç¨‹ç°åœ¨éœ€è¦æ£€æŸ¥çš„å…±äº«å˜é‡ï¼Œä»¥ç¡®ä¿å®ƒæ­£åœ¨ç­‰å¾…çš„æ¡ä»¶ä¸ºçœŸã€‚\nåˆ›å»º N ä¸ªçº¿ç¨‹ã€‚N-1ä¸ªçº¿ç¨‹ç­‰å¾…æ¥è‡ªçº¿ç¨‹0çš„é€šçŸ¥ï¼Œç„¶ååœ¨æ¥åˆ°é€šçŸ¥åï¼Œè‡ªåŠ¨é€’å¢ä¸€ä¸ªå—å…±äº«äº’æ–¥é”ä¿æŠ¤çš„è®¡æ•°å™¨ã€‚\n/* * Wrapper class around a counter, a condition variable, and a mutex. */ class ThreadState { public: std::condition_variable *condition_variable_; std::mutex *mutex_; int counter_; int num_waiting_threads_; ThreadState(int num_waiting_threads) { condition_variable_ = new std::condition_variable(); mutex_ = new std::mutex(); counter_ = 0; num_waiting_threads_ = num_waiting_threads; } ~ThreadState() { delete condition_variable_; delete mutex_; } }; void signal_fn(ThreadState *thread_state) { // Acquire mutex to make sure the shared counter is read in a // consistent state. thread_state-\u003emutex_-\u003elock(); while (thread_state-\u003ecounter_ \u003c thread_state-\u003enum_waiting_threads_) { thread_state-\u003emutex_-\u003eunlock(); // Release the mutex before calling `notify_all()` to make sure // waiting threads have a chance to make progress. thread_state-\u003econdition_variable_-\u003enotify_all(); // Re-acquire the mutex to read the shared counter again. thread_state-\u003emutex_-\u003elock(); } thread_state-\u003emutex_-\u003eunlock(); } void wait_fn(ThreadState *thread_state) { // A lock must be held in order to wait on a condition variable. // This lock is atomically released before the thread goes to sleep // when `wait()` is called. The lock is atomically re-acquired when // the thread is woken up using `notify_all()`. std::unique_lock\u003cstd::mutex\u003e lk(*thread_state-\u003emutex_); thread_state-\u003econdition_variable_-\u003ewait(lk); // Increment the shared counter with the lock re-acquired to inform the // signaling thread that this waiting thread has successfully been // woken up. thread_state-\u003ecounter_++; printf(\"Lock re-acquired after wait()...\\n\"); lk.unlock(); } /* * Signaling thread spins until each waiting thread increments a shared * counter after being woken up from the `wait()` method. */ void condition_variable_example() { int num_threads = 3; printf(\"==============================================================\\n\"); printf(\"Starting %d threads for signal-and-waiting...\\n\", num_threads); std::thread *threads = new std::thread[num_threads]; ThreadState *thread_state = new ThreadState(num_threads - 1); threads[0] = std::thread(signal_fn, thread_state); for (int i = 1; i \u003c num_threads; i++) { threads[i] = std::thread(wait_fn, thread_state); } for (int i = 0; i \u003c num_threads; i++) { threads[i].join(); } printf(\"==============================================================\\n\"); delete thread_state; delete[] threads; } part_a step 1 å®ç°TaskSystemParallelSpawn void TaskSystemParallelSpawn::run(IRunnable *runnable, int num_total_tasks) { // // TODO: CS149 students will modify the implementation of this // method in Part A. The implementation provided below runs all // tasks sequentially on the calling thread. // std::atomic\u003cint\u003e taskId(0); int num_threads = this-\u003enum_threads; std::thread threads[num_threads]; // äº¤å‰åˆ†é…ä»»åŠ¡ for (int i = 0; i \u003c num_threads; i++) { threads[i] = std::thread([\u0026, i]() { int task_id = taskId.fetch_add(1); while (task_id \u003c num_total_tasks) { runnable-\u003erunTask(task_id, num_total_tasks); task_id = taskId.fetch_add(1); } }); } for (int i = 0; i \u003c num_threads; i++) { threads[i].join(); } // printf(\"done\\n\"); } Q:How will you assign tasks to your worker threads? Should you consider static or dynamic assignment of tasks to threads? A:äº¤å‰åˆ†é…ä»»åŠ¡ï¼ŒåŠ¨æ€åˆ†é…ä»»åŠ¡\nQ:How will you ensure that all tasks are executed exactly once? A:ä½¿ç”¨åŸå­å˜é‡taskId\nstep 2 å®ç° TaskSystemParallelThreadPoolSpinning step1 çš„overheadä¸»è¦æ˜¯åˆ›å»ºçº¿ç¨‹çš„å¼€é”€(å°¤å…¶æ˜¯è®¡ç®—é‡ä½çš„ä»»åŠ¡ä¸Š)ï¼Œå› æ­¤ä½¿ç”¨çº¿ç¨‹æ± å¯ä»¥å‡å°‘å¼€é”€\nè¦æ±‚: åœ¨TestSystem åˆ›å»ºæ—¶,æˆ–è€…åœ¨runæ—¶åˆ›å»ºçº¿ç¨‹æ± \nQ1: ä½œä¸ºä¸€ä¸ªå¼€å§‹çš„å®ç°ï¼Œæˆ‘ä»¬å»ºè®®æ‚¨å°†worker threadsè®¾è®¡ä¸ºè¿ç»­å¾ªç¯ï¼Œå§‹ç»ˆæ£€æŸ¥å®ƒä»¬æ˜¯å¦æœ‰æ›´å¤šçš„å·¥ä½œè¦æ‰§è¡Œã€‚(è¿›å…¥ while å¾ªç¯ç›´åˆ°æ¡ä»¶ä¸ºçœŸçš„çº¿ç¨‹é€šå¸¸ç§°ä¸ºâ€œspinningâ€) é‚£ä¹ˆworker thread å¦‚ä½•ç¡®å®šæœ‰workè¦æ‰§è¡Œå‘¢ï¼Ÿ\nTaskSystemParallelThreadPoolSpinning::TaskSystemParallelThreadPoolSpinning(int num_threads) : ITaskSystem(num_threads) { // // TODO: CS149 student implementations may decide to perform setup // operations (such as thread pool construction) here. // Implementations are free to add new class member variables // (requiring changes to tasksys.h). // exit_flag_ = false; for (int i = 0; i \u003c num_threads; i++) { threads.emplace_back(\u0026TaskSystemParallelThreadPoolSpinning::func, this); } } TaskSystemParallelThreadPoolSpinning::~TaskSystemParallelThreadPoolSpinning() { exit_flag_ = true; for (auto \u0026thread : threads) { thread.join(); } } void TaskSystemParallelThreadPoolSpinning::run(IRunnable *runnable, int num_total_tasks) { // // TODO: CS149 students will modify the implementation of this // method in Part A. The implementation provided below runs all // tasks sequentially on the calling thread. // // printf(\"run\\n\"); runnable_ = runnable; num_tasks_ = num_total_tasks; num_tasks_done_ = num_total_tasks; for (int i = 0; i \u003c num_total_tasks; i++) { tasks_mutex_.lock(); tasks_.push(i); tasks_mutex_.unlock(); } while (num_tasks_done_ \u003c num_total_tasks) { std::this_thread::yield(); }; // Q:ä¸ºä»€ä¹ˆè¦ä½¿ç”¨yield // A:å› ä¸ºå¦‚æœä¸ä½¿ç”¨yieldï¼Œé‚£ä¹ˆçº¿ç¨‹ä¼šä¸€ç›´å ç”¨CPUï¼Œå¯¼è‡´å…¶ä»–çº¿ç¨‹æ— æ³•è¿è¡Œ // Q:é‚£æˆ‘ç›´æ¥æ­»å¾ªç¯å‘¢ // A:æ­»å¾ªç¯ä¼šå¯¼è‡´CPUå ç”¨ç‡100%ï¼Œå¯¼è‡´å…¶ä»–çº¿ç¨‹æ— æ³•è¿è¡Œ } Q2:ç¡®ä¿ run ()å®ç°æ‰€éœ€çš„åŒæ­¥è¡Œä¸ºæ˜¯éå¸¸é‡è¦çš„ã€‚å¦‚ä½•æ›´æ”¹ run ()çš„å®ç°ä»¥ç¡®å®šæ‰¹é‡ä»»åŠ¡å¯åŠ¨ä¸­çš„æ‰€æœ‰ä»»åŠ¡éƒ½å·²å®Œæˆï¼Ÿ A:ä½¿ç”¨åŸå­å˜é‡num_tasks_done_ï¼Œæ¯ä¸ªä»»åŠ¡å®Œæˆæ—¶ï¼Œnum_tasks_done_åŠ ä¸€ï¼Œå½“num_tasks_done_ç­‰äºnum_total_tasksæ—¶ï¼Œæ‰€æœ‰ä»»åŠ¡å®Œæˆ\nstep 3 å®ç° TaskSystemParallelThreadPoolSleeping Step2çš„ç¼ºç‚¹ï¼š å½“çº¿ç¨‹â€œspinâ€ç­‰å¾…æŸäº›æ“ä½œæ—¶ï¼Œå®ƒä»¬ä¼šåˆ©ç”¨ CPU æ ¸å¿ƒçš„æ‰§è¡Œèµ„æºã€‚\nä¾‹å¦‚ï¼Œå·¥ä½œçº¿ç¨‹å¯èƒ½ä¼šå¾ªç¯ç­‰å¾…æ–°ä»»åŠ¡åˆ°è¾¾ã€‚ å¦ä¸€ä¸ªä¾‹å­æ˜¯ï¼Œä¸»çº¿ç¨‹å¯èƒ½ä¼šå¾ªç¯ç­‰å¾…è¾…åŠ©çº¿ç¨‹å®Œæˆæ‰€æœ‰ä»»åŠ¡ï¼Œè¿™æ ·å®ƒå°±å¯ä»¥ä» run ()è°ƒç”¨è¿”å›ã€‚ è¿™å¯èƒ½ä¼šå½±å“æ€§èƒ½ï¼Œå› ä¸ºå³ä½¿è¿™äº›çº¿ç¨‹æ²¡æœ‰åšæœ‰ç”¨çš„å·¥ä½œï¼Œä¹Ÿä¼šä½¿ç”¨ CPU èµ„æºæ¥è¿è¡Œè¿™äº›çº¿ç¨‹ã€‚\nåœ¨ä»»åŠ¡çš„è¿™ä¸€éƒ¨åˆ†ä¸­ï¼Œæˆ‘ä»¬å¸Œæœ›æ‚¨é€šè¿‡è®©çº¿ç¨‹å¤„äºä¼‘çœ çŠ¶æ€æ¥æé«˜ä»»åŠ¡ç³»ç»Ÿçš„æ•ˆç‡ï¼Œç›´åˆ°å®ƒä»¬æ‰€ç­‰å¾…çš„æ¡ä»¶å¾—åˆ°æ»¡è¶³ã€‚\næ‚¨çš„å®ç°å¯ä»¥é€‰æ‹©ä½¿ç”¨æ¡ä»¶å˜é‡æ¥å®ç°æ­¤è¡Œä¸ºã€‚æ¡ä»¶å˜é‡æ˜¯ä¸€ä¸ªåŒæ­¥åŸè¯­ï¼Œå®ƒå…è®¸çº¿ç¨‹åœ¨ç­‰å¾…æ¡ä»¶å­˜åœ¨æ—¶ä¼‘çœ (ä¸å ç”¨ CPU å¤„ç†èµ„æº)ã€‚å…¶ä»–çº¿ç¨‹å‘ç­‰å¾…å”¤é†’çš„çº¿ç¨‹å‘å‡ºâ€œä¿¡å·â€ï¼Œä»¥æŸ¥çœ‹å®ƒä»¬æ‰€ç­‰å¾…çš„æ¡ä»¶æ˜¯å¦å·²ç»æ»¡è¶³ã€‚ä¾‹å¦‚ï¼Œå¦‚æœæ²¡æœ‰å·¥ä½œè¦åšï¼Œæ‚¨çš„å·¥ä½œçº¿ç¨‹å¯èƒ½ä¼šå¤„äºä¼‘çœ çŠ¶æ€(è¿™æ ·å®ƒä»¬å°±ä¸ä¼šä»å°è¯•æ‰§è¡Œæœ‰ç”¨å·¥ä½œçš„çº¿ç¨‹é‚£é‡Œå ç”¨ CPU èµ„æº)ã€‚å¦ä¸€ä¸ªä¾‹å­æ˜¯ï¼Œè°ƒç”¨ run ()çš„ä¸»åº”ç”¨ç¨‹åºçº¿ç¨‹å¯èƒ½å¸Œæœ›åœ¨ç­‰å¾…æ‰¹é‡ä»»åŠ¡å¯åŠ¨ä¸­çš„æ‰€æœ‰ä»»åŠ¡ç”±å·¥ä½œçº¿ç¨‹å®Œæˆæ—¶ä¼‘çœ ã€‚(å¦åˆ™ï¼Œä¸€ä¸ªæ—‹è½¬çš„ä¸»çº¿ç¨‹å°†ä»å·¥ä½œçº¿ç¨‹é‚£é‡Œå¤ºèµ° CPU èµ„æº!)æœ‰å…³ C + + ä¸­æ¡ä»¶å˜é‡çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚è§æˆ‘ä»¬çš„ C + + åŒæ­¥æ•™ç¨‹ã€‚\næ‚¨åœ¨è¿™éƒ¨åˆ†ä½œä¸šä¸­çš„å®ç°å¯èƒ½éœ€è¦è€ƒè™‘æ£˜æ‰‹çš„race conditions ã€‚æ‚¨éœ€è¦è€ƒè™‘è®¸å¤šå¯èƒ½çš„çº¿ç¨‹è¡Œä¸ºäº¤é”™\næ‚¨å¯èƒ½éœ€è¦è€ƒè™‘ç¼–å†™é¢å¤–çš„æµ‹è¯•ç”¨ä¾‹æ¥æµ‹è¯•æ‚¨çš„ç³»ç»Ÿã€‚èµ‹å€¼å…¥é—¨ä»£ç åŒ…æ‹¬è¯„åˆ†è„šæœ¬ç”¨äºè¯„åˆ†ä»£ç æ€§èƒ½çš„å·¥ä½œè´Ÿè½½ï¼Œä½†æ˜¯æˆ‘ä»¬ä¹Ÿå°†ä½¿ç”¨ä¸€ç»„æ›´å¹¿æ³›çš„å·¥ä½œè´Ÿè½½æ¥æµ‹è¯•æ‚¨çš„å®ç°çš„æ­£ç¡®æ€§ï¼Œè€Œæˆ‘ä»¬åœ¨å…¥é—¨ä»£ç ä¸­å¹¶æ²¡æœ‰æä¾›è¿™äº›å·¥ä½œè´Ÿè½½ï¼\nThe assignment starter code includes the workloads that the grading script will use to grade the performance of your code, but we will also test the correctness of your implementation using a wider set of workloads that we are not providing in the starter code!\ntasksys.h\n/* * TaskSystemParallelThreadPoolSleeping: This class is the student's * optimized implementation of a parallel task execution engine that uses * a thread pool. See definition of ITaskSystem in * itasksys.h for documentation of the ITaskSystem interface. */ class TaskSystemParallelThreadPoolSleeping : public ITaskSystem { public: TaskSystemParallelThreadPoolSleeping(int num_threads); ~TaskSystemParallelThreadPoolSleeping(); const char *name(); void run(IRunnable *runnable, int num_total_tasks); TaskID runAsyncWithDeps(IRunnable *runnable, int num_total_tasks, const std::vector\u003cTaskID\u003e \u0026deps); void sync(); private: std::vector\u003cstd::thread\u003e threads; int num_tasks_; bool exit_flag_; std::atomic\u003cint\u003e num_tasks_done_; std::queue\u003cint\u003e tasks_; std::mutex tasks_mutex_; IRunnable *runnable_{}; void func(); std::condition_variable *queue_condition_ = new std::condition_variable(); std::condition_variable *all_done_condition_ = new std::condition_variable(); int num_waiting_threads_; std::atomic\u003cint\u003e num_tasks_remaining_; std::mutex all_done_mutex_; }; tasksys.cpp\n/* * ================================================================ * Parallel Thread Pool Sleeping Task System Implementation * ================================================================ */ const char *TaskSystemParallelThreadPoolSleeping::name() { return \"Parallel + Thread Pool + Sleep\"; } void TaskSystemParallelThreadPoolSleeping::func() { int task_id; while (!exit_flag_) { task_id = -1; while (task_id == -1) { std::unique_lock\u003cstd::mutex\u003e lk(tasks_mutex_); // ç­‰å¾…ä»»åŠ¡ queue_condition_-\u003ewait(lk, [] { return 1; }); if (exit_flag_) { return; } if (!tasks_.empty()) { task_id = tasks_.front(); tasks_.pop(); } } runnable_-\u003erunTask(task_id, num_tasks_); num_tasks_remaining_--; if (!num_tasks_remaining_) { // é€šçŸ¥ä¸»çº¿ç¨‹ // printf(\"notify_all_done\\n\"); all_done_condition_-\u003enotify_one(); } else { // é€šçŸ¥å…¶ä»–çº¿ç¨‹ // printf(\"notify_all\\n\"); queue_condition_-\u003enotify_one(); } } } TaskSystemParallelThreadPoolSleeping::TaskSystemParallelThreadPoolSleeping(int num_threads) : ITaskSystem(num_threads) { // // TODO: CS149 student implementations may decide to perform setup // operations (such as thread pool construction) here. // Implementations are free to add new class member variables // (requiring changes to tasksys.h). // exit_flag_ = false; for (int i = 0; i \u003c num_threads; i++) { threads.emplace_back(\u0026TaskSystemParallelThreadPoolSleeping::func, this); } } TaskSystemParallelThreadPoolSleeping::~TaskSystemParallelThreadPoolSleeping() { // // TODO: CS149 student implementations may decide to perform cleanup // operations (such as thread pool shutdown construction) here. // Implementations are free to add new class member variables // (requiring changes to tasksys.h). // exit_flag_ = true; queue_condition_-\u003enotify_all(); for (auto \u0026thread : threads) { thread.join(); } } void TaskSystemParallelThreadPoolSleeping::run(IRunnable *runnable, int num_total_tasks) { // // TODO: CS149 students will modify the implementation of this // method in Parts A and B. The implementation provided below runs all // tasks sequentially on the calling thread. // runnable_ = runnable; num_tasks_ = num_total_tasks; num_tasks_remaining_ = num_total_tasks; tasks_mutex_.lock(); for (int i = 0; i \u003c num_total_tasks; i++) { tasks_.push(i); } tasks_mutex_.unlock(); // é€šçŸ¥å…¶ä»–çº¿ç¨‹ queue_condition_-\u003enotify_all(); // printf(\"run\\n\"); while (num_tasks_remaining_) { std::unique_lock\u003cstd::mutex\u003e lk2(all_done_mutex_); all_done_condition_-\u003ewait(lk2, [] { return 1; }); } // printf(\"all done\\n\"); // printf(\"all done\\n\"); } ç»“æœåˆ†æ:\nsleepå¯¹spinçš„æå‡æ•ˆæœä¸æ˜æ˜¾ï¼Œå¯èƒ½æ˜¯å› ä¸ºä»»åŠ¡å¤ªå°‘ï¼Œçº¿ç¨‹åˆ‡æ¢çš„å¼€é”€æ¯”è¾ƒå¤§.\nè¿è¡Œç»“æœ:\n================================================================================ Running task system grading harness... (11 total tests) - Detected CPU with 16 execution contexts - Task system configured to use at most 8 threads ================================================================================ ================================================================================ Executing test: super_super_light... Reference binary: ./runtasks_ref_linux Results for: super_super_light STUDENT REFERENCE PERF? [Serial] 5.281 5.788 0.91 (OK) [Parallel + Always Spawn] 95.221 92.995 1.02 (OK) [Parallel + Thread Pool + Spin] 10.877 10.446 1.04 (OK) [Parallel + Thread Pool + Sleep] 6.943 42.705 0.16 (OK) ================================================================================ Executing test: super_light... Reference binary: ./runtasks_ref_linux Results for: super_light STUDENT REFERENCE PERF? [Serial] 37.497 37.844 0.99 (OK) [Parallel + Always Spawn] 108.136 108.805 0.99 (OK) [Parallel + Thread Pool + Spin] 10.777 13.615 0.79 (OK) [Parallel + Thread Pool + Sleep] 10.274 44.686 0.23 (OK) ================================================================================ Executing test: ping_pong_equal... Reference binary: ./runtasks_ref_linux Results for: ping_pong_equal STUDENT REFERENCE PERF? [Serial] 603.419 606.739 0.99 (OK) [Parallel + Always Spawn] 167.412 178.638 0.94 (OK) [Parallel + Thread Pool + Spin] 105.983 123.525 0.86 (OK) [Parallel + Thread Pool + Sleep] 108.243 148.316 0.73 (OK) ================================================================================ Executing test: ping_pong_unequal... Reference binary: ./runtasks_ref_linux Results for: ping_pong_unequal STUDENT REFERENCE PERF? [Serial] 1126.19 1109.329 1.02 (OK) [Parallel + Always Spawn] 259.271 260.822 0.99 (OK) [Parallel + Thread Pool + Spin] 199.088 198.013 1.01 (OK) [Parallel + Thread Pool + Sleep] 198.777 214.293 0.93 (OK) ================================================================================ Executing test: recursive_fibonacci... Reference binary: ./runtasks_ref_linux Results for: recursive_fibonacci STUDENT REFERENCE PERF? [Serial] 1052.273 1128.069 0.93 (OK) [Parallel + Always Spawn] 156.014 172.113 0.91 (OK) [Parallel + Thread Pool + Spin] 156.31 171.337 0.91 (OK) [Parallel + Thread Pool + Sleep] 156.462 166.476 0.94 (OK) ================================================================================ Executing test: math_operations_in_tight_for_loop... Reference binary: ./runtasks_ref_linux Results for: math_operations_in_tight_for_loop STUDENT REFERENCE PERF? [Serial] 411.426 423.96 0.97 (OK) [Parallel + Always Spawn] 537.747 532.353 1.01 (OK) [Parallel + Thread Pool + Spin] 99.286 104.844 0.95 (OK) [Parallel + Thread Pool + Sleep] 95.817 239.76 0.40 (OK) ================================================================================ Executing test: math_operations_in_tight_for_loop_fewer_tasks... Reference binary: ./runtasks_ref_linux Results for: math_operations_in_tight_for_loop_fewer_tasks STUDENT REFERENCE PERF? [Serial] 413.681 415.961 0.99 (OK) [Parallel + Always Spawn] 514.021 505.234 1.02 (OK) [Parallel + Thread Pool + Spin] 108.644 117.702 0.92 (OK) [Parallel + Thread Pool + Sleep] 106.84 260.724 0.41 (OK) ================================================================================ Executing test: math_operations_in_tight_for_loop_fan_in... Reference binary: ./runtasks_ref_linux Results for: math_operations_in_tight_for_loop_fan_in STUDENT REFERENCE PERF? [Serial] 212.534 211.52 1.00 (OK) [Parallel + Always Spawn] 76.402 76.09 1.00 (OK) [Parallel + Thread Pool + Spin] 37.203 39.662 0.94 (OK) [Parallel + Thread Pool + Sleep] 36.523 57.039 0.64 (OK) ================================================================================ Executing test: math_operations_in_tight_for_loop_reduction_tree... Reference binary: ./runtasks_ref_linux Results for: math_operations_in_tight_for_loop_reduction_tree STUDENT REFERENCE PERF? [Serial] 208.076 207.488 1.00 (OK) [Parallel + Always Spawn] 45.054 45.227 1.00 (OK) [Parallel + Thread Pool + Spin] 33.079 33.9 0.98 (OK) [Parallel + Thread Pool + Sleep] 34.502 38.389 0.90 (OK) ================================================================================ Executing test: spin_between_run_calls... Reference binary: ./runtasks_ref_linux Results for: spin_between_run_calls STUDENT REFERENCE PERF? [Serial] 353.553 382.373 0.92 (OK) [Parallel + Always Spawn] 180.401 197.119 0.92 (OK) [Parallel + Thread Pool + Spin] 205.374 222.315 0.92 (OK) [Parallel + Thread Pool + Sleep] 214.819 197.579 1.09 (OK) ================================================================================ Executing test: mandelbrot_chunked... Reference binary: ./runtasks_ref_linux Results for: mandelbrot_chunked STUDENT REFERENCE PERF? [Serial] 257.289 256.815 1.00 (OK) [Parallel + Always Spawn] 34.395 34.058 1.01 (OK) [Parallel + Thread Pool + Spin] 34.241 34.922 0.98 (OK) [Parallel + Thread Pool + Sleep] 35.191 35.273 1.00 (OK) ================================================================================ Overall performance results [Serial] : All passed Perf [Parallel + Always Spawn] : All passed Perf [Parallel + Thread Pool + Spin] : All passed Perf [Parallel + Thread Pool + Sleep] : All passed Perf part_b åœ¨ä»»åŠ¡çš„ B éƒ¨åˆ†ä¸­ï¼Œæ‚¨å°†æ‰©å±•æ‚¨çš„ A éƒ¨åˆ†ä»»åŠ¡ç³»ç»Ÿå®ç°ï¼Œä»¥æ”¯æŒå¯èƒ½ä¾èµ–äºä»¥å‰ä»»åŠ¡çš„ä»»åŠ¡çš„å¼‚æ­¥å¯åŠ¨ã€‚è¿™äº›ä»»åŠ¡é—´ä¾èµ–å…³ç³»åˆ›å»ºäº†ä»»åŠ¡æ‰§è¡Œåº“å¿…é¡»éµå®ˆçš„è°ƒåº¦çº¦æŸã€‚\nITaskSystem æ¥å£è¿˜æœ‰ä¸€ä¸ªæ–¹æ³•:\nvirtual TaskID runAsyncWithDeps(IRunnable* runnable, int num_total_tasks, const std::vector\u003cTaskID\u003e\u0026 deps) = 0; RunAsyncWithDeps ()ç±»ä¼¼äº run () ï¼Œå› ä¸ºå®ƒä¹Ÿç”¨äºæ‰§è¡Œ num total asks ä»»åŠ¡çš„æ‰¹é‡å¯åŠ¨ã€‚ä½†æ˜¯ï¼Œå®ƒä¸ run ()åœ¨è®¸å¤šæ–¹é¢æœ‰æ‰€ä¸åŒâ€¦\nAsynchronous Task Launch é¦–å…ˆï¼Œä½¿ç”¨ runAsyncWithDeps ()åˆ›å»ºçš„ä»»åŠ¡ç”±ä»»åŠ¡ç³»ç»Ÿä¸è°ƒç”¨çº¿ç¨‹å¼‚æ­¥æ‰§è¡Œã€‚\nè¿™æ„å‘³ç€ runAsyncWithDeps ()åº”è¯¥ç«‹å³è¿”å›ç»™è°ƒç”¨æ–¹ï¼Œå³ä½¿ä»»åŠ¡å°šæœªå®Œæˆæ‰§è¡Œã€‚\nè¯¥æ–¹æ³•è¿”å›ä¸æ­¤æ‰¹é‡ä»»åŠ¡å¯åŠ¨å…³è”çš„å”¯ä¸€æ ‡è¯†ç¬¦ã€‚\nè°ƒç”¨çº¿ç¨‹å¯ä»¥é€šè¿‡è°ƒç”¨ sync ()æ¥ç¡®å®šå¤§å®¹é‡ä»»åŠ¡å¯åŠ¨çš„å®é™…å®Œæˆæ—¶é—´ã€‚\nvirtual void sync() = 0;\nåªæœ‰å½“ä¸ä¹‹å‰æ‰€æœ‰æ‰¹é‡ä»»åŠ¡å¯åŠ¨å…³è”çš„ä»»åŠ¡å®Œæˆæ—¶ï¼Œsync ()æ‰è¿”å›ç»™è°ƒç”¨æ–¹ã€‚ä¾‹å¦‚ï¼Œè€ƒè™‘ä»¥ä¸‹ä»£ç :\n// assume taskA and taskB are valid instances of IRunnable... std::vector\u003cTaskID\u003e noDeps; // empty vector ITaskSystem *t = new TaskSystem(num_threads); // bulk launch of 4 tasks TaskID launchA = t-\u003erunAsyncWithDeps(taskA, 4, noDeps); // bulk launch of 8 tasks TaskID launchB = t-\u003erunAsyncWithDeps(taskB, 8, noDeps); // at this point tasks associated with launchA and launchB // may still be running t-\u003esync(); // at this point all 12 tasks associated with launchA and launchB // are guaranteed to have terminated å¦‚ä¸Šé¢çš„æ³¨é‡Šä¸­æ‰€è¿°ï¼Œåœ¨çº¿ç¨‹è°ƒç”¨sync() runAsyncWithDeps() ) çš„ä»»åŠ¡å·²å®Œæˆã€‚ å‡†ç¡®åœ°è¯´ï¼Œ runAsyncWithDeps()å‘Šè¯‰æ‚¨çš„ä»»åŠ¡ç³»ç»Ÿæ‰§è¡Œæ–°çš„æ‰¹é‡ä»»åŠ¡å¯åŠ¨ï¼Œä½†æ‚¨çš„å®ç°å¯ä»¥çµæ´»åœ°åœ¨ä¸‹æ¬¡è°ƒç”¨sync()ä¹‹å‰éšæ—¶æ‰§è¡Œè¿™äº›ä»»åŠ¡ã€‚ è¯·æ³¨æ„ï¼Œæ­¤è§„èŒƒæ„å‘³ç€æ— æ³•ä¿è¯æ‚¨çš„å®ç°åœ¨ä» launchB å¯åŠ¨ä»»åŠ¡ä¹‹å‰å…ˆæ‰§è¡Œ launchA ä¸­çš„ä»»åŠ¡ï¼\nSupport for Explicit Dependencies runAsyncWithDeps()çš„ç¬¬äºŒä¸ªå…³é”®ç»†èŠ‚æ˜¯å®ƒçš„ç¬¬ä¸‰ä¸ªå‚æ•°ï¼šTaskID æ ‡è¯†ç¬¦å‘é‡ï¼Œå¿…é¡»å¼•ç”¨ä¹‹å‰ä½¿ç”¨runAsyncWithDeps()å¯åŠ¨çš„æ‰¹é‡ä»»åŠ¡ã€‚ è¯¥å‘é‡æŒ‡å®šå½“å‰æ‰¹é‡ä»»åŠ¡å¯åŠ¨ä¸­çš„ä»»åŠ¡æ‰€ä¾èµ–çš„å…ˆå‰ä»»åŠ¡ã€‚ å› æ­¤ï¼Œåœ¨ä¾èµ–å‘é‡ä¸­ç»™å‡ºçš„å¯åŠ¨ä¸­çš„æ‰€æœ‰ä»»åŠ¡å®Œæˆä¹‹å‰ï¼Œæ‚¨çš„ä»»åŠ¡è¿è¡Œæ—¶æ— æ³•å¼€å§‹æ‰§è¡Œå½“å‰æ‰¹é‡ä»»åŠ¡å¯åŠ¨ä¸­çš„ä»»ä½•ä»»åŠ¡ï¼ ä¾‹å¦‚ï¼Œè€ƒè™‘ä»¥ä¸‹ç¤ºä¾‹ï¼š\nstd::vector\u003cTaskID\u003e noDeps; // empty vector std::vector\u003cTaskID\u003e depOnA; std::vector\u003cTaskID\u003e depOnBC; ITaskSystem *t = new TaskSystem(num_threads); TaskID launchA = t-\u003erunAsyncWithDeps(taskA, 128, noDeps); depOnA.push_back(launchA); TaskID launchB = t-\u003erunAsyncWithDeps(taskB, 2, depOnA); TaskID launchC = t-\u003erunAsyncWithDeps(taskC, 6, depOnA); depOnBC.push_back(launchB); depOnBC.push_back(launchC); TaskID launchD = t-\u003erunAsyncWithDeps(taskD, 32, depOnBC); t-\u003esync(); ä¸Šé¢çš„ä»£ç æœ‰å››ä¸ªæ‰¹é‡ä»»åŠ¡å¯åŠ¨ï¼ˆtaskAï¼š128 ä¸ªä»»åŠ¡ï¼ŒtaskBï¼š2 ä¸ªä»»åŠ¡ï¼ŒtaskCï¼š6 ä¸ªä»»åŠ¡ï¼ŒtaskDï¼š32 ä¸ªä»»åŠ¡ï¼‰ã€‚ è¯·æ³¨æ„ï¼Œä»»åŠ¡ B å’Œä»»åŠ¡ C çš„å¯åŠ¨å–å†³äºä»»åŠ¡ Aã€‚ taskD çš„æ‰¹é‡å¯åŠ¨ ( launchD ) å–å†³äºlaunchBå’ŒlaunchCçš„ç»“æœã€‚ å› æ­¤ï¼Œè™½ç„¶æ‚¨çš„ä»»åŠ¡è¿è¡Œæ—¶å¯ä»¥æŒ‰ä»»æ„é¡ºåºï¼ˆåŒ…æ‹¬å¹¶è¡Œï¼‰å¤„ç†ä¸launchBå’ŒlaunchCå…³è”çš„ä»»åŠ¡ï¼Œä½†è¿™äº›å¯åŠ¨ä¸­çš„æ‰€æœ‰ä»»åŠ¡å¿…é¡»åœ¨launchAçš„ä»»åŠ¡å®Œæˆåå¼€å§‹æ‰§è¡Œï¼Œå¹¶ä¸”å®ƒä»¬å¿…é¡»åœ¨è¿è¡Œæ—¶å¼€å§‹ä¹‹å‰å®Œæˆä»launchDæ‰§è¡Œä»»ä½•ä»»åŠ¡ã€‚\næˆ‘ä»¬å¯ä»¥é€šè¿‡ä»»åŠ¡å›¾ç›´è§‚åœ°è¯´æ˜è¿™äº›ä¾èµ–å…³ç³»ã€‚ ä»»åŠ¡å›¾æ˜¯æœ‰å‘æ— ç¯å›¾ (DAG)ï¼Œå…¶ä¸­å›¾ä¸­çš„èŠ‚ç‚¹å¯¹åº”äºæ‰¹é‡ä»»åŠ¡å¯åŠ¨ï¼Œä»èŠ‚ç‚¹ X åˆ°èŠ‚ç‚¹ Y çš„è¾¹è¡¨ç¤º Y å¯¹ X è¾“å‡ºçš„ä¾èµ–å…³ç³»ã€‚ä¸Šè¿°ä»£ç çš„ä»»åŠ¡å›¾æ˜¯ï¼š è¯·æ³¨æ„ï¼Œå¦‚æœæ‚¨åœ¨å…·æœ‰å…«ä¸ªæ‰§è¡Œä¸Šä¸‹æ–‡çš„ Myth è®¡ç®—æœºä¸Šè¿è¡Œä¸Šé¢çš„ç¤ºä¾‹ï¼Œåˆ™å¹¶è¡Œè°ƒåº¦launchBå’ŒlaunchCä¸­çš„ä»»åŠ¡çš„èƒ½åŠ›å¯èƒ½éå¸¸æœ‰ç”¨ï¼Œå› ä¸ºå•ç‹¬çš„æ‰¹é‡ä»»åŠ¡å¯åŠ¨éƒ½ä¸è¶³ä»¥ä½¿ç”¨æ‰€æœ‰æ‰§è¡Œæœºå™¨çš„èµ„æºã€‚\nTask æ‚¨å¿…é¡»ä» A éƒ¨åˆ†æ‰©å±•ä»»åŠ¡ç³»ç»Ÿå®ç°ï¼Œæ‰èƒ½æ­£ç¡®å®ç°TaskSystem::runAsyncWithDeps()å’ŒTaskSystem::sync() ã€‚ ä¸ A éƒ¨åˆ†ä¸€æ ·ï¼Œæˆ‘ä»¬ä¸ºæ‚¨æä¾›ä»¥ä¸‹å…¥é—¨æç¤ºï¼š\nIt may be helpful to think about the behavior of runAsyncWithDeps() as pushing a record corresponding to the bulk task launch, or perhaps records corresponding to each of the tasks in the bulk task launch onto a â€œwork queueâ€. Once the record to work to do is in the queue, runAsyncWithDeps() can return to the caller. The trick in this part of the assignment is performing the appropriate bookkeeping to track dependencies. What must be done when all the tasks in a bulk task launch complete? (This is the point when new tasks may become available to run.) It can be helpful to have two data structures in your implementation: (1) a structure representing tasks that have been added to the system via a call to runAsyncWithDeps(), but are not yet ready to execute because they depend on tasks that are still running (these tasks are â€œwaitingâ€ for others to finish) and (2) a â€œready queueâ€ of tasks that are not waiting on any prior tasks to finish and can safely be run as soon as a worker thread is available to process them. You need not worry about integer wrap around when generating unique task launch ids. We will not hit your task system with over 2^31 bulk task launches. You can assume all programs will either call only run() or only runAsyncWithDeps(); that is, you do not need to handle the case where a run() call needs to wait for all proceeding calls to runAsyncWithDeps() to finish. åœ¨part_b/å­ç›®å½•ä¸­å®ç°Béƒ¨åˆ†å®ç°ï¼Œä»¥ä¸æ­£ç¡®çš„å‚è€ƒå®ç°ï¼ˆ part_b/runtasks_ref_* ï¼‰è¿›è¡Œæ¯”è¾ƒã€‚\n","wordCount":"4588","inLanguage":"zh","datePublished":"2023-12-18T00:00:00Z","dateModified":"2024-01-11T00:00:00Z","author":[{"@type":"Person","name":"Ysyy"}],"mainEntityOfPage":{"@type":"WebPage","@id":"/posts/cmu-15418cs-618/asst2/"},"publisher":{"@type":"Organization","name":"ysyy's blog","logo":{"@type":"ImageObject","url":"img/Q.gif"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href accesskey=h title="Ysyy's Blog (Alt + H)"><img src=img/Q.gif alt aria-label=logo height=35>Ysyy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=search title="ğŸ” æœç´¢ (Alt + /)" accesskey=/><span>ğŸ” æœç´¢</span></a></li><li><a href=/ title="ğŸ  ä¸»é¡µ"><span>ğŸ  ä¸»é¡µ</span></a></li><li><a href=posts title="ğŸ“š æ–‡ç« "><span>ğŸ“š æ–‡ç« </span></a></li><li><a href=tags title="ğŸ§© æ ‡ç­¾"><span>ğŸ§© æ ‡ç­¾</span></a></li><li><a href=archives/ title="â±ï¸ æ—¶é—´è½´"><span>â±ï¸ æ—¶é—´è½´</span></a></li><li><a href=about title="ğŸ™‹ğŸ»â€â™‚ï¸ å…³äº"><span>ğŸ™‹ğŸ»â€â™‚ï¸ å…³äº</span></a></li><li><a href=links title="ğŸ¤ å‹é“¾"><span>ğŸ¤ å‹é“¾</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href>ä¸»é¡µ</a>&nbsp;Â»&nbsp;<a href=/posts/>Posts</a></div><h1 class=post-title>asst2</h1><div class=post-meta>&lt;span title='2023-12-18 00:00:00 +0000 UTC'>2023-12-18&lt;/span>&amp;nbsp;Â·&amp;nbsp;10 åˆ†é’Ÿ&amp;nbsp;Â·&amp;nbsp;Ysyy</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>ç›®å½•</span></summary><div class=inner><ul><li><a href=#c-sync aria-label="C++ Sync">C++ Sync</a><ul><li><a href=#thread%e7%9a%84%e4%bd%bf%e7%94%a8 aria-label=threadçš„ä½¿ç”¨>threadçš„ä½¿ç”¨</a></li><li><a href=#mutex aria-label=mutex>mutex</a></li><li><a href=#condition_variable aria-label=condition_variable>condition_variable</a></li></ul></li><li><a href=#part_a aria-label=part_a>part_a</a><ul><li><a href=#step-1-%e5%ae%9e%e7%8e%b0tasksystemparallelspawn aria-label="step 1 å®ç°TaskSystemParallelSpawn">step 1 å®ç°TaskSystemParallelSpawn</a></li><li><a href=#step-2-%e5%ae%9e%e7%8e%b0--tasksystemparallelthreadpoolspinning aria-label="step 2 å®ç°  TaskSystemParallelThreadPoolSpinning">step 2 å®ç° TaskSystemParallelThreadPoolSpinning</a></li><li><a href=#step-3-%e5%ae%9e%e7%8e%b0-tasksystemparallelthreadpoolsleeping aria-label="step 3 å®ç° TaskSystemParallelThreadPoolSleeping">step 3 å®ç° TaskSystemParallelThreadPoolSleeping</a></li></ul></li><li><a href=#part_b aria-label=part_b>part_b</a><ul><li><a href=#asynchronous-task-launch aria-label="Asynchronous Task Launch">Asynchronous Task Launch</a></li><li><a href=#support-for-explicit-dependencies aria-label="Support for Explicit Dependencies">Support for Explicit Dependencies</a></li><li><a href=#task aria-label=Task>Task</a></li></ul></li></ul></div></details></div><div class=post-content><h2 id=c-sync>C++ Sync<a hidden class=anchor aria-hidden=true href=#c-sync>#</a></h2><h3 id=threadçš„ä½¿ç”¨>threadçš„ä½¿ç”¨<a hidden class=anchor aria-hidden=true href=#threadçš„ä½¿ç”¨>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;thread&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>my_func</span>(<span style=color:#66d9ef>int</span> thread_id, <span style=color:#66d9ef>int</span> num_threads) {
</span></span><span style=display:flex><span> printf(<span style=color:#e6db74>&#34;Hello from spawned thread %d of %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, thread_id, num_threads);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span><span style=color:#f92672>**</span> argv) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  std<span style=color:#f92672>::</span><span style=color:#66d9ef>thread</span> t0 <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span><span style=color:#66d9ef>thread</span>(my_func, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>  std<span style=color:#f92672>::</span><span style=color:#66d9ef>thread</span> t1 <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span><span style=color:#66d9ef>thread</span>(my_func, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  printf(<span style=color:#e6db74>&#34;The main thread is running concurrently with spawned threads.</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  t0.join();
</span></span><span style=display:flex><span>  t1.join();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  printf(<span style=color:#e6db74>&#34;Spawned threads have terminated at this point.</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=mutex>mutex<a hidden class=anchor aria-hidden=true href=#mutex>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;chrono&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;map&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;mutex&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;thread&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> 
</span></span><span style=display:flex><span>std<span style=color:#f92672>::</span>map<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>string, std<span style=color:#f92672>::</span>string<span style=color:#f92672>&gt;</span> g_pages;
</span></span><span style=display:flex><span>std<span style=color:#f92672>::</span>mutex g_pages_mutex;
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>save_page</span>(<span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>string<span style=color:#f92672>&amp;</span> url)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// simulate a long page fetch
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>this_thread<span style=color:#f92672>::</span>sleep_for(std<span style=color:#f92672>::</span>chrono<span style=color:#f92672>::</span>seconds(<span style=color:#ae81ff>2</span>));
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>string result <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;fake content&#34;</span>;
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>lock_guard<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>mutex<span style=color:#f92672>&gt;</span> guard(g_pages_mutex);
</span></span><span style=display:flex><span>    g_pages[url] <span style=color:#f92672>=</span> result;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() 
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span><span style=color:#66d9ef>thread</span> t1(save_page, <span style=color:#e6db74>&#34;http://foo&#34;</span>);
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span><span style=color:#66d9ef>thread</span> t2(save_page, <span style=color:#e6db74>&#34;http://bar&#34;</span>);
</span></span><span style=display:flex><span>    t1.join();
</span></span><span style=display:flex><span>    t2.join();
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>    <span style=color:#75715e>// safe to access g_pages without lock now, as the threads are joined
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> pair : g_pages)
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> pair.first <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; =&gt; &#34;</span> <span style=color:#f92672>&lt;&lt;</span> pair.second <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Output</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>http://bar <span style=color:#f92672>=</span>&gt; fake content
</span></span><span style=display:flex><span>http://foo <span style=color:#f92672>=</span>&gt; fake content
</span></span></code></pre></div><h3 id=condition_variable>condition_variable<a hidden class=anchor aria-hidden=true href=#condition_variable>#</a></h3><p>çº¿ç¨‹è°ƒç”¨ wait (lock)æ¥æŒ‡ç¤ºå®ƒå¸Œæœ›ç­‰å¾…æ¥è‡ªå¦ä¸€ä¸ªçº¿ç¨‹çš„é€šçŸ¥ã€‚</p><p>æ³¨æ„ï¼Œäº’æ–¥å¯¹è±¡(åŒ…è£…åœ¨ std: : only _ lock ä¸­)è¢«ä¼ é€’ç»™ wait ()è°ƒç”¨ã€‚å½“é€šçŸ¥çº¿ç¨‹æ—¶ï¼Œæ¡ä»¶å˜é‡å°†è·å¾—é”ã€‚</p><p>è¿™æ„å‘³ç€å½“è°ƒç”¨ wait ()è¿”å›æ—¶ï¼Œè°ƒç”¨çº¿ç¨‹æ˜¯é”çš„å½“å‰æŒæœ‰è€…ã€‚é”é€šå¸¸ç”¨äºä¿æŠ¤çº¿ç¨‹ç°åœ¨éœ€è¦æ£€æŸ¥çš„å…±äº«å˜é‡ï¼Œä»¥ç¡®ä¿å®ƒæ­£åœ¨ç­‰å¾…çš„æ¡ä»¶ä¸ºçœŸã€‚</p><p>åˆ›å»º N ä¸ªçº¿ç¨‹ã€‚N-1ä¸ªçº¿ç¨‹ç­‰å¾…æ¥è‡ªçº¿ç¨‹0çš„é€šçŸ¥ï¼Œç„¶ååœ¨æ¥åˆ°é€šçŸ¥åï¼Œè‡ªåŠ¨é€’å¢ä¸€ä¸ªå—å…±äº«äº’æ–¥é”ä¿æŠ¤çš„è®¡æ•°å™¨ã€‚</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Wrapper class around a counter, a condition variable, and a mutex.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ThreadState</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>condition_variable <span style=color:#f92672>*</span>condition_variable_;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>mutex <span style=color:#f92672>*</span>mutex_;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> counter_;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> num_waiting_threads_;
</span></span><span style=display:flex><span>    ThreadState(<span style=color:#66d9ef>int</span> num_waiting_threads)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        condition_variable_ <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> std<span style=color:#f92672>::</span>condition_variable();
</span></span><span style=display:flex><span>        mutex_ <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> std<span style=color:#f92672>::</span>mutex();
</span></span><span style=display:flex><span>        counter_ <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        num_waiting_threads_ <span style=color:#f92672>=</span> num_waiting_threads;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#f92672>~</span>ThreadState()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>delete</span> condition_variable_;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>delete</span> mutex_;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>signal_fn</span>(ThreadState <span style=color:#f92672>*</span>thread_state)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Acquire mutex to make sure the shared counter is read in a
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// consistent state.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    thread_state<span style=color:#f92672>-&gt;</span>mutex_<span style=color:#f92672>-&gt;</span>lock();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (thread_state<span style=color:#f92672>-&gt;</span>counter_ <span style=color:#f92672>&lt;</span> thread_state<span style=color:#f92672>-&gt;</span>num_waiting_threads_)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        thread_state<span style=color:#f92672>-&gt;</span>mutex_<span style=color:#f92672>-&gt;</span>unlock();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Release the mutex before calling `notify_all()` to make sure
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// waiting threads have a chance to make progress.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        thread_state<span style=color:#f92672>-&gt;</span>condition_variable_<span style=color:#f92672>-&gt;</span>notify_all();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Re-acquire the mutex to read the shared counter again.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        thread_state<span style=color:#f92672>-&gt;</span>mutex_<span style=color:#f92672>-&gt;</span>lock();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    thread_state<span style=color:#f92672>-&gt;</span>mutex_<span style=color:#f92672>-&gt;</span>unlock();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>wait_fn</span>(ThreadState <span style=color:#f92672>*</span>thread_state)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// A lock must be held in order to wait on a condition variable.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// This lock is atomically released before the thread goes to sleep
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// when `wait()` is called. The lock is atomically re-acquired when
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// the thread is woken up using `notify_all()`.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>unique_lock<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>mutex<span style=color:#f92672>&gt;</span> lk(<span style=color:#f92672>*</span>thread_state<span style=color:#f92672>-&gt;</span>mutex_);
</span></span><span style=display:flex><span>    thread_state<span style=color:#f92672>-&gt;</span>condition_variable_<span style=color:#f92672>-&gt;</span>wait(lk);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Increment the shared counter with the lock re-acquired to inform the
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// signaling thread that this waiting thread has successfully been
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// woken up.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    thread_state<span style=color:#f92672>-&gt;</span>counter_<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;Lock re-acquired after wait()...</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    lk.unlock();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Signaling thread spins until each waiting thread increments a shared
</span></span></span><span style=display:flex><span><span style=color:#75715e> * counter after being woken up from the `wait()` method.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>condition_variable_example</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> num_threads <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;==============================================================</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;Starting %d threads for signal-and-waiting...</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, num_threads);
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span><span style=color:#66d9ef>thread</span> <span style=color:#f92672>*</span>threads <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> std<span style=color:#f92672>::</span><span style=color:#66d9ef>thread</span>[num_threads];
</span></span><span style=display:flex><span>    ThreadState <span style=color:#f92672>*</span>thread_state <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ThreadState(num_threads <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    threads[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span><span style=color:#66d9ef>thread</span>(signal_fn, thread_state);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;</span> num_threads; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        threads[i] <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span><span style=color:#66d9ef>thread</span>(wait_fn, thread_state);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> num_threads; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        threads[i].join();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;==============================================================</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>delete</span> thread_state;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>delete</span>[] threads;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=part_a>part_a<a hidden class=anchor aria-hidden=true href=#part_a>#</a></h2><h3 id=step-1-å®ç°tasksystemparallelspawn>step 1 å®ç°TaskSystemParallelSpawn<a hidden class=anchor aria-hidden=true href=#step-1-å®ç°tasksystemparallelspawn>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>void</span> TaskSystemParallelSpawn<span style=color:#f92672>::</span>run(IRunnable <span style=color:#f92672>*</span>runnable, <span style=color:#66d9ef>int</span> num_total_tasks)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// TODO: CS149 students will modify the implementation of this
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// method in Part A.  The implementation provided below runs all
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// tasks sequentially on the calling thread.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>atomic<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> taskId(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> num_threads <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>num_threads;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span><span style=color:#66d9ef>thread</span> threads[num_threads];
</span></span><span style=display:flex><span>    <span style=color:#75715e>// äº¤å‰åˆ†é…ä»»åŠ¡
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> num_threads; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        threads[i] <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span><span style=color:#66d9ef>thread</span>([<span style=color:#f92672>&amp;</span>, i]()
</span></span><span style=display:flex><span>                                 {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>int</span> task_id <span style=color:#f92672>=</span> taskId.fetch_add(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>while</span> (task_id <span style=color:#f92672>&lt;</span> num_total_tasks)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    runnable<span style=color:#f92672>-&gt;</span>runTask(task_id, num_total_tasks);
</span></span><span style=display:flex><span>                    task_id <span style=color:#f92672>=</span> taskId.fetch_add(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>                } });
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> num_threads; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        threads[i].join();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// printf(&#34;done\n&#34;);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>Q:How will you assign tasks to your worker threads? Should you consider static or dynamic assignment of tasks to threads?
A:äº¤å‰åˆ†é…ä»»åŠ¡ï¼ŒåŠ¨æ€åˆ†é…ä»»åŠ¡</p><p>Q:How will you ensure that all tasks are executed exactly once?
A:ä½¿ç”¨åŸå­å˜é‡taskId</p><h3 id=step-2-å®ç°--tasksystemparallelthreadpoolspinning>step 2 å®ç° TaskSystemParallelThreadPoolSpinning<a hidden class=anchor aria-hidden=true href=#step-2-å®ç°--tasksystemparallelthreadpoolspinning>#</a></h3><p>step1 çš„overheadä¸»è¦æ˜¯åˆ›å»ºçº¿ç¨‹çš„å¼€é”€(å°¤å…¶æ˜¯è®¡ç®—é‡ä½çš„ä»»åŠ¡ä¸Š)ï¼Œå› æ­¤ä½¿ç”¨çº¿ç¨‹æ± å¯ä»¥å‡å°‘å¼€é”€</p><p>è¦æ±‚: åœ¨TestSystem åˆ›å»ºæ—¶,æˆ–è€…åœ¨runæ—¶åˆ›å»ºçº¿ç¨‹æ± </p><p>Q1: ä½œä¸ºä¸€ä¸ªå¼€å§‹çš„å®ç°ï¼Œæˆ‘ä»¬å»ºè®®æ‚¨å°†worker threadsè®¾è®¡ä¸ºè¿ç»­å¾ªç¯ï¼Œå§‹ç»ˆæ£€æŸ¥å®ƒä»¬æ˜¯å¦æœ‰æ›´å¤šçš„å·¥ä½œè¦æ‰§è¡Œã€‚(è¿›å…¥ while å¾ªç¯ç›´åˆ°æ¡ä»¶ä¸ºçœŸçš„çº¿ç¨‹é€šå¸¸ç§°ä¸ºâ€œspinningâ€)
é‚£ä¹ˆworker thread å¦‚ä½•ç¡®å®šæœ‰workè¦æ‰§è¡Œå‘¢ï¼Ÿ</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>TaskSystemParallelThreadPoolSpinning<span style=color:#f92672>::</span>TaskSystemParallelThreadPoolSpinning(<span style=color:#66d9ef>int</span> num_threads) <span style=color:#f92672>:</span> ITaskSystem(num_threads)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// TODO: CS149 student implementations may decide to perform setup
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// operations (such as thread pool construction) here.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Implementations are free to add new class member variables
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// (requiring changes to tasksys.h).
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    exit_flag_ <span style=color:#f92672>=</span> false;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> num_threads; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        threads.emplace_back(<span style=color:#f92672>&amp;</span>TaskSystemParallelThreadPoolSpinning<span style=color:#f92672>::</span>func, <span style=color:#66d9ef>this</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>TaskSystemParallelThreadPoolSpinning<span style=color:#f92672>::~</span>TaskSystemParallelThreadPoolSpinning()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    exit_flag_ <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>thread</span> <span style=color:#f92672>:</span> threads)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>thread</span>.join();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> TaskSystemParallelThreadPoolSpinning<span style=color:#f92672>::</span>run(IRunnable <span style=color:#f92672>*</span>runnable, <span style=color:#66d9ef>int</span> num_total_tasks)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// TODO: CS149 students will modify the implementation of this
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// method in Part A.  The implementation provided below runs all
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// tasks sequentially on the calling thread.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// printf(&#34;run\n&#34;);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    runnable_ <span style=color:#f92672>=</span> runnable;
</span></span><span style=display:flex><span>    num_tasks_ <span style=color:#f92672>=</span> num_total_tasks;
</span></span><span style=display:flex><span>    num_tasks_done_ <span style=color:#f92672>=</span> num_total_tasks;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> num_total_tasks; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        tasks_mutex_.lock();
</span></span><span style=display:flex><span>        tasks_.push(i);
</span></span><span style=display:flex><span>        tasks_mutex_.unlock();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (num_tasks_done_ <span style=color:#f92672>&lt;</span> num_total_tasks)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>this_thread<span style=color:#f92672>::</span>yield();
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Q:ä¸ºä»€ä¹ˆè¦ä½¿ç”¨yield
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// A:å› ä¸ºå¦‚æœä¸ä½¿ç”¨yieldï¼Œé‚£ä¹ˆçº¿ç¨‹ä¼šä¸€ç›´å ç”¨CPUï¼Œå¯¼è‡´å…¶ä»–çº¿ç¨‹æ— æ³•è¿è¡Œ
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Q:é‚£æˆ‘ç›´æ¥æ­»å¾ªç¯å‘¢
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// A:æ­»å¾ªç¯ä¼šå¯¼è‡´CPUå ç”¨ç‡100%ï¼Œå¯¼è‡´å…¶ä»–çº¿ç¨‹æ— æ³•è¿è¡Œ
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>Q2:ç¡®ä¿ run ()å®ç°æ‰€éœ€çš„åŒæ­¥è¡Œä¸ºæ˜¯éå¸¸é‡è¦çš„ã€‚å¦‚ä½•æ›´æ”¹ run ()çš„å®ç°ä»¥ç¡®å®šæ‰¹é‡ä»»åŠ¡å¯åŠ¨ä¸­çš„æ‰€æœ‰ä»»åŠ¡éƒ½å·²å®Œæˆï¼Ÿ
A:ä½¿ç”¨åŸå­å˜é‡num_tasks_done_ï¼Œæ¯ä¸ªä»»åŠ¡å®Œæˆæ—¶ï¼Œnum_tasks_done_åŠ ä¸€ï¼Œå½“num_tasks_done_ç­‰äºnum_total_tasksæ—¶ï¼Œæ‰€æœ‰ä»»åŠ¡å®Œæˆ</p><h3 id=step-3-å®ç°-tasksystemparallelthreadpoolsleeping>step 3 å®ç° TaskSystemParallelThreadPoolSleeping<a hidden class=anchor aria-hidden=true href=#step-3-å®ç°-tasksystemparallelthreadpoolsleeping>#</a></h3><p>Step2çš„ç¼ºç‚¹ï¼š
å½“çº¿ç¨‹â€œspinâ€ç­‰å¾…æŸäº›æ“ä½œæ—¶ï¼Œå®ƒä»¬ä¼šåˆ©ç”¨ CPU æ ¸å¿ƒçš„æ‰§è¡Œèµ„æºã€‚</p><ul><li>ä¾‹å¦‚ï¼Œå·¥ä½œçº¿ç¨‹å¯èƒ½ä¼šå¾ªç¯ç­‰å¾…æ–°ä»»åŠ¡åˆ°è¾¾ã€‚</li><li>å¦ä¸€ä¸ªä¾‹å­æ˜¯ï¼Œä¸»çº¿ç¨‹å¯èƒ½ä¼šå¾ªç¯ç­‰å¾…è¾…åŠ©çº¿ç¨‹å®Œæˆæ‰€æœ‰ä»»åŠ¡ï¼Œè¿™æ ·å®ƒå°±å¯ä»¥ä» run ()è°ƒç”¨è¿”å›ã€‚</li></ul><p>è¿™å¯èƒ½ä¼šå½±å“æ€§èƒ½ï¼Œå› ä¸ºå³ä½¿è¿™äº›çº¿ç¨‹æ²¡æœ‰åšæœ‰ç”¨çš„å·¥ä½œï¼Œä¹Ÿä¼šä½¿ç”¨ CPU èµ„æºæ¥è¿è¡Œè¿™äº›çº¿ç¨‹ã€‚</p><p>åœ¨ä»»åŠ¡çš„è¿™ä¸€éƒ¨åˆ†ä¸­ï¼Œæˆ‘ä»¬å¸Œæœ›æ‚¨é€šè¿‡è®©çº¿ç¨‹å¤„äºä¼‘çœ çŠ¶æ€æ¥æé«˜ä»»åŠ¡ç³»ç»Ÿçš„æ•ˆç‡ï¼Œç›´åˆ°å®ƒä»¬æ‰€ç­‰å¾…çš„æ¡ä»¶å¾—åˆ°æ»¡è¶³ã€‚</p><p>æ‚¨çš„å®ç°å¯ä»¥é€‰æ‹©ä½¿ç”¨æ¡ä»¶å˜é‡æ¥å®ç°æ­¤è¡Œä¸ºã€‚æ¡ä»¶å˜é‡æ˜¯ä¸€ä¸ªåŒæ­¥åŸè¯­ï¼Œå®ƒå…è®¸çº¿ç¨‹åœ¨ç­‰å¾…æ¡ä»¶å­˜åœ¨æ—¶ä¼‘çœ (ä¸å ç”¨ CPU å¤„ç†èµ„æº)ã€‚å…¶ä»–çº¿ç¨‹å‘ç­‰å¾…å”¤é†’çš„çº¿ç¨‹å‘å‡ºâ€œä¿¡å·â€ï¼Œä»¥æŸ¥çœ‹å®ƒä»¬æ‰€ç­‰å¾…çš„æ¡ä»¶æ˜¯å¦å·²ç»æ»¡è¶³ã€‚ä¾‹å¦‚ï¼Œå¦‚æœæ²¡æœ‰å·¥ä½œè¦åšï¼Œæ‚¨çš„å·¥ä½œçº¿ç¨‹å¯èƒ½ä¼šå¤„äºä¼‘çœ çŠ¶æ€(è¿™æ ·å®ƒä»¬å°±ä¸ä¼šä»å°è¯•æ‰§è¡Œæœ‰ç”¨å·¥ä½œçš„çº¿ç¨‹é‚£é‡Œå ç”¨ CPU èµ„æº)ã€‚å¦ä¸€ä¸ªä¾‹å­æ˜¯ï¼Œè°ƒç”¨ run ()çš„ä¸»åº”ç”¨ç¨‹åºçº¿ç¨‹å¯èƒ½å¸Œæœ›åœ¨ç­‰å¾…æ‰¹é‡ä»»åŠ¡å¯åŠ¨ä¸­çš„æ‰€æœ‰ä»»åŠ¡ç”±å·¥ä½œçº¿ç¨‹å®Œæˆæ—¶ä¼‘çœ ã€‚(å¦åˆ™ï¼Œä¸€ä¸ªæ—‹è½¬çš„ä¸»çº¿ç¨‹å°†ä»å·¥ä½œçº¿ç¨‹é‚£é‡Œå¤ºèµ° CPU èµ„æº!)æœ‰å…³ C + + ä¸­æ¡ä»¶å˜é‡çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚è§æˆ‘ä»¬çš„ C + + åŒæ­¥æ•™ç¨‹ã€‚</p><p>æ‚¨åœ¨è¿™éƒ¨åˆ†ä½œä¸šä¸­çš„å®ç°å¯èƒ½éœ€è¦è€ƒè™‘æ£˜æ‰‹çš„race conditions ã€‚æ‚¨éœ€è¦è€ƒè™‘è®¸å¤šå¯èƒ½çš„çº¿ç¨‹è¡Œä¸ºäº¤é”™</p><p>æ‚¨å¯èƒ½éœ€è¦è€ƒè™‘ç¼–å†™é¢å¤–çš„æµ‹è¯•ç”¨ä¾‹æ¥æµ‹è¯•æ‚¨çš„ç³»ç»Ÿã€‚èµ‹å€¼å…¥é—¨ä»£ç åŒ…æ‹¬è¯„åˆ†è„šæœ¬ç”¨äºè¯„åˆ†ä»£ç æ€§èƒ½çš„å·¥ä½œè´Ÿè½½ï¼Œä½†æ˜¯æˆ‘ä»¬ä¹Ÿå°†ä½¿ç”¨ä¸€ç»„æ›´å¹¿æ³›çš„å·¥ä½œè´Ÿè½½æ¥æµ‹è¯•æ‚¨çš„å®ç°çš„æ­£ç¡®æ€§ï¼Œè€Œæˆ‘ä»¬åœ¨å…¥é—¨ä»£ç ä¸­å¹¶æ²¡æœ‰æä¾›è¿™äº›å·¥ä½œè´Ÿè½½ï¼</p><p>The assignment starter code includes the workloads that the grading script will use to grade the performance of your code, but we will also test the correctness of your implementation using a wider set of workloads that we are not providing in the starter code!</p><p>tasksys.h</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * TaskSystemParallelThreadPoolSleeping: This class is the student&#39;s
</span></span></span><span style=display:flex><span><span style=color:#75715e> * optimized implementation of a parallel task execution engine that uses
</span></span></span><span style=display:flex><span><span style=color:#75715e> * a thread pool. See definition of ITaskSystem in
</span></span></span><span style=display:flex><span><span style=color:#75715e> * itasksys.h for documentation of the ITaskSystem interface.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TaskSystemParallelThreadPoolSleeping</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> ITaskSystem
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    TaskSystemParallelThreadPoolSleeping(<span style=color:#66d9ef>int</span> num_threads);
</span></span><span style=display:flex><span>    <span style=color:#f92672>~</span>TaskSystemParallelThreadPoolSleeping();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>name</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>(IRunnable <span style=color:#f92672>*</span>runnable, <span style=color:#66d9ef>int</span> num_total_tasks);
</span></span><span style=display:flex><span>    TaskID <span style=color:#a6e22e>runAsyncWithDeps</span>(IRunnable <span style=color:#f92672>*</span>runnable, <span style=color:#66d9ef>int</span> num_total_tasks,
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>TaskID<span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>deps);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sync</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span><span style=color:#66d9ef>thread</span><span style=color:#f92672>&gt;</span> threads;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> num_tasks_;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> exit_flag_;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>atomic<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> num_tasks_done_;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>queue<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> tasks_;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>mutex tasks_mutex_;
</span></span><span style=display:flex><span>    IRunnable <span style=color:#f92672>*</span>runnable_{};
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>func</span>();
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>condition_variable <span style=color:#f92672>*</span>queue_condition_ <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> std<span style=color:#f92672>::</span>condition_variable();
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>condition_variable <span style=color:#f92672>*</span>all_done_condition_ <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> std<span style=color:#f92672>::</span>condition_variable();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> num_waiting_threads_;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>atomic<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> num_tasks_remaining_;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>mutex all_done_mutex_;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>tasksys.cpp</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * ================================================================
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Parallel Thread Pool Sleeping Task System Implementation
</span></span></span><span style=display:flex><span><span style=color:#75715e> * ================================================================
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>TaskSystemParallelThreadPoolSleeping<span style=color:#f92672>::</span>name()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;Parallel + Thread Pool + Sleep&#34;</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> TaskSystemParallelThreadPoolSleeping<span style=color:#f92672>::</span>func()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> task_id;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>exit_flag_)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        task_id <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (task_id <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            std<span style=color:#f92672>::</span>unique_lock<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>mutex<span style=color:#f92672>&gt;</span> lk(tasks_mutex_);
</span></span><span style=display:flex><span>            <span style=color:#75715e>// ç­‰å¾…ä»»åŠ¡
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            queue_condition_<span style=color:#f92672>-&gt;</span>wait(lk, []
</span></span><span style=display:flex><span>                                   { <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>; });
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (exit_flag_)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>tasks_.empty())
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                task_id <span style=color:#f92672>=</span> tasks_.front();
</span></span><span style=display:flex><span>                tasks_.pop();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        runnable_<span style=color:#f92672>-&gt;</span>runTask(task_id, num_tasks_);
</span></span><span style=display:flex><span>        num_tasks_remaining_<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>num_tasks_remaining_)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// é€šçŸ¥ä¸»çº¿ç¨‹
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// printf(&#34;notify_all_done\n&#34;);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            all_done_condition_<span style=color:#f92672>-&gt;</span>notify_one();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// é€šçŸ¥å…¶ä»–çº¿ç¨‹
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// printf(&#34;notify_all\n&#34;);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            queue_condition_<span style=color:#f92672>-&gt;</span>notify_one();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>TaskSystemParallelThreadPoolSleeping<span style=color:#f92672>::</span>TaskSystemParallelThreadPoolSleeping(<span style=color:#66d9ef>int</span> num_threads) <span style=color:#f92672>:</span> ITaskSystem(num_threads)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// TODO: CS149 student implementations may decide to perform setup
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// operations (such as thread pool construction) here.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Implementations are free to add new class member variables
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// (requiring changes to tasksys.h).
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    exit_flag_ <span style=color:#f92672>=</span> false;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> num_threads; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        threads.emplace_back(<span style=color:#f92672>&amp;</span>TaskSystemParallelThreadPoolSleeping<span style=color:#f92672>::</span>func, <span style=color:#66d9ef>this</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>TaskSystemParallelThreadPoolSleeping<span style=color:#f92672>::~</span>TaskSystemParallelThreadPoolSleeping()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// TODO: CS149 student implementations may decide to perform cleanup
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// operations (such as thread pool shutdown construction) here.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Implementations are free to add new class member variables
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// (requiring changes to tasksys.h).
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    exit_flag_ <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>    queue_condition_<span style=color:#f92672>-&gt;</span>notify_all();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>thread</span> <span style=color:#f92672>:</span> threads)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>thread</span>.join();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> TaskSystemParallelThreadPoolSleeping<span style=color:#f92672>::</span>run(IRunnable <span style=color:#f92672>*</span>runnable, <span style=color:#66d9ef>int</span> num_total_tasks)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// TODO: CS149 students will modify the implementation of this
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// method in Parts A and B.  The implementation provided below runs all
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// tasks sequentially on the calling thread.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    runnable_ <span style=color:#f92672>=</span> runnable;
</span></span><span style=display:flex><span>    num_tasks_ <span style=color:#f92672>=</span> num_total_tasks;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    num_tasks_remaining_ <span style=color:#f92672>=</span> num_total_tasks;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    tasks_mutex_.lock();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> num_total_tasks; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        tasks_.push(i);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    tasks_mutex_.unlock();
</span></span><span style=display:flex><span>    <span style=color:#75715e>// é€šçŸ¥å…¶ä»–çº¿ç¨‹
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    queue_condition_<span style=color:#f92672>-&gt;</span>notify_all();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// printf(&#34;run\n&#34;);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (num_tasks_remaining_)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>unique_lock<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>mutex<span style=color:#f92672>&gt;</span> lk2(all_done_mutex_);
</span></span><span style=display:flex><span>        all_done_condition_<span style=color:#f92672>-&gt;</span>wait(lk2, []
</span></span><span style=display:flex><span>                                  { <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>; });
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// printf(&#34;all done\n&#34;);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// printf(&#34;all done\n&#34;);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>ç»“æœåˆ†æ:</p><p>sleepå¯¹spinçš„æå‡æ•ˆæœä¸æ˜æ˜¾ï¼Œå¯èƒ½æ˜¯å› ä¸ºä»»åŠ¡å¤ªå°‘ï¼Œçº¿ç¨‹åˆ‡æ¢çš„å¼€é”€æ¯”è¾ƒå¤§.</p><p>è¿è¡Œç»“æœ:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#f92672>================================================================================</span>
</span></span><span style=display:flex><span>Running task system grading harness... <span style=color:#f92672>(</span><span style=color:#ae81ff>11</span> total tests<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  - Detected CPU with <span style=color:#ae81ff>16</span> execution contexts
</span></span><span style=display:flex><span>  - Task system configured to use at most <span style=color:#ae81ff>8</span> threads
</span></span><span style=display:flex><span><span style=color:#f92672>================================================================================</span>
</span></span><span style=display:flex><span><span style=color:#f92672>================================================================================</span>
</span></span><span style=display:flex><span>Executing test: super_super_light...
</span></span><span style=display:flex><span>Reference binary: ./runtasks_ref_linux
</span></span><span style=display:flex><span>Results <span style=color:#66d9ef>for</span>: super_super_light
</span></span><span style=display:flex><span>                                        STUDENT   REFERENCE   PERF?
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Serial<span style=color:#f92672>]</span>                                5.281     5.788       0.91  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Always Spawn<span style=color:#f92672>]</span>               95.221    92.995      1.02  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Thread Pool + Spin<span style=color:#f92672>]</span>         10.877    10.446      1.04  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Thread Pool + Sleep<span style=color:#f92672>]</span>        6.943     42.705      0.16  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>================================================================================</span>
</span></span><span style=display:flex><span>Executing test: super_light...
</span></span><span style=display:flex><span>Reference binary: ./runtasks_ref_linux
</span></span><span style=display:flex><span>Results <span style=color:#66d9ef>for</span>: super_light
</span></span><span style=display:flex><span>                                        STUDENT   REFERENCE   PERF?
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Serial<span style=color:#f92672>]</span>                                37.497    37.844      0.99  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Always Spawn<span style=color:#f92672>]</span>               108.136   108.805     0.99  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Thread Pool + Spin<span style=color:#f92672>]</span>         10.777    13.615      0.79  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Thread Pool + Sleep<span style=color:#f92672>]</span>        10.274    44.686      0.23  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>================================================================================</span>
</span></span><span style=display:flex><span>Executing test: ping_pong_equal...
</span></span><span style=display:flex><span>Reference binary: ./runtasks_ref_linux
</span></span><span style=display:flex><span>Results <span style=color:#66d9ef>for</span>: ping_pong_equal
</span></span><span style=display:flex><span>                                        STUDENT   REFERENCE   PERF?
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Serial<span style=color:#f92672>]</span>                                603.419   606.739     0.99  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Always Spawn<span style=color:#f92672>]</span>               167.412   178.638     0.94  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Thread Pool + Spin<span style=color:#f92672>]</span>         105.983   123.525     0.86  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Thread Pool + Sleep<span style=color:#f92672>]</span>        108.243   148.316     0.73  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>================================================================================</span>
</span></span><span style=display:flex><span>Executing test: ping_pong_unequal...
</span></span><span style=display:flex><span>Reference binary: ./runtasks_ref_linux
</span></span><span style=display:flex><span>Results <span style=color:#66d9ef>for</span>: ping_pong_unequal
</span></span><span style=display:flex><span>                                        STUDENT   REFERENCE   PERF?
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Serial<span style=color:#f92672>]</span>                                1126.19   1109.329    1.02  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Always Spawn<span style=color:#f92672>]</span>               259.271   260.822     0.99  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Thread Pool + Spin<span style=color:#f92672>]</span>         199.088   198.013     1.01  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Thread Pool + Sleep<span style=color:#f92672>]</span>        198.777   214.293     0.93  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>================================================================================</span>
</span></span><span style=display:flex><span>Executing test: recursive_fibonacci...
</span></span><span style=display:flex><span>Reference binary: ./runtasks_ref_linux
</span></span><span style=display:flex><span>Results <span style=color:#66d9ef>for</span>: recursive_fibonacci
</span></span><span style=display:flex><span>                                        STUDENT   REFERENCE   PERF?
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Serial<span style=color:#f92672>]</span>                                1052.273  1128.069    0.93  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Always Spawn<span style=color:#f92672>]</span>               156.014   172.113     0.91  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Thread Pool + Spin<span style=color:#f92672>]</span>         156.31    171.337     0.91  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Thread Pool + Sleep<span style=color:#f92672>]</span>        156.462   166.476     0.94  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>================================================================================</span>
</span></span><span style=display:flex><span>Executing test: math_operations_in_tight_for_loop...
</span></span><span style=display:flex><span>Reference binary: ./runtasks_ref_linux
</span></span><span style=display:flex><span>Results <span style=color:#66d9ef>for</span>: math_operations_in_tight_for_loop
</span></span><span style=display:flex><span>                                        STUDENT   REFERENCE   PERF?
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Serial<span style=color:#f92672>]</span>                                411.426   423.96      0.97  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Always Spawn<span style=color:#f92672>]</span>               537.747   532.353     1.01  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Thread Pool + Spin<span style=color:#f92672>]</span>         99.286    104.844     0.95  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Thread Pool + Sleep<span style=color:#f92672>]</span>        95.817    239.76      0.40  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>================================================================================</span>
</span></span><span style=display:flex><span>Executing test: math_operations_in_tight_for_loop_fewer_tasks...
</span></span><span style=display:flex><span>Reference binary: ./runtasks_ref_linux
</span></span><span style=display:flex><span>Results <span style=color:#66d9ef>for</span>: math_operations_in_tight_for_loop_fewer_tasks
</span></span><span style=display:flex><span>                                        STUDENT   REFERENCE   PERF?
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Serial<span style=color:#f92672>]</span>                                413.681   415.961     0.99  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Always Spawn<span style=color:#f92672>]</span>               514.021   505.234     1.02  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Thread Pool + Spin<span style=color:#f92672>]</span>         108.644   117.702     0.92  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Thread Pool + Sleep<span style=color:#f92672>]</span>        106.84    260.724     0.41  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>================================================================================</span>
</span></span><span style=display:flex><span>Executing test: math_operations_in_tight_for_loop_fan_in...
</span></span><span style=display:flex><span>Reference binary: ./runtasks_ref_linux
</span></span><span style=display:flex><span>Results <span style=color:#66d9ef>for</span>: math_operations_in_tight_for_loop_fan_in
</span></span><span style=display:flex><span>                                        STUDENT   REFERENCE   PERF?
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Serial<span style=color:#f92672>]</span>                                212.534   211.52      1.00  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Always Spawn<span style=color:#f92672>]</span>               76.402    76.09       1.00  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Thread Pool + Spin<span style=color:#f92672>]</span>         37.203    39.662      0.94  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Thread Pool + Sleep<span style=color:#f92672>]</span>        36.523    57.039      0.64  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>================================================================================</span>
</span></span><span style=display:flex><span>Executing test: math_operations_in_tight_for_loop_reduction_tree...
</span></span><span style=display:flex><span>Reference binary: ./runtasks_ref_linux
</span></span><span style=display:flex><span>Results <span style=color:#66d9ef>for</span>: math_operations_in_tight_for_loop_reduction_tree
</span></span><span style=display:flex><span>                                        STUDENT   REFERENCE   PERF?
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Serial<span style=color:#f92672>]</span>                                208.076   207.488     1.00  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Always Spawn<span style=color:#f92672>]</span>               45.054    45.227      1.00  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Thread Pool + Spin<span style=color:#f92672>]</span>         33.079    33.9        0.98  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Thread Pool + Sleep<span style=color:#f92672>]</span>        34.502    38.389      0.90  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>================================================================================</span>
</span></span><span style=display:flex><span>Executing test: spin_between_run_calls...
</span></span><span style=display:flex><span>Reference binary: ./runtasks_ref_linux
</span></span><span style=display:flex><span>Results <span style=color:#66d9ef>for</span>: spin_between_run_calls
</span></span><span style=display:flex><span>                                        STUDENT   REFERENCE   PERF?
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Serial<span style=color:#f92672>]</span>                                353.553   382.373     0.92  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Always Spawn<span style=color:#f92672>]</span>               180.401   197.119     0.92  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Thread Pool + Spin<span style=color:#f92672>]</span>         205.374   222.315     0.92  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Thread Pool + Sleep<span style=color:#f92672>]</span>        214.819   197.579     1.09  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>================================================================================</span>
</span></span><span style=display:flex><span>Executing test: mandelbrot_chunked...
</span></span><span style=display:flex><span>Reference binary: ./runtasks_ref_linux
</span></span><span style=display:flex><span>Results <span style=color:#66d9ef>for</span>: mandelbrot_chunked
</span></span><span style=display:flex><span>                                        STUDENT   REFERENCE   PERF?
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Serial<span style=color:#f92672>]</span>                                257.289   256.815     1.00  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Always Spawn<span style=color:#f92672>]</span>               34.395    34.058      1.01  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Thread Pool + Spin<span style=color:#f92672>]</span>         34.241    34.922      0.98  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Thread Pool + Sleep<span style=color:#f92672>]</span>        35.191    35.273      1.00  <span style=color:#f92672>(</span>OK<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>================================================================================</span>
</span></span><span style=display:flex><span>Overall performance results
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Serial<span style=color:#f92672>]</span>                                : All passed Perf
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Always Spawn<span style=color:#f92672>]</span>               : All passed Perf
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Thread Pool + Spin<span style=color:#f92672>]</span>         : All passed Perf
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Parallel + Thread Pool + Sleep<span style=color:#f92672>]</span>        : All passed Perf
</span></span></code></pre></div><h2 id=part_b>part_b<a hidden class=anchor aria-hidden=true href=#part_b>#</a></h2><p>åœ¨ä»»åŠ¡çš„ B éƒ¨åˆ†ä¸­ï¼Œæ‚¨å°†æ‰©å±•æ‚¨çš„ A éƒ¨åˆ†ä»»åŠ¡ç³»ç»Ÿå®ç°ï¼Œä»¥æ”¯æŒå¯èƒ½ä¾èµ–äºä»¥å‰ä»»åŠ¡çš„ä»»åŠ¡çš„å¼‚æ­¥å¯åŠ¨ã€‚è¿™äº›ä»»åŠ¡é—´ä¾èµ–å…³ç³»åˆ›å»ºäº†ä»»åŠ¡æ‰§è¡Œåº“å¿…é¡»éµå®ˆçš„è°ƒåº¦çº¦æŸã€‚</p><p>ITaskSystem æ¥å£è¿˜æœ‰ä¸€ä¸ªæ–¹æ³•:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>virtual</span> TaskID <span style=color:#a6e22e>runAsyncWithDeps</span>(IRunnable<span style=color:#f92672>*</span> runnable, <span style=color:#66d9ef>int</span> num_total_tasks,
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>TaskID<span style=color:#f92672>&gt;&amp;</span> deps) <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span></code></pre></div><p>RunAsyncWithDeps ()ç±»ä¼¼äº run () ï¼Œå› ä¸ºå®ƒä¹Ÿç”¨äºæ‰§è¡Œ num <em>total</em> asks ä»»åŠ¡çš„æ‰¹é‡å¯åŠ¨ã€‚ä½†æ˜¯ï¼Œå®ƒä¸ run ()åœ¨è®¸å¤šæ–¹é¢æœ‰æ‰€ä¸åŒ&mldr;</p><h3 id=asynchronous-task-launch>Asynchronous Task Launch<a hidden class=anchor aria-hidden=true href=#asynchronous-task-launch>#</a></h3><p>é¦–å…ˆï¼Œä½¿ç”¨ runAsyncWithDeps ()åˆ›å»ºçš„ä»»åŠ¡ç”±ä»»åŠ¡ç³»ç»Ÿä¸è°ƒç”¨çº¿ç¨‹å¼‚æ­¥æ‰§è¡Œã€‚</p><p>è¿™æ„å‘³ç€ runAsyncWithDeps ()åº”è¯¥ç«‹å³è¿”å›ç»™è°ƒç”¨æ–¹ï¼Œå³ä½¿ä»»åŠ¡å°šæœªå®Œæˆæ‰§è¡Œã€‚</p><p>è¯¥æ–¹æ³•è¿”å›ä¸æ­¤æ‰¹é‡ä»»åŠ¡å¯åŠ¨å…³è”çš„å”¯ä¸€æ ‡è¯†ç¬¦ã€‚</p><p>è°ƒç”¨çº¿ç¨‹å¯ä»¥é€šè¿‡è°ƒç”¨ sync ()æ¥ç¡®å®šå¤§å®¹é‡ä»»åŠ¡å¯åŠ¨çš„å®é™…å®Œæˆæ—¶é—´ã€‚</p><p><code>virtual void sync() = 0;</code></p><p>åªæœ‰å½“ä¸ä¹‹å‰æ‰€æœ‰æ‰¹é‡ä»»åŠ¡å¯åŠ¨å…³è”çš„ä»»åŠ¡å®Œæˆæ—¶ï¼Œsync ()æ‰è¿”å›ç»™è°ƒç”¨æ–¹ã€‚ä¾‹å¦‚ï¼Œè€ƒè™‘ä»¥ä¸‹ä»£ç :</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>// assume taskA and taskB are valid instances of IRunnable...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>TaskID<span style=color:#f92672>&gt;</span> noDeps;  <span style=color:#75715e>// empty vector
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>ITaskSystem <span style=color:#f92672>*</span>t <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> TaskSystem(num_threads);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// bulk launch of 4 tasks
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>TaskID launchA <span style=color:#f92672>=</span> t<span style=color:#f92672>-&gt;</span>runAsyncWithDeps(taskA, <span style=color:#ae81ff>4</span>, noDeps);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// bulk launch of 8 tasks
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>TaskID launchB <span style=color:#f92672>=</span> t<span style=color:#f92672>-&gt;</span>runAsyncWithDeps(taskB, <span style=color:#ae81ff>8</span>, noDeps);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// at this point tasks associated with launchA and launchB
</span></span></span><span style=display:flex><span><span style=color:#75715e>// may still be running
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>t<span style=color:#f92672>-&gt;</span>sync();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// at this point all 12 tasks associated with launchA and launchB
</span></span></span><span style=display:flex><span><span style=color:#75715e>// are guaranteed to have terminated
</span></span></span></code></pre></div><p>å¦‚ä¸Šé¢çš„æ³¨é‡Šä¸­æ‰€è¿°ï¼Œåœ¨çº¿ç¨‹è°ƒç”¨sync() runAsyncWithDeps() ) çš„ä»»åŠ¡å·²å®Œæˆã€‚ å‡†ç¡®åœ°è¯´ï¼Œ runAsyncWithDeps()å‘Šè¯‰æ‚¨çš„ä»»åŠ¡ç³»ç»Ÿæ‰§è¡Œæ–°çš„æ‰¹é‡ä»»åŠ¡å¯åŠ¨ï¼Œä½†æ‚¨çš„å®ç°å¯ä»¥çµæ´»åœ°åœ¨ä¸‹æ¬¡è°ƒç”¨sync()ä¹‹å‰éšæ—¶æ‰§è¡Œè¿™äº›ä»»åŠ¡ã€‚ è¯·æ³¨æ„ï¼Œæ­¤è§„èŒƒæ„å‘³ç€æ— æ³•ä¿è¯æ‚¨çš„å®ç°åœ¨ä» launchB å¯åŠ¨ä»»åŠ¡ä¹‹å‰å…ˆæ‰§è¡Œ launchA ä¸­çš„ä»»åŠ¡ï¼</p><h3 id=support-for-explicit-dependencies>Support for Explicit Dependencies<a hidden class=anchor aria-hidden=true href=#support-for-explicit-dependencies>#</a></h3><p>runAsyncWithDeps()çš„ç¬¬äºŒä¸ªå…³é”®ç»†èŠ‚æ˜¯å®ƒçš„ç¬¬ä¸‰ä¸ªå‚æ•°ï¼šTaskID æ ‡è¯†ç¬¦å‘é‡ï¼Œå¿…é¡»å¼•ç”¨ä¹‹å‰ä½¿ç”¨runAsyncWithDeps()å¯åŠ¨çš„æ‰¹é‡ä»»åŠ¡ã€‚ è¯¥å‘é‡æŒ‡å®šå½“å‰æ‰¹é‡ä»»åŠ¡å¯åŠ¨ä¸­çš„ä»»åŠ¡æ‰€ä¾èµ–çš„å…ˆå‰ä»»åŠ¡ã€‚ å› æ­¤ï¼Œåœ¨ä¾èµ–å‘é‡ä¸­ç»™å‡ºçš„å¯åŠ¨ä¸­çš„æ‰€æœ‰ä»»åŠ¡å®Œæˆä¹‹å‰ï¼Œæ‚¨çš„ä»»åŠ¡è¿è¡Œæ—¶æ— æ³•å¼€å§‹æ‰§è¡Œå½“å‰æ‰¹é‡ä»»åŠ¡å¯åŠ¨ä¸­çš„ä»»ä½•ä»»åŠ¡ï¼ ä¾‹å¦‚ï¼Œè€ƒè™‘ä»¥ä¸‹ç¤ºä¾‹ï¼š</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span>std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>TaskID<span style=color:#f92672>&gt;</span> noDeps;  <span style=color:#75715e>// empty vector
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>TaskID<span style=color:#f92672>&gt;</span> depOnA;   
</span></span><span style=display:flex><span>std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>TaskID<span style=color:#f92672>&gt;</span> depOnBC;   
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ITaskSystem <span style=color:#f92672>*</span>t <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> TaskSystem(num_threads);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>TaskID launchA <span style=color:#f92672>=</span> t<span style=color:#f92672>-&gt;</span>runAsyncWithDeps(taskA, <span style=color:#ae81ff>128</span>, noDeps);    
</span></span><span style=display:flex><span>depOnA.push_back(launchA);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>TaskID launchB <span style=color:#f92672>=</span> t<span style=color:#f92672>-&gt;</span>runAsyncWithDeps(taskB, <span style=color:#ae81ff>2</span>, depOnA);
</span></span><span style=display:flex><span>TaskID launchC <span style=color:#f92672>=</span> t<span style=color:#f92672>-&gt;</span>runAsyncWithDeps(taskC, <span style=color:#ae81ff>6</span>, depOnA);
</span></span><span style=display:flex><span>depOnBC.push_back(launchB);
</span></span><span style=display:flex><span>depOnBC.push_back(launchC);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>TaskID launchD <span style=color:#f92672>=</span> t<span style=color:#f92672>-&gt;</span>runAsyncWithDeps(taskD, <span style=color:#ae81ff>32</span>, depOnBC);            
</span></span><span style=display:flex><span>t<span style=color:#f92672>-&gt;</span>sync();
</span></span></code></pre></div><p>ä¸Šé¢çš„ä»£ç æœ‰å››ä¸ªæ‰¹é‡ä»»åŠ¡å¯åŠ¨ï¼ˆtaskAï¼š128 ä¸ªä»»åŠ¡ï¼ŒtaskBï¼š2 ä¸ªä»»åŠ¡ï¼ŒtaskCï¼š6 ä¸ªä»»åŠ¡ï¼ŒtaskDï¼š32 ä¸ªä»»åŠ¡ï¼‰ã€‚ è¯·æ³¨æ„ï¼Œä»»åŠ¡ B å’Œä»»åŠ¡ C çš„å¯åŠ¨å–å†³äºä»»åŠ¡ Aã€‚ taskD çš„æ‰¹é‡å¯åŠ¨ ( launchD ) å–å†³äºlaunchBå’ŒlaunchCçš„ç»“æœã€‚ å› æ­¤ï¼Œè™½ç„¶æ‚¨çš„ä»»åŠ¡è¿è¡Œæ—¶å¯ä»¥æŒ‰ä»»æ„é¡ºåºï¼ˆåŒ…æ‹¬å¹¶è¡Œï¼‰å¤„ç†ä¸launchBå’ŒlaunchCå…³è”çš„ä»»åŠ¡ï¼Œä½†è¿™äº›å¯åŠ¨ä¸­çš„æ‰€æœ‰ä»»åŠ¡å¿…é¡»åœ¨launchAçš„ä»»åŠ¡å®Œæˆåå¼€å§‹æ‰§è¡Œï¼Œå¹¶ä¸”å®ƒä»¬å¿…é¡»åœ¨è¿è¡Œæ—¶å¼€å§‹ä¹‹å‰å®Œæˆä»launchDæ‰§è¡Œä»»ä½•ä»»åŠ¡ã€‚</p><p>æˆ‘ä»¬å¯ä»¥é€šè¿‡ä»»åŠ¡å›¾ç›´è§‚åœ°è¯´æ˜è¿™äº›ä¾èµ–å…³ç³»ã€‚ ä»»åŠ¡å›¾æ˜¯æœ‰å‘æ— ç¯å›¾ (DAG)ï¼Œå…¶ä¸­å›¾ä¸­çš„èŠ‚ç‚¹å¯¹åº”äºæ‰¹é‡ä»»åŠ¡å¯åŠ¨ï¼Œä»èŠ‚ç‚¹ X åˆ°èŠ‚ç‚¹ Y çš„è¾¹è¡¨ç¤º Y å¯¹ X è¾“å‡ºçš„ä¾èµ–å…³ç³»ã€‚ä¸Šè¿°ä»£ç çš„ä»»åŠ¡å›¾æ˜¯ï¼š
<img loading=lazy src=https://github.com/jeremyephron/asst2/raw/master/figs/task_graph.png alt="Alt text"></p><p>è¯·æ³¨æ„ï¼Œå¦‚æœæ‚¨åœ¨å…·æœ‰å…«ä¸ªæ‰§è¡Œä¸Šä¸‹æ–‡çš„ Myth è®¡ç®—æœºä¸Šè¿è¡Œä¸Šé¢çš„ç¤ºä¾‹ï¼Œåˆ™å¹¶è¡Œè°ƒåº¦launchBå’ŒlaunchCä¸­çš„ä»»åŠ¡çš„èƒ½åŠ›å¯èƒ½éå¸¸æœ‰ç”¨ï¼Œå› ä¸ºå•ç‹¬çš„æ‰¹é‡ä»»åŠ¡å¯åŠ¨éƒ½ä¸è¶³ä»¥ä½¿ç”¨æ‰€æœ‰æ‰§è¡Œæœºå™¨çš„èµ„æºã€‚</p><h3 id=task>Task<a hidden class=anchor aria-hidden=true href=#task>#</a></h3><p>æ‚¨å¿…é¡»ä» A éƒ¨åˆ†æ‰©å±•ä»»åŠ¡ç³»ç»Ÿå®ç°ï¼Œæ‰èƒ½æ­£ç¡®å®ç°TaskSystem::runAsyncWithDeps()å’ŒTaskSystem::sync() ã€‚ ä¸ A éƒ¨åˆ†ä¸€æ ·ï¼Œæˆ‘ä»¬ä¸ºæ‚¨æä¾›ä»¥ä¸‹å…¥é—¨æç¤ºï¼š</p><ul><li>It may be helpful to think about the behavior of runAsyncWithDeps() as pushing a record corresponding to the bulk task launch, or perhaps records corresponding to each of the tasks in the bulk task launch onto a &ldquo;work queue&rdquo;. Once the record to work to do is in the queue, runAsyncWithDeps() can return to the caller.</li><li>The trick in this part of the assignment is performing the appropriate bookkeeping to track dependencies. What must be done when all the tasks in a bulk task launch complete? (This is the point when new tasks may become available to run.)</li><li>It can be helpful to have two data structures in your implementation: (1) a structure representing tasks that have been added to the system via a call to runAsyncWithDeps(), but are not yet ready to execute because they depend on tasks that are still running (these tasks are &ldquo;waiting&rdquo; for others to finish) and (2) a &ldquo;ready queue&rdquo; of tasks that are not waiting on any prior tasks to finish and can safely be run as soon as a worker thread is available to process them.</li><li>You need not worry about integer wrap around when generating unique task launch ids. We will not hit your task system with over 2^31 bulk task launches.</li><li>You can assume all programs will either call only run() or only runAsyncWithDeps(); that is, you do not need to handle the case where a run() call needs to wait for all proceeding calls to runAsyncWithDeps() to finish.</li></ul><p>åœ¨part_b/å­ç›®å½•ä¸­å®ç°Béƒ¨åˆ†å®ç°ï¼Œä»¥ä¸æ­£ç¡®çš„å‚è€ƒå®ç°ï¼ˆ part_b/runtasks_ref_* ï¼‰è¿›è¡Œæ¯”è¾ƒã€‚</p></div><footer class=post-footer><ul class=post-tags><li><a href=/tags/cmu-15418cs-618/>cmu-15418&amp;cs-618</a></li></ul><nav class=paginav><a class=prev href=/posts/tips/windows%E4%B8%8B%E7%9A%84%E5%AD%90%E7%B3%BB%E7%BB%9F/><span class=title>Â« ä¸Šä¸€é¡µ</span><br><span>windows ä¸‹çš„å­ç³»ç»Ÿ</span>
</a><a class=next href=/posts/tools/docker/docker/><span class=title>ä¸‹ä¸€é¡µ Â»</span><br><span>docker Usage</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share asst2 on twitter" href="https://twitter.com/intent/tweet/?text=asst2&amp;url=%2fposts%2fcmu-15418cs-618%2fasst2%2f&amp;hashtags=cmu-15418%26cs-618"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share asst2 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=%2fposts%2fcmu-15418cs-618%2fasst2%2f&amp;title=asst2&amp;summary=asst2&amp;source=%2fposts%2fcmu-15418cs-618%2fasst2%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share asst2 on reddit" href="https://reddit.com/submit?url=%2fposts%2fcmu-15418cs-618%2fasst2%2f&title=asst2"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share asst2 on facebook" href="https://facebook.com/sharer/sharer.php?u=%2fposts%2fcmu-15418cs-618%2fasst2%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share asst2 on whatsapp" href="https://api.whatsapp.com/send?text=asst2%20-%20%2fposts%2fcmu-15418cs-618%2fasst2%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share asst2 on telegram" href="https://telegram.me/share/url?text=asst2&amp;url=%2fposts%2fcmu-15418cs-618%2fasst2%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share asst2 on ycombinator" href="https://news.ycombinator.com/submitlink?t=asst2&u=%2fposts%2fcmu-15418cs-618%2fasst2%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2024 <a href>ysyy's blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="å¤åˆ¶";function s(){t.innerHTML="å·²å¤åˆ¶ï¼",setTimeout(()=>{t.innerHTML="å¤åˆ¶"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>